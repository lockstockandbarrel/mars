! d7997ccd-145b-4ca1-9d13-aa166affe43f
!>>>>> build/dependencies/M_calculator/src/M_calculator.f90
!>
!!##NAME
!!   calculator - [M_calculator] parse calculator expression and return numeric and string values
!!   (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine calculator(inline,outlin,mssg,slast,ierr)
!!
!!    character(len=*),intent=(in)           :: inline
!!    character(len=iclen_calc),intent=(out) :: outlin
!!    character(len=iclen_calc),intent=(out) :: mssg
!!    doubleprecision, intent=(out)          :: slast
!!    integer, intent=(out)                  :: ierr
!!
!!##DESCRIPTION
!!    CALCULATOR(3f) evaluates FORTRAN-like expressions. It can be used to add
!!    calculator-like abilities to your program.
!!
!!##OPTIONS
!!     inline  INLINE is a string expression up to (iclen_calc=512) characters long.
!!             The syntax of an expression is described in
!!             the main document of the Calculator Library.
!!     outlin  Returned numeric value as a string when IERR=0.
!!     mssg    MSSG is a string that can serve several purposes
!!             o Returned string value when IERR=2
!!             o Error message string when IERR=-1
!!             o Message from 'funcs' or 'dump' command when IERR=1
!!     slast   SLAST has different meanings depending on whether a string or number
!!             is being returned
!!             o REAL value set to last successfully calculated value when IERR=0
!!             o Number of characters in returned string variable when IERR=2
!!     ierr    status flag.
!!               -1  An error occurred
!!                0  A numeric value was returned
!!                1  A message was returned
!!                2  A string value was returned
!!##EXAMPLES
!!
!!   Example calculator program
!!
!!       program demo_calculator
!!       !compute(1f): line mode calculator program (that calls calculator(3f))
!!       use M_calculator, only: calculator,iclen_calc
!!       ! iclen_calc : max length of expression or variable value as a string
!!       implicit none
!!       integer,parameter         :: dp=kind(0.0d0)
!!       character(len=iclen_calc) :: line
!!       character(len=iclen_calc) :: outlin
!!       character(len=iclen_calc) :: event
!!       real(kind=dp)             :: rvalue
!!       integer                   :: ierr
!!       ierr=0
!!       call calculator('ownmode(1)',outlin,event,rvalue,ierr)
!!       ! activate user-defined function interface
!!       INFINITE: do
!!          read(*,'(a)',end=999)line
!!          if(line.eq.'.')stop
!!          call calculator(line,outlin,event,rvalue,ierr)
!!          select case (ierr)
!!          ! several different meanings to the error flag returned by calculator
!!          case(0)
!!          ! a numeric value was returned without error
!!            write(*,'(a,a,a)')trim(outlin),' = ',trim(line)
!!          case(2)
!!          ! a string value was returned without error
!!            write(*,'(a)')trim(event(:int(rvalue)))
!!          case(1)
!!          ! a request for a message has been returned (from DUMP or FUNC)
!!            write(*,'(a,a)')'message===>',trim(event(:len_trim(event)))
!!          case(-1)
!!          ! an error has occurred
!!            write(*,'(a,a)')'error===>',trim(event(:len_trim(event)))
!!          case default
!!          ! this should not occur
!!            WRITE(6,'(A,i10)')'*CALCULATOR* UNEXPECTED IERR VALUE ',IERR
!!          end select
!!       enddo INFINITE
!!       999 continue
!!       end program demo_calculator
!!
!!##SEE ALSO
!!     see INUM0(),RNUM0(),SNUM0(),,EXPRESSION().
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR   John S. Urban
!!##VERSION  1.0 19971123,20161218
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
module M_calculator

use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdout=>OUTPUT_UNIT    ! access computing environment
!!implicit doubleprecision (a-h,o-z)
implicit none
private

integer, parameter                     :: db = kind(0.0d0) ! SELECTED_REAL_KIND(15,300) ! real*8
integer,parameter                      :: dp = kind(0.0d0)

integer,parameter,public               :: iclen_calc=512           ! max length of expression or variable value as a string
integer,parameter,public               :: ixy_calc=55555           ! number of variables in X() and Y() array
real(kind=dp),save,public              :: x(ixy_calc)=0.0_dp       ! x array for procedure funcs_
real(kind=dp),save,public              :: y(ixy_calc)=0.0_dp       ! y array for procedure funcs_

integer,parameter,public                  :: icname_calc=20        ! max length of a variable name

character(len=:),allocatable,save         :: keys_q(:)             ! contains the names of string variables
character(len=:),allocatable,save,public  :: values(:)             ! string variable values
integer,save,public,allocatable           :: values_len(:)         ! lengths of the string variable values

character(len=:),allocatable,save         :: keyr_q(:)             ! contains the names of numeric variables
real(kind=dp),save,allocatable            :: values_d(:)           ! numeric variable values
character(len=*),parameter                :: g='(*(g0,1x))'

public :: calculator
public :: stuff
public :: stuffa
! CONVENIENCE ROUTINES
public :: inum0        ! resolve a calculator string into a whole integer number
public :: rnum0        ! resolve a calculator string into a real number (return 0 on errors)
public :: dnum0        ! resolve a calculator string into a doubleprecision number (return 0 on error s)
public :: snum0        ! resolve a calculator expression into a string(return blank on errors)
public :: expression   ! call calculator() calculator and display messages

public :: set_mysub
public :: set_myfunc

integer,parameter                      :: ixyc_calc=50                   ! number of variables in $X() and $(Y) array
integer,parameter                      :: icbuf_calc=23*(iclen_calc/2+1) ! buffer for string as it is expanded

!  no check on whether line expansion ever causes line length to
!  exceed allowable number of characters.
!  number of characters to prevent over-expansion would currently be
!  23 digits per number max*(input number of characters/2+1).

character(len=iclen_calc)       :: mssge   ! for error message/messages /returning string value

character(len=iclen_calc),save  :: xc(ixyc_calc)=' '        ! $x array for procedure funcs_
character(len=iclen_calc),save  :: yc(ixyc_calc)=' '        ! $y array for procedure funcs_
character(len=iclen_calc),save  :: nc(ixyc_calc)=' '        ! $n array for procedure funcs_

character(len=iclen_calc),save  :: last='0.0'               ! string containing last answer (i.e. current value)
logical,save                    :: ownon=.false.            ! flag for whether to look for substitute_subroutine(3f)

integer,save                    :: ktoken                   ! count of number of token strings assembled
!
! requires
!  rand,
!
private :: a_to_d_                       ! returns a real value rval from a numeric character string chars.
private :: squeeze_
private :: stufftok_
private :: funcs_
private :: pows_
private :: given_name_get_stringvalue_
private :: parens_
private :: args_
private :: factors_
private :: expressions_
private :: help_funcs_

private :: juown1_placeholder
private :: c_placeholder

abstract interface
   subroutine juown1_interface(func,iflen,args,iargstp,n,fval,ctmp,ier)
      import dp
      character(len=*),intent(in)  :: func
      integer,intent(in)           :: iflen
      real(kind=dp),intent(in)     :: args(100)
      integer,intent(in)           :: iargstp(100)
      integer,intent(in)           :: n
      real(kind=dp)                :: fval
      character(len=*)             :: ctmp
      integer                      :: ier
   end subroutine juown1_interface
end interface

abstract interface
   real function c_interface(args,n)
      import dp
      integer,intent(in)         :: n
      real(kind=dp),intent(in)   :: args(n)
   end function c_interface
end interface
public c_interface
public juown1_interface

procedure(juown1_interface),pointer :: mysub => juown1_placeholder
procedure(c_interface),pointer      :: myfunc => c_placeholder

public locate        ! [M_list] find PLACE in sorted character array where value can be found or should be placed
   private locate_c
   private locate_d
public insert        ! [M_list] insert entry into a sorted allocatable array at specified position
   private insert_c
   private insert_d
   private insert_i
public replace       ! [M_list] replace entry by index from a sorted allocatable array if it is present
   private replace_c
   private replace_d
   private replace_i
public remove        ! [M_list] delete entry by index from a sorted allocatable array if it is present
   private remove_c
   private remove_d
   private remove_i

!character(len=*),parameter::ident_1="&
!&@(#)M_list::locate(3f): Generic subroutine locates where element is or should be in sorted allocatable array"
interface locate
   module procedure locate_c, locate_d
end interface

!character(len=*),parameter::ident_2="&
!&@(#)M_list::insert(3f): Generic subroutine inserts element into allocatable array at specified position"
interface insert
   module procedure insert_c, insert_d, insert_i
end interface

!character(len=*),parameter::ident_3="&
!&@(#)M_list::replace(3f): Generic subroutine replaces element from allocatable array at specified position"
interface replace
   module procedure replace_c, replace_d, replace_i
end interface

!character(len=*),parameter::ident_4="&
!&@(#)M_list::remove(3f): Generic subroutine deletes element from allocatable array at specified position"
interface remove
   module procedure remove_c, remove_d, remove_i
end interface
contains
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine set_myfunc(proc)
procedure(c_interface) :: proc
   myfunc => proc
end subroutine set_myfunc
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine set_mysub(proc)
procedure(juown1_interface) :: proc
   mysub => proc
end subroutine set_mysub
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
recursive subroutine calculator(inline,outlin,mssg,slast,ierr)
!
!     The goal is to create a procedure easily utilized from other
!     programs that takes a standard Fortran value statement and reduces
!     it down to a value, efficiently and using standard Fortran
!     standards where ever feasible.
!
!  Version 2.0: 03/13/87
!  Version 3.0: 07/11/2013
!  Version 5.0: 07/16/2013
!
!  o  adjacent powers are done left to right, not right to left
!  o  code does not prevent - and + beside an other operator.
!  o  no check on whether user input more characters than allowed.
!     no check on whether line expansion ever causes line length to
!     exceed allowable number of characters.
!     number of characters to prevent over-expansion would currently be
!     23 digits per number max*(input number of characters/2+1).
!  o  allowing for ixy_calc arguments in max and min seems too high. if reducing
!     array size helps significantly in costs, do so.
!  o  parentheses are required on a function call.
!  o  square brackets [] are equivalent to parenthesis ().
!===========================================================================--------------------------------------------------------
!  2. need a generic help function to list commands and functions
!  3. allow multiple expressions per line with a semi-colon between them
!     (like the parse functions).
!  4. make a function to fill x and y arrays, or to read values into them
!     from a file; and make some statistical functions that work on the
!     arrays.
!  6. allow user-written functions to be called from funcs_ routine.
!  7. allow for user-defined arrays and array operations.
!===========================================================================--------------------------------------------------------
!  12/07/87 --- put in an implicit real (a-h,o-z) statement in each
!              procedure so that it could quickly be changed to
!              implicit real*8 (a-h,o-z) for a vax. be careful of
!              type mismatch between external functions and the
!              real variables.
!              use following xedit commands where periods denote
!              spaces
!              c/implicit real../implicit real*8./ *
! 12/11/87  --- changed ifix calls to int calls as ifix on vax does
!              not allow real*8 in ifix calls
! 12/11/87  --- moving all prints out of column 1 so it is not picked
!              out by vax as carriage control.
! 12/28/87  --- put bn format specifier into a_to_d_ routine because
!              vax assumes zero fill
! 06/23/88  --- making a first cut at allowing string variables.
!               1. string variable names must start with a dollar-sign
!               2. strings can only be up to (iclen_calc) characters long
!               3. they will be returned in the message string to
!                  the calling program
!               4. input strings must be delimited with double quotes.
!                  to place a double quote into the string, put two
!                  double quotes adjacent to each other.
!               5. a flag value for ier to distinguish between string
!                  and numeric output?
!#----------------------------------------------------------------------------------------------------------------------------------
!subroutine calculator(inline,outlin,mssg,slast,ierr)

! ident_1="@(#) M_calculator calculator(3f) The procedure CALCULATOR(3f) acts like a calculator"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)            :: inline
character(len=iclen_calc),intent(out)  :: outlin
character(len=iclen_calc),intent(out)  :: mssg
real(kind=dp),intent(out)              :: slast
integer,intent(out)                    :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=icbuf_calc)              :: line
character(len=iclen_calc)              :: varnam
character(len=iclen_calc)              :: junout
real(kind=dp),save                     :: rlast=0.0_dp
integer                                :: i10
integer                                :: i20
integer                                :: idum
integer                                :: imax
integer                                :: indx
integer                                :: iplace
integer                                :: istart
integer                                :: nchar2
integer                                :: nchard
!-----------------------------------------------------------------------------------------------------------------------------------
   line=inline                                      ! set working string to initial input line
   imax=len(inline)                                 ! determine the length of the input line
   mssg=' '                                         ! set returned message/error/string value string to a blank
   outlin=' '
   BIG: do                                          ! for $A=numeric and A=string
      ierr=1                                           ! set status flag to message mode
      mssge=' '                                        ! set message/error/string value in GLOBAL to a blank
      varnam=' '
      call squeeze_(line,imax,nchard,varnam,nchar2,ierr) ! preprocess the string: remove blanks and process special characters
                                                         ! also remove all quoted strings and replace them with a token
!-----------------------------------------------------------------------------------------------------------------------------------
      if(ierr.eq.-1)then                ! if an error occurred during preprocessing of the string, set returned message and quit
         slast=rlast                    ! set returned real value to last good calculated value
         mssg=mssge                     ! place internal message from GLOBAL into message returned to user
         return
      elseif(nchard.eq.0)then  ! if a blank input string was entered report it as an error and quit
         ierr=-1
         mssg='*calculator* input line was empty'
      elseif(line(1:nchard).eq.'dump')then ! process dump command
         write(*,g)line(1:nchard)
         write(*,g)' current value= ',last
         write(*,g)' variable name       variable value     '
         if(allocated(keyr_q))then
            do i10=1,size(keyr_q)
               if(keyr_q(i10).ne.' ')then
                  write(junout,'('' '',2a,g23.16e3)')keyr_q(i10),' ',values_d(i10)
                  write(*,g)trim(junout)
               endif
            enddo
         endif
         if(allocated(keys_q))then
            do i20=1,size(keys_q)
               if(keys_q(i20).ne.' ')then
                  write(junout,'('' '',3a)')keys_q(i20),' ',values(i20)(:values_len(i20))
                  write(*,g)trim(junout)
               endif
            enddo
         endif
         mssg='variable listing complete'
      elseif(line(1:nchard).eq.'funcs') then     ! process funcs command
         call help_funcs_()
         mssg='function listing complete'
!-----------------------------------------------------------------------------------------------------------------------------------
      else                                                ! this is an input line to process
         call parens_(line,nchard,ierr)                   ! process the command
         if(ierr.eq.0)then                 ! if no errors occurred set output string, store the value as last, store any variable
                                           ! numeric value with no errors, assume nchard is 23 or less
            outlin=line(1:nchard)                         ! set string output value
            last=line(1:nchard)                           ! store last value (for use with question-mark token)
            call a_to_d_(last(1:nchard),rlast,idum)       ! set real number output value
            if(nchar2.ne.0.and.varnam(1:1).ne.'$')then    ! if the statement defines a variable make sure variable name is stored
               call locate(keyr_q,varnam(:nchar2),indx,ierr) ! determine placement of the variable and whether it is new
               if(ierr.eq.-1)then
                  slast=rlast                             ! set returned real value to last good calculated value
                  mssg=mssge                              ! place internal message from GLOBAL into message returned to user
                  return
               endif
               if(indx.le.0)then                          ! if the variable needs added, add it
                  istart=iabs(indx)
                  call insert(keyr_q,varnam(:nchar2),istart)
                  call insert(values_d,0.0d0,istart)
               endif
               call a_to_d_(last(1:nchard),values_d(iabs(indx)),ierr)  ! store a defined variable's value
            elseif(nchar2.ne.0)then                       ! numeric value to string
               line(:)=' '
               line=varnam(:nchar2)//'="'//last(1:nchard)//'"'
               imax=len_trim(line)                        ! determine the length of the input line
               cycle BIG
            endif
         elseif(ierr.eq.2)then ! returned output is not numeric, but alphanumeric (it is a string)
!!!!!!!  could return string values directly instead of thru message field
!!!!!!!  make sure normal output values are not left indeterminate
            mssg=mssge                                    ! set returned string value to returned string value
            if(nchar2.ne.0.and.varnam(1:1).eq.'$')then    ! if the statement defines a variable make sure variable name is stored
               call locate(keys_q,varnam(:nchar2),indx,ierr) ! determine placement of the variable and whether it is new
               if(ierr.eq.-1)then
                  slast=rlast                             ! set returned real value to last good calculated value
                  mssg=mssge                              ! place internal message from GLOBAL into message returned to user
                  return
               endif
               iplace=iabs(indx)
               if(indx.le.0)then                             ! if the variable needs added, add it
                  call insert(keys_q,varnam(:nchar2),iplace) ! adding the new variable name to the variable name array
                  call insert(values,' '            ,iplace)
                  call insert(values_len,0              ,iplace)
               endif
               call replace(values,mssg,iplace)
               call replace(values_len,len_trim(mssg),iplace)
               rlast=dble(values_len(iplace))             ! returned value is length of string when string is returned
            elseif(nchar2.ne.0)then                       ! string but being stored to numeric variable
                line=varnam(:nchar2)//'='//mssg
                imax=len_trim(line)                       ! determine the length of the input line
                cycle BIG
            else                                          ! a string function with an assignment to it (for example "Hello"
               rlast=len_trim(mssg)                       ! probably should pass message length up from someplace
            endif
         endif
         mssg=mssge
      endif
      exit BIG
   enddo BIG
   slast=rlast                                            ! set returned value to last successfully calculated real value
end subroutine calculator
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine help_funcs_()

! ident_2="@(#) M_calculator help_funcs_(3fp) prints help for calculator functions"

character(len=80),allocatable :: help_text(:)
integer                       :: i
help_text=[ &
&'--------------------------------------------------------------------------------',&
&'standard functions available:                                                   ',&
&'--------------------------------------------------------------------------------',&
!&'--------------------------------------------------------------------------------',&
!&' c(                   : user-defined function                                   ',&
!&' ownmode(             : call user-defined procedures                            ',&
&'--------------------------------------------------------------------------------',&
&' len_trim($value)         : number of characters trimming trailing spaces       ',&
&' index($value,$match)     : return position $match occurs in $value or zero     ',&
&' sign(val1,val2)          : magnitude of val1 with the sign of val2             ',&
&' real(value)              : conversion to real type                             ',&
&' matchw($string,$pattern) : wildcard match;*=any string, ?=any character        ',&
&' str($str|expr,....)      : append as strings and then convert to number        ',&
&' round(value,digits)      :                                                     ',&
&' ichar($value)            : return ASCII Decimal Equivalent of character        ',&
&' $char(value)             : return character given ASCII Decimal Equivalent     ',&
&' $f(format,value)         : using FORMAT to create it convert number to string  ',&
&' $repeat(string,count)    : repeat string count times                           ',&
&' $if(expr,$val1,$val2)    : if expr==0 return $val1, else return $val2          ',&
&' if(expr,val1,val2)       : if expr==0 return val1, else return val2            ',&
&' hypot(x,y)               : Euclidean distance function                         ',&
&'--------------------------------------------------------------------------------',&
&'WHOLE NUMBERS:                                                                  ',&
&' aint(value) : truncation toward zero to a whole number                         ',&
&' anint(value): nearest whole number                                             ',&
&' int(value)  : conversion to integer type                                       ',&
&' nint(value) : nearest integer                                                  ',&
&' floor(A)    : greatest integer less than or equal to A                         ',&
&' ceiling(A)  : least integer greater than or equal to A                         ',&
&'--------------------------------------------------------------------------------',&
&'MISCELLANEOUS:                                                                  ',&
&' max(v1,v2,v3,...v50)  : maximum value of list                                  ',&
&' min(v1,v2,v3,...v50)  : minimum value of list                                  ',&
&' dim(x,y)    : maximum of X-Y and zero                                          ',&
&' frac(A)     : fractional part of A (A - INT(A))                                ',&
&' mod(A,P)    : remainder function                                               ',&
&' abs(value)  : absolute value                                                   ',&
&' exp(value)  : exponent of value                                                ',&
&'BESSEL FUNCTIONS:                                                               ',&
&' bessel_j0 : of first kind of order 0  | bessel_j1 : of first kind of order 1   ',&
&' bessel_y0 : of second kind of order 0 | bessel_y1 : of second kind of order 1  ',&
&' bessel_jn : of first kind             | bessel_yn : of second kind             ',&
&'NUMERIC FUNCTIONS:                                                              ',&
&' sqrt(value) : return square root of value                                      ',&
&' log(v1)     : logarithm of value to base e                                     ',&
&' log10(v1)   : logarithm of value to base 10                                    ',&
&'--------------------------------------------------------------------------------',&
&'RANDOM NUMBERS:                                                                 ',&
&' srand(seed_value) : set seed value for rand()                                  ',&
&' rand()            : random number                                              ',&
&'--------------------------------------------------------------------------------',&
&'SYSTEM:                                                                         ',&
&' $setenv(name,value),$se(name,value)   : set environment variable value         ',&
&' $getenv(name),$ge(name)               : get environment variable value         ',&
&' $sh(command)                          : return output of system command        ',&
&'--------------------------------------------------------------------------------',&
&'ARRAY STORAGE:                                                                  ',&
&' $nstore(start_index,$value1,$value2,$value3,....) | $n(index)                  ',&
&' $xstore(start_index,$value1,$value2,$value3,....) | $x(index)                  ',&
&' $ystore(start_index,$value1,$value2,$value3,....) | $y(index)                  ',&
&' xstore(start_index,value1,value2,value3,....)     | x(index)                   ',&
&' ystore(start_index,value1,value2,value3,....)     | y(index)                   ',&
&'--------------------------------------------------------------------------------',&
&'STRING MODIFICATION:                                                            ',&
&' $l($input_string)        : convert string to lowercase                         ',&
&' $u($input_string)        : convert string to uppercase                         ',&
&' $substr($input_string,start_column,end_column)                                 ',&
&' $str($a|e,$a|e,$a|e,....):append string and value expressions into string      ',&
&'--------------------------------------------------------------------------------',&
&'CALENDAR:                                                                       ',&
&' ye(),year()     : current year       | mo(),month()    : current month         ',&
&' da(),day()      : current day        | ho(),hour()     : current hour          ',&
&' tz(),timezone() : current timezone   | mi(),minute()   : current minute        ',&
&' se(),second()   : current second     |                                         ',&
&' $mo([n])        : name of month      |                                         ',&
&'--------------------------------------------------------------------------------',&
&'TRIGONOMETRIC:                                                                  ',&
&' cos(radians) : cosine  | acos(x/r)   | cosh(x)  | acosh(x)  | cosd(degrees)    ',&
&' sin(radians) : sine    | asin(y/r)   | sinh(x)  | asinh(x)  | sind(degrees)    ',&
&' tan(radians) : tangent | atan(y/x)   | tanh(x)  | atanh(x)  | tand(degrees)    ',&
&'                        | atan2(x,y)  |                                         ',&
&'--------------------------------------------------------------------------------',&
&'UNIT CONVERSION:                                                                ',&
&' c2f(c) : centigrade to Fahrenheit    | f2c(f) : Fahrenheit to centigrade       ',&
&' d2r(d) : degrees to radians          | r2d(r) : radians to degrees             ',&
&'--------------------------------------------------------------------------------',&
&'LOGICAL:                                                                        ',&
&' ge(a,b) : greater than or equal to   | le(a,b) : A less than or equal to B     ',&
&' gt(a,b) : A greater than B           | lt(a,b) : A less than B                 ',&
&' eq(a,b) : A equal to B               | ne(a,b) : A not equal to B              ',&
&' in(lower_bound,test_value,upper_bound) : test if value in given range          ',&
&'LEXICAL LOGICAL:                                                                ',&
&' lge($a,$b): greater than or equal to | lle($a,$b): A less than or equal to B   ',&
&' lgt($a,$b): A greater than B         | llt($a,$b): A less than B               ',&
&' leq($a,$b): A equal to B             | lne($a,$b): A not equal to B            ',&
&'--------------------------------------------------------------------------------',&
&'HIGHER FUNCTIONS:                                                               ',&
&' fraction(x): fraction part of model | exponent(x) : largest exponent           ',&
&' gamma(x): gamma function            | log_gamma(x): logarithm of gamma function',&
&' tiny()  : smallest number           | huge():       largest number             ',&
!' erf(x), erfc_scaled(x): Error function | erfc(x): Complementary error function ',&
&'--------------------------------------------------------------------------------',&
&'                                                                                ']
   do i=1,size(help_text)
      write(*,g)help_text(i)
   enddo
end subroutine help_funcs_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    parens_(3fp) - [M_calculator] crack out the parenthesis and solve
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    recursive subroutine parens_(string,nchar,ier)
!!    character(len=*)             :: string
!!    integer,intent(inout)        :: nchar
!!    integer,intent(out)          :: ier
!!##DESCRIPTION
!!    crack out the parenthesis and solve
!!##OPTIONS
!!    string  input string to expand and return
!!    nchar   length of string on input and output
!!    ier     status code
!!
!!              0=good numeric return
!!              2=good alphameric return
!!             -1=error occurred, message is in mssge
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
recursive subroutine parens_(string,nchar,ier)

! ident_3="@(#) M_calculator parens_(3fp) crack out the parenthesis and solve"

character(len=*)             :: string
integer,intent(inout)        :: nchar
integer,intent(out)          :: ier

character(len=icbuf_calc)    :: wstrng
character(len=:),allocatable :: dummy
integer                      :: imax
integer                      :: ileft
integer                      :: iright
integer                      :: i
integer                      :: iz
integer                      :: iwnchr
real(kind=dp)                :: rdum
!#----------------------------------------------------------------------------------------------------------------------------------
   imax=nchar
   ier=0
   INFINITE: do
!#----------------------------------------------------------------------------------------------------------------------------------
   ileft=0                                    ! where rightmost left paren was found
   do i=imax,1,-1                             ! find rightmost left paren
      if(string(i:i).eq.'(')then
         ileft=i
         exit
      endif
   enddo
!#----------------------------------------------------------------------------------------------------------------------------------
      if(ileft.eq.0)then                          ! no left parenthesis was found; finish up
         if(index(string(:nchar),')').ne.0) then  ! if here there are no left paren. check for an (unmatched) right paren
            ier=-1
            mssge='*parens_* extraneous right parenthesis found'
         else
   !        no parenthesis left, reduce possible expression to a single value primitive and quit
   !        a potential problem is that a blank string or () would end up here too.
            call expressions_(string,nchar,rdum,ier)
         endif
         return
      endif
!#----------------------------------------------------------------------------------------------------------------------------------
      iright=index(string(ileft:nchar),')') ! left parenthesis was found; find matching right paren
      if(iright.eq.0) then
         ier=-1
         mssge='*parens_* right parenthesis missing'
         return
      endif
!#----------------------------------------------------------------------------------------------------------------------------------
      iright=iright+ileft-1  !there was a matched set of paren remaining in the string
      iz=1  ! check now to see if this is a function call. search for an operator
!     if ileft is 1, then last set of parenthesis,(and for an expression)
      if(ileft.ne.1)then
         do i=ileft-1,1,-1
            iz=i
            if(index('#=*/(,',string(i:i)).ne.0)then
               iz=iz+1
               goto 11
            endif
         enddo
!        if here, a function call begins the string, as iz=1 but ileft doesn't
      endif
!=======================================================================------------------------------------------------------------
!     iz=position beginning current primitive's string
!     ileft=position of opening parenthesis for this primitive
!     iright=position of end and right parenthesis for this string
11    continue
      if(iz.eq.ileft)then  ! if ileft eq iz then a parenthesized expression, not a function call
         wstrng=string(ileft+1:iright-1)
         iwnchr=iright-1-(ileft+1)+1
         call expressions_(wstrng,iwnchr,rdum,ier)
      else
         wstrng=string(iz:iright)
         iwnchr=iright-iz+1
         call funcs_(wstrng,iwnchr,ier)
      endif
      if(ier.eq.-1)return !     if an error occurred in expressions_ or funcs_, then return
      ! restring the evaluated primitive back into the main string
      ! remember that if an expression, iz=ileft
      ! last set of -matched- parentheses, and entire string was evaluated
      if(iz.eq.1.and.iright.eq.nchar)then
         dummy=wstrng(:iwnchr)
         nchar=iwnchr
!        last set of -matched- parentheses, but other characters still to right
      elseif(iz.eq.1)then
         dummy=wstrng(:iwnchr)//string(iright+1:nchar)
         nchar=iwnchr+nchar-iright
      elseif(iright.eq.nchar)then
!        last expression evaluated was at end of string
         dummy=string(:iz-1)//wstrng(:iwnchr)
         nchar=iz-1+iwnchr
      else
!        last expression evaluated was in middle of string
         dummy=string(:iz-1)//wstrng(:iwnchr)//string(iright+1:nchar)
         nchar=iz-1+iwnchr+nchar-iright
      endif
!     set last place to look for a left parenthesis to one to the left
!     of the beginning of the primitive just reduced, or to a 1 so that
!     the loop looking for the left parenthesis doesn't look for a
!     parenthesis at position 0:0
      imax=max(iz-1,1)
      string=dummy
   enddo INFINITE
end subroutine parens_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    funcs_(3fp) - [M_calculator]given string of form name(p1,p2,...) (p(i) are non-parenthesized expressions)
!!    call procedure "name" with those values as parameters.
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    recursive subroutine funcs_(wstrng,nchars,ier)
!!
!!     character(len=*)                    :: wstrng
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
recursive subroutine funcs_(wstrng,nchars,ier)

! ident_4="@(#) M_calculator funcs_(3fp) given string of form name(p1 p2 ...) (p(i) are non-parenthesized expressions) call procedure "name""

character(len=*)                    :: wstrng
integer                             :: nchars
integer                             :: ier

integer,parameter                   :: iargs=100
character(len=10),save              :: days(7)
character(len=10),save              :: months(12)
character(len=iclen_calc)           :: ctmp
character(len=iclen_calc)           :: ctmp2
character(len=iclen_calc)           :: junout
character(len=iclen_calc)           :: cnum
character(len=icname_calc)          :: wstrng2

real(kind=dp)                       :: args(iargs)

real(kind=dp)                       :: arg1
real(kind=dp)                       :: arg2
real(kind=dp)                       :: bottom
real(kind=dp)                       :: false
real(kind=dp)                       :: fval
real(kind=dp)                       :: top
real(kind=dp)                       :: true
real(kind=dp)                       :: val

real,external                       :: c

!!integer,save                        :: ikeepran=22
integer                             :: i
integer                             :: i1
integer                             :: i1010
integer                             :: i1033
integer                             :: i1060
integer                             :: i1066
integer                             :: i2
integer                             :: i2020
integer                             :: i3030
integer                             :: i410
integer                             :: i440
integer                             :: i520
integer                             :: iargs_type(iargs)
integer                             :: ibegin(ixyc_calc),iterm(ixyc_calc)
integer                             :: icalen
integer                             :: icount
integer                             :: idarray(8)
integer                             :: idig
integer                             :: idum
integer                             :: iend
integer                             :: iend1
integer                             :: iend2
integer                             :: iflen
integer                             :: ii
integer                             :: iii
integer                             :: ileft
integer                             :: ilen
integer                             :: in
integer                             :: indexout
integer                             :: ios
integer                             :: iright
integer                             :: istart
integer                             :: istore
integer                             :: istoreat
integer                             :: isub
integer                             :: itype
integer                             :: ival
integer                             :: ivalue
integer                             :: jend
integer                             :: n
integer                             :: ierr
integer                             :: ii2

intrinsic                           :: abs,aint,anint,exp,nint,int,log,log10
intrinsic                           :: acos,asin,atan,cos,cosh,sin,sinh,tan,tanh
intrinsic                           :: sqrt,atan2,dim,mod,sign,max,min
!-----------------------------------------------------------------------------------------------------------------------------------
   data months/'January','February','March','April','May','June','July','August','September','October','November','December'/
   data days/'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'/

   TRUE=0.0d0
   FALSE=1.0d0
   ier=0
   iright=nchars-1
   ileft=index(wstrng(1:nchars),'(')+1
   iend=ileft-2
   iflen=iright-ileft+1
!  n=number of parameters found
   if(iright-ileft.lt.0)then ! if call such as fx() expression string is null
      n=0
   else ! take string of expressions separated by commas and place values into an array and return how many values were found
      call args_(wstrng(ileft:iright),iflen,args,iargs_type,n,ier,100)
      if(ier.eq.-1)then
         goto 999
      else
         ier=0 ! ier could be 2 from args_()
      endif
   endif
   wstrng2=' '
   wstrng2(:iend)=lower(wstrng(:iend))
   fval=0.0d0
   if(ier.eq.-1)then
      goto 999
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
select case (wstrng2(:iend))
case("abs","aint","anint","ceil","ceiling","floor","frac","int","nint",&
    &"d2r","r2d",&
    &"c2f","f2c",&
    &"gamma","log_gamma",&
    &"log","log10","exp",&
    &"bessel_j0","bessel_j1","bessel_y0","bessel_y1",&
    &"erf","erfc","erfc_scaled",&
    &"sin","cos","tan",&
    &"sind","cosd","tand",&
    &"sinh","cosh","tanh",&
    &"asin","acos","atan",&
    &"asinh","acosh","atanh",&
!   &"cpu_time",&
    &"exponent","fraction",&
    &"real","sqrt")
      if(n.ne.1)then                                                    ! check number of parameters
        mssge='*funcs_* incorrect number of parameters in '//wstrng2(:iend)
        ier=-1
      elseif(iargs_type(1).ne.0)then                                    ! check type of parameters
        mssge='*funcs_* parameter not numeric in '//wstrng2(:iend)
        ier=-1
      else                                                              ! single numeric argument
         select case (wstrng2(:iend))
!=======================================================================------------------------------------------------------------
         case("acos");

         if(args(1).gt.1.or.args(1).lt.-1)then
           mssge='*acos* parameter not in range -1 >= value <=1'
           ier=-1
         else
            fval= acos(args(1))
         endif
         case("atan");   fval= atan(args(1))
         case("asin");   fval= asin(args(1))

         !case("cpu_time");   fval= cpu_time(args(1))
         case("fraction");   fval= fraction(args(1))
         case("exponent");   fval= exponent(args(1))
         case("gamma");      fval= gamma(args(1))
         case("log_gamma");  fval= log_gamma(args(1))

         case("cos");    fval= cos(args(1))
         case("sin");    fval= sin(args(1))
         case("tan");    fval= tan(args(1))

         case("acosh");    fval= acosh(args(1))
         case("asinh");    fval= asinh(args(1))
         case("atanh");    fval= atanh(args(1))

         case("cosd");   fval= cos(args(1)*acos(-1.0d0)/180.d0)
         case("sind");   fval= sin(args(1)*acos(-1.0d0)/180.d0)
         case("tand");   fval= tan(args(1)*acos(-1.0d0)/180.d0)

         case("cosh");   fval= cosh(args(1))
         case("sinh");   fval= sinh(args(1))
         case("tanh");   fval= tanh(args(1))

         case("erf");         fval= erf(args(1))
         case("erfc");        fval= erfc(args(1))
         case("erfc_scaled"); fval= erfc_scaled(args(1))

         case("d2r");    fval= args(1)*acos(-1.0d0)/180.d0
         case("r2d");    fval= args(1)*180.d0/acos(-1.0d0)

         case("c2f");    fval= (args(1)+40.0d0)*9.0d0/5.0d0 - 40.0d0
         case("f2c");    fval= (args(1)+40.0d0)*5.0d0/9.0d0 - 40.0d0

         case("bessel_j0");    fval= bessel_j0(args(1))
         case("bessel_j1");    fval= bessel_j1(args(1))
         case("bessel_y0");    fval= bessel_y0(args(1))
         case("bessel_y1");    fval= bessel_y1(args(1))

         case("abs");    fval= abs(args(1))
         case("aint");   fval= aint(args(1))
         case("anint");  fval= anint(args(1))
         case("ceil","ceiling");   fval=ceiling(real(args(1)))
         case("exp");    fval= exp(args(1))
         case("floor");  fval= floor(real(args(1)))
         case("frac");   fval= args(1)-int(args(1))
         case("int");    fval= int(args(1))
         case("nint");   fval= nint(args(1))
         case("real");   fval= real(args(1))
         case("sqrt");   fval= sqrt(args(1))
!=======================================================================------------------------------------------------------------
         case("log")
            if(args(1).le.0.0d0)then                                          ! check for appropriate value range for function
               write(*,g)'*log* ERROR: cannot take log of ',real(args(1))
            else                                                              ! call function with one positive numeric parameter
               fval= log(args(1))
            endif
!=======================================================================------------------------------------------------------------
         case("log10")
            if(args(1).le.0.0d0)then                                          ! check for appropriate value range for function
               write(*,g)'*log10* ERROR: cannot take log of ',real(args(1))
            else                                                              ! call function with one positive numeric parameter
               fval= log10(args(1))
            endif
!=======================================================================------------------------------------------------------------
         end select
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("atan2","dim","mod","bessel_jn","bessel_yn","sign","hypot","modulo","scale")
      if(n.ne.2)then                                                           ! check number of parameters
        mssge='*funcs_* incorrect number of parameters in '//wstrng2(:iend)
        ier=-1
      elseif(.not.all(iargs_type(1:2).eq.0))then                                ! check type of parameters
        mssge='*funcs_* parameters not all numeric in '//wstrng2(:iend)
        ier=-1
      else                                                                     ! single numeric argument
         select case (wstrng2(:iend))
         case("atan2");      fval=  atan2       ( args(1),       args(2)       )
         case("dim");        fval=  dim         ( args(1),       args(2)       )
         case("mod");        fval=  mod         ( args(1),       args(2)       )
         case("modulo");     fval=  modulo      ( args(1),       args(2)       )
         case("scale");      fval=  scale       ( args(1),       int(args(2))  )
         case("bessel_jn");  fval=  bessel_jn   ( int(args(1)),  args(2)       )
         case("bessel_yn");  fval=  bessel_yn   ( int(args(1)),  args(2)       )
         case("btest");      fval=  merge(TRUE, FALSE,  btest( int(args(1)),  int(args(2))  ) )
         case("sign");       fval=  sign        ( args(1),       args(2)       )
         case("hypot");      fval=  hypot       ( args(1),       args(2)       )
         end select
      endif
!=======================================================================------------------------------------------------------------
case("tiny")
      fval=tiny(0.d0)
case("epsilon")
      fval=epsilon(0.d0)
case("huge")
      fval=huge(0.d0)
!=======================================================================------------------------------------------------------------
case("x");
      ivalue=int(args(1)+0.5d0)
      if(ivalue.lt.1.or.ivalue.gt.ixy_calc)then              ! if value not at least 1, or if not less than ixy_calc, report it
        mssge='*funcs_* illegal subscript value for x array'
        ier=-1
      else
        fval= x(ivalue)
      endif
!=======================================================================------------------------------------------------------------
case("y")
      ivalue=int(args(1)+0.5d0)
!     if value not at least 1, make it 1. if not less than ixy_calc, make it ixy_calc
      if(ivalue.lt.1.or.ivalue.gt.ixy_calc)then
         mssge='*funcs_* illegal subscript value for y array'
         ier=-1
      else
         fval= y(ivalue)
      endif
!=======================================================================------------------------------------------------------------
case("max")
      if(n.lt.1)then
         ier=-1
         mssge='*max* incorrect number of parameters for '//wstrng(:iend)
      elseif(.not.all(iargs_type(1:n).eq.0))then ! check type of parameters
         ier=-1
         mssge='*max* illegal parameter type (must be numeric)'
      else
         fval=args(1)
         do i=2,n
            fval=max(fval,args(i))
         enddo
      endif
!=======================================================================------------------------------------------------------------
case("min")
       if(n.lt.1)then
         ier=-1
         mssge='incorrect number of parameters for '//wstrng(:iend)
      elseif(.not.all(iargs_type(1:n).eq.0))then ! check type of parameters
         ier=-1
         mssge='*min* illegal parameter type (must be numeric)'
       else
          fval=args(1)
          do i=2,n
             fval=min(fval,args(i))
          enddo
       endif
!=======================================================================------------------------------------------------------------
case("xstore","ystore")                                        ! xstore function===>(where_to_start,value1,value2,value3...)
      if(n.lt.2)then                                           ! need at least subscript to start storing at and a value
         ier=-1
         mssge='incorrect number of parameters for '//wstrng(:iend)
         fval=0.0d0
      else                                                     ! at least two values so something can be stored
         istoreat=int(args(1)+0.50d0)                          ! array subscript to start storing values at
         if(istoreat.lt.1.or.istoreat+n-2.gt.ixy_calc)then     ! ignore -entire- function call if a bad subscript reference was made
            mssge='*funcs_* illegal subscript value for array in '//wstrng(:iend)
            ier=-1
            fval=0.0d0
         else                                                  ! legitimate subscripts to store at
            STEPTHRU: do i1033=2,n                             ! for each argument after the first one store the argument
               select case(wstrng2(:iend))                     ! select X array or Y array
                  case("xstore");x(istoreat)=args(i1033)
                  case("ystore");y(istoreat)=args(i1033)
               end select
               istoreat=istoreat+1                             ! increment location to store next value at
            enddo STEPTHRU
            fval=args(n)                                       ! last value stored will become current value
         endif
      endif
!=======================================================================------------------------------------------------------------
case("lle","llt","leq","lge","lgt","lne")
      if(iargs_type(1).eq.2.and.iargs_type(2).eq.2)then
         do i2020=1,n
            if(args(i2020).le.0.or.args(i2020).gt.size(values))then
               ier=-1
               mssge='unacceptable locations for strings encountered'
               goto 999
            endif
         enddo
         fval=FALSE ! assume false unless proven true
         i1=int(args(1))
         i2=int(args(2))
         ier=0
         select case (wstrng2(:iend))
         case("lle")
            if(values(i1).le.values(i2))fval=TRUE
         case("llt")
            if(values(i1).lt.values(i2))fval=TRUE
         case("leq") ! if any string matches the first
            do i410=2,n
               if(iargs_type(i410).ne.2)then     ! all parameters should be a string
                  ier=-1
                  mssge='non-string value encountered'
               elseif(values(i1).eq.values(int(args(i410)+0.5d0)))then
                  fval=TRUE
               endif
            enddo
         case("lge")
            if(values(i1).ge.values(i2))fval=TRUE
         case("lgt")
            if(values(i1).gt.values(i2))fval=TRUE
         case("lne")
            do i440=2,n
               fval=TRUE
               if(iargs_type(i440).ne.2)then     ! all parameters should be a string
                  ier=-1
                  mssge='non-string value encountered'
               elseif(values(i1).eq.values(int(args(i440)+0.5d0)))then
                  fval=FALSE
               endif
            enddo
         case default
            ier=-1
            mssge='internal error in funcs_ in lexical functions'
         end select
      else
         ier=-1
         mssge='lexical functions must have character parameters'
      endif
!=======================================================================------------------------------------------------------------
case("le","lt","eq","ge","gt","ne")
      fval=FALSE
      do i520=1,n
         if(iargs_type(i520).ne.0)then  ! this parameter was not a number
            ier=-1
            mssge='*logical* parameter was not a number'
            goto 999
         endif
      enddo
      if(n.eq.2.or.n.eq.3)then
         if(n.eq.3)then
            idig=int(args(3))
            if(idig.le.0.or.idig.gt.13)then
               mssge='*logical* precision must be between 1 and 13'
               ier=-1
               goto 999
            endif
            write(junout,'(a,3(g23.16e3,1x),i5)')'args=',args(1),args(2),args(3),idig
            write(*,g)trim(junout)
            arg1=round(args(1),idig)
            arg2=round(args(2),idig)
            write(junout,'(a,3(g23.16e3,1x),i5,1x,2(g23.16e3,1x))')'b. args=',args(1),args(2),args(3),idig,arg1,arg2
            write(*,g)trim(junout)
         else
            arg1=args(1)
            arg2=args(2)
         endif
         call stuff('LOGICAL1',arg1)
         call stuff('LOGICAL2',arg2)
         call stuff('STATUS',arg2-arg1)
         select case(wstrng2(:iend))
         case("le"); if(arg1.le.arg2)fval=TRUE
         case("lt"); if(arg1.lt.arg2)fval=TRUE
         case("eq"); if(arg1.eq.arg2)fval=TRUE
         case("ge"); if(arg1.ge.arg2)fval=TRUE
         case("gt"); if(arg1.gt.arg2)fval=TRUE
         case("ne"); if(arg1.ne.arg2)fval=TRUE
         case default
            ier=-1
            mssge='*logical* internal error in funcs_'
         end select
      else
         ier=-1
         mssge='*logical* must have 2 or 3 parameters'
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("ichar")
      if(n.ne.1)then
         mssge='*ichar* takes one parameter'
         ier=-1
      elseif(iargs_type(1).ne.2)then
         mssge='*ichar* parameter must be a string'
         ier=-1
      else
         fval=ichar(values(int(args(1)))(1:1))
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$ge","$getenv") ! $getenv or $ge get system environment variable
   ii=int(args(1)+0.5d0)
   ilen=values_len(ii)
   if(ilen.ge.1)then
      call get_environment_variable(values(ii)(:ilen),ctmp)
      fval=len_trim(ctmp)
      if(fval.eq.0)then ! if value comes back blank and a non-blank default string is present, use it
         if(n.ge.2)then
            ii2=int(args(2)+0.5d0)
            ctmp=values(ii2)
            fval=values_len(ii2)
         endif
      endif
      fval=max(1.0d0,fval)
   else
      ctmp=' '
      fval=1.0d0
   endif
   ier=2
   iend=len_trim(ctmp)
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("if")
      if(args(1).eq. TRUE)then
        fval=args(2)
      else
        fval=args(3)
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$if")                                      ! $if function
      ier=2                                      ! returning string
!     check that 2nd and 3rd are acceptable string variables, should do generically at name lookup time
      if(args(1).eq. TRUE)then
        ii=int(args(2))
      else
        ii=int(args(3))
      endif
      ctmp=values(ii)
      iend=values_len(ii)
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("in")                                                            ! in(lower_value,value,upper_value)
      fval=FALSE
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      select case(n)
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case(2)                                                         ! if two parameters test {first - second}<epsilon
        if(iargs_type(1).eq.0.and.iargs_type(2).eq.0)then
           val=abs(args(1)-args(2))
           top=epsilon(0.0d0)
           bottom=-top
        else
         mssge='*in* parameters must be numeric'
         ier=-1
        endif
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case(3)                                                         ! if three parameters test if second between first and third
        if(iargs_type(1).eq.0.and.iargs_type(2).eq.0.and.iargs_type(3).eq.0)then
           bottom=args(1)
           val=args(2)
           top=args(3)
        else
         mssge='*in* parameters must be numeric'
         ier=-1
        endif
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case default
         mssge='*in* number of parameters not valid IN(LOWER_VALUE,VALUE,UPPER_VALUE)'
         ier=-1
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      end select
      !=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      if(ier.ge.0) then
         if(val.ge.bottom.and.val.le.top)fval=TRUE
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("index")
      ii=int(args(1))
      iii=int(args(2))
      if(iargs_type(1).eq.2.and.iargs_type(2).eq.2)then ! if parameter was a string leave it alone
         iend1=values_len(ii)
         iend2=values_len(iii)
         fval=index(values(ii)(:iend1),values(iii)(:iend2))
      endif
      ier=0   ! flag that returning a number, not a string
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("len","len_trim")
      ii=int(args(1))
      iend1=values_len(ii)
      fval=len_trim(values(ii)(:iend1))
      ier=0   ! flag that returning a number, not a string
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("rand")                                                            ! random number
      select case (n)                                                   ! check number of parameters
      case (0)                                                          ! use default method
         itype=3
      case (1)                                                          ! determine user-specified method
         itype=int(args(1)+0.5d0)
         if(itype.lt.1.or.itype.gt.3)then
            itype=3
         endif
      case default
         mssge='illegal number of arguments for rand()'
         ier=-1
         itype=-1
      end select

      select case (itype)                                               ! select various methods
      case (-1)                                                         ! an error has already occurred
      case (2)                                                          ! standard Fortran function
         call random_number(harvest=fval)
      !!case default                                                      ! "Numerical Recipes" routine
      !!fval=ran_mod(ikeepran)
      case default
         call random_number(harvest=fval)
      end select
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("srand")                                                           ! seed random number sequence
      select case (n)                                                   ! check number of parameters
      case (1)                                                          ! no user-specified type
         itype=3                                                        ! use default method
      case (2)                                                          ! determine user-specified method
         itype=int(args(2)+0.5d0)                                         ! user-specified type
      case default                                                      ! call syntax error
         mssge='illegal number of arguments for srand()'
         ier=-1
      end select
      if(ier.eq.0)then
         ivalue=int(args(1)+0.5d0)                                           ! determine seed value
         select case (itype)                                               ! select various methods
         case (2)                                                          ! standard Fortran method
            call init_random_seed(ivalue)
         !!case (3)                                                          ! default is "Numerical Recipes" method
         !!   ikeepran=-abs(ivalue)
         !!   fval=ran_mod(ikeepran)                                         ! just setting seed; fval is a dummy here
         case default
            mssge='unknown type for srand()'
            ier=-1
         end select
         fval=ivalue
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$f")                              ! $f(format,value) Using single format specifier, return string
      ier=2                             ! string will be returned
      if(n.eq.0)then
         ctmp=' '
      else
         ctmp=' '
         if(iargs_type(1).eq.2)then     ! if first field is a string
            ii=int(args(1))             ! get index into values() array
            iend1=values_len(ii)            ! maximum end is at end of string
            if(n.gt.1)fval=args(n)      ! get the real value
            write(ctmp,'('// values(ii)(:iend1)//')',iostat=ios)args(2:n)
            if(ios.ne.0)then
               ctmp='*'
               ier=-1
               mssge='*$f()* error writing value'
            endif
         endif
      endif
      iend=len_trim(ctmp)
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$repeat")                              ! $repeat(string,count) concatenate string count times
      ier=2                                  ! string will be returned
      if(n.eq.0)then
         ctmp=' '
      else
         ctmp=' '
         if(iargs_type(1).eq.2)then     ! if first field is a string
            ii=int(args(1))             ! get index into values() array
            iend1=values_len(ii)        ! maximum end is at end of string
            if(n.gt.1)fval=args(n)      ! get the real value
            if(fval.lt.0)then
               ier=-1
               mssge='Argument NCOPIES of REPEAT intrinsic is negative'
            else
               ctmp=repeat(values(ii)(:iend1),nint(fval))
            endif
         else
            ier=-1
            mssge='*$repeat()* first value not string'
         endif
      endif
      iend=len_trim(ctmp)
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$char")
      ier=2                                      ! return string
      if(n.eq.0)then
         ier=-1
         mssge='*$char* must have at least one parameter'
      else
         iend=0
         do i3030=1,n                            ! unlike FORTRAN, can take multiple characters and mix strings and numbers
            ii=int(args(i3030))
            if(iargs_type(i3030).eq.2)then       ! if parameter was a string leave it alone
               iend2=iend+values_len(ii)
               ctmp(iend+1:iend2)=values(ii)
               iend=iend2
            else                                 ! convert numeric ADE to a character
               iend=iend+1
               ctmp(iend:iend)=char(ii)
            endif
         enddo
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$substr")                                  ! $substr(string,start,end)
      ier=2                                      ! return string
      if(n.eq.0)then
         ctmp=' '
      else
         ii=int(args(1))
         istart=1
         iend1=values_len(ii)                        ! maximum end is at end of string
         ctmp=' '
         if(iargs_type(1).eq.2)then
            if(n.gt.1)istart=min(max(1,int(args(2))),iend1)
            if(n.gt.2)iend1=max(min(int(args(3)),iend1),1)
            iend=iend1-istart+1
            ctmp(:iend)=values(ii)(istart:iend1)
         endif
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$nstore","$xstore","$ystore")
      ier=2                                      ! return string
      if(n.lt.2)then
         ier=-1
         mssge='incorrect number of parameters for '//wstrng(:iend)
      else
         ivalue=int(args(1)+0.5d0)
!        $nstore function===>store $n(where_to_start,value1,value2,value3...)
!        ignore -entire- function call if a bad subscript reference was made
         if(ivalue.lt.1.or.ivalue+n-2.gt.ixyc_calc)then
           mssge='illegal subscript value for array in '//wstrng2(:iend)
           ier=-1
         else
            do i1066=ivalue,ivalue+n-2,1
               isub=i1066-ivalue+2
               select case(wstrng2(:iend))
               case("$nstore"); nc(i1066)=values(int(args(isub)))
               case("$xstore"); xc(i1066)=values(int(args(isub)))
               case("$ystore"); yc(i1066)=values(int(args(isub)))
               end select
            enddo
            ctmp=values(ivalue+n-2)
            iend=len_trim(ctmp) ! very inefficient
         endif
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("str","$str","$") ! "$str" appends numbers and strings into a new string
                   ! "str" converts string to number IF string is simple numeric value
      jend=0
      ctmp=' '
      do i1010=1,n
         istart=jend+1                                     ! where to start appended argument in output string
         if(iargs_type(i1010).eq.2)then                    ! this parameter was a string
            in=int(args(i1010))                            ! the value of a string argument is the subscript for where the string is
            jend=istart+values_len(in)-1                       ! where appended argument ends in output string
            ctmp(istart:jend)=values(in)(:values_len(in))
         elseif(iargs_type(i1010).eq.0)then                ! this parameter was a number
            if(args(i1010).ne.0)then
               call value_to_string(args(i1010),cnum,ilen,ier,fmt='(g23.16e3)',trimz=.true.) ! minimum of 23 characters required
               if(ier.ne.-1)then
                  ilen=max(ilen,1)
                  jend=istart+ilen-1
                  if(cnum(ilen:ilen).eq.'.')jend=jend-1    ! this number ends in a decimal
                  jend=max(jend,istart)
                  if(jend.gt.len(ctmp))then
                     write(*,g)'*funcs_* $str output string truncated'
                     jend=len(ctmp)
                  endif
                  ctmp(istart:jend)=cnum(:ilen)
               endif
            else                                           ! numeric argument was zero
               ctmp(istart:istart)='0'
               jend=jend+1
            endif
         else
            mssge='*funcs_* parameter to function $str not interpretable'
            ier=-1
         endif
      enddo
      if(ier.ge.0)then
         select case(wstrng2(:iend))
         case("$str","$")
             ier=2
         case("str")
             ier=0
             call a_to_d_(ctmp,fval,ier)                    ! str function
         case default
            mssge='*funcs_* internal error: should not get here'
            ier=-1
         end select
      endif
      iend=jend
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$x","$y","$n")
      ier=2                                                  ! returning string
      ivalue=int(args(1)+0.5d0)
      if(ivalue.lt.1.or.ivalue.gt.ixyc_calc)then             ! if value not at least 1, or if not less than ixyc_calc, report it
        mssge='illegal subscript value for $x array'
        ier=-1
      else
         select case(wstrng2(:iend))
            case("$x");ctmp= xc(ivalue)
            case("$y"); ctmp= yc(ivalue)
            case("$n"); ctmp= nc(ivalue)
         end select
         iend=len_trim(ctmp) ! very inefficient
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("unusedf")
      fval=0.0d0
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$l") ! $l lower(string)
      ier=2                                      ! returning string
      if(n.ne.1)then
         ctmp=' '
         ier=-1
         mssge='*$l* must have one parameter'
      else
         ctmp=lower(values(int(args(1)+0.5d0)))
         iend=len_trim(ctmp) ! very inefficient
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$u")! $u upper(string)
      ier=2                                      ! returning string
      if(n.ne.1)then
         ctmp=' '
         ier=-1
         mssge='*$u* must have one parameter'
      else
         ctmp=upper(values(int(args(1)+0.5d0)))
         iend=len_trim(ctmp) ! very inefficient
      endif
!=======================================================================------------------------------------------------------------
case("c");      fval= myfunc(args,n)                          ! c(curve_number) or c(curve_number,index)
!=======================================================================------------------------------------------------------------
case("ownmode")                                               ! specify whether to look for substitute_subroutine(3f) routine
      if(n.eq.1.and.iargs_type(1).eq.0)then
         if(args(1).gt.0)then
            ownon=.true.
         else
            ownon=.false.
         endif
         fval= args(1)
      else
        mssge='*ownmode* illegal arguments'
        ier=-1
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("delimx")                ! 'delimx(istore,line,delimiters)  parse a string into $x array and return number of tokens
      if(n.ne.3)then                                                                     ! wrong number of parameters
         ier=-1
         mssge='incorrect number of parameters for '//wstrng(:iend)
      else
         if(iargs_type(2).ne.2)then
            mssge='*delimx* second parameter not a string'
           ier=-1
         else
            ctmp=values(int(args(2)+0.5d0))                                                ! string to parse
            if(iargs_type(3).ne.2)then
               mssge='*delimx* delimiter parameter not a string'
              ier=-1
            else
               ctmp2=values(int(args(3)+0.5d0))                                            ! delimiters
               if(iargs_type(1).ne.0)then
                  mssge='*delimx* first parameter not an index number'
                 ier=-1
               else
                  istore=int(args(1)+0.5d0)                                                ! where to start storing into $n array at
                  call delim(ctmp,['#NULL#'],ixyc_calc,icount,ibegin,iterm,ilen,ctmp2)
                  if(istore.lt.1.or.istore+n-2.gt.ixyc_calc)then  ! ignore entire function call if bad subscript reference was made
                     mssge='illegal subscript value for array in delim'
                     ier=-1
                  else
                     do i1060=1,icount
                        xc(istore)=ctmp(ibegin(i1060):iterm(i1060))
                        istore=istore+1
                     enddo
                     fval=icount  ! return number of tokens found
                     ier=0
                  endif
               endif
            endif
         endif
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("round")
      if(n.ne.2)then                                                           ! check number of parameters
        mssge='*funcs_* incorrect number of parameters in '//wstrng2(:iend)
        ier=-1
      elseif(.not.all(iargs_type(1:2).eq.0))then                                ! check type of parameters
        mssge='*funcs_* parameters not all numeric in '//wstrng2(:iend)
        ier=-1
      else                                                                      ! single numeric argument
         fval=round(args(1),int(args(2)))
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("ifdef")
      fval=-1
      if(n.ne.1)then                                             ! check number of parameters
         mssge='*ifdef* incorrect number of parameters in '//wstrng(:iend)
         ier=-1
      elseif(iargs_type(1).ne.2)then                             ! the parameter should be a name of a variable
         mssge='*ifdef* name not a string:'//wstrng(:iend)
         ier=-1
      else
         ii=int(args(1))                                         ! get index into values() array
         iend1=values_len(ii)                                        ! maximum end is at end of string
         if(values(ii)(1:1).eq.'$')then
            call locate(keys_q,values(ii)(:iend1),indexout,ierr) ! determine if the string variable name exists
         else
            call locate(keyr_q,values(ii)(:iend1),indexout,ierr) ! determine if the numeric variable name exists
         endif
         if(ierr.ne.0)then                                       ! unexpected error
            ier=-1
         elseif(indexout.gt.0)then                               ! found variable name
            fval=0
         else                                                    ! did not find variable name
            fval=-1
         endif
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("ye","year","mo","month","da","day","tz","timezone","ho","hour","mi","minute","se","second","ms","millisecond")
         icalen=1                                                       ! default value that is safe even if an error occurs
         !------------------------------------------
         call date_and_time(values=idarray)
         !------------------------------------------
         if(n.eq.0)then
            select case(wstrng2(:iend))                                 ! select desired subscript of value to return
               case("ye","year");         icalen=1                      ! year
               case("mo","month");        icalen=2                      ! month
               case("da","day");          icalen=3                      ! day
               case("tz","timezone");     icalen=4                      ! timezone
               case("ho","hour");         icalen=5                      ! hour
               case("mi","minute");       icalen=6                      ! minute
               case("se","second");       icalen=7                      ! second
               case("sd","millisecond");  icalen=8
               case default                                             ! report internal error if name was not matched
                  ier=-1
                  mssge='*calendar* internal error, unknown keyword'//wstrng2(:iend)
               end select
               fval=idarray(icalen)
         else
            ier=-1
            mssge='*calendar* parameters not allowed'
            fval=0.0d0
         endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case("$mo")                             ! $mo(1-12) is "January, February, ... ")
      ctmp=''
      ier=2                             ! string will be returned
      if(n.lt.1)then                    ! $mo() use today
         call date_and_time(values=idarray)
         ival=idarray(2)
      elseif(n.eq.1)then                ! $mo(N) just index into month names
         ival=mod(int(args(1))-1,12)+1
         if(ival.le.0)ival=ival+12
      elseif(args(2).eq.1)then          ! $mo(YYYYMMDD,1) returns MM
         ival=int(args(1))
         ival=ival-((ival/10000)*10000) ! reduce to a four-digit value
         ival=ival/100                  ! keep two high digits out of the four
         ival=mod(ival-1,12)+1          ! ensure in range 1 to 12
         if(ival.le.0)ival=ival+12
      else
         ival=1
         ctmp='UNKNOWN'
         iend=7
         mssge='*$mo* parameter(s) not valid'
         ier=-1
      endif
      if(ctmp.eq.'')then
         ctmp=months(ival)
      endif
      iend=len_trim(ctmp(1:20))
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=------------------------------------------------------------
case default
      if(ownon)then
!        ==>wstrng(1:iend)=procedure name.
!        ==>iend=length of procedure name.
!        ==>args=array of ixy_calc elements containing procedure arguments.
!        ==>iargs_type=type of argument
!        ==>n=integer number of parameters
!        ==>x=array of ixy_calc x values
!        ==>y=array of ixy_calc y values
!        ==>ctmp is returned string if string function is called ( in which case fval is returned number of characters in ctmp)
         ier=0
         call mysub(wstrng(:iend),iend,args,iargs_type,n,fval,ctmp,ier)
!        <==fval=returned value to replace function call with
!        <=>ier=returned error flag.  Set to -1 if an error occurs.  Otherwise, user should leave it alone
         if(ier.eq.-1)then
         elseif(ier.eq.2)then
            iend=int(fval) ! string functions should return string length in fval
            if(fval.le.0)then
               mssge='*funcs_* bad length for returned string'
               ier=-1
            endif
         else
            ier=0
         endif
      else
        mssge='*funcs_* function not found: '//wstrng(:iend)
        ier=-1                           ! ya done blown it if you get here
      endif
!-----------------------------------------------------------------------------------------------------------------------------------
end select
!-----------------------------------------------------------------------------------------------------------------------------------
999   continue             ! return based on value of ier
      select case(ier)
      case(2)   ! return string value
        call stufftok_(fval,wstrng,nchars,ctmp(:iend),iend,ier) ! add a new token variable and assign string to it
      case(0)   ! return numeric value
        call value_to_string(fval,wstrng,nchars,idum,fmt='(g23.16e3)',trimz=.true.) ! minimum of 23 characters required
      case(-1)  ! return error
      case default
         write(*,g)'*funcs_* unknown closing value ',ier
         ier=-1
      end select
end subroutine funcs_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    stufftok_(3fp)- [M_calculator] add a new token variable and assign string to it
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine stufftok_(fval,wstrng,nchars,string,iend,ier)

! ident_5="@(#) M_calculator stufftok_(3fp) add a new token variable and assign string to it"

real(kind=dp)          :: fval
character(len=*)       :: wstrng
integer                :: nchars
character(len=*)       :: string
integer                :: iend
integer                :: ier

character(len=5)       :: toknam
!-----------------------------------------------------------------------------------------------------------------------------------
   ktoken=ktoken+1                            ! increment the counter of strings found to get a place to store into
   nchars=5
   write(toknam,'(''$_'',i3.3)')ktoken        ! build a unique name for the token string found for this output string
   wstrng=toknam
   call stuffa(toknam,string(:iend),'')       ! cannot do this earlier or indexs from call that defined args could be wrong
   fval=0.0d0
   ier=2
   mssge=string(:iend)
end subroutine stufftok_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    args_(3fp)- [M_calculator] given 'par1,par2,...' store non-parenthesized expression par(n) into a real or string array
!! (LICENSE:PD)
!!##SYNOPSIS
!!
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine args_(line,ilen,array,itype,iarray,ier,mx)

! ident_6="@(#) M_calculator args_(3fp) given 'par1 par2 ...' store non-parenthesized expression par(n) into a real or string array"

!@ (#) record type of par(n) into itype()"
!@ (#) Commas are only legal delimiters. extra or redundant delimiters are ignored.

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)           :: line      ! input string
integer,intent(in)                    :: ilen      ! length of input string
integer,intent(in)                    :: mx        ! up to mx par(i) will be extracted. if more found an error is generated.
real(kind=dp),intent(out)             :: array(mx)
integer,intent(out)                   :: itype(mx) ! itype=0 for number, itype=2 for string
integer,intent(out)                   :: iarray    ! number of parameters found
integer                               :: ier       ! ier=-1 if error occurs, ier undefined (not changed) if no error.
!-----------------------------------------------------------------------------------------------------------------------------------
integer :: icalc
integer :: icol
integer :: iend
integer :: ilook
integer :: istart
character(len=1),parameter :: delimc=','
character(len=icbuf_calc)  :: wstrng
!-----------------------------------------------------------------------------------------------------------------------------------
   iarray=0
   if(ilen.eq.0)then  ! check if input line (line) was totally blank
      return
   endif
!  there is at least one non-delimiter character in the command.
!  ilen is the column position of the last non-blank character
!  find next non-delimiter
   icol=1
   do ilook=1,mx,1
     do
        if(line(icol:icol).ne.delimc)then
           iarray=iarray+1
           istart=icol
           iend=index(line(istart:ilen),delimc)
           if(iend.eq.0)then   ! no delimiter left
              icalc=ilen-istart+1
              wstrng=line(istart:ilen)
              ier=0
              call expressions_(wstrng,icalc,array(iarray),ier)
              itype(iarray)=ier
              return
           else
              iend=iend+istart-2
              icalc=iend-istart+1
              wstrng=line(istart:iend)
              ier=0
              call expressions_(wstrng,icalc,array(iarray),ier)
              itype(iarray)=ier
              if(ier.eq.-1)return
           endif
           icol=iend+2
           exit
        else
           icol=icol+1
           if(icol.gt.ilen)return       ! last character in line was a delimiter, so no text left
        endif
     enddo
     if(icol.gt.ilen)return       ! last character in line was a delimiter, so no text left
   enddo
   write(mssge,'(a,i4,a)')'more than ',mx,' arguments not allowed'
   ier=-1
end subroutine args_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!! expressions_(3fp) - [M_calculator] resolve a series of terms into a single value and restring
!! (LICENSE:PD)
!!##SYNOPSIS
!!
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine expressions_(string,nchar,value,ier)

! ident_7="@(#) M_calculator expressions_(3fp) resolve a series of terms into a single value and restring"

character(len=*),intent(inout) :: string
integer,intent(inout)          :: nchar
real(kind=dp),intent(out)      :: value
integer,intent(out)            :: ier
character(len=icbuf_calc) :: dummy            ! no single term may be over (icbuf_calc) characters
integer :: ier2
integer :: iend
integer :: iendm
integer :: iendp
integer :: ista
integer :: istat
integer :: nchar2
real(kind=dp) :: temp
!-----------------------------------------------------------------------------------------------------------------------------------
                               !!!!! what happens if the returned string is longer than the input string?
      value=0.0d0              ! initialize sum value to be returned to 0
      if(nchar.eq.0) return    ! if this is a null string return
                 ! first cut at handling string variables. assuming, with little checking, that the only string expression
                 ! that can get here is a single variable name (or variable token) and that string variable names start with a $
                 ! and that the error flag should be set to the value 2 to indicate that a string, not a number, is being returned
                 ! for the 2 to get back, it must not be changed by this routine or anything it calls
      if(string(1:1).eq.'$')then
         call given_name_get_stringvalue_(string,ier)
         if(ier.eq.-1)return
         ier=2                 ! flag that a character string is being returned
!x       return
      endif
!x!!!!!
      ista=1                                        ! initialize the position of the unary sum operator for the current term
      if(index('#=',string(1:1)).ne.0)then          ! check if input string starts with a unary (+-) operator
        istat=2                                     ! a starting unary sum operator is present, so the first term starts in column 2
      else                                          ! input string does not start with a unary sum (-+) operator
        istat=1                                     ! no initial sum operator is present, so the first term starts in column 1
      endif
      do
         iendp=index(string(istat:nchar),'#')     ! find left-most addition operator
         iendm=index(string(istat:nchar),'=')     ! find left-most subtraction operator
         iend=min(iendp,iendm)                    ! find left-most sum (+-) operator assuming at least one of each exists
         if(iend.eq.0)iend=max(iendm,iendp)       ! if one of the sum operators is not remaining, find left-most of remaining type
         if(iend.eq.0)then                        ! if no more sum operators remain this is the last remaining term
            iend=nchar                            ! find end character of remaining term
         else                                     ! more than one term remains
            iend=iend+istat-2                     ! find end character position of this (left-most) term
         endif
         dummy=string(istat:iend)                 ! set string dummy to current(left-most) term
         nchar2=iend-istat+1                      ! calculate number of characters in current term
!        given that the current term ( dummy) is an optionally signed string containing only the operators **, * an / and no
!        parenthesis, reduce the string to a single value and add it to the sum of terms (value). do not change the input string.
         call pows_(dummy,nchar2,ier)            ! evaluate and remove ** operators and return the altered string (dummy)
         if(ier.eq.-1) return                     ! if an error occurred, return
         call factors_(dummy,nchar2,temp,ier)       ! evaluate and remove * and / operators, return the evaluated -value- temp
         if(ier.eq.-1)return                      ! if an error occurred, return
         if(string(ista:ista).eq.'=')then         ! if term operator was a subtraction, subtract temp from value
            value=value-temp
         else                                     ! operator was an addition (+) , add temp to value
!           if first term was not signed, then first character will not be a subtraction, so addition is implied
            value=value+temp
         endif
         ista=iend+1                      ! calculate where next sum operator (assuming there is one) will be positioned in (string)
         istat=ista+1                     ! calculate where beginning character of next term will be (if another term remains)
         if(iend.ne.nchar)then
            if(istat.gt.nchar)then                ! a trailing sum operation on end of string
               ier=-1
               mssge='trailing sum operator'
               return
            endif
         ! if last term was not the end of (string) terms remain. keep summing terms
         else
            exit
         endif
      enddo
      call value_to_string(value,string,nchar,ier2,fmt='(g23.16e3)',trimz=.true.) ! convert sum of terms to string and return
      if(ier2.lt.0)ier=ier2
end subroutine expressions_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!! (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine pows_(wstrng,nchar,ier)
!!
!!    character(len=*),intent(inout) :: wstrng
!!    integer,intent(inout)          :: nchar
!!    integer                        :: ier
!!##DESCRIPTION
!!    given an unparenthesized string of form:
!!
!!       stringo opo fval1 ** fval2 opo2 stringo2
!!
!!    where opo is a preceding optional operator from set /,* and
!!    stringo is the string that would precede opo when it exists,
!!    and opo2 is an optional trailing operator from set /,*,**
!!    and stringo2 the string that would follow op2 when it exists,
!!    evaluate the expression fval1**fval2 and restring it; repeating
!!    from left to right until no power operators remain in the string
!!    or an error occurs
!!
!!##OPTIONS
!!    wstrng  input string returned with power operators evaluated
!!    nchar   input length of wstrng, returned corrected for new wstrng returned.
!!    ier     error status
!!
!!
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine pows_(wstrng,nchar,ier)

! ident_8="@(#) M_calculator pows_(3fp) expand power functions in a string working from left to right"

character(len=*),intent(inout) :: wstrng    ! input string returned with power operators evaluated
integer,intent(inout)          :: nchar     ! input length of wstrng, returned corrected for new wstrng returned.
integer                        :: ier       ! error status
character(len=iclen_calc)     :: tempch
character(len=icbuf_calc)      :: dummy
character(len=1)               :: z
real(kind=dp)                  :: fval1
real(kind=dp)                  :: fval2
integer                        :: i
integer                        :: id2
integer                        :: idum
integer                        :: im2
integer                        :: ip        ! position of beginning of first ** operator
integer                        :: ip2
integer                        :: iright    ! end of fval2 string
integer                        :: iz        ! beginning of fval1 string
integer                        :: nchart
!-----------------------------------------------------------------------------------------------------------------------------------
      INFINITE: do
!        find first occurrence of operator, starting at left and moving right
         ip=index(wstrng(:nchar),'**')
         if(ip.eq.0) then
            exit INFINITE
         elseif(ip.eq.1) then
            ier=-1
            mssge='power function "**" missing exponentiate'
            exit INFINITE
         elseif((ip+2).gt.nchar) then
            ier=-1
            mssge='power function "**" missing power'
            exit INFINITE
         endif
!
!        find beginning of fval1 for this operator. go back to
!        beginning of string or to any previous * or / operator
         FINDVAL: do i=ip-1,1,-1
            iz=i
            z=wstrng(i:i)
               if(index('*/',z).ne.0)then  ! note that use of index function was faster than .eq. on cyber
                  iz=iz+1
                  goto 11
               endif
         enddo FINDVAL
         iz=1
11       continue
         if(ip-iz.eq.0)then
           ier=-1
           mssge='operator / is beside operator **'
           exit INFINITE
         endif
!
!        now isolate beginning and end of fval2 string for current operator
!        note that looking for * also looks for ** operator, so checking
!        for * or / or ** to right
!
         im2=index(wstrng((ip+2):nchar),'*')
         id2=index(wstrng((ip+2):nchar),'/')
         ip2=min0(im2,id2)
         if(ip2.eq.0)ip2=max0(im2,id2)
         if(ip2.eq.0)then
           iright=nchar
         elseif(ip2.eq.1)then
           ier=-1
           mssge='two operators from set [*/**] are side by side'
           exit INFINITE
         else
           iright=ip2+ip
         endif
         call a_to_d_(wstrng(iz:ip-1),fval1,ier)
         if(ier.eq.-1)then
            exit INFINITE
         endif
         call a_to_d_(wstrng(ip+2:iright),fval2,ier)
         if(ier.eq.-1)then
            exit INFINITE
         endif
         if(fval1.lt.0.0d0)then
!           this form better/safe? if(abs( fval2-int(fval2)/fval2).le..0001)
            if(fval2-int(fval2).eq.0.0d0)then
               fval1=fval1**int(fval2)
            else
               mssge='negative to the real power not allowed'
               ier=-1
               exit INFINITE
            endif
         else
            fval1=fval1**fval2
         endif
         call value_to_string(fval1,tempch,nchart,idum,fmt='(g23.16e3)',trimz=.true.) ! minimum of 23 characters required
!        place new value back into string and correct nchar.
!        note that not checking for nchar greater than (icbuf_calc)
!        in dummy or greater than len(wstrng).
         if(iz.eq.1.and.iright.eq.nchar)then      ! there was only one operator and routine is done
            dummy=tempch(1:nchart)
            nchar=nchart
         else if(iz.eq.1)then                     ! iz was 1, but iright was nchar so
            dummy=tempch(1:nchart)//wstrng(iright+1:nchar)
            nchar=nchart+nchar-(iright+1)+1
         else if(iright.eq.nchar)then             ! iz was not 1, but iright was nchar so
            dummy=wstrng(1:iz-1)//tempch(1:nchart)
            nchar=(iz-1)+nchart
         else                                     ! iz was not 1, and iright was not nchar so
            dummy=wstrng(1:iz-1)//tempch(1:nchart)//wstrng(iright+1:nchar)
            nchar=(iz-1)+nchart+(nchar-(iright+1)+1)
         endif
         wstrng=dummy
      enddo INFINITE
end subroutine pows_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!! (LICENSE:PD)
!!##SYNOPSIS
!!
!!##DESCRIPTION
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine factors_(wstrng,nchr,fval1,ier)

! ident_9="@(#) M_calculator factors_(3fp) reduce unparenthesized string with only * and / operators to val"

!
!     The input string is unaltered. for any single pass thru the routine, the string structure is assumed to be:
!         fval1 op fval2 op fval op fval op fval op fval
!     where no blanks are in the string (only significant if string structure is bad) and the only operators are * or /.
!     working from left to right:
!       1. locate and place into a real variable the fval1 string
!       2. if one exists, locate and place into a real variable the fval2 string
!       3. perform the indicated operation between fval1 and fval2
!          and store into fval1.
!       3. repeat steps 2 thru 4 until no operators are left or
!          an error occurs.
!
!     nchr   = the position of the last non-blank character in the input string wstrng
!     ip     = the position of the current operator to be used.
!              to the left of this is the fval1 string.
!     iright = the position of the last character in the fval2 string.
!     wstrng = the input string to be interpreted.
!       ier  = is a flag indicating whether an error has occurred
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*) :: wstrng
real(kind=dp)    :: fval1
real(kind=dp)    :: fval2
integer          :: id
integer          :: id2
integer          :: ier
integer          :: im
integer          :: im2
integer          :: ip
integer          :: ip2
integer          :: iright
integer          :: nchr
!-----------------------------------------------------------------------------------------------------------------------------------
      if((nchr).eq.0)then
         ier=-1
         mssge='trying to add/subtract a null string'
         return
      endif
!     find position of first operator
      im=index(wstrng(:nchr),'*')
      id=index(wstrng(:nchr),'/')
!     ip should be the position of the left-most operator
      ip=min0(im,id)
!     if one or both of the operators were not present, then
!     either im or id (or both) are zero, so look for max
!     instead of min for ip
      if(ip.eq.0) ip=max0(im,id)
      if( ip.eq.0 )then
!        no operator character (/ or *) left
         call a_to_d_(wstrng(1:nchr),fval1,ier)
         return
      elseif (ip.eq.1)then
!        if no string to left of operator, have a bad input string
         ier=-1
         mssge='first factor or quotient for "*" or "/" missing or null'
         return
      endif
!     convert located string for fval1 into real variable fval1
      call a_to_d_(wstrng(1:ip-1),fval1,ier)
      if(ier.eq.-1)return
      do
         if(ip.eq.nchr)then
!          if no string to left of operator, have a bad input string
           ier=-1
           mssge='second factor or quotient for "*" or "/" missing or null'
           return
         endif
!        locate string to put into fval2 for current operator by starting just to right of operator and ending at end of current
!        string or at next operator note that because of previous checks we know there is something to right of the operator.
         im2=index(wstrng((ip+1):nchr),'*')
         id2=index(wstrng((ip+1):nchr),'/')
         ip2=min0(im2,id2)
         if(ip2.eq.0)ip2=max0(im2,id2)
         if(ip2.eq.0)then
            iright=nchr
         elseif(ip2.eq.1)then
            ier=-1
            mssge='two operators from set [*/] are side by side'
            return
         else
            iright=ip2+ip-1
         endif
!        place located string for fval2 into real variable fval2
         call a_to_d_(wstrng(ip+1:iright),fval2,ier)
         if(ier.eq.-1)return
!        do specified operation between fval1 and fval2
         if(wstrng(ip:ip).eq.'*') then
            fval1=fval1*fval2
         else if(fval2.eq.0) then
            ier=-1
            mssge='division by zero'
            return
         else
            fval1=fval1/fval2
         endif
         if(iright.eq.nchr)return
         ip=iright+1
      enddo
end subroutine factors_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!     a_to_d_(3f) - [M_calculator] returns a double precision value from a numeric character string specifically for M_calculator(3fm)
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine a_to_d_(chars,rval,ierr)
!!
!!    character(len=*),intent(in) :: chars
!!    doubleprecision,intent(out) :: rval
!!    integer,intent(out)         :: ierr
!!
!!##DESCRIPTION
!!    Convert a string representing a numeric scalar value to a numeric value, specifically
!!    for the M_calculator(3fp) module.Works with any g-format input, including integer, real, and exponential forms.
!!
!!       1. if chars=? set rval to value stored as current value, return.
!!       2. if the string starts with a $ assume it is the name of a
!!          string variable or token and return its location as a doubleprecision number.
!!       3. try to read string into a doubleprecision value. if successful, return.
!!       4. if not interpretable as a doubleprecision value, see if it is a
!!          defined variable name and use that name's value if it is.
!!       5. if no value can be associated to the string and/or if
!!          an unexpected error has occurred, set error flag and
!!          error message and set rval to zero and return.
!!       6. note that blanks are treated as null, not zero.
!!
!!##OPTIONS
!!      chars  is the input string
!!      rval   is the doubleprecision output value
!!      ierr   0 if no error occurs
!!
!!##EXAMPLE
!!
!!
!!##VERSION
!!       o 07/15/1986  J. S. Urban
!!       o 12/28/1987  modified to specify bn in formats for reads. vax
!!                    defaults to zero-fill on internal files.
!!       o 12/22/2016  Changed to generate man(1) pages via prep(1).
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine a_to_d_(chars,rval8,ierr)

! ident_10="@(#) M_calculator a_to_d_(3f) returns a real value rval8 from a numeric character string chars."

! CAREFUL: LAST is in GLOBAL, but can be read from when passed to this routine as CHARS. DO NOT CHANGE CHARS.
character(len=*),intent(in) :: chars
character(len=:),allocatable :: chars_local
real(kind=dp),intent(out)   :: rval8
integer,intent(out)         :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=13)           :: frmt
integer                     :: ier
integer                     :: indx
integer                     :: ioerr
!-----------------------------------------------------------------------------------------------------------------------------------
   ioerr=0
   chars_local=trim(adjustl(chars))//' ' ! minimum of one character required
   if(chars_local.eq.'?')then       ! if string is a (unsigned) question mark, use value returned from last completed calculation
     !x!read(last,'(bn,g512.40)',iostat=ioerr,err=9991)rval8  ! assuming cannot get a read error out of reading last
     write(frmt,101)len(last)                                 ! build a format statement to try and read the string as a number with
     chars_local=trim(last)//repeat(' ',512)                  ! kludge: problems if string is not long enough for format
     read(chars_local,fmt=frmt,iostat=ioerr,err=9991)rval8    ! try and read the string as a number
   elseif('$'.eq.chars_local(1:1))then                ! string is a string variable name
      call locate(keys_q,chars_local,indx,ier)        ! try to find the index in the character array for the string variable
      if(indx.le.0)then                         ! if indx is not .gt. 0 string was not a variable name
         ierr=-1
      mssge='undeclared string variable '//chars_local
      else
         rval8=real(indx)   ! set value to position of string in the string array
         !!!! flag via a value for ierr that a string, not a number, has been found
      endif
      return
   ! no error on read on Sun on character string as a number, so make sure first character not numeric and try as variable name
   elseif(index('0123456789.-+',chars_local(1:1)).eq.0)then   ! does not start with a numeric character. try as a variable name
      call locate(keyr_q,chars_local,indx,ier)
      if(indx.le.0)then                                 ! if indx is not .gt. 0 string was not a variable name
         ierr=-1
       mssge='*a_2_d_* undeclared variable ['//chars_local//']'
      else
         rval8=values_d(indx)
      endif
      return
   else                            ! string is a number or a numeric variable name that starts with a numeric character
     write(frmt,101)len(chars_local)                       ! build a format statement to try and read the string as a number with
101  format( '(bn,g',i5,'.0)' )
chars_local=chars_local//repeat(' ',512)                   ! kludge: problems if string is not long enough for format
     read(chars_local,fmt=frmt,iostat=ioerr,err=999)rval8  ! try and read the string as a number
     chars_local=trim(chars_local)
   endif
   return                                ! string has successfully been converted to a number
9991  continue                           ! string could not be read as number,so try as variable name that starts with number
999   continue                           ! string could not be read as number,so try as variable name that starts with number
   rval8=0.0d0
   indx=0
   !  either here because of a read error (too big, too small, bad characters in string) or this is a variable name
   !  or otherwise unreadable.
   !!!!! look carefully at what happens with a possible null string
   call locate(keyr_q,chars_local,indx,ier)
   if(indx.le.0)then                             ! if indx is not .gt. 0 string was not a variable name
      mssge='bad variable name or unusable value = '//chars_local
      ierr=-1
   else
      rval8=values_d(indx)
   endif
end subroutine a_to_d_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    squeeze_ - [M_calculator] change +-[] to #=(),replace strings with placeholders,delete comments
!!    (LICENSE:PD)
!!
!!##DESCRIPTION
!!    Remove all blanks from input string and return position of last non-blank character in nchars using imax as the highest
!!    column number to search in. Return a zero in nchars if the string is blank.
!!
!!    replace all + and - characters with the # and = characters which will be used to designate + and - operators, as opposed to
!!    value signs.
!!
!!    replace [] with ()
!!
!!    remove all strings from input string and replace them with string tokens and store the values for the string tokens.
!!    assumes character strings are (iclen_calc) characters max.
!!    if string is delimited with double quotes, the double quote character may be represented inside the string by
!!    putting two double quotes beside each other ("he said ""greetings"", i think" ==> he said "greetings", i think)
!!
!!  !!!! if an equal sign is followed by a colon the remainder of the input line is placed into a string as-is
!!  !!!! without the need for delimiting it. ($string1=: he said "greetings", i think ==> he said "greetings", i think)
!!
!!    anything past an # is considered a comment and ignored
!!
!!    assumes length of input string is less than (icbuf_calc) characters
!!
!!    if encounters more than one equal sign, uses right-most as the
!!    end of variable name and replaces others with & and makes a
!!    variable name out of it (ie a=b=10 ===> a&b=10)
!!
!!  !!!!the length of string could actually be increased by converting quoted strings to tokens
!!
!!  !!!!maybe change this to allow it or flag multiple equal signs?
!!
!!  !!!!no check if varnam is a number or composed of characters
!!  !!!!like ()+-*/. . maybe only allow a-z with optional numeric
!!  !!!!suffix and underline character?
!!
!!  !!!!variable names ending in letter e can be confused with
!!  !!!!e-format numbers (is 2e+20 the variable 2e plus 20 or
!!  !!!!the single number 200000000000000000000?). to reduce
!!  !!!!amount of resources used to check for this, and since
!!  !!!!words ending in e are so common, will assume + and -
!!  !!!!following an e are part of an e-format number if the
!!  !!!!character before the e is a period or digit (.0123456789).
!!  !!!!and won't allow variable names of digit-e format).
!!
!!  !!!!make sure variable called e and numbers like e+3 or .e+3 are handled satisfactorily
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine squeeze_(string,imax,nchars,varnam,nchar2,ier)

! ident_11="@(#) M_calculator squeeze_(3fp) change +-[] to #=() replace strings with placeholders delete comments"

integer, parameter                      :: ilen=(icbuf_calc)+2
character(len=*)                        :: string
integer                                 :: imax
integer,intent(out)                     :: nchars
character(len=icname_calc),intent(out)  :: varnam
integer,intent(out)                     :: nchar2
integer,intent(out)                     :: ier
character(len=ilen)                     :: dummy
character(len=1)                        :: back1
character(len=1)                        :: back2
integer                                 :: iplace
character(len=1)                        :: currnt
character(len=iclen_calc)               :: ctoken
!!character(len=10),parameter             :: list  =' +-="#[]{}'  ! list of special characters
!!character(len=10),parameter             :: list2 =' #=&  ()()'  ! list of what to convert special characters too when appropriate
character(len=5)                        :: toknam
integer                                 :: i10
integer                                 :: i20
integer                                 :: idum
integer                                 :: ilook
integer                                 :: indx
integer                                 :: instring
integer                                 :: ipoint
integer                                 :: ivar
integer                                 :: kstrln
!-----------------------------------------------------------------------------------------------------------------------------------
!  keep track of previous 2 non-blank characters in dummy for when trying to distinguish between e-format numbers
!  and variables ending in e.
   back1=' '
   back2=' '
   varnam=' '                   ! initialize output variable name to a blank string
   ivar=0
   nchar2=0
   nchars=0                     ! the position of the last non-blank character in the output string (string)
   dummy(1:2)='  '
!-----------------------------------------------------------------------------------------------------------------------------------
!  instead of just copy string to buffer, cut out rows of sign operators
!  dummy(3:)=string
   dummy=' '
   idum=3
   instring=0
   do i10=1,len_trim(string)
      ! if adjacent sign characters skip new character and maybe change sign of previous character
      if(string(i10:i10).eq.'"'.and.instring.eq.0 )then   ! starting a string
         instring=1
      elseif(string(i10:i10).eq.'"'.and.instring.eq.1)then ! ending a string
         instring=0
      endif
      if(instring.ne.1)then
         if(string(i10:i10).eq.'+')then                 ! if found a + look to see if previous a + or -
            if(dummy(idum-1:idum-1).eq.'+')then         ! last character stored was also a sign (it was +)
               cycle                                    ! skip because ++ in a row
            elseif(dummy(idum-1:idum-1).eq.'-')then     ! skip -+ and just leave -
               cycle
            endif
         elseif(string(i10:i10).eq.'-')then             ! last character stored was also a sign (it was -)
            if(dummy(idum-1:idum-1).eq.'+')then         ! +- in a row
               dummy(idum-1:idum-1)='-'                 ! change sign of previous plus
               cycle                                    ! skip because +- in a row
            elseif(dummy(idum-1:idum-1).eq.'-')then     ! skip but change sign of previous
               dummy(idum-1:idum-1)='+'                 ! change -- to +
               cycle
            endif
         endif
      endif
      ! character not skipped
      dummy(idum:idum)=string(i10:i10)            ! simple copy of character
      idum=idum+1
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   string=' '
   ipoint=2                                       ! ipoint is the current character pointer for (dummy)
   ktoken=0                                       ! initialize the number of strings found in this string
   BIG: do ilook=1,imax
      ipoint=ipoint+1                             ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)                 ! store current character into currnt
      select case(currnt)            ! check to see if current character has special meaning and requires processing ' +-="#[]{}'
!-----------------------------------------------------------------------------------------------------------------------------------
      case(" ")                                   ! current is a blank not in a string. ignore it
         cycle BIG
!-----------------------------------------------------------------------------------------------------------------------------------
      case("+")                                      ! current is a plus
         if(back1.eq.'e'.or.back1.eq.'E')then        ! if previous letter was an e it could be e-format sign or operator.
!           note not using dummy directly, as it may contain blanks letter before +- was an e. must decide if the +- is part of
!           an e-format number or intended to be the last character of a variable name.
!!!!!       what is effect on a---b or other +- combinations?
            ! if letter before e is not numeric this is a variable name and - is an operator
            if(index('0123456789.',back2).eq.0)then
              currnt="#"                        ! no digit before the e, so the e is the end of a variable name
            else                                ! digit before e, so assume this is number and do not change +- to #= operators
            endif
         else
            currnt="#"                          ! previous letter was not e, so +- is an operator so change +- to #= operators
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
      case("-")                                      ! current is a minus
         if(back1.eq.'e'.or.back1.eq.'E')then        ! if previous letter was an e it could be e-format sign or operator.
!           note not using dummy directly, as it may contain blanks letter before +- was an e. must decide if the +- is part of
!           an e-format number or intended to be the last character of a variable name.
!!!!!       what is effect on a---b or other +- combinations?
            ! if letter before e is not numeric this is a variable name and - is an operator
            if(index('0123456789.',back2).eq.0)then
              currnt="="                       ! no digit before the e, so the e is the end of a variable name
            else                               ! digit before e, so assume this is number and do not change +- to #= operators
            endif
         else
            currnt="="                         ! previous letter was not e, so +- is an operator so change +- to #= operators
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
      case("=")                                      ! current is a plus or minus
         currnt="&"
         ivar=nchars+1                               ! ivar is the position of an equal sign, if any
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case ("{", "[")
      currnt='('                                     ! currnt is [ or { . Replace with (
      case ("}", "]")
      currnt=')'                                     ! currnt is ] or }, . Replace with )
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case("#")                                      ! any remainder is a comment
         exit
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case('"')                                   ! if character starts a quoted string, extract it and replace it with a token
!     figure out length of string, find matching left double quote, reduce internal "" to "
      kstrln=0                                    ! initialize extracted string length
      ctoken=' '                                  ! initialize extracted string
      do i20 = ipoint+1,imax+2                    ! try to find a matching double quote to the right of the first
         ipoint=ipoint+1
         if(dummy(ipoint:ipoint).eq.'"')then         !!!!! caution : could look at dummy(imax+1:imax+1)
            if(dummy(ipoint+1:ipoint+1).ne.'"')then  ! this is the end of the string
               goto 30
            else                                     ! this is being used to try and represent an internal double-quote
               kstrln=kstrln+1                               ! determine length of string to remove
               ctoken(kstrln:kstrln)=dummy(ipoint:ipoint)    ! store the character into the current string storage
               ipoint=ipoint+1
            endif
         else                                             ! this is an internal character of the current string
            kstrln=kstrln+1                               ! determining length of string to remove
            ctoken(kstrln:kstrln)=dummy(ipoint:ipoint)    ! store the character into the current string storage
         endif
      enddo
      ier=-1                                         ! if you get here an unmatched string delimiter (") has been detected
      mssge='unmatched quotes in a string'
      return
30    continue
!!!!! check that current token string is not over (iclen_calc) characters long . what about the string "" or """" or """ ?
      ktoken=ktoken+1                             ! increment the counter of strings found
      write(toknam,'(''$_'',i3.3)')ktoken         ! build a unique name for the token string found for this input string
      nchars=nchars+1                             ! increment counter of characters stored
      string(nchars:nchars+4)=toknam              ! replace original delimited string with its token
      nchars=nchars+4
!                                                    store the token name and value in the string variable arrays
      call locate(keys_q,toknam,indx,ier)         ! determine storage placement of the variable and whether it is new
      if(ier.eq.-1)return
      iplace=iabs(indx)
      if(indx.le.0)then                           ! check if the token name needs added or is already defined
         call insert(keys_q,toknam, iplace)   ! adding the new variable name to the variable name array
         call insert(values,' '   , iplace)
         call insert(values_len,0     , iplace)
      endif
      call replace(values,ctoken(:kstrln),iplace)          ! store a defined variable's value
      call replace(values_len,kstrln,iplace)                   ! store length of string
!!!!! note that reserving variable names starting with $_ for storing character token strings
      cycle BIG
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      case default                                   ! current is not one of the special characters in list
      end select
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
                                                  ! for all but blank characters and strings
      back2=back1
      back1=currnt
      nchars=nchars+1
      string(nchars:nchars)=currnt
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   enddo BIG
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
!  end of string or hit beginning of comment

   if(ivar.ne.0)then                   ! check to see if a variable name was defined:
   nchar2=ivar-1                       ! variable was declared nchar2 is the position of the last character in the variable name
     if(nchar2.gt.20)then
      ier=-1
      mssge='new variable names must be 20 characters long or less'
     else if(nchar2.eq.0)then
      ier=-1
      mssge='input starts with =; cannot define a null variable name'
     else                              ! split up variable name and expression
                                       ! legal length variable name
       if(index('eE',string(nchar2:nchar2)).ne.0.and.nchar2.ne.1)then ! could be an unacceptable variable name
           if(index('0123456789',string(nchar2-1:nchar2-1)).ne.0)then
!            an unacceptable variable name if going to avoid conflict with
!            e-format numbers in a relatively straight-forward manner
             mssge='variable names ending in digit-e not allowed'
             ier=-1
           endif
        endif
        dummy=string
        varnam=dummy(1:ivar-1)
        if(nchars.ge.ivar+1)then
           string=dummy(ivar+1:nchars)
        else
           string=' '
        endif
        nchars=nchars-ivar
     endif
   endif
end subroutine squeeze_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!       [M_calculator] given_name_get_stringvalue_(3fp) - return associated value for variable name"
!!       (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine given_name_get_stringvalue_(chars,ierr)
!!
!!    character(len=*),intent(in)  :: chars
!!    integer,intent(out)          :: ierr
!!##DESCRIPTION
!!       return the actual string when given a string variable name or token
!!       the returned string is passed thru the message/string/error GLOBAL variable
!!##OPTIONS
!!       CHARS
!!       IER     ierr is set and returned as
!!
!!                 -1  an error occurs
!!                  2  a string is returned
!!##RETURNS
!!       MSSGE  when successful the variable value is returned through the global variable MSSGE
!!
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine given_name_get_stringvalue_(chars,ierr)

! ident_12="@(#) M_calculator given_name_get_stringvalue_(3fp) return associated value for variable name"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars
integer,intent(out)          :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                      :: index
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   index=0
   call locate(keys_q,chars,index,ierr)
   if(ierr.eq.-1) then
   elseif(index.le.0)then
      ierr=-1
!!!!  what if len(chars) is 0? look carefully at what happens with a possible null string
      mssge=' variable '//trim(chars)//' is undefined'
   else
      ierr=2
      mssge=values(index)
   endif
end subroutine given_name_get_stringvalue_
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    stuff(3f) - [M_calculator] directly store value into calculator dictionary for efficiency
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine stuff(varnam,val,ioflag)
!!
!!    class(*),intent(in)         :: varnam
!!    character(len=*),intent(in) :: val
!!    integer,intent(in),optional :: ioflag
!!
!!##DEFINITION
!!    breaking the rule of only accessing the calculator thru calculator(3f):
!!
!!    a direct deposit of a value into the calculator assumed to
!!    be used only by friendly calls, for efficiency and to avoid
!!    problems with recursion if a routine called by the calculator
!!    in substitute_subroutine(3f) wants to store something back into the calculator
!!    variable table
!!
!!    Normally values are stored or defined in the calculator module
!!    M_calculator(3fm) using the calculator(3f) routine or the convenience
!!    routines in the module M_calculator(3fm). For efficiency when
!!    large numbers of values require being stored the stuff(3f) procedure
!!    can be used to store numeric values by name in the calculator
!!    dictionary.
!!
!!    breaking the rule of only accessing the calculator thru calculator(3f):
!!
!!    stuff(3f) is assumed to only be used when needed for efficiency and to
!!    avoid problems with recursion if a routine called by the calculator
!!    in substitute_subroutine(3f) wants to store something back into the
!!    calculator variable table.
!!
!!##OPTIONS
!!    varnam  name of calculator variable to define or replace val
!!    numeric value to associate with the name VARNAME. May be
!!            integer, real, or doubleprecision.
!!    ioflag  optional flag to use with journal logging. This string is
!!            passed directly to M_framework__journal::journal(3f)
!!            as the first parameter. The default is to not log the
!!            definitions to the journal(3f) command if this parameter is
!!            blank or not present.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_stuff
!!    use M_calculator, only : stuff, dnum0
!!    implicit none
!!    doubleprecision :: value
!!       call stuff('A',10.0)
!!       call stuff('PI',3.1415926535897932384626433832795)
!!       value=dnum0('A*PI')
!!       write(*,*)value
!!    end program demo_stuff
!!
!!   Expected result:
!!
!!    31.415926535897931
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine stuff(varnam,value,ioflag)

! ident_14="@(#) M_calculator stuff(3fp) pass key value and integer|real|doubleprecision value to dictionary(3f) as doubleprecision"

character(len=*),intent(in)           :: varnam        ! variable name to add or replace value of
class(*),intent(in)                   :: value
character(len=*),intent(in),optional  :: ioflag

real(kind=dp)                         :: val8          ! input value to store
character(len=:),allocatable          :: varnam_local  ! some trouble with variable length character strings on some machines
integer                               :: ierr
integer                               :: index
integer                               :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
   varnam_local=adjustl(trim(varnam))//' '                      ! remove leading spaces but make sure at least one character long
   if(varnam_local(1:1).eq.'$')then                             ! add new variable to numeric value dictionary at specified location
      mssge='*stuff* numeric variable names must not start with a $'
      ierr=-1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   call locate(keyr_q,varnam_local,index,ierr)
   istart=iabs(index)
   if(index.le.0)then   ! add entry to dictionary
      call insert(keyr_q,varnam_local,istart)
      call insert(values_d,0.0d0,istart)
   endif

   select type(value)
    type is (integer);         val8=dble(value)
    type is (real);            val8=dble(value)
    type is (doubleprecision); val8=value
   end select
   call replace(values_d,val8,istart)
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(ioflag))then                    ! display values with an assumed variable length of 20 characters so get neat columns
      write(*,g)ioflag,varnam_local//'=',val8
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine stuff
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!     stuffa(3f) - [M_calculator] directly store a string into calculator
!!     variable name table
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine stuffa(varnam,string,ioflag)
!!
!!    character(len=*),intent(in)          :: varnam
!!    character(len=*),intent(in)          :: string
!!    character(len=*),intent(in),optional :: ioflag
!!
!!##DEFINITION
!!    Breaking the rule of only accessing the calculator thru calculator(3f):
!!
!!    a direct deposit of a value into the calculator assumed to be used
!!    only by friendly calls, for efficiency and to avoid problems with
!!    recursion if a routine called by the calculator in JUOWN1(3f) wants
!!    to store something back into the calculator
!!    variable table.
!!
!!##OPTIONS
!!    varnam    variable name to create or replace in calculator module
!!    string    string to associate with the calculator variable name varnam
!!    ioflag    journal logging type passed on to journal(3f) procedure. If it
!!              is not present or blank, the journal(3f) routine is not evoked.
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_stuffa
!!    use M_calculator, only : stuffa
!!    use M_calculator, only : snum0
!!    implicit none
!!       call stuffa('$A','')
!!       call stuffa('$mystring','this is the value of the string')
!!       write(*,*)snum0('$mystring')
!!       call stuffa('$mystring','this is the new value of the string')
!!       write(*,*)snum0('$mystring')
!!    end program demo_stuffa
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine stuffa(varnam,string,ioflag)

! ident_15="@(#) M_calculator stuffa(3f) directly store a string into calculator variable name table"

character(len=*),intent(in)           :: varnam    !  assuming friendly, not checking for null or too long varnam0
character(len=:),allocatable          :: varnam_local
character(len=*),intent(in)           :: string
character(len=*),intent(in),optional  :: ioflag
character(len=:),allocatable          :: ioflag_local
integer                               :: indx
integer                               :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(ioflag))then
      ioflag_local=trim(ioflag)
   else
      ioflag_local=' '
   endif
   varnam_local=adjustl(trim(varnam))
   ierr=0
!-----------------------------------------------------------------------------------------------------------------------------------
   call locate(keys_q,varnam_local,indx,ierr)
   if(indx.le.0)then                                        ! variable name not in dictionary
      indx=iabs(indx)
      call insert(keys_q,varnam_local,indx)                 ! adding the new variable name to the variable name array
      call insert(values,' '         ,indx)
      call insert(values_len,0       ,indx)
   elseif(ioflag_local.ne.'')then                           ! display variable string to trail and output as indicated by ioflag
      write(*,g)ioflag,varnam_local//'=',string
   endif
   ! found variable name in dictionary
   call replace(values,string,indx)
   call replace(values_len,len_trim(string),indx)
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine stuffa
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!      inum0(3f) - [M_calculator] return integer value from calculator expression
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!   integer function inum0(inline,ierr)
!!
!!    character(len=*),intent(in)  :: inline
!!    integer,optional,intent(out) :: ierr
!!
!!##SYNOPSIS
!!
!!    INUM0() evaluates a CHARACTER argument as a FORTRAN-like
!!    calculator expression and returns an integer.
!!
!!     o INUM0() uses the calculator routine CALCULATOR(3f)
!!     o Remember that the calculator treats all values as DOUBLEPRECISION.
!!
!!    Values returned are assumed to be very close to being whole integer
!!    values. A small value (0.01) is added to the result before it is
!!    returned to reduce roundoff error problems. This could introduce
!!    errors if INUM0 is misused and is not being used to calculate
!!    essentially integer results.
!!##DESCRIPTION
!!
!!    inline  INLINE is a CHARACTER variable up to 255 characters long that is
!!            similar to a FORTRAN 77 numeric expression. Keep it less than 80
!!            characters when possible.
!!    ierr    zero (0) if no error occurs
!!
!!##DEPENDENCIES
!!         All programs that call the calculator routine can supply their
!!         own substitute_subroutine(3f) and substitute_C(3f) procedures. See
!!         the ../html/Example.html">example program for samples.
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_inum0
!!       use M_calculator, only : inum0
!!       implicit none
!!       integer :: i,j,k
!!          i=inum0('20/3.4')
!!          j=inum0('CI = 13 * 3.1')
!!          k=inum0('CI')
!!          write(*,*)'Answers are ',I,J,K
!!       end program demo_inum0
!!
!!##SEE ALSO
!!       The syntax of an expression is as described in
!!       the main document of the Calculator Library.
!!   See
!!       CALCULATOR(),
!!       RNUM0(),
!!       DNUM0(),
!!       SNUM0(),
!!       EXPRESSION()
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR:  John S. Urban
!!##VERSION: 19971123
!-----------------------------------------------------------------------------------------------------------------------------------
integer function inum0(inline,ierr)

! ident_16="@(#) M_calculator inum0(3f) resolve a calculator string into a whole integer number"

!  The special string '*' returns -99999, otherwise return 0 on errors
character(len=*),intent(in)  :: inline
integer,optional,intent(out) :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
integer,parameter            :: IBIG=2147483647               ! overflow value (2**31-1)
integer                      :: iend
real,parameter               :: SMALL=0.0001                  ! and epsilon value
doubleprecision              :: dnum1
character(len=iclen_calc)    :: cdum20
integer                      :: ierr_local
integer                      :: ilen
!-----------------------------------------------------------------------------------------------------------------------------------
ierr_local=0
if(inline.eq.' ')then                                      ! return 0 for a blank string
   dnum1=0.0d0
elseif(inline.eq.'*')then                                  ! return -99999 on special string "*"
   dnum1=-99999d0
else                                                       ! parse string using calculator function
   iend=len(inline)
   call expression(inline(:iend),dnum1,cdum20,ierr_local,ilen)
   if(ierr_local.ne.0)then
      dnum1=0.0d0
   endif
endif
if(present(ierr))then
   ierr=ierr_local
endif
!-----------------------------------------------------------------------------------------------------------------------------------
! on most machines int() would catch the overflow, but this is safer
if(dnum1.gt.IBIG)then
   write(*,g)'*inum0* integer overflow 2**31-1 <',dnum1
   inum0=IBIG
elseif(dnum1.gt.0)then
   inum0=int(dnum1+SMALL)
else
   inum0=int(dnum1-SMALL)
endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function inum0
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!       rnum0(3f) - [M_calculator] returns real number from string expression using CALCULATOR(3f)
!!       (LICENSE:PD)
!!##SYNOPSIS
!!
!!    real function rnum0(inline)
!!
!!     character(len=*), intent=(in) :: inline
!!     integer,intent(out),optional  :: ierr
!!
!!##DESCRIPTION
!!     RNUM0() is used to return a REAL value from a CHARACTER string representing
!!     a numeric expression. It uses the M_calculator(3fp) module.
!!
!!     inline  INLINE is a CHARACTER variable up to (iclen_calc=512) characters long
!!             that is similar to a FORTRAN 77 numeric expression.
!!     ierr    error code. If zero, no error occurred
!!
!!##DEPENDENCIES
!!       o User-supplied routines:
!!         All programs that call the calculator routine can supply their
!!         own substitute_subroutine(3f) and substitute_C(3f) procedures. See
!!         the example program for samples.
!!##EXAMPLES
!!
!!   Sample program
!!
!!     program demo_rnum0
!!     use M_calculator, only : rnum0
!!     implicit none
!!     real :: x, y, z
!!        x=rnum0('20/3.4')
!!        y=rnum0('CI = 10 * sin(3.1416/4)')
!!        z=rnum0('CI')
!!        write(*,*)x,y,z
!!     end program demo_rnum0
!!
!!##SEE ALSO
!!
!!       o The syntax of an expression is as described in the main documentation
!!         of the Calculator Library.
!!       o See EXPRESSION(3f), CALCULATOR(3f), INUM0(3f), DNUM0(3f), SNUM0(3f).
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR    John S. Urban
!!##VERSION   1.0,19971123
real function rnum0(inline,ierr)

! ident_17="@(#) M_calculator rnum0(3f) resolve a calculator string into a real number"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: inline
integer,optional,intent(out) :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=iclen_calc)    :: cdum20
doubleprecision              :: d_answer
integer                      :: ierr_local
integer                      :: ilen
integer                      :: iend
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr_local=0
   if(inline.eq.' ')then
      d_answer=0.0d0
   elseif(inline.eq.'*')then                            !  the special string '*' returns -99999.0
      d_answer=-99999.0d0
   else
      iend=len(inline)
      call expression(inline(:iend),d_answer,cdum20,ierr_local,ilen)
      if(ierr_local.ne.0)then
         d_answer=0.0d0
      endif
   endif
   if(present(ierr))then
      ierr=ierr_local
   endif
   rnum0=real(d_answer)
!-----------------------------------------------------------------------------------------------------------------------------------
end function rnum0
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!      dnum0(3f) - [M_calculator] return double precision value from string expression using calculator(3f)
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!   doubleprecision function dnum0(inline,ierr)
!!
!!    character(len=*),intent(in) :: inline
!!    integer,optional,intent(out) :: ierr
!!
!!##DESCRIPTION
!!     DNUM0() is used to return a DOUBLEPRECISION value from a CHARACTER string
!!     representing a numeric expression.
!!       o If an error occurs in evaluating the expression INUM() returns zero(0).
!!       o DNUM0() ultimately uses the calculator routine CALCULATOR(3f)
!!
!!      inline  INLINE is a CHARACTER variable up to (iclen_calc=255) characters long
!!              that is similar to a FORTRAN 77 numeric expression.
!!      ierr    error code. If zero, no error occurred
!!
!!##EXAMPLES
!!
!!   Sample Program
!!
!!     program demo_dnum0
!!     use M_calculator, only : dnum0
!!     implicit none
!!        doubleprecision x,y,z
!!        X=DNUM0('20/3.4')
!!        Y=DNUM0('CI = 10 * sin(3.1416/4)')
!!        Z=DNUM0('CI')
!!        write(*,*)x,y,z
!!     end program demo_dnum0
!!
!!##SEE ALSO
!!
!!       o The syntax of an expression is as described in the main documentation of the Calculator Library.
!!       o See EXPRESSION(), CALCULATOR(), RNUM0(), SNUM0().
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR + John S. Urban
!!##VERSION 1.0, 19971123
doubleprecision function dnum0(inline,ierr)

! ident_18="@(#) M_calculator dnum0(3f) resolve a calculator string into a doubleprecision number"

character(len=*),intent(in) :: inline
integer,optional,intent(out) :: ierr
character(len=iclen_calc)           :: cdum20
doubleprecision             :: dnum1
integer                     :: iend
integer                     :: ierr_local
integer                     :: ilen
   ierr_local=0
   if(inline.eq.' ')then
      dnum1=0.0d0
   elseif(inline.eq.'*')then    !  the special string '*' returns -99999.0
      dnum1=-99999.0d0
   else
      iend=len(inline)
      call expression(inline(:iend),dnum1,cdum20,ierr_local,ilen)
      if(ierr_local.ne.0)then
         dnum1=0.0d0
      endif
   endif
   dnum0=dnum1
   if(present(ierr))then
      ierr=ierr_local
   endif
end function dnum0
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     snum0(3f) - [M_calculator] resolve a calculator expression into a string(return blank on errors)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function snum0(inline0,ierr)
!!
!!    character(len=:),allocatable :: snum0(inline0)
!!    character(len=*),intent(in)  :: inline0                           ! input string
!!    integer,optional,intent(out) :: ierr
!!
!!##DESCRIPTION
!!     SNUM0() is used to return a string value up to (iclen_calc=512) characters
!!     long from a string expression.
!!     SNUM0() uses the calculator routine CALCULATOR(3f)
!!
!!     inline0  INLINE0 is a CHARACTER variable up to (iclen_calc=512) characters long that
!!              is similar to a FORTRAN 77 expression.
!!     ierr     error code. If zero, no error occurred
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_snum0
!!     use m_calculator, only: rnum0, snum0
!!     implicit none
!!     real :: rdum
!!     character(len=80)  :: ic,jc,kc
!!
!!        rdum=rnum0('A=83/2') ! set a variable in the calculator
!!        kc=snum0('$MYTITLE="This is my title variable"')
!!
!!        ic=snum0('$STR("VALUE IS [",A,"]")')
!!        jc=snum0('$MYTITLE')
!!
!!        write(*,*)'IC=',trim(ic)
!!        write(*,*)'JC=',trim(jc)
!!        write(*,*)'KC=',trim(kc)
!!
!!     end program demo_snum0
!!
!!    The output should look like
!!
!!      IC=VALUE IS [41.5]
!!      JC=This is my title variable
!!      KC=This is my title variable
!!
!!##DEPENDENCIES
!!       o User-supplied routines:
!!         All programs that call the calculator routine can supply their
!!         own substitute_subroutine(3f) and substitute_C(3f) procedures. See
!!         the example program for samples.
!!
!!##SEE ALSO
!!       o The syntax of an expression is described in the main document of the
!!         Calculator Library.
!!       o See CALCULATOR(), RNUM0(), SNUM0(), EXPRESSION().
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR    John S. Urban
!!##VERSION   1.0, 19971123
!===================================================================================================================================
function snum0(inline0,ierr)

! ident_19="@(#) M_calculator snum0(3f) resolve a calculator expression into a string"

!  a few odd things are done because some compilers did not work as expected
character(len=:),allocatable :: snum0
character(len=*),intent(in)  :: inline0                           ! input string
integer,optional,intent(out) :: ierr
character(len=iclen_calc)    :: lcopy                             ! working string
character(len=iclen_calc)    :: inline                            ! working copy of input string
integer                      :: ierr_local
integer                      :: iend                              ! size of input string
integer                      :: ilen
doubleprecision              :: dnum1

   inline=inline0                                                 ! some compilers need a copy of known length to work as expected
   ierr_local=0
   if(inline.eq.' ')then                                          ! what to do for a blank string
      snum0=' '                                                   ! return a blank string
   else                                                           ! non-blank input expression
      iend=len(inline)                                            ! size of working string
      lcopy=' '                                                   ! initialize trimmed string
      lcopy=adjustl(inline(:iend))                                ! trim leading spaces
      if(lcopy(1:1).eq.'$'.or.lcopy(1:1).eq.'"')then              ! this is a string that needs evaluated
         dnum1=0.0d0
         call expression(inline(:iend),dnum1,lcopy,ierr_local,ilen)
         if(ierr_local.ne.2)then                                  ! check if expression was evaluated to a string successfully
            snum0=' '                                             ! input string was not resolved to a string
         endif
         snum0=lcopy(:max(1,ilen))                                ! return whatever expression() returned
      else                                                        ! input was just a string, not an expression so just copy it
         snum0=inline(:iend)                                      ! copy input string to output
      endif
   endif
   if(present(ierr))then
      ierr=ierr_local
   endif
end function snum0
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     expression(3f) - [M_calculator] return value from a string expression processing messages to simplify call to CALCULATOR(3f)
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine expression(inlin0,outval,outlin0,ierr,ilen)
!!
!!     character(len=*), intent=(in)  :: inlin0
!!     doubleprecision, intent=(out)  :: outval
!!     character(len=*), intent=(out) :: outlin0
!!     integer, intent=(out)          :: ierr
!!     integer, intent=(out)          :: ilen
!!
!!##DESCRIPTION
!!     expression() takes a string containing a FORTRAN-like expression and evaluates
!!     it and returns a numeric or string value as appropriate.
!!     The main purpose of expression() is to assume the burden of displaying the
!!     calculator messages for codes that make multiple calls to CALCULATOR(3f).
!!     CALCULATOR(3f) does not display error messages directly.
!!
!!       o EXPRESSION(3f) calls the calculator routine CALCULATOR(3f) to evaluate the
!!         expressions.
!!       o Messages beginning with a # are considered comments and are not passed
!!         on to the calculator.
!!
!!     inlin0  INLIN0 is a string containing a numeric expression. The expression can
!!             be up to (iclen_calc=512) characters long. The syntax of an expression
!!             is as described in the main document of the Calc library. For example:
!!
!!               'A=sin(3.1416/5)'
!!               '# this is a comment'
!!               '$STR("The value is ",40/3)'
!!
!!     outval  OUTVAL is a numeric value calculated from the expression in INLIN0
!!             (when IERR returns 0).
!!             When a string value is returned (IERR=2) then OUTVAL is the length of
!!             the output string.
!!     outlin0  OUTLIN0 contains a string representation of the number returned in
!!              OUTVAL up to 23 characters long when INLIN0 is a numeric expression. It
!!              contains a string up to (iclen_calc=512) characters long when INLIN0 is
!!              a string expression.
!!     ierr    IERR returns
!!
!!             o -1 if an error occurred
!!             o 0 if a numeric value is returned (value is in OUTVAL, string
!!               representation of the value is in OUTLIN2).
!!             o 1 if no value was returned but a message was displayed (If a 'dump'
!!               or 'funcs' command was passed to the calculator).
!!             o 2 if the expression evaluated to a string value instead of a
!!               numeric value (value is in OUTLIN0).
!!     ilen    ILEN returns the length of the input string minus trailing blanks.
!!
!!##DEPENDENCIES
!!       o User-supplied routines:
!!         All programs that call the calculator routine can supply their
!!         own substitute_subroutine(3f) and substitute_C(3f) procedures. See
!!         the example program for samples.
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_expression
!!     use M_calculator, only : iclen_calc
!!     use M_calculator, only : expression
!!     implicit none
!!     character(len=iclen_calc) ::  outlin0
!!     doubleprecision :: outval
!!     integer :: ierr, ilen
!!        call expression('A=3.4**5    ',outval,outlin0,ierr,ilen)
!!        write(*,*)'value of expression is ',outval
!!        write(*,*)'string representation of value is ',trim(outlin0)
!!        write(*,*)'error flag value is ',ierr
!!        write(*,*)'length of expression is ',ilen
!!     end program demo_expression
!!
!!   Results:
!!
!!     value of expression is    454.35424000000000
!!     string representation of value is 454.35424
!!     error flag value is            0
!!     length of expression is            8
!!
!!##SEE ALSO
!!     See also: RNUM0(),CALCULATOR(),INUM0(),SNUM0()
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!>
!! AUTHOR   John S. Urban
!!##VERSION  V1.0, 19971123
recursive subroutine expression(inlin0,outval,outlin0,ierr,ilen)

! ident_20="@(#) M_calculator expression(3f) call CALCULATOR(3f) calculator and display messages"

! evaluate a FORTRAN-like string expression and return a numeric
! value and its character equivalent or a string value as appropriate
character(len=*),intent(in) :: inlin0
doubleprecision             :: outval
character(len=*)            :: outlin0
integer,intent(out)         :: ierr
integer,intent(out)         :: ilen

character(len=iclen_calc)   :: line
character(len=iclen_calc)   :: outlin
doubleprecision,save        :: rvalue=0.0d0
intrinsic                   :: len
integer                     :: imaxi
character(len=iclen_calc)   :: event
!#----------------------------------------------------------------------------------------------------------------------------------
   ! copy INLIN0 to working copy LINE and find position of last non-blank character
   ! in the string
   line=''
   line=inlin0
   ! if the line is blank set imaxi to 1, else set it to the least of the length of the input string or (iclen_calc)
   ! NOTE: not checking if input expression is longer than (iclen_calc) characters!!
   imaxi=max(min(len(line),len(inlin0)),1)
   ilen=len_trim(line(1:imaxi))
!-----------------------------------------------------------------------------------------------------------------------------------
   if(ilen.eq.0)then                                            ! command was totally blank
      ierr=-1
      write(*,g)'*expression* warning===> blank expression'
!-----------------------------------------------------------------------------------------------------------------------------------
   elseif(line(:1).eq.'#')then                                  ! line was a comment
!-----------------------------------------------------------------------------------------------------------------------------------
   else
      ierr=0
      call calculator(line(:ilen),outlin,event,rvalue,ierr)         ! evaluate the expression
!-----------------------------------------------------------------------------------------------------------------------------------
      select case(ierr)
      case(-1)                                    ! trapped error, display error message
        write(*,g)'*expression* error===>',event
        !call pdec(line(:ilen))                   ! echo input string as is and in ASCII decimal
      case(1)                                     ! general message, display message
        write(*,g)'*expression* message===>',event
      case(0)                                     ! numeric output
         outlin0=outlin
      case(2)                                     ! string output
         outlin0=event                            ! assumes outlin is long enough to return the string into
         ilen=int(rvalue)                         ! in special mode where a string is returned, rvalue is the length of the string
      case default
        write(*,g)'*expression* warning===> unexpected ierr value=',ierr
      end select
!-----------------------------------------------------------------------------------------------------------------------------------
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   outval=rvalue                            ! return normal sized real value
end subroutine expression
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine juown1_placeholder(func,iflen,args,iargstp,n,fval,ctmp,ier)
      ! extend functions available to the calculator routine
!
!     if the function ownmode(1) is called this subroutine
!     will be accessed to do user-written functions.
!
!     func(iend-1)=procedure name.  func should not be changed.
!     iflen=length of procedure name.
!     args=array of 100 elements containing procedure arguments.
!     iargstp=type of argument(1=value,2=position of string value)
!     n=integer number of parameters
!     x=array of 55555 x values
!     y=array of 55555 y values
!     fval=value to replace function call
!     ctmp=string to return when returning a string value
!     ier=returned error flag value.
!         set to -1 if an error occurs.
!         set to  0 if a number is returned
!         set to  2 if a string is returned
!
!!use M_calculator, only : x, y, values, values_len
character(len=*),intent(in) :: func
integer,intent(in)          :: iflen
real(kind=db),intent(in)    :: args(100)
integer,intent(in)          :: iargstp(100)
integer,intent(in)          :: n
real(kind=db)               :: fval
character(len=*)            :: ctmp
integer                     :: ier

integer                     :: i10
integer                     :: iwhich
integer                     :: ilen
!-----------------------------------------------------------------------
   fval=0.0d0
!-----------------------------------------------------------------------
   write(*,*)'*juown1_placeholder* unknown function ', func(1:iflen)
   write(*,*)'function name length is..',iflen
   write(*,*)'number of arguments .....',n
   do i10=1,n
      if(iargstp(i10).eq.0)then
         write(*,*)i10,' VALUE=',args(i10)
      elseif(iargstp(i10).eq.2)then
         iwhich=int(args(i10)+0.5d0)
         ilen=values_len(iwhich)
         write(*,*)i10,' STRING='//values(iwhich)(:ilen)
      else
         write(*,*)'unknown parameter type is ',iargstp(i10)
      endif
   enddo
end subroutine juown1_placeholder
!----------------------------------------------------------------------------------------------------------------------------------!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!----------------------------------------------------------------------------------------------------------------------------------!
real function c_placeholder(args,n)
! a built-in calculator function called c must be satisfied.
! write whatever you want here as a function
integer,intent(in)          :: n
real(kind=db),intent(in) :: args(n)
   c_placeholder=0.0_db
end function c_placeholder
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!use M_strings, only : upper, lower, value_to_string
!use M_list,    only : locate, insert, replace
!===================================================================================================================================
elemental pure function upper(str,begin,end) result (string)

!character(len=*),parameter::ident_21="@(#)M_strings::upper(3f): Changes a string to uppercase"

character(*), intent(In)      :: str                 ! inpout string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
   string = str                                      ! initialize output string to input string

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = char(iachar(str(i:i))-32)    ! change miniscule letter to uppercase
       end select
   end do

end function upper
!===================================================================================================================================
elemental pure function lower(str,begin,end) result (string)

!character(len=*),parameter::ident_22="@(#)M_strings::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
   string = str

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)     ! change letter to miniscule
      case default
      end select
   end do

end function lower
!===================================================================================================================================
subroutine delim(line,array,n,icount,ibegin,iterm,ilen,dlim)

!character(len=*),parameter::ident_9="@(#)M_strings::delim(3f): parse a string and store tokens into an array"

!
!     given a line of structure " par1 par2 par3 ... parn "
!     store each par(n) into a separate variable in array.
!
!     IF ARRAY(1) == '#N#' do not store into string array  (KLUDGE))
!
!     also count number of elements of array initialized, and
!     return beginning and ending positions for each element.
!     also return position of last non-blank character (even if more
!     than n elements were found).
!
!     no quoting of delimiter is allowed
!     no checking for more than n parameters, if any more they are ignored
!
character(len=*),intent(in)    :: line
integer,intent(in)             :: n
character(len=*)               :: array(n)
integer,intent(out)            :: icount
integer,intent(out)            :: ibegin(n)
integer,intent(out)            :: iterm(n)
integer,intent(out)            :: ilen
character(len=*),intent(in)    :: dlim
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(line)):: line_local
logical             :: lstore
integer             :: i10
integer             :: iarray
integer             :: icol
integer             :: idlim
integer             :: iend
integer             :: ifound
integer             :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
      icount=0
      ilen=len_trim(line)
      line_local=line

      idlim=len(dlim)
      if(idlim > 5)then
         idlim=len_trim(dlim)      ! dlim a lot of blanks on some machines if dlim is a big string
         if(idlim == 0)then
            idlim=1     ! blank string
         endif
      endif

      if(ilen == 0)then                                        ! command was totally blank
         return
      endif
!
!     there is at least one non-blank character in the command
!     ilen is the column position of the last non-blank character
!     find next non-delimiter
      icol=1

      if(array(1) == '#N#')then                                ! special flag to not store into character array
         lstore=.false.
      else
         lstore=.true.
      endif

      do iarray=1,n,1                                          ! store into each array element until done or too many words
         NOINCREMENT: do
            if(index(dlim(1:idlim),line_local(icol:icol)) == 0)then  ! if current character is not a delimiter
               istart=icol                                     ! start new token on the non-delimiter character
               ibegin(iarray)=icol
               iend=ilen-istart+1+1                            ! assume no delimiters so put past end of line
               do i10=1,idlim
                  ifound=index(line_local(istart:ilen),dlim(i10:i10))
                  if(ifound > 0)then
                     iend=min(iend,ifound)
                  endif
               enddo
               if(iend <= 0)then                               ! no remaining delimiters
                 iterm(iarray)=ilen
                 if(lstore)then
                    array(iarray)=line_local(istart:ilen)
                 endif
                 icount=iarray
                 return
               else
                 iend=iend+istart-2
                 iterm(iarray)=iend
                 if(lstore)then
                    array(iarray)=line_local(istart:iend)
                 endif
               endif
               icol=iend+2
               exit NOINCREMENT
            endif
            icol=icol+1
         enddo NOINCREMENT
!        last character in line was a delimiter, so no text left
!        (should not happen where blank=delimiter)
         if(icol > ilen)then
           icount=iarray
           if( (iterm(icount)-ibegin(icount)) < 0)then         ! last token was all delimiters
              icount=icount-1
           endif
           return
         endif
      enddo
      icount=n  ! more than n elements
end subroutine delim
!===================================================================================================================================
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

!character(len=*),parameter::ident_40="@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt.ne.'') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         write(*,*)'*value_to_string* UNKNOWN TYPE'
         chars=' '
      end select
      if(fmt.eq.'') then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.').ne.0) call trimzeros(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local.ne.0)then
      !! cannot currently do I/O from a function being called from I/O
      !!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine locate_c(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_5="&
!&@(#)M_list::locate_c(3f): find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',trim(value)//' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
end subroutine locate_c
!===================================================================================================================================
subroutine locate_d(list,value,place,ier,errmsg)

!character(len=*),parameter::ident_6="&
!&@(#)M_list::locate_d(3f): find PLACE in sorted doubleprecision array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

doubleprecision,allocatable            :: list(:)
doubleprecision,intent(in)             :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   arraysize=size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=int(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
end subroutine locate_d
!===================================================================================================================================
subroutine remove_i(list,place)

!character(len=*),parameter::ident_13="@(#)M_list::remove_i(3fp): remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_i
!===================================================================================================================================
subroutine remove_c(list,place)

!character(len=*),parameter::ident_9="@(#)M_list::remove_c(3fp): remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
end subroutine remove_c
subroutine remove_d(list,place)

!character(len=*),parameter::ident_10="&
!&@(#)M_list::remove_d(3fp): remove doubleprecision value from allocatable array at specified position"

doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_d
!===================================================================================================================================
subroutine replace_c(list,value,place)

!character(len=*),parameter::ident_14="@(#)M_list::replace_c(3fp): replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len(value)
   end=size(list)
   if(place.lt.0.or.place.gt.end)then
           write(stderr,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len(value).le.len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
end subroutine replace_c
!===================================================================================================================================
subroutine replace_d(list,value,place)

!character(len=*),parameter::ident_15="&
!&@(#)M_list::replace_d(3fp): place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)   :: value
doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_d* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_d
!===================================================================================================================================
subroutine replace_i(list,value,place)

!character(len=*),parameter::ident_18="@(#)M_list::replace_i(3fp): place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_i
!===================================================================================================================================
subroutine insert_c(list,value,place)

!character(len=*),parameter::ident_19="@(#)M_list::insert_c(3fp): place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end

   if(.not.allocated(list))then
      list=[character(len=max(len(value),2)) :: ]
   endif

   ii=max(len(value),len(list),2)
   end=size(list)

   if(end.eq.0)then                                          ! empty array
      list=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place.gt.end)then                                  ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_c
!===================================================================================================================================
subroutine insert_d(list,value,place)

!character(len=*),parameter::ident_21="&
!&@(#)M_list::insert_d(3fp): place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)       :: value
doubleprecision,allocatable      :: list(:)
integer,intent(in)               :: place
integer                          :: end
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_d* error: index out of range. end=',end,' index=',place,' value=',value
   endif
end subroutine insert_d
!===================================================================================================================================
subroutine insert_i(list,value,place)

!character(len=*),parameter::ident_23="@(#)M_list::insert_i(3fp): place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function round(val,idigits0)
implicit none
!character(len=*),parameter :: ident="@(#) M_math::round(3f): round val to specified number of significant digits"
integer,parameter          :: dp=kind(0.0d0)
real(kind=dp),intent(in)   :: val
integer,intent(in)         :: idigits0
   integer                 :: idigits,ipow
   real(kind=dp)           :: aval,rnormal
   real(kind=dp)           :: round
!  this does not work very well because of round-off errors.
!  Make a better one, probably have to use machine-dependent bit shifting
   ! make sure a reasonable number of digits has been requested
   idigits=max(1,idigits0)
   aval=abs(val)
!  select a power that will normalize the number
!  (put it in the range 1 > abs(val) <= 0)
   if(aval.ge.1)then
      ipow=int(log10(aval)+1)
   else
      ipow=int(log10(aval))
   endif
   rnormal=val/(10.0d0**ipow)
   if(rnormal.eq.1)then
      ipow=ipow+1
   endif
   !normalize, multiply by 10*idigits to an integer, and so on
   round=real(anint(val*10.d0**(idigits-ipow)))*10.d0**(ipow-idigits)
end function round
!===================================================================================================================================
subroutine trimzeros(string)

!character(len=*),parameter::ident_50="@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.').eq.0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i.le.1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros
!===================================================================================================================================
subroutine init_random_seed(mine)

!character(len=*),parameter::ident_7="&
!&@(#)M_random::init_random_seed(3f): initialize random_number(3f) to return a single value with single integer seed like srand(3c)"

! to make this start with a single number like srand(3c) take the seed and
! use the value to fill the seed array, adding 37 to each subsequent value
! till the array is filled.
integer,intent(in) :: mine
   integer         :: i, n
   integer, dimension(:), allocatable :: seed
   call random_seed(size = n)
   allocate(seed(n))
   seed = mine + 37 * (/ (i - 1, i = 1, n) /)
  !write(*,*)seed
  !write(*,*)(/ (i - 1, i = 1, n) /)
   call random_seed(put = seed)
   deallocate(seed)
end subroutine init_random_seed
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_calculator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================


!>>>>> build/dependencies/M_history/src/M_history.f90

!>
!!##NAME
!!    redo(3f) - [M_history] Fortran-based Input History Editor
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine redo(inputline,r)
!!
!!      character(len=*) :: inputline
!!      character(len=1),intent(in),optional :: r
!!
!!##DESCRIPTION
!!    the redo(3f) routine lets you recall, list, save, and modify previously
!!    entered program input. Built-in help is included.
!!
!!    The redo(3f) input history editor is a simple-to-use input history
!!    editor interface modeled on the CDC NOS command REDO. It uses a
!!    line editor model that means no special escape characters or control
!!    characters are required. Typically, only a few minutes are required
!!    to master usage.
!!
!!    When using redo(3f) input lines are usually first read into a character
!!    variable and then passed to the routine. The returned string can then
!!    be parsed or read from with an internal READ(3f). So, for example,
!!    if you have an existing READ(3f) such as
!!
!!       READ(*,101) A,I,K
!!
!!    replace it with something similar to
!!
!!      USE M_HISTORY,ONLY : REDO
!!      CHARACTER(LEN=255) :: LINE ! make variable big enough to read a line
!!            :
!!            :
!!      READ(*,'(A)') LINE   ! read line into character variable
!!      CALL REDO(LINE)      ! pass line to REDO(3f). This is a no-op except
!!                           ! for storing the line into the input history
!!                           ! unless the input line is the "r" command
!!      READ(LINE,101)A,I,K  ! read from variable like you did from file
!!##OPTIONS
!!      inputline    line to record into history buffer file or to edit.
!!
!!      r            Optional character to use as command to invoke editing.
!!                   Defaults to 'r'.
!!
!!##USAGE
!!    When prompted for an input line by your program you may at any time
!!    enter "r" on a line by itself, or a line beginning with "r r_command"
!!    and you will enter the command history edit mode. Now you can recall
!!    and edit previous input or compose an input line using the editor
!!    commands.
!!
!!    By default, you will be editing the last line you entered, shifted
!!    one character to the right by an exclamation character.
!!
!!    The character you respond with in column one controls what happens next.
!!
!!    o If you enter "?" while in command edit mode, help is displayed.
!!
!!    o If the last input line is not the desired line to edit,
!!      select the line to edit by entering its line number or by
!!      using the /,l,u, and d commands (see below for details) to find the desired input line.
!!    o Next enter an editing directive (c,m) to edit the selected line. The
!!      "change" command will change all occurrences of an old string to a
!!      new string ...
!!
!!       c/old/new/
!!
!!    o or the "modify" command can be used with the special characters # &amp; and ^ ...
!!        o A # under a character will delete a character.
!!        o An "&" (ampersand) will cause the character above it to be replaced with a space.
!!        o  To insert a string enter ^string#.
!!        o Otherwise, enter a character under one in the currently displayed command and it will replace it.
!!        o hit RETURN to start another edit of the line
!!    o Once the change is executed you will be prompted for another edit
!!      directive
!!    o You will stay in edit mode until you enter a return on a
!!      blank line to feed your line to your program; or enter "." or
!!      "q" (which means cancel changes and return a blank line).
!!
!!    A detailed summary of the main edit-mode commands follows. In the
!!    descriptions, N stands for a number ...
!!
!!  LISTING COMMAND HISTORY
!!     l|p N      list from line N. -N shows N last lines
!!     L|P N      same as 'l' except no line numbers (for pasting)
!!     /string    search for simple string in all history lines
!!
!!  Note that the buffer is set to the last line displayed
!!
!!  POSITIONING TO PREVIOUS COMMANDS
!!     u N        up through buffer
!!     d N        down through buffer
!!     N          load line number
!!
!!  EDITING THE CURRENT BUFFER LINE
!!     c/oldstring/newstring/   change all occurrences of old string
!!                              to new string. Note that s
!!                              (for substitute) is a synonym for c
!!                              (for change).
!!
!!                              For the "c" directive the second character
!!                              becomes the delimiter. Traditionally one
!!                              usually uses a delimiter of / unless the
!!                              string you are editing contains /.
!!
!!     mmod_string    If the first character of your entry is m or blank,
!!              o REPLACE a string by entering a replacement character under it
!!              o LEAVE a character alone by leaving a space under it
!!              o DELETE a character by putting a # character under it
!!              o BLANK OUT a character by putting an & under it
!!              o INSERT A STRING by entering ^STRING#
!!
!!       The "modify" directive takes a little practice but this single
!!       directive accommodates positionally deleting, replacing, and
!!       inserting text. it is hardest using "modify" to put the strings
!!       "&" and "#" into your lines. to put a # or & character into a
!!       string use the 'c' command instead or ^&# or ^##.
!!
!!     ;N N N N ...  Append specified lines to current line
!!
!!  HELP
!!        h|?    display help text
!!
!!  SYSTEM COMMANDS
!!        !cmd   execute system command
!!
!!  DUMPING AND LOADING THE COMMAND HISTORY
!!
!!        w FILENAME   write entire command history to specified file
!!        r FILENAME   replace command history with file contents
!!        a FILENAME   append lines from file onto command history
!!
!!##EXAMPLE PROGRAM
!!   Sample program
!!
!!       program demo_redo
!!       use M_history, only : redo
!!       implicit none
!!       character(len=1024) ::  line
!!       integer             :: ios
!!       integer             :: cstat
!!       character(len=256)  :: sstat
!!       write(*,'(a)')                                             &
!!       & 'REDO(3f) COMMAND INPUT EDITOR',                         &
!!       & 'enter "r" or "r r_command" on the input line to go',    &
!!       & 'into history edit mode. Once in history edit mode you', &
!!       & 'may enter "?" to get some help. Enter "quit" to exit',  &
!!       & 'the program.'
!!       do
!!          write(*,'(a)',advance='no')'>->'    ! write prompt
!!          read(*,'(a)',iostat=ios) line       ! read new input line
!!          ! if "r", edit and return a line from the history editor
!!          call redo(line) ! store into history if not "r".
!!          if(line == 'quit')stop ! exit program if user enters "quit"
!!          ! now call user code to process new line of data
!!          ! As an example, call the system shell
!!          call execute_command_line(trim(line),cmdstat=cstat,cmdmsg=sstat)
!!       enddo
!!       end program demo_redo
!!
!!##SAMPLE USAGE
!!
!!    The example program is basically a loop that reads a command from
!!    standard input and then executes it as a subshell unless the "r"
!!    command is entered.
!!
!!    Now, we will enter an echo(1) command followed by a few other lines
!!    of input. Then we recall the echo(1) command and use a few of the
!!    features of redo(3) to change and then re-execute the command.
!!
!!       >echo This isss a Test
!!       This isss a Test
!!       >date
!!       Sun May 31 23:54:09 EDT 2009
!!       >pwd
!!       /cygdrive/c/urbanjs/MYCYGWIN/DISKA/public_html/public/CLONE/REDO
!!       >r                            ! enter edit mode
!!       00001 echo This isss a Test   ! last commands are displayed
!!       00002 date
!!       00003 pwd
!!       !pwd
!!       >1                            ! go to first line in history
!!       !echo This isss a Test
!!                    ##   t           ! delete and replace characters
!!       !echo This is a test          ! insert a string
!!                       ^new #
!!       !echo This is a new test
!!       c/test/TEST/                  ! change a substring
!!       !echo This is a new TEST
!!                          &          | replace character with spaces
!!       !echo This is a newTEST
!!                                     ! a blank line ends editing
!!       This is a newTEST
!!       >quit
!!
!!##AUTHOR
!!    John S. Urban, 1988,2009,2011,2015 (last change: Nov 2019)
!!##LICENSE
!!    MIT
module M_history
!
!  Acting much like a line-mode editor, the REDO(3f) procedure lets
!  you list, edit, save, and modify your interactively entered program
!  input. Built-in help and no dependence on terminal control sequences
!  makes this a simple-to-master and portable input history editor.
!
use, intrinsic :: iso_fortran_env, only : ERROR_UNIT        ! access computing environment
use, intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
implicit none
private

public  :: redo                    !  copy a line into history file or edit history if command is "r" and return line

private :: open_history_           !  open history file
private :: redol_                  !  edit history
private :: help_                   !  produce help text for redo(3f) usage

!  should use unused file, not just unit 1071 for history
!  add option to read in and replace history file

integer,parameter :: READLEN=1024  ! width of history file

integer,save,private       :: stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0

interface string_to_value
   module procedure a2d, a2i
end interface

interface v2s
   module procedure i2s
end interface

interface msg
   module procedure msg_scalar, msg_one
end interface msg

interface journal
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
end interface journal

interface str
   module procedure str_scalar, str_one
end interface str
contains
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine redo(inputline,r,lun)
!      if line starts with r word call redol_()
!      uses unit 1071
!       r
!       r string

! ident_1="@(#) M_history redo(3f) open binary direct access file for keeping history"

character(len=*),intent(inout) :: inputline                ! user string
character(len=1),intent(in),optional :: r                  ! character to use to trigger editing
integer,intent(in),optional          :: lun
character(len=1)                     :: r_local            ! character to use to trigger editing
integer,save                         :: iobuf=1071         ! unit number to use for redo history buffer
integer,save                         :: iredo              ! number of lines read from standard input into redo file
logical,save                         :: lcalled=.false.    ! flag whether first time this routine called or not
character(len=READLEN)               :: onerecord
integer                              :: ioparc
integer                              :: ilast
!-----------------------------------------------------------------------------------------------------------------------------------
if(present(r))then
   r_local=r
else
   r_local='r'
endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  open history file and initialize
   if(.not.lcalled)then                                     ! open the redo buffer file
      lcalled=.true.
      iredo=0   ! number of lines in redo buffer
      call open_history_(iobuf,' ','scratch',ioparc)        ! redo buffer
      if(ioparc /= 0)then
         call journal('sc','error creating history file')
         return
      endif
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ilast=len_trim(inputline)

   if(ilast == 1.and.inputline(1:1) == r_local)then                             ! redo command
      call redol_(inputline,iobuf,iredo,READLEN,' ',lun)
      ilast=len_trim(inputline)
   elseif(inputline(1:min(2,len(inputline))) == r_local//' ')then               ! redo command with a string following
      call redol_(inputline,iobuf,iredo,READLEN,inputline(3:max(3,ilast)),lun)
      ilast=len_trim(inputline)
   endif

   if(ilast /= 0)then                                                           ! put command into redo buffer
      iredo=iredo+1
      onerecord=inputline                ! make string the correct length; ASSUMING inputline IS NOT LONGER THAN onerecord
      write(iobuf,rec=iredo)onerecord
   endif
end subroutine redo
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine open_history_(iunit,fname,sname,ierr)
implicit none
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_history open_history_(3fp) open history file for REDO(3f) procedure"

integer,intent(in)          :: iunit   ! Fortran unit to open
character(len=*),intent(in) :: fname   ! filename to open
character(len=*),intent(in) :: sname   ! flag. If "scratch" ignore FNAME and open a scratch file
integer,intent(out)         :: ierr    ! error code returned by opening file
character(len=1024)         :: msg
!-----------------------------------------------------------------------------------------------------------------------------------
  if(sname == 'scratch')then
     open(unit=iunit,status='scratch',form='unformatted',access='direct',recl=READLEN,iostat=ierr,iomsg=msg,action='readwrite')
  else
     open(unit=iunit,file=trim(fname),status=trim(sname),form='unformatted',access='direct', &
     & recl=READLEN,iostat=ierr,iomsg=msg,action='readwrite')
  endif
!-----------------------------------------------------------------------------------------------------------------------------------
  if(ierr /= 0)then
     call journal('sc','*open_history_* open error ',ierr,'=',msg)
  endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine open_history_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine redol_(redoline,iobuf,iredo,ibuf0,init,lun)
!
!  to do:
!  might want to support a count on change to do the Nth to the Mth occurrence
!  support edit window in change
!  prompt to verify each change made with change()
!  maybe make .NAME stick into variable $NAME in the calculator
!  allow changing the edit characters in a modify

! ident_3="@(#) M_history redoline(3fp) redo a previous input line"

character(len=*),intent(out)   :: redoline    ! edited command line to be returned
integer,intent(in)             :: iobuf       ! history file unit to read old commands from
integer                        :: iredo       !iredo ......  (i) number of lines in history file
character(len=*),intent(in)    :: init        ! initial command string
integer,intent(in)             :: ibuf0       ! the width of the history file in characters; <= len(redoline)
integer,intent(in),optional    :: lun         ! LUN to read history commands from

doubleprecision                :: val8
integer                        :: i10, i15, i20, i30
integer                        :: iounit
integer                        :: idump
integer                        :: idown
integer                        :: lun_local
integer                        :: ipoint
integer                        :: iread
integer                        :: istart
integer                        :: ios
integer                        :: ii
integer                        :: ilong
integer                        :: icall
integer                        :: iup
integer                        :: ix
integer                        :: ibuf
integer                        :: ilast
integer                        :: cstat
character                      :: cmd
character(:),allocatable       :: cmdline
character(len=len(redoline)+1) :: cin, cinbuf ! 1 greater than length of redoline
character(len=1024),save       :: numbers
character(len=1024),save       :: msg
integer,allocatable            :: ivals(:)
integer                        :: iend
integer                        :: i
integer                        :: ierr
integer                        :: ier
logical,save                   :: ddd=.false.
data numbers/'123456789012345678901234567890123456789012345678901234567890&
   &12345678901234567890123456789012345678901234567890123456789012345678901234&
   &56789012345678901234567890123456789012345678901234567890123456789012345678&
   &90123456789012345678901234567890123456789012345678901234567890123456789012&
   &34567890123456789012345678901234567890123456789012345678901234567890123456&
   &78901234567890123456789012345678901234567890123456789012345678901234567890&
   &12345678901234567890123456789012345678901234567890123456789012345678901234&
   &56789012345678901234567890123456789012345678901234567890123456789012345678&
   &90123456789012345678901234567890123456789012345678901234567890123456789012&
   &34567890123456789012345678901234567890123456789012345678901234567890123456&
   &78901234567890123456789012345678901234567890123456789012345678901234567890&
   &'/
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(lun))then
      lun_local=lun
   else
      lun_local=5
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ipoint=iredo                                          ! initial line in history file to start with
   icall=0                                               ! flag if have been thru loop or just got here
   cin=init                                              ! initialize the directive
   ibuf=min(ibuf0,len(redoline))
   if(ibuf <= 0)return
!-----------------------------------------------------------------------------------------------------------------------------------
1  continue
   if(ipoint <= 0)then                                   ! if no lines in redo history file
      redoline=' '                                       ! make command to 'redo' a blank line since no commands entered
   else
      read(iobuf,rec=ipoint,err=999)redoline(1:ibuf)     ! get last line in history file as line to redo
      ! WARNING: OSF1 DIGITAL Fortran 77 Driver V5.2-10 DIGITAL Fortran 77 V5.2-171-428BH
      ! after this read the following storage was corrupted; switched declaration of
      ! init and redoline and problem cleared but it is probably corrupting cin and
      ! doesn't show because of logic.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   READLINE: do                                             ! display buffer and decide on command on first call or read command
      ilong=max(1,len_trim(redoline(1:ibuf)))               ! find length of command to redo
      write(*,'(a,a)')'!',redoline(:ilong)                  ! show old command
      if(icall /= 0)then                                    ! if not first call read the directive
         read(lun_local,'(a)',iostat=ios)cinbuf
         if(ios /= 0)then                                   ! if there was an I/O error reread line
            exit READLINE
         endif
         call notabs(cinbuf,cin,ilast)
      elseif(cin == ' ')then                                ! first call and no initial command passed in
         cin='l -5'                                         ! on first call do this default command if init is blank
         ilast=4
      else                                                  ! if initial command was not blank do it instead of default
         ilast=len_trim(cin)
      endif
      icall=icall+1
!-----------------------------------------------------------------------------------------------------------------------------------
      if(ilast == 0)then                                                 ! blank command line; return and execute
         return
      endif
!-----------------------------------------------------------------------------------------------------------------------------------
      cmd=cin(1:1)
      if(ddd)call journal('d','*redol* cmd=',cmd,'options=',cin)
      select case(cmd)                                                   ! first character defines edit action
!-----------------------------------------------------------------------------------------------------------------------------------
       case(' ')                                                         ! modify the string
         call modif(redoline,cin(2:))
!-----------------------------------------------------------------------------------------------------------------------------------
       case('m')                                                         ! modify the string with line number header
         write(*,'(1x,a)',iostat=ios)numbers(:len_trim(redoline))
         call modif(redoline,cin(2:))
!-----------------------------------------------------------------------------------------------------------------------------------
       case('c','s')                                                     ! change old string to new
         call change(redoline,trim(cin(1:255)),ier)                      ! xedit-like change command
!     C/STRING1/STRING2/    OR CW/STRING1/STRING2/  (CHANGE IN WINDOW)
!     WHERE / MAY BE ANY CHARACTER OTHER THAN W OR BLANK, WHICH IS NOT
!     INCLUDED IN STRING1 OR STRING2
!-----------------------------------------------------------------------------------------------------------------------------------
       case('u','b')                                                     ! up or back through buffer
         if(cin(2:) == ' ')then
            iup=1
         else
            iup=int(s2v(cin(2:),ierr,onerr=0))
         endif
         ipoint=max(ipoint-iup,1)
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case('d','f')                                                     ! down or forward through buffer
         if(cin(2:) == ' ')then
            idown=1
         else
            idown=int(s2v(cin(2:),ierr,onerr=0))
         endif
         ipoint=min(ipoint+idown,iredo)
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case(';')                                                         ! append lines
         ivals=int(s2vs(cin(2:)))
         if(allocated(ivals))then
            do i=1,size(ivals)
               ii=ivals(i)
               if(ii >= 1.and.ii <= iredo)then
                  read(iobuf,rec=ii,err=999)cinbuf(1:ibuf)               ! get last line in history file as line to redo
                  iend=len_trim(redoline)
                  redoline=redoline(:iend)//';'//trim(cinbuf)            !! should warn of truncation
               else
                  call journal('sc','*redol_* line not found in history',ii)
               endif
            enddo
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('?','h')                                                     ! display help
         call help_()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('D')                                                         ! toggle debug mode
         if(ddd .eqv. .false.)then
            ddd=.true.
            call journal('>')
         else
            ddd=.false.
            call journal('<')
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('l','p')                                                     ! display history buffer file with line numbers
         if(cin(2:) == ' ')then
            istart=iredo+1-20                                            ! default is to back up 20 lines
         else
            istart=int(s2v(cin(2:),ierr,onerr=0))
            if(ddd)call journal('d','*redol* istart=',istart,'ierr=',ierr)
            if(ierr /= 0)istart=iredo
            if(istart < 0)then
               istart=iredo+1+istart
            endif
         endif
         istart=min(max(1,istart),iredo)                                 ! make istart a safe value
         if(ddd)call journal('d','*redol* istart=',istart,'iredo=',iredo)
         do i10=istart,iredo
            read(iobuf,rec=i10,iostat=ios)redoline(1:ibuf)
            if(ios /= 0)then
               exit READLINE
            endif
            ix=max(1,len_trim(redoline))
            write(*,'(i5.5,1x,a)',iostat=ios)i10,redoline(:ix)
            if(ios /= 0)then
               exit READLINE
            endif
         enddo
!-----------------------------------------------------------------------------------------------------------------------------------
       case('w')                                                         ! dump to a file
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_w()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('e','E')                                                     ! dump and edit history file and read it back in
          cmdline=cin(2:)                                                ! assume rest of command is a system command
          if(cmdline=='')cmdline='vim'                                   ! if no system command use "vim"
          cin='scratch.tmp'                                              ! assume this is a writable scratch file name
          cmdline=trim(cmdline)//' '//cin                                ! append scratch filename to system command
          call do_w()                                                    ! dump history file
          call execute_command_line(cmdline,cmdstat=cstat,cmdmsg=msg)    ! Execute the command line specified by the string.
          if(cstat == 0)then                                             ! rewrite or append to history file
             if(cmd == 'e')iredo=0
             call do_ar()
          endif
          open(newunit=iounit,file=cin,iostat=ios)                       ! remove scratch file
          if(ios /= 0)then
            call journal('sc','*redol_* error opening scratch file file',cin,ios,'=',msg)
          endif
          close(unit=iounit,status='delete',iostat=ios,iomsg=msg)
          if(ios /= 0)then
            call journal('sc','*redol_* error removing scratch file file',cin,ios,'=',msg)
          endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('a')                                                         ! append to history from a file
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_ar()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('r')                                                         ! replace history from a file
          iredo=0
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_ar()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('P','L')                                                     ! display history buffer file without line numbers
         if(cin(2:) == ' ')then                                          ! default is to go back up to 20
            istart=iredo+1-20
         else
            istart=int(s2v(cin(2:),ierr,onerr=0))
            if(istart < 0)then
               istart=iredo+1+istart
            endif
         endif
         istart=min(max(1,istart),iredo)                                 ! make istart a safe value
         do i30=istart,iredo                                             ! easier to cut and paste if no numbers
            read(iobuf,rec=i30,iostat=ios)redoline(1:ibuf)
            if(ios /= 0)then
               goto 999
            endif
            ix=max(1,len_trim(redoline))
            write(*,'(a)',err=999)redoline(:ix)
         enddo
!-----------------------------------------------------------------------------------------------------------------------------------
       case('/')                                                         ! display matches in buffer
         if(ilast < 2)then
            cycle
         endif
         do i20=1,iredo
            read(iobuf,rec=i20,err=999,iostat=ios)redoline(1:ibuf)
            if(index(redoline(1:ibuf),cin(2:ilast)) /= 0)then
               ix=max(1,len_trim(redoline))
               write(*,'(i5.5,1x,a)',err=999)i20,redoline(:ix)
               ipoint=i20
            endif
         enddo
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case('!')                                                              ! external command
         if(ilast < 2)then
            cycle
         endif
         call execute_command_line(trim(cin(2:)),cmdstat=cstat,cmdmsg=msg)    ! Execute the command line specified by the string.
         !call system(trim(cin(2:)))                                          ! Execute the command line specified by the string.
!-----------------------------------------------------------------------------------------------------------------------------------
       case('.','q')                                                          ! blank out command and quit
         exit READLINE
!-----------------------------------------------------------------------------------------------------------------------------------
       case default                                                           ! assume anything else is a number
         val8=s2v(cin,ierr,onerr=0)
         if(ierr == 0)then
            iread=int(val8)
         else
            iread=0
         endif
         if(iread > 0.and.iread <= iredo)then
            read(iobuf,rec=iread,err=999,iostat=ios)redoline(1:ibuf)
            ipoint=iread
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
      end select
!-----------------------------------------------------------------------------------------------------------------------------------
   enddo READLINE
!-----------------------------------------------------------------------------------------------------------------------------------
999 continue
   redoline=' '
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine do_w()
WRITE: block
   open(newunit=idump,file=cin,iostat=ios,status='UNKNOWN',iomsg=msg)
   if(ios /= 0)then
      call journal('sc','*redol_* error opening dump file',ios,'=',msg)
      exit WRITE
   endif
   do i15=1,iredo
      read(iobuf,rec=i15,iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         call journal('sc','*redol_* error reading history file',ios,'=',msg)
         exit WRITE
      endif
      ix=max(1,len_trim(redoline))
      write(idump,'(a)',iostat=ios,iomsg=msg)redoline(:ix)
      if(ios /= 0)then
         call journal('sc','*redol_* error writing dump file',ios,'=',msg)
         close(idump,iostat=ios)
         exit WRITE
      endif
   enddo
   call journal('sc','wrote file ',cin)
endblock WRITE
close(idump,iostat=ios)
end subroutine do_w
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine do_ar()
REPLACE: block
   open(newunit=idump,file=cin,iostat=ios,status='OLD',iomsg=msg)
   if(ios /= 0)then
      call journal('sc','*redol_* error opening file',ios,'=',msg)
      exit REPLACE
   endif
   do
      read(idump,'(a)',iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         if(.not.is_iostat_end(ios))then
            call journal('sc','*redol_* error reading file ',cin,ios,'=',msg)
         endif
         exit REPLACE
      endif
      iredo=iredo+1
      write(iobuf,rec=iredo,iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         call journal('sc','*redol_* error writing history file',ios,'=',msg)
         exit REPLACE
      endif
   enddo
endblock REPLACE
call journal('sc','read file ',cin)
close(idump,iostat=ios)
end subroutine do_ar
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine redol_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine help_()

! ident_4="@(#) M_history help_(3fp) prints help for REDO(3f)"

character(len=80),allocatable :: usage(:)
integer                       :: i
!-----------------------------------------------------------------------------------------------------------------------------------
usage=[ &
&' History Edit commands (where N is a number):                                   ',&
&'+______________________________________________________________________________+',&
&'|List History                           |History File:                         |',&
&'| l|p N    # list from line N.          | w   file # write history to a file   |',&
&'!          # -N shows N last lines      | a   file # append file to history    |',&
&'| L|P N    # same as l sans line numbers| r   file # replace history with file |',&
&'| /string  # search for simple string   |Return to Normal Command Mode:        |',&
&'|Position in History File:              |      # return and execute command    |',&
&'| u|b N    # up/back through buffer     | .|q  # quit and return a blank line  |',&
&'| d|f N    # down/forward through buffer|Help:                                 |',&
&'| N        # load line number           |  h|?   # display this help text      |',&
&'|System:                                |Append lines to current line:         |',&
&'| !system_command # execute command     |  ;N N N N ...                        |',&
&'|______________________________________________________________________________|',&
&'|Edit Buffer:                                                                  |',&
&'| c|s/oldstring/newstring/  # change/substitute                                |',&
&'| mmod_string               # Modify with line number header                   |',&
&'|  mod_string               # Modify (replace, delete, insert)                 |',&
&'|    #         -- deletes                                                      |',&
&'|    &         -- replaces with a blank                                        |',&
&'|    ^STRING#  -- inserts a string                                             |',&
&'|              -- blank leaves as-is                                           |',&
&'|    Any other -- replaces character                                           |',&
&'+______________________________________________________________________________+']
!-----------------------------------------------------------------------------------------------------------------------------------
   !WRITE(*,'(a)'),usage(i),i=1,size(usage))
   do i=1,size(usage)
      call journal('sc',usage(i))
   enddo
end subroutine help_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function sep(input_line,delimiters,nulls)

intrinsic index, min, present, len
character(len=*),intent(in)              :: input_line
character(len=*),optional,intent(in)     :: delimiters
character(len=*),optional,intent(in)     :: nulls
character(len=:),allocatable             :: sep(:)
   call split(input_line,sep,delimiters,'right',nulls)
end function sep
subroutine split(input_line,array,delimiters,order,nulls)

intrinsic index, min, present, len
character(len=*),intent(in)              :: input_line
character(len=*),optional,intent(in)     :: delimiters
character(len=*),optional,intent(in)     :: order
character(len=*),optional,intent(in)     :: nulls
character(len=:),allocatable,intent(out) :: array(:)
integer                       :: n
integer,allocatable           :: ibegin(:)
integer,allocatable           :: iterm(:)
character(len=:),allocatable  :: dlim
character(len=:),allocatable  :: ordr
character(len=:),allocatable  :: nlls
integer                       :: ii,iiii
integer                       :: icount
integer                       :: lgth
integer                       :: i10,i20,i30
integer                       :: icol
integer                       :: idlim
integer                       :: ifound
integer                       :: inotnull
integer                       :: ireturn
integer                       :: imax
   if (present(delimiters)) then
      if(delimiters /= '')then
         dlim=delimiters
      else
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)
      endif
   else
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)
   endif
   idlim=len(dlim)
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif
   n=len(input_line)+1
   if(allocated(ibegin))deallocate(ibegin)
   if(allocated(iterm))deallocate(iterm)
   allocate(ibegin(n))
   allocate(iterm(n))
   ibegin(:)=1
   iterm(:)=1
   lgth=len(input_line)
   icount=0
   inotnull=0
   imax=0
   if(lgth > 0)then
      icol=1
      infinite: do i30=1,lgth,1
         ibegin(i30)=icol
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then
            iterm(i30)=lgth
            do i10=1,idlim
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               if(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2
            inotnull=inotnull+1
         else
            iterm(i30)=icol-1
            icol=icol+1
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30
         if(icol > lgth)then
            exit infinite
         endif
      enddo infinite
   endif
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))
   select case (trim(adjustl(ordr)))
   case ('reverse','right') ; ii=ireturn ; iiii=-1
   case default             ; ii=1       ; iiii=1
   end select
   do i20=1,icount
      if(iterm(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
   end subroutine split

subroutine substitute(targetline,old,new,ierr,start,end)

character(len=*)               :: targetline
character(len=*),intent(in)    :: old
character(len=*),intent(in)    :: new
integer,intent(out),optional   :: ierr
integer,intent(in),optional    :: start
integer,intent(in),optional    :: end
character(len=len(targetline)) :: dum1
integer                        :: ml, mr, ier1
integer                        :: maxlengthout
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
   if (present(start)) then
      ml=start
   else
      ml=1
   endif
   if (present(end)) then
      mr=end
   else
      mr=len(targetline)
   endif
   ier1=0
   maxlengthout=len(targetline)
   original_input_length=len_trim(targetline)
   dum1(:)=' '
   id=mr-ml
   len_old=len(old)
   len_new=len(new)
   if(id <= 0)then
      il=1
      ir=maxlengthout
      dum1(:)=' '
   else
      il=ml
      ir=min0(mr,maxlengthout)
      dum1=targetline(:il-1)
   endif
   if(len_old == 0)then
      ichr=len_new + original_input_length
      if(ichr > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1
      if(present(ierr))ierr=ier1
      return
   endif
   ichr=il
   ic=il
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1
      if(ind == ic-1.or.ind > ir)then
         exit loop
      endif
      ier1=ier1+1
      if(ind > ic)then
         ladd=ind-ic
         if(ichr-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)
   case default
      ladd=original_input_length-ic
      if(ichr+ladd > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
end subroutine substitute
subroutine change(target_string,cmd,ierr)

character(len=*),intent(inout)   :: target_string
character(len=*),intent(in)      :: cmd
character(len=1)                 :: delimiters
integer                          :: ierr
integer                          :: itoken
integer,parameter                :: id=2
character(len=:),allocatable     :: old,new
logical                          :: ifok
integer                          :: lmax
integer                          :: start_token,end_token
   lmax=len_trim(cmd)
   if(lmax >= 4)then
      delimiters=cmd(id:id)
      itoken=0

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))
   else
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
end subroutine change
function strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)

character(len=*),intent(in)  :: source_string
character(len=*),intent(in)  :: delimiters
integer,intent(inout)        :: itoken
logical                      :: strtok_status
integer,intent(out)          :: token_start
integer,intent(inout)        :: token_end
integer,save                 :: isource_len
   if(itoken <= 0)then
      token_start=1
   else
      token_start=token_end+1
   endif
   isource_len=len(source_string)
   if(token_start > isource_len)then
      token_end=isource_len
      strtok_status=.false.
      return
   endif
   do while (token_start  <=  isource_len)
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
   token_end=token_start
   do while (token_end  <=  isource_len-1)
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then
         exit
      endif
      token_end = token_end + 1
   enddo
   if (token_start  >  isource_len) then
      strtok_status=.false.
   else
      itoken=itoken+1
      strtok_status=.true.
   endif
end function strtok
subroutine modif(cline,modi)

character(len=*)            :: cline
character(len=*),intent(in) :: modi
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'
integer                     :: maxscra
character(len=len(cline))   :: dum2
logical                     :: linsrt
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(modi)
   lmax=min0(len(cline),maxscra)
   lmx1=lmax-1
   dum2=' '
   linsrt=.false.
   iend=len_trim(cmod)
   i=0
   ic=0
   ichr=0
11 continue
   i=i+1
   if(ichr > lmx1)goto 999
   if(linsrt) then
      if(i > iend) cmod(i:i)=c(1:1)
      if(cmod(i:i) == c(1:1))then
         linsrt=.false.
         if(ic+1 == i)then
            ichr=ichr+1
            dum2(ichr:ichr)=c(1:1)
         endif
         do j=ic,i
            ichr=ichr+1
            if(ichr > lmax)goto 999
            dum2(ichr:ichr)=cline(j:j)
         enddo
         ic=i
         goto 1
      endif
      ichr=ichr+1
      dum2(ichr:ichr)=cmod(i:i)
   else
      ic=ic+1
      if(cmod(i:i) == c(1:1))goto 1
      if(cmod(i:i) == c(3:3))then
         linsrt=.true.
         goto 1
      endif
      ichr=ichr+1
      if(cmod(i:i) == c(2:2))then
         dum2(ichr:ichr)=' '
         goto 1
      endif
      if(cmod(i:i) == ' ')then
         dum2(ichr:ichr)=cline(ic:ic)
      else
         dum2(ichr:ichr)=cmod(i:i)
      endif
   endif
1  continue
   if(i < lmax)goto 11
999   continue
   cline=dum2
end subroutine modif

elemental pure function upper(str,begin,end) result (string)

character(*), intent(in)      :: str
integer, intent(in), optional :: begin,end
character(len(str))           :: string
integer                       :: i
integer                       :: ibegin,iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(ibegin,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)
       select case (str(i:i))
       case ('a':'z')
          string(i:i) = char(iachar(str(i:i))+diff)
       end select
   enddo

end function upper
elemental pure function lower(str,begin,end) result (string)

character(*), intent(in)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))-diff)
      case default
      end select
   enddo

end function lower

elemental impure subroutine notabs(instr,outstr,lgth)

character(len=*),intent(in)   :: instr
character(len=*),intent(out)  :: outstr
integer,intent(out)           :: lgth
integer,parameter             :: tabsize=8
integer                       :: ipos
integer                       :: lenin
integer                       :: lenout
integer                       :: istep
character(len=1)              :: c
integer                       :: iade
   ipos=1
   lenin=len_trim(instr( 1:len(instr) ))
   lenout=len(outstr)
   outstr=" "
      scan_line: do istep=1,lenin
         c=instr(istep:istep)
         iade=iachar(c)
         expand_tabs : select case (iade)
         case(9)
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)
            ipos=ipos+1
         case default
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select expand_tabs
      enddo scan_line
      ipos=min(ipos,lenout)
      lgth=len_trim(outstr(:ipos))
end subroutine notabs

subroutine a2i(chars,valu,ierr)

character(len=*),intent(in) :: chars
integer,intent(out)         :: valu
integer,intent(out)         :: ierr
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
subroutine a2d(chars,valu,ierr,onerr)

character(len=*),intent(in)  :: chars
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu
integer,intent(out)          :: ierr
class(*),optional,intent(in) :: onerr
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"
character(len=15)            :: frmt
character(len=256)           :: msg
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
   ierr=0
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu
      end select
   endif
   if(ierr /= 0)then
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg /= '')then
            call journal('sc','*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
doubleprecision function s2v(chars,ierr,onerr)

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
function i2s(ivalue,fmt) result(outstr)

integer,intent(in)           :: ivalue
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
subroutine trimzeros_(string)

character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: expo
integer                      :: ipos
integer                      :: i, ii
   str=string
   ipos=scan(str,'eEdD')
   if(ipos>0) then
      expo=str(ipos:)
      str=str(1:ipos-1)
   endif
   if(index(str,'.') == 0)then
      ii=len_trim(str)
      str(ii+1:ii+1)='.'
   endif
   do i=len_trim(str),1,-1
      select case(str(i:i))
      case('0')
         cycle
      case('.')
         if(i <= 1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)
         exit
      end select
   enddo
   if(ipos>0)then
      string=trim(str)//trim(expo)
   else
      string=str
   endif
end subroutine trimzeros_
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str
character(len=1),optional,intent(in) :: esc
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
   if(present(esc))then
      iesc=iachar(esc)
   else
      iesc=-1
   endif
   inlen=len(quoted_str)
   allocate(character(len=inlen) :: unquoted_str)
   if(inlen >= 1)then
      if(quoted_str(1:1) == single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
   before=-2
   unquoted_str(:)=''
   iput=1
   inside=.false.
   stepthrough: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before == iesc)then
           iput=iput-1
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2
      elseif(current == quote)then
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo stepthrough
   unquoted_str=unquoted_str(:iput-1)
end function unquote
function s2vs(string,delim) result(darray)

character(len=*),intent(in)        :: string
character(len=*),optional          :: delim
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)

character(len=:),allocatable       :: carray(:)
integer                            :: i
integer                            :: ier
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
   call split(string,carray,delimiters=delim_local)
   allocate(darray(size(carray)))
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)
   enddo
end function s2vs

logical function base(x,b,y,a)
implicit none
character(len=*),intent(in)  :: x
character(len=*),intent(out) :: y
integer,intent(in)           :: b,a
integer                      :: temp

base=.true.
if(decodebase(x,b,temp)) then
   if(codebase(temp,a,y)) then
   else
      print *,'Error in coding number.'
      base=.false.
   endif
else
   print *,'Error in decoding number.'
   base=.false.
endif

end function base

logical function decodebase(string,basein,out_baseten)
implicit none

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: xmaxreal=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')
  if(basein == 0.and.ipound > 1)then
     call string_to_value(string_local(:ipound-1),basein_local,ierr)
     string_local=string_local(ipound+1:)
     if(basein_local >= 0)then
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  all: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else all
     out_baseten=0;y=0.0; mult=1.0
     long=len_trim(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit all
        endif
        if(ch<='9') then
              j=iachar(ch)-iachar('0')
        else
              j=iachar(ch)-iachar('A')+10
        endif
        if(j>=basein_local)then
           exit all
        endif
        y=y+mult*j
        if(mult>xmaxreal/basein_local)then
           exit all
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif all
end function decodebase
logical function codebase(inval10,outbase,answer)
implicit none

integer,intent(in)           :: inval10
integer,intent(in)           :: outbase
character(len=*),intent(out) :: answer
integer                      :: n
real                         :: inval10_local
integer                      :: outbase_local
integer                      :: in_sign
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
    print *,'*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
    codebase=.false.
  else
     do while(inval10_local>0.0 )
        n=int(inval10_local-outbase_local*int(inval10_local/outbase_local))
        if(n<10) then
           answer=achar(iachar('0')+n)//answer
        else
           answer=achar(iachar('A')+n-10)//answer
        endif
        inval10_local=int(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign == -1)then
     answer='-'//trim(answer)
  endif
  if(answer == '')then
     answer='0'
  endif
end function codebase
function todecimal(base, instr)

character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
function tobase(base, number)

character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

function fmt(source_string,length)

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: istart
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: fmt(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
   do i=1,2
      iword_max=0
      ilines=1
      ilength=0
      itoken=0
      do while ( strtok(source_string,itoken,istart,iend,delimiters) )
         iword=iend-istart+1
         iword_max=max(iword_max,iword)
         if(iword > length)then
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then
               fmt(ilines)=source_string(istart:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then
            if(i == 2)then
               fmt(ilines)=fmt(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=ilength+iword+1
         else
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               fmt(ilines)=fmt(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then
         allocate(character(len=max(length,iword_max)) :: fmt(ilines))
         fmt=' '
      endif
   enddo
   fmt=fmt(:ilines)
end function fmt

function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

class(*),intent(in),optional  :: generic1 ,generic2 ,generic3 ,generic4 ,generic5
class(*),intent(in),optional  :: generic6 ,generic7 ,generic8 ,generic9
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_scalar=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
end function msg_scalar
function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

class(*),intent(in)           :: generic1(:)
class(*),intent(in),optional  :: generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable   :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic
end function msg_one

subroutine where_write_message(where,msg)

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times
character(len=3)                   :: adv

character(len=:),allocatable,save  :: prefix_template
character(len=:),allocatable       :: prefix
logical,save                       :: prefix_it=.false.
character(len=4096)                :: mssge
   adv='yes'
   prefix=''
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
         endif
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      case('+'); adv='no'
      case('>'); debug=.true.
      case('<'); debug=.false.
      case('%')
         if(msg == '')then
            prefix_it=.false.
         else
            prefix_template=msg
            prefix_it=.true.
         endif
      case('N')
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            stdout=6
         endif
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
end subroutine where_write_message

subroutine where_write_message_all(where, g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,nospace)
implicit none
character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
logical,intent(in),optional   :: nospace
   call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,nospace))
end subroutine where_write_message_all

subroutine write_message_only(message)

character(len=*),intent(in)          :: message
   call where_write_message('sc',trim(message))
end subroutine write_message_only
function str_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
implicit none
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=:),allocatable  :: sep_local
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   str_scalar=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function str_scalar
function str_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: str_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   str_one=trim(line)
contains

subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   line=trim(line)//"]"//sep_local
   istart=len_trim(line)+increment
end subroutine print_generic

end function str_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_history


!>>>>> build/dependencies/M_io/src/M_io.F90

!===================================================================================================================================
MODULE M_io
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit

implicit none
private
integer,parameter,private:: sp=kind(1.0), dp=kind(1.0d0)
public uniq
public print_inquire
public notopen
public filename_generator
public number_of_lines
public get_next_char
public dirname
public basename
public splitpath
public joinpath
public fileopen
public filebyte, slurp
public fileread, gulp, swallow
public filewrite
public fileclose
public filedelete
public get_tmp
public read_line
public getline
public read_table
public rd
public separator
public lookfor
public which
public get_env
public is_hidden_file
public getname

! ident_1="@(#) M_io rd(3f) ask for string or number from standard input with user-definable prompt"
interface rd
   module procedure rd_character
   module procedure rd_integer
   module procedure rd_real
   module procedure rd_doubleprecision
   module procedure rd_logical
end interface

! ident_2="@(#) M_io read_table(3f) read file containing a table of numeric values"
interface read_table
   module procedure read_table_i
   module procedure read_table_r
   module procedure read_table_d
end interface

interface filedelete
   module procedure filedelete_filename
   module procedure filedelete_lun
end interface

integer,save,private       :: my_stdout=stdout
logical,save               :: debug=.false.
integer,save               :: last_int=0

interface string_to_value
   module procedure a2d, a2i
end interface

interface v2s
   module procedure i2s
end interface

interface journal
   !!module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   !!module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

interface str
   module procedure msg_scalar, msg_one
end interface str
character(len=*),parameter,private :: gen='(*(g0,1x))'

interface get_env
   module procedure get_env_integer
   module procedure get_env_real
   module procedure get_env_double
   module procedure get_env_character
   module procedure get_env_logical
end interface get_env

type :: force_keywd_hack  ! force keywords, using @awvwgk method
end type force_keywd_hack
! so then any argument that comes afer "force_keywd" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_keywd_hack), optional, intent(in) :: force_keywd
!-----------------------------------
! old names
interface swallow;  module procedure fileread;  end interface
interface gulp;     module procedure fileread;  end interface
interface slurp;    module procedure filebyte;  end interface
interface readenv
   module procedure get_env_integer
   module procedure get_env_real
   module procedure get_env_double
   module procedure get_env_character
   module procedure get_env_logical
end interface readenv
public readenv
!-----------------------------------

CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      uniq(3f) - [M_io:QUERY] append a number to the end of filename to make
!!                 a unique name if name exists
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!      Usage
!!
!!       character(len=:),allocatable function uniq(name,istart,verbose,create)
!!       character(len=*),intent(in) :: name
!!       integer,intent(in),optional :: istart
!!       logical,intent(in),optional :: verbose
!!       logical,intent(in),optional :: create
!!
!!##DESCRIPTION
!!    Given a filename test if it is in use or exists. If it is, or if it
!!    ends in a period add a number to the end of the name and
!!    test if the new name exists. If necessary, increment the number and
!!    try again up to the value 9999999. By default an empty file is created
!!    if an unused name is found.
!!
!!
!!##OPTIONS
!!    name     base input name used to create output filename
!!             If name ends in "." a numeric suffix is always added.
!!    istart   number to start with as a suffix. Default is 1. Must be a
!!             positive integer less than 9999999.
!!    verbose  writes extra messages to stdout. Defaults to .false.
!!    create   create file if a new unused name is successfully
!!             found. Defaults to .true. .
!!
!!##RETURNS
!!    uniq     A unique filename that is the same as the NAME input parameter
!!             except with a number appended at the end if needed. If could
!!             not find a unique name a blank is returned.
!!
!!##EXAMPLE
!!
!!    Sample program
!!
!!       program demo_uniq
!!       use M_io, only : uniq
!!       implicit none
!!       character(len=4096) :: myname
!!       integer             :: i
!!          myname=uniq('does_not_exist')
!!          write(*,*)'name stays the same   :',trim(myname)
!!          open(unit=10,file='does_exist')
!!          myname=uniq('does_exist')
!!          write(*,*)'name has suffix added :',trim(myname)
!!          do i=1,10
!!             myname=uniq('does_exist')
!!             write(*,*) 'FILENAME:',trim(myname)
!!             open(unit=20+i,file=myname)
!!          enddo
!!       end program demo_uniq
!!
!!    Expected output
!!
!!     name stays the same does_not_exist
!!     name has suffix added does_exist0001
!!     FILENAME:does_exist0002
!!     FILENAME:does_exist0003
!!     FILENAME:does_exist0004
!!     FILENAME:does_exist0005
!!     FILENAME:does_exist0006
!!     FILENAME:does_exist0007
!!     FILENAME:does_exist0008
!!     FILENAME:does_exist0009
!!     FILENAME:does_exist0010
!!     FILENAME:does_exist0011
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!! Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
function uniq(name,istart,verbose,create)
implicit none

! ident_3="@(#) M_io uniq(3f) append a number to the end of filename to make a unique name if name exists"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: name
character(len=:),allocatable :: uniq
integer,intent(in),optional  :: istart
logical,intent(in),optional  :: verbose
logical,intent(in),optional  :: create
!-----------------------------------------------------------------------------------------------------------------------------------
logical                     :: around
integer,save                :: icount=1           ! counter to generate suffix from
character(len=4096),save    :: lastname=' '       ! name called with last time the routine was called
integer                     :: ilen
integer                     :: itimes
integer                     :: iscr
integer                     :: ios
logical                     :: verbose_local
logical                     :: create_local
!-----------------------------------------------------------------------------------------------------------------------------------
   uniq=trim(name)                                   ! the input name will be returned if it passes all the tests
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lastname /= name)then                          ! if a different input name than last time called reset icount
      lastname=name                                  ! a new name to keep for subsequent calls
      icount=1                                       ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(create))then
      create_local=create
   else
      create_local=.true.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(istart))then
      icount=istart                                  ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len_trim(name)                               ! find last non-blank character in file name
!-----------------------------------------------------------------------------------------------------------------------------------
   if(ilen /= 0)then                                 ! a blank input name so name will just be a suffix
      if(name(ilen:ilen) /= '.')then                 ! always append a number to a file ending in .
         inquire(file=name(:ilen),exist=around)      ! check filename as-is
         if(.not.around)then                         ! file name does not exist, can use it as-is
            uniq=trim(name)
            if(create_local)then
               open(newunit=iscr,file=uniq,iostat=ios,status='new')
               close(unit=iscr,iostat=ios)
            endif
            return
         endif
      endif
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   itimes=0                                           ! count number of times tried to get a uniq name
   deallocate(uniq)
   allocate(character(len=ilen+8) :: uniq)            ! make it useable with an internal WRITE(3f) with room for a numeric suffix
   uniq(:)=name
   INFINITE: do                                       ! top of loop trying for a unique name
      if(itimes >= 9999999)then                       ! if too many tries to be reasonable give up
         call journal('sc','*uniq* unable to find a unique filename. Too many tries')
         uniq=''
         return
      endif
      if(icount > 9999999) icount=1                  ! reset ICOUNT when it hits arbitrary maximum value
      if(icount <= 9999)then
         write(uniq(ilen+1:),'(i4.4)')icount          ! create name by adding a numeric string to end
      else
         write(uniq(ilen+1:),'(i7.7)')icount          ! create name by adding a numeric string to end
      endif
      icount=icount+1                                 ! increment counter used to come up with suffix
      inquire(file=uniq,exist=around)                 ! see if this filename already exists
      if(.not.around)then                             ! found an unused name
         if(verbose_local)then
            call journal('c','*uniq* name='//trim(uniq)) ! write out message reporting name used
         endif
         if(create_local)then
            open(newunit=iscr,file=uniq,iostat=ios,status='new')
            close(unit=iscr,iostat=ios)
         endif
         uniq=trim(uniq)
         return                                       ! return successfully
      endif
      itimes=itimes+1                                 ! haven't found a unique name, try again
   enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
end function uniq
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    print_inquire(3f) - [M_io:QUERY] Do INQUIRE on file by name/number and
!!                        print results
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   Definition:
!!
!!    subroutine print_inquire(lun)
!!      or
!!    subroutine print_inquire(name)
!!    integer,intent(in),optional          :: lun
!!    character(len=*),intent(in),optional :: name
!!
!!##DESCRIPTION
!!    Given either a Fortran file-unit-number or filename, call the
!!    INQUIRE(3f) intrinsic and print typical status information.
!!
!!##OPTIONS
!!    lun    if lun is not equal to -1 then query by number and ignore
!!           filename even if present
!!    name   if lun = -1  or is not present then query by this filename
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_print_inquire
!!    use M_io, only : print_inquire, fileopen
!!    implicit none
!!    character(len=4096)  :: filename
!!    character(len=20)    :: mode
!!    integer              :: ios
!!    character(len=256)   :: message
!!    integer              :: lun
!!       do
!!          write(*,'(a)',advance='no')'enter filename>'
!!          read(*,'(a)',iostat=ios)filename
!!          if(ios /= 0)exit
!!          write(*,'(a)',advance='no')'enter mode ([rwa][bt][+]>'
!!          read(*,'(a)',iostat=ios)mode
!!          if(ios /= 0)exit
!!          lun=fileopen(filename,mode,ios)
!!          if(ios == 0)then
!!             write(*,*)'OPENED'
!!          else
!!             write(*,*)'ERROR: IOS=',ios
!!          endif
!!          if(lun /= -1)then
!!             call print_inquire(lun,'')
!!             close(lun,iostat=ios,iomsg=message)
!!             if(ios /= 0)then
!!                write(*,'(a)')trim(message)
!!             endif
!!          endif
!!       enddo
!!    end program demo_print_inquire
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine print_inquire(lun_in,namein_in) ! Version: JSU-1997-12-31, 2020-01-11

! ident_4="@(#) M_io print_inquire(3f) Do INQUIRE on file by name/number and print results"

integer,intent(in),optional             :: lun_in        ! if unit >= 0 then query by unit number, else by name
character(len=*),intent(in),optional    :: namein_in
integer                        :: ios
character(len=256)             :: message
character(len=:),allocatable   :: namein
integer                        :: lun
!==============================================================================================
!  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
!  ACTION    =  READ        | WRITE         |  READWRITE
!  FORM      =  FORMATTED   |  UNFORMATTED
!  POSITION  =  ASIS        |  REWIND       |  APPEND
!  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
character(len=20)             :: access         ; namelist/inquire/access
character(len=20)             :: asynchronous   ; namelist/inquire/asynchronous
character(len=20)             :: blank          ; namelist/inquire/blank
character(len=20)             :: decimal        ; namelist/inquire/decimal
character(len=20)             :: delim          ; namelist/inquire/delim
character(len=20)             :: direct         ; namelist/inquire/direct
character(len=20)             :: encoding       ; namelist/inquire/encoding
logical                       :: exist          ; namelist/inquire/exist

character(len=20)             :: form           ; namelist/inquire/form
character(len=20)             :: formatted      ; namelist/inquire/formatted
character(len=20)             :: unformatted    ; namelist/inquire/unformatted

integer                       :: id             ; namelist/inquire/id
character(len=20)             :: name           ; namelist/inquire/name
logical                       :: named          ; namelist/inquire/named
integer                       :: nextrec        ; namelist/inquire/nextrec
integer                       :: number         ; namelist/inquire/number
logical                       :: opened         ; namelist/inquire/opened
character(len=20)             :: pad            ; namelist/inquire/pad
logical                       :: pending        ; namelist/inquire/pending
integer                       :: pos            ; namelist/inquire/pos
character(len=20)             :: position       ; namelist/inquire/position

character(len=20)             :: action         ; namelist/inquire/action
character(len=20)             :: read           ; namelist/inquire/read
character(len=20)             :: readwrite      ; namelist/inquire/readwrite
character(len=20)             :: write          ; namelist/inquire/write

integer                       :: recl           ; namelist/inquire/recl
character(len=20)             :: round          ; namelist/inquire/round
character(len=20)             :: sequential     ; namelist/inquire/sequential
character(len=20)             :: sign           ; namelist/inquire/sign
integer                       :: size           ; namelist/inquire/size
character(len=20)             :: stream         ; namelist/inquire/stream
!==============================================================================================
   namein=merge_str(namein_in,'',present(namein_in))
   lun=merge(lun_in,-1,present(lun_in))
   ! exist, opened, and named always become defined unless an error condition occurs.
   !!write(*,*)'LUN=',lun,' FILENAME=',namein
   !-----------------------------------------------------------------------------------------------------------------------------------
   name=''
   if(namein == ''.and.lun /= -1)then
         call journal('sc','*print_inquire* checking unit',lun)
         inquire(unit=lun,                                                                               &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
    elseif(namein /= '')then
         call journal('sc','*print_inquire* checking file:'//namein)
         inquire(file=namein,                                                                            &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
     if(name == '')name=namein
    else
       call journal('sc','*print_inquire* must specify either filename or unit number')
    endif
!-----------------------------------------------------------------------------------------------------------------------------------
   write(*,nml=inquire,delim='none')
   return
!-----------------------------------------------------------------------------------------------------------------------------------
999   continue
   call journal('sc','*print_inquire* bad inquire')
!  If an error condition occurs during execution of an INQUIRE  statement,
!  all of the inquiry identifiers except ios become undefined.
   call journal('sc','*print_inquire* inquire call failed,iostat=',ios,'message=',message)
end subroutine print_inquire
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    separator(3f) - [M_io:QUERY] try to determine pathname directory
!!                    separator character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function separator() result(sep)
!!
!!     character(len=1) :: sep
!!
!!##DESCRIPTION
!!
!!    Try to determine the separator character used to separate directory
!!    names from file basenames. It is assumed it is either a backslash or
!!    a slash character.
!!
!!    First, the environment variables PATH, HOME, PWD, and  SHELL  are
!!    examined for a backslash, then a slash.
!!
!!    Then, using the name the program was invoked with, then an INQUIRE(3f)
!!    of that name, then ".\NAME" and "./NAME" try to find an expected
!!    separator character.
!!
!!    Can be very system dependent. If the queries fail the default returned
!!    is "/".
!!
!!    The value is cached as a return value for subsequent calls.
!!
!!##EXAMPLE
!!
!!   sample usage
!!
!!    program demo_separator
!!    use M_io, only : separator
!!    implicit none
!!       write(*,*)'separator=',separator()
!!    end program demo_separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function separator() result(sep)

! use the pathname returned as arg0 to determine pathname separator
implicit none
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!*!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !*!FORT BUG:if(sep_cache /= ' ')then  ! use cached value.
    !*!FORT BUG:    sep=sep_cache
    !*!FORT BUG:    return
    !*!FORT BUG:endif
    if(isep /= -1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios == 0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\') /= 0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/') /= 0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !*!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    read_table(3f) - [M_io:READ] read file containing a table of numeric values
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine read_table(filename,array,ierr,comment)
!!
!!    character(len=*),intent(in)          :: filename
!!    TYPE,allocatable,intent(out)         :: array(:,:)
!!    integer,intent(out)                  :: ierr
!!    character(len=1,intent(in),optional  :: comment
!!
!!   where TYPE may be REAL, INTEGER, or DOUBLEPRECISION
!!
!!##DESCRIPTION
!!    Read a table from a file that is assumed to be columns of numbers,
!!    ignoring characters not in the set [0-9edED+-.] and requiring each
!!    row contain the same number of values.
!!
!!    The input file is assumed to be of a small enough size that it can
!!    be copied into memory.
!!
!!##OPTIONS
!!    filename   filename to read
!!    array      array to create. May be INTEGER, REAL, or DOUBLEPRECISION
!!    ierr       zero if no error occurred.
!!    comment    ignore lines which contain this as the first non-blank
!!               character. Ignore it and subsequent characters on any line.
!!##EXAMPLES
!!
!!    Sample program, assuming the input file "inputfile" exists:
!!
!!     program demo_read_table
!!     use M_io, only : read_table
!!     implicit none
!!     doubleprecision,allocatable :: array(:,:)
!!     integer :: i, ierr
!!
!!     ! create test file
!!     open(file='inputfile',unit=10,action='write')
!!     write(10,'(a)') [character(len=80):: &
!!      ' ___.___.___                           ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '|---+---+---|                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      ' -----------                           ', &
!!      '    #-----#-----#------#               ', &
!!      '|   | 1   | 3e2 | 4    |               ', &
!!      '|   #-----#-----#------#               ', &
!!      '|   | 2.0 | -5  | +2.2 |               ', &
!!      '    #-----#-----#------#               ', &
!!      '                                       ', &
!!      '#___#___#___#                          ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '#---#---#---#                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      '#---#---#---#                          ', &
!!      '                                       ', &
!!      '1;10;45                                ', &
!!      '10, ,, ,,20    45                      ', &
!!      '  2 20  15                             ', &
!!      ' big=20.345 medium=20  small=15        ', &
!!      '                                       ', &
!!      '30 30e3   0                            ', &
!!      '  4 300.444e-1 -10                     ', &
!!      '40 30.5555d0 -10                       ', &
!!      '  4 300.444E-1 -10                     ', &
!!      '40 30.5555D0 -10                       ', &
!!      '                                       ']
!!     close(unit=10)
!!
!!     ! read file as a table
!!     call read_table('inputfile',array,ierr)
!!
!!     ! print values
!!     write(*,*)'size=       ',size(array)
!!     write(*,*)'size(dim=1)=',size(array,dim=1)
!!     write(*,*)'size=(dim=2)',size(array,dim=2)
!!     do i=1,size(array,dim=1)
!!        write(*,*)array(i,:)
!!     enddo
!!
!!     ! remove sample file
!!     open(file='inputfile',unit=10)
!!     close(unit=10,status='delete')
!!
!!     end program demo_read_table
!!
!!   Results:
!!
!!     size=                 45
!!     size(dim=1)=          15
!!     size=(dim=2)           3
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      300.0000000000000      4.000000000000000
!!       2.000000000000000     -5.000000000000000      2.200000000000000
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      10.00000000000000      45.00000000000000
!!       10.00000000000000      20.00000000000000      45.00000000000000
!!       2.000000000000000      20.00000000000000      15.00000000000000
!!       20.34499999999999      20.00000000000000      15.00000000000000
!!       30.00000000000000      30000.00000000000      0.000000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine read_table_d(filename,darray,ierr,comment)
! note the array is allocated as text, and then doubleprecision, and then placed in the output array.
! for large files it would be worth it to just determine the file size and allocate and fill the output
! array

character(len=*),intent(in)             :: FILENAME
doubleprecision,allocatable,intent(out) :: darray(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
character(len=:),allocatable :: page(:) ! array to hold file in memory
integer                      :: irows,irowsmax
integer                      :: icols
integer                      :: i
doubleprecision,allocatable  :: dline(:)
   ierr=0
   ! allocate character array and copy file into it
   call fileread(FILENAME,page)
   if(.not.allocated(page))then
      write(*,*)'*demo_read_table* failed to load file '//FILENAME
      if(allocated(darray))deallocate(darray)
      allocate(darray(0,0))
      ierr=-1
   else
      call cleanse()
      if(allocated(darray))deallocate(darray)
      if(size(page,dim=1) == 0)then
         allocate(darray(0,0))
      else
         irowsmax=size(page,dim=1)
         icols=size(s2vs(page(1)))
         allocate(darray(irowsmax,icols))
         darray=0.0d0
         irows=0
         do i=1,irowsmax
            dline=s2vs(page(i))
            irows=irows+1
            if(size(dline) /= icols)then
               write(*,gen)page(i),'does not contain',icols,'values'
               ierr=ierr+1
               darray(irows,:min(size(dline),icols))=dline(min(size(dline),icols))
            else
               darray(irows,:)=dline
            endif
         enddo
         if(irows /= irowsmax)then
            darray=darray(:irows,:icols)
         endif
         deallocate(page)  ! release memory
      endif
   endif
contains
    subroutine cleanse()
    integer :: i,j,k
    integer :: ios
    integer :: ikeep
    character(len=:),allocatable :: words(:), line
    doubleprecision :: value
    ikeep=0
    do i=1,size(page,dim=1)
       ! do this more rigourously
       ! [+-]NNNNNN[.NNNN][ED][+-]NN
       line=''
       ! get rid of all characters not in a number and
       ! then split the remaining line and keep only
       ! tokens that can be read as a number
       do j=1,len(page)
          if(present(comment))then
             if(page(i)(j:j) == comment)then
                page(i)(j:)=' '
                exit
             endif
          endif
          select case(page(i)(j:j))
          case('e','E','d','D','+','-','.','0':'9')
          case default
             page(i)(j:j)=' '
          end select
       enddo
       call split(page(i),words)
       do k=1,size(words)
          read(words(k),*,iostat=ios)value
          if(ios == 0)then
             line=line//crop(words(k))//' '
          endif
       enddo
       if(line /= '')then
          ikeep=ikeep+1
          page(ikeep)(:)=line
       endif
    enddo
    page=page(:ikeep)
    end subroutine cleanse
end subroutine read_table_d
!===================================================================================================================================
subroutine read_table_i(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
integer,allocatable,intent(out)         :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=nint(darray)
end subroutine read_table_i
!===================================================================================================================================
subroutine read_table_r(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
real,allocatable,intent(out)            :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=real(darray)
end subroutine read_table_r
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileread(3f) - [M_io:READ] read (ie. slurp) a file into a string array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine fileread(filename,pageout)
!!
!!    character(len=*),intent(in) :: filename
!!      or
!!    integer,intent(in)          :: io
!!
!!    character(len=:),allocatable,intent(out) :: pageout(:)
!!##DESCRIPTION
!!    Read an entire file into memory as a character array, one character
!!    variable per line.
!!
!!    NOTE:
!!
!!    Do not casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!    filename   filename to read into memory, or LUN (Fortran Logical
!!               Unit Number). If filename is a LUN, file must be opened
!!               with
!!
!!                  form='unformatted',access='stream'
!!
!!               as in
!!
!!                 open(unit=igetunit, file=filename,     &
!!                 & action="read", iomsg=message,        &
!!                 & form="unformatted", access="stream", &
!!                 & status='old',iostat=ios)
!!
!!               An exception is that although stdin cannot currently
!!               generally be treated as a stream file file the data
!!               will be read from stdin if the filename is '-'.
!!
!!    pageout    array of characters to hold file
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_fileread
!!    use M_io,      only : fileread
!!    implicit none
!!    character(len=4096)          :: FILENAME   ! file to read
!!    character(len=:),allocatable :: pageout(:) ! array to hold file in memory
!!    integer                      :: longest, lines, i
!!    character(len=*),parameter   :: gen='(*(g0,1x))'
!!       ! get a filename
!!       call get_command_argument(1, FILENAME)
!!       ! allocate character array and copy file into it
!!       call fileread(FILENAME,pageout)
!!       if(.not.allocated(pageout))then
!!          write(*,gen)'*demo_fileread* failed to load file',FILENAME
!!       else
!!          ! write file from last line to first line
!!          longest=len(pageout)
!!          lines=size(pageout)
!!          write(*,gen)'number of lines is',lines
!!          write(*,gen)'and length of lines is',longest
!!          write(*,'(a)')repeat('%',longest+2)
!!          write(*,'("%",a,"%")')(trim(pageout(i)),i=lines,1,-1)
!!          write(*,'(a)')repeat('%',longest+2)
!!          deallocate(pageout)  ! release memory
!!       endif
!!    end program demo_fileread
!!
!!   Given
!!
!!    first line
!!    second line
!!    third line
!!
!!   Expected output
!!
!!    >  number of lines is 3
!!    >  and length of lines is 11
!!    > %%%%%%%%%%%%%
!!    > %third line %
!!    > %second line%
!!    > %first line %
!!    > %%%%%%%%%%%%%
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine fileread(FILENAME,pageout)
implicit none
class(*),intent(in)                      :: FILENAME   ! file to read
character(len=:),allocatable,intent(out) :: pageout(:) ! page to hold file in memory
character(len=1),allocatable             :: text(:)    ! array to hold file in memory

   call filebyte(FILENAME,text) ! allocate character array and copy file into it

   if(.not.allocated(text))then
      select type(FILENAME)
       type is (character(len=*)); write(*,*)'*fileread* failed to load file '//FILENAME
       type is (integer);          write(*,'(a,i0)')'*fileread* failed to load file unit ',FILENAME
      end select
   else  ! convert array of characters to array of lines
      pageout=page(text)
      deallocate(text)     ! release memory
   endif

contains
function page(array)  result (table)

! ident_5="@(#) page(3fp) function to copy char array to page of text"

character(len=1),intent(in)  :: array(:)
character(len=:),allocatable :: table(:)
integer                      :: i
integer                      :: linelength
integer                      :: length
integer                      :: lines
integer                      :: linecount
integer                      :: position
integer                      :: sz
!!character(len=1),parameter   :: nl=new_line('A')
character(len=1),parameter   :: nl = char(10)
character(len=1),parameter   :: cr = char(13)
   lines = 0
   linelength = 0
   length = 0
   sz=size(array)
   do i = 1,sz
      if( array(i) == nl )then
         linelength = max(linelength,length)
         lines = lines + 1
         length = 0
      else
         length = length + 1
      endif
   enddo
   if( sz > 0 )then
      if( array(sz) /= nl )then
         lines = lines+1
      endif
   endif

   if(allocated(table))deallocate(table)
   allocate(character(len=linelength) :: table(lines))
   table(:) = ' '

   linecount = 1
   position = 1
   do i = 1,sz
      if( array(i) == nl )then
         linecount=linecount+1
         position=1
      elseif( array(i) == cr )then
      elseif( linelength /= 0 )then
         table(linecount)(position:position) = array(i)
         position = position+1
      endif
   enddo
end function page
end subroutine fileread
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filebyte(3f) - [M_io:READ] read (ie. slurp) a file into a character array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine filebyte(filename,text,length.lines)
!!
!!    character(len=*),intent(in) :: filename
!!     or
!!    integer,intent(in)          :: filenumber
!!
!!    character(len=1),allocatable,intent(out) :: text(:)
!!    integer,intent(out),optional :: length
!!    integer,intent(out),optional :: lines
!!##DESCRIPTION
!!    Read an entire file as a stream into memory as an array of single
!!    characters, retaining line end terminators.
!!
!!    NOTE:
!!
!!    Never casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!       filename   filename to read into memory or LUN (Fortran Logical
!!                  Unit Number) If a LUN, file must be opened with
!!
!!                     form='unformatted',access='stream'
!!
!!                  as in
!!
!!                    open(unit=igetunit, file=filename,     &
!!                    & action="read", iomsg=message,        &
!!                    & form="unformatted", access="stream", &
!!                    & status='old',iostat=ios)
!!
!!                  An exception is that although stdin cannot currently
!!                  generally be treated as a stream file file the data
!!                  will be read from stdin if the filename is '-'.
!!
!!       text       array of characters to hold file
!!       length     returns length of longest line read(Optional).
!!       lines      returns number of lines read(Optional).
!!
!!##EXAMPLES
!!
!!    Sample program, which  creates test input file "inputfile":
!!
!!     program demo_filebyte
!!     use M_io, only      : filebyte
!!     implicit none
!!     character(len=1),allocatable :: text(:) ! array to hold file in memory
!!     character(len=*),parameter :: FILENAME='inputfile' ! file to read
!!
!!     ! create test file
!!     open(file=FILENAME,unit=10,action='write')
!!     write(10,'(a)') new_line('A')//'esrever lliw'
!!     write(10,'(a)') 'margorp elpmas eht taht'
!!     write(10,'(a)') 'elif elpmas a si sihT'
!!     close(unit=10)
!!
!!     call filebyte(FILENAME,text) ! allocate character array and copy file into it
!!
!!     if(.not.allocated(text))then
!!        write(*,*)'*rever* failed to load file '//FILENAME
!!     else
!!        ! write file reversed to stdout
!!        write(*,'(*(a:))',advance='no')text(size(text):1:-1)
!!        deallocate(text)  ! release memory
!!     endif
!!
!!     end program demo_filebyte
!!
!!    Expected output:
!!
!!     >This is a sample file
!!     >that the sample program
!!     >will reverse
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine filebyte(filename,text,length,lines)
implicit none

! ident_6="@(#) M_io filebyte(3f) allocate text array and read file filename into it"

class(*),intent(in)                      :: filename    ! filename to shlep
character(len=1),allocatable,intent(out) :: text(:)     ! array to hold file
integer,intent(out),optional             :: length      ! length of longest line
integer,intent(out),optional             :: lines       ! number of lines
integer :: nchars=0             ! holds size of file
integer :: igetunit             ! use newunit=igetunit in f08
integer :: ios=0                ! used for I/O error status
integer :: length_local
integer :: lines_local
integer :: i
integer :: icount
character(len=256)  :: message
character(len=4096) :: label
character(len=:),allocatable :: line
   length_local=0
   lines_local=0
   message=''
   select type(FILENAME)
    type is (character(len=*))
       if(filename /= '-') then
          open(newunit=igetunit, file=trim(filename), action="read", iomsg=message,&
           &form="unformatted", access="stream",status='old',iostat=ios)
          label=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
    type is (integer)
       if(filename /= stdin) then
          rewind(unit=filename,iostat=ios,iomsg=message)
          igetunit=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
       write(label,'("unit ",i0)')filename
   end select
   if(ios == 0)then  ! if file was successfully opened
      inquire(unit=igetunit, size=nchars)
      if(nchars <= 0)then
         call stderr_local( '*filebyte* empty file '//trim(label) )
         return
      endif
      ! read file into text array
      if(allocated(text))deallocate(text) ! make sure text array not allocated
      allocate ( text(nchars) )           ! make enough storage to hold file
      read(igetunit,iostat=ios,iomsg=message) text      ! load input file -> text array
      if(ios /= 0)then
         call stderr_local( '*filebyte* bad read of '//trim(label)//':'//trim(message) )
      endif
   else
      call stderr_local('*filebyte* '//message)
      allocate ( text(0) )           ! make enough storage to hold file
   endif

   close(iostat=ios,unit=igetunit)            ! close if opened successfully or not

   if(present(lines).or.present(length))then  ! get length of longest line and number of lines
      icount=0
      do i=1,nchars
         if(text(i) == NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
            icount=0
         endif
         icount=icount+1
      enddo
      if(nchars /= 0)then
         if(text(nchars) /= NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
         endif
      endif
      if(present(lines))lines=lines_local
      if(present(length))length=length_local
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine copystdin()
integer :: iostat
   open(newunit=igetunit, iomsg=message,&
   &form="unformatted", access="stream",status='scratch',iostat=iostat)
   open(unit=stdin,pad='yes')
   INFINITE: do while (getline(line,iostat=iostat)==0)
      write(igetunit)line//new_line('a')
   enddo INFINITE
   rewind(igetunit,iostat=iostat,iomsg=message)
end subroutine copystdin
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine stderr_local(message)
character(len=*) :: message
   write(stderr,'(a)')trim(message)    ! write message to standard error
end subroutine stderr_local
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine filebyte
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    number_of_lines(3f) - [M_io:QUERY] read an open sequential file to get
!!                          number of lines
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function number_of_lines(lun) result(nlines)
!!
!!    integer,intent(in)          :: lun
!!    integer                     :: nlines
!!
!!##DESCRIPTION
!!    Rewind an open sequential file and read through it to count the number
!!    of lines. The file is rewound on exit. If it is not readable -1 is returned.
!!
!!##OPTIONS
!!    lun       logical unit number of open sequential file to count lines in.
!!
!!##RETURNS
!!    nlines    number of lines read. If it is not readable -1 is returned.
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_number_of_lines
!!    use M_io,      only : number_of_lines, fileopen
!!    implicit none
!!    integer :: ios
!!    integer :: lun
!!       lun=fileopen('test.txt','r',ios)
!!       if(ios == 0)then
!!          write(*,*) number_of_lines(lun)
!!       else
!!          write(*,*)'ERROR: IOS=',ios
!!       endif
!!    end program demo_number_of_lines
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function number_of_lines(lun) result(nlines)
!@(#) determine number or lines in file given a LUN to the open file
integer,intent(in) :: lun

integer            :: ios
integer            :: nlines
character(len=256) :: iomsg

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)
   nlines = 0

   do
   read(lun, '(A)', end=99, iostat=ios,iomsg=iomsg)
      if (ios /= 0) then
         write(stderr,gen)'*number_of_lines*:',trim(iomsg)
         nlines=-1
         exit
      endif
      nlines = nlines + 1
   enddo

99 continue

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)

end function number_of_lines
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:QUERY] Find a FUN/LUN (Fortran-unit-number) that is not in use
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       integer function notopen(start,end,err)
!!       integer,optional,intent(in)  :: start
!!       integer,optional,intent(in)  :: end
!!       integer,optional,intent(out) :: err
!!##DESCRIPTION
!!    A free FORTRAN unit number is needed to OPEN a file. NOTOPEN() returns
!!    a FORTRAN unit number from START to END not currently associated with
!!    an I/O unit. START and END are expected to be positive integers where
!!    END  >=  START.
!!
!!    If NOTOPEN() returns -1, then no free FORTRAN unit could be found in
!!    the specified range.
!!
!!    Otherwise, NOTOPEN() returns an integer representing a free FORTRAN
!!    logical unit number. Note that NOTOPEN() assumes the following unit
!!    numbers defined by the Fortran 2008 ISO_FORTRAN_ENV module
!!
!!       ERROR_UNIT,INPUT_UNIT,OUTPUT_UNIT
!!
!!    are special, and will never return those values.
!!
!!##OPTIONS
!!       start  optional logical unit number to start scan at, defaults to 10.
!!       end    optional logical unit number to stop scan at, defaults to 99.
!!       err    optional error flag returned. ERR will be non-zero if
!!              no errors. If not present and an error occurs the program
!!              will stop instead of returning.
!!
!!##NOTES
!!
!!    Why are the default START and END limits from 10 to 99? the Fortran 77
!!    standard did not specify a specific limit on the upper range limit, but
!!    the LUN range of 1 to 99 was almost always supported in conventional
!!    programming environments. Additionally, units in the range 0-10 have
!!    often been the units used for pre-assigned files. Occasionally 100,
!!    101 and 102 are reserved (for files such as standard input, standard
!!    output, standard error, ...). Therefore, the defaults for START and
!!    END were selected to be 10 and 99. And most programs do not need
!!    more than 90 files simultaneously open, so the defaults work well in
!!    practice with many versions/vintages of Fortran.
!!
!!    Note that an environment may impose a limit on the number of
!!    simultaneously open files (which some compilers work around).
!!
!!    Beginning with f2008, you can probably use OPEN(NEWUNIT=...) instead
!!    of an open unit locator.
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!     program demo_notopen ! test the NOTOPEN(3f) function
!!     use m_io, only: notopen
!!     implicit none
!!     integer :: ii, ierr, igot
!!
!!     write(*,*)'check for preassigned files from unit 0 to unit 1000'
!!     write(*,*)'(5 and 6 always return -1)'
!!
!!     do ii=0,1000
!!        if(notopen(ii,ii,ierr)  /=  ii)then
!!           write(*,*)'INUSE:',ii, notopen(ii,ii,ierr)
!!        endif
!!     enddo
!!
!!     ! open all files from UNIT=10 to UNIT=30 so have used units
!!     do ii=10,30,1
!!       open(unit=ii,status="scratch")
!!     enddo
!!     ! close UNIT=25
!!     close(25)
!!
!!     ! find open file in range 10 to 30
!!     write(*,*)'Should get 25 for this ..',notopen(10,30,ierr)
!!
!!     close(18)
!!     do ii=10,32
!!       igot=notopen(ii,ii,ierr)
!!       write(*,*)'For unit ',ii,' I got ',igot,' with ERR=',ierr
!!     enddo
!!
!!     end program demo_notopen
!!
!!    Expected output(can vary with each programming environment):
!!
!!       check for preassigned files from unit 0 to unit 1000
!!       (5 and 6 always return -1)
!!       INUSE:    0    -1
!!       INUSE:    5    -1
!!       INUSE:    6    -1
!!       Should get 25 for this .. 25
!!       For  unit  10  I  got  -1  with  ERR=  -1
!!       For  unit  11  I  got  -1  with  ERR=  -1
!!       For  unit  12  I  got  -1  with  ERR=  -1
!!       For  unit  13  I  got  -1  with  ERR=  -1
!!       For  unit  14  I  got  -1  with  ERR=  -1
!!       For  unit  15  I  got  -1  with  ERR=  -1
!!       For  unit  16  I  got  -1  with  ERR=  -1
!!       For  unit  17  I  got  -1  with  ERR=  -1
!!       For  unit  18  I  got  18  with  ERR=   0
!!       For  unit  19  I  got  -1  with  ERR=  -1
!!       For  unit  20  I  got  -1  with  ERR=  -1
!!       For  unit  21  I  got  -1  with  ERR=  -1
!!       For  unit  22  I  got  -1  with  ERR=  -1
!!       For  unit  23  I  got  -1  with  ERR=  -1
!!       For  unit  24  I  got  -1  with  ERR=  -1
!!       For  unit  25  I  got  25  with  ERR=   0
!!       For  unit  26  I  got  -1  with  ERR=  -1
!!       For  unit  27  I  got  -1  with  ERR=  -1
!!       For  unit  28  I  got  -1  with  ERR=  -1
!!       For  unit  29  I  got  -1  with  ERR=  -1
!!       For  unit  30  I  got  -1  with  ERR=  -1
!!       For  unit  31  I  got  31  with  ERR=   0
!!       For  unit  32  I  got  32  with  ERR=   0
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
integer function notopen(start,end,err)
implicit none

! ident_7="@(#) M_io notopen(3f) find free FORTRAN unit number to OPEN() a file"

integer,optional,intent(in)    :: start                           ! unit number to start looking at
integer,optional,intent(in)    :: end                             ! last unit number to look at
integer,optional,intent(out)   :: err                             ! error flag returned
integer                        :: istart
integer                        :: iend
integer                        :: ierr

integer         :: i10                                            ! counter from start to end
integer         :: ios                                            ! iostatus from INQUIRE
logical         :: lopen                                          ! returned from INQUIRE
logical         :: lexist                                         ! returned from INQUIRE
!-----------------------------------------------------------------------------------------------------------------------------------
   !! IEND=MERGE( END, 99, PRESENT(END)) do not use merge, as TSOURCE must be evaluated before the call
   if(present(start))then; istart=start; else; istart=10; endif
   if(present(end  ))then; iend  =end  ; else; iend  =99; endif
   ierr=0
   notopen=(-1)                                                   ! result if no units are available
!-----------------------------------------------------------------------------------------------------------------------------------
   do i10=istart,iend                                             ! check units over selected range
      select case (i10)                                           ! always skip these predefined units
      case(stderr,stdin,stdout)
          cycle
      end select
      inquire( unit=i10, opened=lopen, exist=lexist, iostat=ios )
      if( ios == 0 )then                                          ! no error on inquire
         if(.not. lopen .and. lexist)then                         ! if unit number not in use, return it
            notopen = i10
            exit                                                  ! only need to find one, so return
         endif
      else
         write(stderr,*)'*notopen*:error on unit ',i10,'=',ios
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   if (notopen  <  0 )then                                       ! no valid unit was found in given range
      ierr=-1
   else                                                           ! valid value being returned
      ierr=0
   endif
   if(present(err))then                                           ! if error flag is present set it
      err=ierr
   elseif(ierr /= 0)then                                          ! if error occurred and error flag not present stop program
      stop 1
   endif
end function notopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dirname(3f) - [M_io:PATHNAMES] strip last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dirname(FILENAME) result (DIRECTORY)
!!
!!      character(len=*),intent(in)  :: FILENAME
!!      character(len=:),allocatable :: DIRECTORY
!!
!!##DESCRIPTION
!!    Output FILENAME with its last non-slash component and trailing slashes
!!    removed. If FILENAME contains no slash or backslash character, output
!!    '.' (meaning the current directory).
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that FILENAME does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to remove the last leaf from
!!
!!##RETURNS
!!      DIRECTORY  directory name for pathname
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dirname
!!    use M_io, only : dirname
!!    implicit none
!!    character(len=:),allocatable :: filename
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1 , command_argument_count()
!!       call get_command_argument (i , length=filename_length)
!!       if(allocated(filename))deallocate(filename)
!!       allocate(character(len=filename_length) :: filename)
!!       call get_command_argument (i , value=filename)
!!       write(*,'(a)')dirname(filename)
!!    enddo
!!    end program demo_dirname
!!
!!   Sample program executions:
!!
!!      demo_dirname /usr/bin/          -> "/usr"
!!      demo_dirname dir1/str dir2/str  -> "dir1" followed by "dir2"
!!      demo_dirname stdio.h            -> "."
!!
!!##SEE ALSO
!!    dirname(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        dirname(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function dirname(filename) result (directory)
implicit none

! ident_8="@(#) M_io dirname(3f) strip last component from filename"

character(len=*),intent(in)      :: filename
character(len=:),allocatable     :: directory
integer                          :: iend
character(len=1)                 :: sep
!-----------------------------------------------------------------------------------------------------------------------------------
   sep=separator()
   directory=trim(filename)
   call removetail()                         ! trim trailing slashes even if duplicates
   iend=index(directory,sep,back=.true.)     ! find last slash if any
   if(iend == 0)then                         ! filename is a leaf
      directory='.'                          ! special case
   else
      directory=directory(:iend-1)           ! remove leaf
      call removetail()                      ! trim off trailing slashes in case duplicates
   endif
   directory=trim(directory)                 ! clean up return value
contains
   subroutine removetail()              ! replace trailing slashes with spaces even if duplicates
   integer :: right
   do right=len(directory),1,-1
      if(directory(right:right) == sep.or.directory(right:right) == ' ')then
         directory(right:right)=' '
      else
         exit
      endif
   enddo
   end subroutine removetail

end function dirname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    basename(3f) - [M_io:PATHNAMES] return last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function basename(FILENAME,SUFFIX) result (LEAF)
!!
!!      character(len=:),allocatable :: FILENAME
!!      character(len=*),intent(in),optional :: SUFFIX
!!      character(len=*),intent(in) :: LEAF
!!
!!##DESCRIPTION
!!    Output LEAF of filename with directory paths removed.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to extract the last leaf from
!!      SUFFIX     suffix to remove. If not present
!!                 the rightmost ".string" string is removed.
!!                 If present the LEAF is returned with any matching
!!                 suffix removed.
!!
!!##RETURNS
!!      LEAF  returned leaf name
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_basename
!!    use M_io, only : basename
!!    implicit none
!!    character(len=:),allocatable :: fn
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1, command_argument_count()
!!       call get_command_argument (i, length=filename_length)
!!       if(allocated(fn))deallocate(fn)
!!       allocate(character(len=filename_length) :: fn)
!!       call get_command_argument (i, value=fn)
!!       ! leaf with any suffix removed
!!       ! leaf with suffix retained
!!       ! with suffix unless it is ".f90"
!!       write(*,'(*(a,1x))') basename(fn), basename(fn,''), basename(fn,'.f90')
!!    enddo
!!    end program demo_basename
!!
!!   Sample program executions:
!!
!!     $demo_basename /usr/bin/
!!     bin bin bin
!!     $demo_basename dir1/fred.x dir2/.y
!!     fred fred.x fred.x
!!     .y .y .y
!!     $demo_basename stdio.h
!!     stdio stdio.h stdio.h
!!     $demo_basename /name.f90
!!     name name.f90 name
!!
!!##SEE ALSO
!!    basename(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        basename(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function basename(filename,suffix) result (leaf)
implicit none

! ident_9="@(#) M_io basename(3f) strip last component from filename"

character(len=*),intent(in)          :: filename
character(len=*),intent(in),optional :: suffix
character(len=:),allocatable         :: leaf
integer                              :: iend
integer                              :: i
integer,parameter                    :: maxlen=4096
character(len=maxlen)                :: name
character(len=maxlen)                :: bname
character(len=maxlen)                :: extension
character(len=1)                 :: sep
   sep=separator()
   ! trim trailing separators
   iend=len_trim(filename)
   do i=iend,1,-1
      if(filename(i:i) /= sep)exit
      iend=iend-1
   enddo
   !
   call splitpath(filename(:iend),name=name,basename=bname,ext=extension)
   if(present(suffix))then
      leaf=merge(bname,name,suffix == extension)
   else
      leaf=bname
   endif
   if(leaf == '')leaf=name
   leaf=trim(leaf)
end function basename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileopen(3f) - [M_io] A simple open of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function fileopen(filename,mode,ios) result(lun)
!!
!!    character(len=*),intent(in)           :: filename
!!    character(len=*),intent(in),optional  :: mode
!!    integer,intent(out),optional          :: ios
!!    integer                               :: lun
!!
!!##DESCRIPTION
!!    fileopen(3f) is a convenience routine that allows you to open a file
!!    for sequential reading and writing as a text file in a form commonly
!!    found in C and interpreted languages such as shells. See the OPEN(3f)
!!    statement for more demanding I/O specifications (asynchronous, direct,
!!    unformatted, ... ). The documentation for the flexible and powerful
!!    OPEN(3f) statement can be a bit overwhelming; this routine cuts it
!!    down to the just the simple basic functions typically available in
!!    a scripting language such as bash, tcsh, sh, ...
!!
!!    Specify the file's name as the string FILENAME with a shell-like prefix
!!    specifying the access mode, or alternatively specify a plain FILENAME
!!    and the kind of access you need to the file with the string MODE.
!!
!!    Three fundamental kinds of access are available: read, write,
!!    and append.
!!
!!##OPTION
!!   FILENAME  The filename to open. If the beginning of the filename is
!!
!!             <   open for read. File must exist
!!             >   open for write. Will overwrite current file
!!             >>  open for append. Will append to current file
!!
!!             If no prefix exists to specify a file access mode, it
!!             will depend on the values of the MODE argument (meaning
!!             the default will be "readwrite").
!!
!!             A blank filename causes a unit number for a scratch file
!!             to be returned.
!!
!!   MODE     [rwa][tb][+]
!!            An alternate way to specify the file access mode is to specify
!!            a MODE value. It should begin with one of the three characters
!!            "r", "w", or "a". It defaults to 'rw'. It is case-insensitive.
!!
!!
!!        READING PREFIX
!!        r,<   Open the file for reading; the operation will fail if the
!!              file does not exist, or if the host system does not permit
!!              you to read it.
!!
!!        WRITING PREFIXES
!!        w,>   Open a file for writing from the beginning of the file.
!!              If the file whose name you specified already existed,
!!              the call fails.
!!
!!        o     Open the file for writing from the beginning of the file:
!!              effectively, this always creates a new file. If the file
!!              whose name you specified already existed, its old contents
!!              are discarded.
!!
!!        a,<<  Initially open the file for appending data (ie. writing
!!              at the end of file).
!!
!!        SUFFIX
!!
!!        b   Append a "b" to any of the three modes above to specify that
!!            you are opening the file as a "binary file" (the default is
!!            to open the file as a sequential formatted text file. This
!!            switch changes to to an unformatted stream).
!!
!!                   open( ... access='stream';form='unformatted')
!!
!!        t   Append a "t" to any of the three modes (rwa) to specify a
!!            formatted stream
!!
!!                   open( ... access='stream';form='formatted')
!!
!!        +   Finally, you might need to both read and write from the same
!!            file. You can specify "rw" or you can append a `+' to any of
!!            the three primary modes ("rwa") to permit "readwrite" access
!!
!!        v   Additionally, "v" selects verbose mode, which prints the
!!            OPEN(3f) options explicitly selected
!!
!!        NOTES
!!
!!            If you want to append both `b' and `+', you can do it in
!!            either order: for example, "rb+" means the same thing as
!!            "r+b" when used as a mode string.)
!!
!!    IOS    The error code returned by the OPEN(3f) statement ultimately
!!           executed by this function. If not present the program stops on
!!           an error.
!!##RETURNS
!!        FILEOPEN(3f) returns a Fortran unit number which you can use
!!        for other file operations, unless the file you requested could
!!        not be opened; in that situation, the result is -1 (a reserved
!!        value that cannot be returned as a NEWUNIT value on an OPEN(3f))
!!        and IOS will be non-zero.
!!
!!##EXAMPLE
!!
!!  Common usage
!!
!!   READ
!!     R=fileopen('<in.txt')
!!     or
!!     R=fileopen('in.txt','r')
!!
!!   WRITE
!!     W=fileopen('>out.txt')
!!     or
!!     W=fileopen('out.txt','W')
!!
!!   READWRITE
!!     RW=fileopen('inout.txt')
!!
!!   APPEND
!!     A=fileopen('>>inout.txt')
!!     or
!!     A=fileopen('inout.txt','a')
!!
!!   Sample program
!!
!!       program demo_fileopen
!!       use M_io, only : fileopen, fileclose, print_inquire
!!       implicit none
!!       integer :: lun
!!       lun=fileopen('fred.txt')
!!       call print_inquire(lun)
!!       end program demo_fileopen
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileopen(filename,mode,ios) result(lun)
character(len=*),intent(in)           :: filename
character(len=*),intent(in),optional  :: mode
integer,intent(out),optional          :: ios
integer                               :: lun, i, ios_local,ifound,gts
character(len=:),allocatable          :: local_mode
character(len=256)                    :: message
character(len=:),allocatable          :: action, position, access, form, status, file
logical                               :: verbose
   local_mode=lower(merge_str(mode,'',present(mode)))
   file=trim(adjustl(filename))//'   '
   ifound=index(file,'>>')
   if(ifound /= 0)then
      file(ifound:ifound+1)='  '
      local_mode=local_mode//'a'
   endif
   ifound=index(file,'>')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'w'
   endif
   ifound=index(file,'<')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'r'
   endif
   file=adjustl(file)
   local_mode=merge_str('rw',local_mode,local_mode == '')
   file=trim(file)

   gts=0
   action=''
   position='asis'
   form='formatted'
   access='sequential'
   status='unknown'
   verbose=.false.
   do i=1,len(local_mode) ! create order independence
      select case(local_mode(i:i))
       case('r','<'); if(action /= 'readwrite'.and.action /= 'read')action='read'//action
                      if(status == 'unknown')status='old'
       case('w','>'); if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')status='new'
                      if(gts > 0)then
                         position='append'
                      endif
                      gts=gts+1
       case('o');     if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')then
                         status='replace'
                      endif
       case('a');     position='append'
                      if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status == 'old')status='unknown'
       case('b');     access='stream';form='unformatted'
       case('t');     access='stream';form='formatted'
       case('+');     action='readwrite'
                      status='unknown'
       case('v');     verbose=.true.
       case default
         write(*,'(*(g0))',advance='no')'*fileopen* unknown mode key ',local_mode(i:i)
         write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & ' INPUTNAME=',trim(file), &
         & ' MODE=',trim(local_mode)
      end select
   enddo
   if(action == '')action='readwrite'

   if(verbose)then
      write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & 'INPUTNAME=',trim(file), &
         & 'MODE=',trim(local_mode)
      write(*,'(a)',advance='no')'==>'
      write(*,'(*(:,"[",g0,"=",g0,"]"))') &
         & 'FILE=',trim(file), &
         & 'FORM=',trim(form), &
         & 'ACCESS=',trim(access), &
         & 'ACTION=',trim(action), &
         & 'POSITION=',trim(position), &
         & 'STATUS=',trim(status)
   endif
   if(file /= ' ')then
    open(file=file,newunit=lun,form=form,access=access,action=action,position=position,status=status,iostat=ios_local,iomsg=message)
   else
    open(newunit=lun,form=form,access=access,action=action,status='scratch',iostat=ios_local,iomsg=message)
   endif
   !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
   !  ACTION    =  READ|WRITE  |  READWRITE
   !  FORM      =  FORMATTED   |  UNFORMATTED
   !  POSITION  =  ASIS        |  REWIND       |  APPEND
   !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
   if(ios_local /= 0)then
      call journal('sc','*fileopen* ',message)
      lun=-1
   endif
   if(present(ios))then        ! caller has asked for status so let caller process any error
      ios=ios_local
   elseif(ios_local /= 0)then  ! caller did not ask for status so stop program on error
      stop 1
   endif
end function fileopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileclose(3f) - [M_io] A simple close of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function fileclose(lun) result(ios)
!!
!!      integer,intent(in)       :: lun
!!      integer                  :: ios
!!##DESCRIPTION
!!   A convenience command for closing a file that leaves an
!!   error message in the current journal file if active.
!!##OPTION
!!   LUN unit number to close
!!##RETURNS
!!   IOS status value from CLOSE
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_fileclose
!!     use M_io, only : fileclose, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios, ierr
!!        lun=fileopen('<input.txt',ios=ierr)
!!        if(ierr /= 0)then
!!           write(*,*)'<ERROR> opening file'
!!        endif
!!        ios=fileclose(lun)
!!     end program demo_fileclose
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileclose(lun) result(ios)
integer,intent(in)       :: lun
integer                  :: ios
character(len=256)       :: message
   close(unit=lun,iostat=ios,iomsg=message)
   if(ios /= 0)then
      call journal('sc','*fileclose* ',message)
      stop
   endif
end function fileclose
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filewrite(3f) - [M_io:WRITE] A simple write of a CHARACTER array to a file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function filewrite(filename,data,status,position) result(ierr)
!!
!!      character(len=*),intent(in) :: filename
!!      character(len=*),intent(in) :: data(:)
!!      character(len=*),intent(in),optional :: status
!!      character(len=*),intent(in),optional :: position
!!      integer                     :: ierr
!!##DESCRIPTION
!!   A convenience procedure for writing a CHARACTER array as
!!   a new file.
!!##OPTION
!!   FILENAME   file to create or write. If the name ends
!!              in ">" the default for STATUS changes to
!!              "REPLACE". If it ends in ">>" STATUS changes to
!!              "UNKNOWN" and the default POSITION changes to "APPEND".
!!   DATA       CHARACTER array to write to file
!!   STATUS     STATUS to use on OPEN(7f). Defaults to "NEW".
!!              Allowed values are  NEW|REPLACE|OLD|SCRATCH|UNKNOWN
!!   POSITION   POSITION to use on OPEN(7f). Defaults to "REWIND".
!!              Allowed values are  ASIS|REWIND|APPEND
!!##RETURNS
!!   IERR       status value. Zero indicates no error occurred
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filewrite
!!     use M_io, only : filewrite
!!     implicit none
!!     integer :: ierr
!!     character(len=:),allocatable :: data(:)
!!        data=[ character(len=80) :: &
!!             &'This is the text to write  ', &
!!             &'into the file. It will be  ', &
!!             &'trimmed on the right side. ', &
!!             &' ', &
!!             &'     That is all Folks!    ', &
!!             &'']
!!        ierr=filewrite('_scratch.txt',data)
!!     end program demo_filewrite
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filewrite(filename,filedata,status,position) result (ierr)
! write filedata to file filename
character(len=*),intent(in)           :: filename
character(len=*),intent(in)           :: filedata(:)
character(len=*),intent(in),optional  :: status
character(len=*),intent(in),optional  :: position
integer                               :: ierr
integer                               :: lun, i, ios, ilen
character(len=256)                    :: message
character(len=:),allocatable          :: file
character(len=:),allocatable          :: local_status
character(len=:),allocatable          :: local_position
character(len=:),allocatable          :: default_status
character(len=:),allocatable          :: default_position
   ierr=0
   default_status='NEW'
   default_position='REWIND'
   file=trim(adjustl(filename))//'  '
   ilen=max(len_trim(file),2)
   if(file(ilen-1:ilen) == '>>')then
      ilen=ilen-2
      file=file(:ilen)
      default_status='UNKNOWN'
      default_position='APPEND'
   elseif(file(ilen:ilen) == '>')then
      ilen=ilen-1
      file=file(:ilen)
      default_status='REPLACE'
   else
      file=trim(file)
   endif
   if(present(position))then; local_position=position; else; local_position=default_position; endif
   if(present(status))then;   local_status=status;     else; local_status=default_status;     endif
   if(file /= ' ')then
      open(file=file, &
      & newunit=lun, &
      & form='formatted', &         !  FORM      =  FORMATTED   |  UNFORMATTED
      & access='sequential', &      !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
      & action='write', &           !  ACTION    =  READ|WRITE  |  READWRITE
      & position=local_position, &  !  POSITION  =  ASIS        |  REWIND       |  APPEND
      & status=local_status, &      !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
      & iostat=ios, &
      & iomsg=message)
   else
      lun=stdout
      ios=0
   endif
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
      ierr=ios
   else
      do i=1,size(filedata)                                                    ! write file
         write(lun,'(a)',iostat=ios,iomsg=message)trim(filedata(i))
         if(ios /= 0)then
            write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
            ierr=ios
            exit
         endif
      enddo
   endif
   close(unit=lun,iostat=ios,iomsg=message)                                 ! close file
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',trim(message)
      ierr=ios
   endif
end function filewrite
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filedelete(3f) - [M_io] A simple close of an open file with STATUS='DELETE'
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function filedelete(lun) result(ios)
!!
!!     integer,intent(in)          :: lun
!!       or
!!     character(len=*),intent(in) :: filename
!!     integer                     :: ios
!!
!!##DESCRIPTION
!!   A convenience command for deleting an OPEN(3f) file that leaves an
!!   error message in the current journal file if active
!!##OPTION
!!   LUN  unit number of open file to delete or filename.
!!##RETURNS
!!   IOS  status returned by CLOSE().
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filedelete
!!     use M_io, only : filedelete, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios
!!        lun=fileopen('<input.txt')
!!        ios=filedelete(lun)
!!     end program demo_filedelete
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filedelete_lun(lun) result(iostat)
integer,intent(in)    :: lun
integer               :: iostat
character(len=256)    :: message
   close(unit=lun,iostat=iostat,status='delete',iomsg=message)
   if(iostat /= 0)then
      call journal('sc','*filedelete* ',message)
   endif
end function filedelete_lun
function filedelete_filename(filename) result(iostat)
character(len=*),intent(in) :: filename
integer                     :: number
integer                     :: iostat
character(len=256)          :: message
logical                     :: opened
logical                     :: exist
   inquire(file=filename,opened=opened,iostat=iostat,exist=exist,number=number)
   if(exist)then
      if(.not.opened)then
         open(newunit=number,iostat=iostat,file=filename)
      endif
      close(unit=number,iostat=iostat,status='delete',iomsg=message)
      if(iostat /= 0)then
         call journal('sc','*filedelete* ',message)
      endif
   endif
end function filedelete_filename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    joinpath(3f) - [M_io:PATHNAMES] join parts of a pathname together
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9)  result(path)
!!
!!     character(len=*), intent(in)           :: a1, a2
!!     character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
!!     character(len=:), allocatable          :: path
!!##DESCRIPTION
!!##OPTIONS
!!     a1,a2  the first two pathname sections to join. Required
!!     a3-a9  additional optional sections to join
!!##RETURNS
!!     pathname sections joined together with trailing spaces removed from
!!     the ends of sections and a separator (as returned by separator(3f)
!!     ) placed between them, and duplicate adjacent separators removed
!!     accept for one beginning the joined pathname.
!!##EXAMPLE
!!
!!   Sample program
!!
!!      program demo_joinpath
!!      use M_io, only : joinpath
!!      implicit none
!!         write(*,*)joinpath(&
!!         &'/share/user','/man/','man3','joinpath.3m_io'//'.gz' &
!!         &)
!!      end program demo_joinpath
!!
!! Results:
!!
!!      >  /share/user/man/man3/joinpath.3m_io.gz
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1 /= '')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   if (present(a6)) path = path // filesep // trim(a6)
   if (present(a7)) path = path // filesep // trim(a7)
   if (present(a8)) path = path // filesep // trim(a8)
   if (present(a9)) path = path // filesep // trim(a9)
   path=adjustl(path//'  ')
   call substitute(path,filesep//filesep,filesep,start=2) ! some systems allow names starting with '//' or '\\'
   path=trim(path)
end function joinpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     splitpath(3f) - [M_io:PATHNAMES] split a Unix pathname into components
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine splitpath(path,dir,name,basename,ext)
!!
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),intent(in)  :: path
!!    character(len=maxlen),intent(out),optional :: dir
!!    character(len=maxlen),intent(out),optional :: name
!!    character(len=maxlen),intent(out),optional :: basename
!!    character(len=maxlen),intent(out),optional :: ext
!!
!!##DESCRIPTION
!!    splitpath(3f) splits given pathname assuming a forward slash separates
!!    filename components and that the right-most period in the last leaf
!!    of the pathname is considered the beginning of an extension. If
!!    an extension is found it is left present in NAME but removed from
!!    BASENAME.
!!
!!    This routine does not check the system for the existence or type of
!!    the filename components; it merely parses a string.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!    path      Path to be broken into components. It is assumed
!!
!!              o Forward slashes (/) separate pathname components.
!!              o the name '.' means "current directory"
!!              o the name '..' means "up one directory"
!!              o a pathname ending in a slash is a directory name
!!              o a slash starting the pathname represents the root
!!                directory.
!!              o trailing spaces are insignificant.
!!
!!    Using these rules helps to reduce incorrect parsing, but the
!!    routine is only intended for simple parsing of names of the form
!!    "[dir/]name[.extension].
!!
!!##RESULTS
!!    dir       Path of directories, including the trailing slash.
!!    name      Name of file leaf or, if no file is specified in path,
!!              name of the lowest directory.
!!    basename  NAME with any extension removed
!!    ext       File name extension, if any, including the leading period (.).
!!
!!    The path parameter can be a complete or partial file specification. The
!!    special name "." is assumed to mean the current directory, and the
!!    special name ".." is assumed to mean one directory above the current
!!    directory.
!!
!!##EXAMPLE
!!
!!   program demo_splitpath
!!
!!    use m_io, only : splitpath
!!    implicit none
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),parameter   :: file(*)=[&
!!       & 'dirs/name.ext  ', &
!!       & 'xx/IO/zz/NN.FF ', &
!!       & 'xx/IO/zz/NN    ', &
!!       & '/xx/IO/zz/NN   ', &
!!       & '/xx/IO/zz/     ', &
!!       & '/xx/IO/zz.A/   ', &
!!       & '/xx/IO/zz/.    ', &
!!       & '               ', &
!!       & './             ', &
!!       & '/              ', &
!!       & '/..            ', &
!!       & './..           ', &
!!       & 'name.          ', &
!!       & '.name          ', &
!!       & '.name.         ', &
!!       & '.              ', &
!!       & '..             ', &
!!       & '...            ']
!!
!!    character(len=maxlen)  :: dir
!!    character(len=maxlen)  :: name
!!    character(len=maxlen)  :: basename
!!    character(len=maxlen)  :: ext
!!    integer                :: i
!!    integer                :: longest
!!    longest=maxval(len_trim(file)) ! find longest filename
!!
!!    do i=1,size(file)
!!       call splitpath(file(i), dir, name, basename, ext)
!!       write(*,'(*("| ",a:))')  &
!!       & file(i)(:longest),     &
!!       & dir(:longest),         &
!!       & name(:longest),        &
!!       & basename(:longest),    &
!!       & ext(:longest)
!!    enddo
!!   end program demo_splitpath
!!
!!   Output
!!
!!    | dirs/name.ext | dirs          | name.ext      | name          | .ext
!!    | xx/IO/zz/NN.FF| xx/IO/zz      | NN.FF         | NN            | .FF
!!    | xx/IO/zz/NN   | xx/IO/zz      | NN            | NN            |
!!    | /xx/IO/zz/NN  | /xx/IO/zz     | NN            | NN            |
!!    | /xx/IO/zz/    | /xx/IO/zz     |               |               |
!!    | /xx/IO/zz.A/  | /xx/IO/zz.A   |               |               |
!!    | /xx/IO/zz/.   | /xx/IO/zz/.   |               |               |
!!    |               | .             |               |               |
!!    | ./            | .             |               |               |
!!    | /             | /             |               |               |
!!    | /..           | /             |               |               |
!!    | ./..          | ./..          |               |               |
!!    | name.         |               | name.         | name          | .
!!    | .name         |               | .name         | .name         |
!!    | .name.        |               | .name.        | .name         | .
!!    | .             | .             |               |               |
!!    | ..            |               |               |               |
!!    | ...           |               | ...           | ..            | .
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine splitpath(path,dir,name,basename,ext)
implicit none

! ident_10="@(#) M_io splitpath(3f) split Unix pathname into components (dir name basename extension)"

!===================================================================================================================================
character(len=*),intent(in)           :: path
character(len=*),intent(out),optional :: dir
character(len=*),intent(out),optional :: name
character(len=*),intent(out),optional :: basename
character(len=*),intent(out),optional :: ext
integer,parameter                     :: maxlen=4096
character(len=maxlen)                 :: dir_local
character(len=maxlen)                 :: name_local
character(len=maxlen)                 :: basename_local
character(len=maxlen)                 :: ext_local
character(len=len(path)+1)            :: path_local
integer                               :: where
integer                               :: i
integer                               :: iend
character(len=1)                 :: sep
   sep=separator()
!===================================================================================================================================
   path_local=path                           ! initialize variables
   dir_local=''
   name_local=''
   basename_local=''
   ext_local=''
   iend=len_trim(path_local)
   LOCAL : block
!===================================================================================================================================
   if(iend == 0)then                         ! blank input path
      dir_local='.'
      exit LOCAL
   endif
!===================================================================================================================================
   if(path_local(iend:iend) == sep)then      ! assume entire name is a directory if it ends in a slash
      if(iend > 1)then
         dir_local=path_local(:iend-1)
      else                                   ! if just a slash it means root directory so leave it as slash
         dir_local=path_local
      endif
      exit LOCAL
   endif
!===================================================================================================================================
   TRIMSLASHES: do i=iend,1,-1               ! trim off trailing slashes even if duplicates
      if(path_local(i:i) == sep)then
         path_local(i:i)=' '
         iend=i-1
      else
         iend=i
         exit TRIMSLASHES
      endif
   enddo TRIMSLASHES

   if(iend == 0)then                         ! path composed entirely of slashes.
      dir_local=sep
      exit LOCAL
   endif
!===================================================================================================================================
   where=INDEX(path_local,sep,BACK=.true.)   ! find any right-most slash in remaining non-null name_local after trimming trailing slashes
   if(where <= 0)then                        ! no slash in path so everything left is name_local
      name_local=path_local(:iend)                 ! this is name_local unless '.' or '..'
   else                                      ! last slash found
      dir_local=path_local(:where-1)               ! split into directory
      name_local=path_local(where+1:iend)          ! this is name_local unless '.' or '..'
   endif
!===================================================================================================================================
   select case (name_local(1:3))                   ! special cases where name_local is a relative directory name_local '.' or '..'
   case('.  ')
      dir_local=path_local
      name_local=''
   case('.. ')
      if(dir_local == '')then
         if(path_local(1:1) == sep)then
            dir_local=sep
         endif
      else
         dir_local=path_local
      endif
      name_local=''
   case default
   end select
!===================================================================================================================================
   if(name_local == '.')then
      name_local=''
   endif
!===================================================================================================================================
   iend=len_trim(name_local)
   where=INDEX(name_local,'.',BACK=.true.)         ! find any extension
   if(where > 0.and.where /= 1)then         ! only consider a non-blank extension name_local
      ext_local=name_local(where:)
      basename_local=name_local(:where-1)
   else
      basename_local=name_local
   endif
!===================================================================================================================================
   endblock LOCAL
   if(present(dir))dir=dir_local
   if(present(name))name=name_local
   if(present(basename))basename=basename_local
   if(present(ext))ext=ext_local
end subroutine splitpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getline(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                  string up to line length limit
!!    (LICENSE:PD)
!!
!!##SYNTAX
!!   function getline(line,lun,iostat) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,intent(out),optional             :: iostat
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!    Read a line of any length up to programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function
!!    to work properly, which is typically true.
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a
!!    time could (depending on the programming environment used) be
!!    inefficient, as it could reallocate and allocate memory used for
!!    the output string with each buffer read.
!!
!!##OPTIONS
!!    LINE    line read
!!    LUN     optional LUN (Fortran logical I/O unit) number. Defaults
!!            to stdin.
!!    IOSTAT  status returned by READ(IOSTAT=IOS). If not zero, an error
!!            occurred or an end-of-file or end-of-record was encountered.
!!            This is the same value as returned by the function. See the
!!            example program for a usage case.
!!##RETURNS
!!    IER     zero unless an error occurred. If not zero, LINE returns the
!!            I/O error message.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_getline
!!    use,intrinsic :: iso_fortran_env, only : stdin=>input_unit
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : getline
!!    implicit none
!!    integer :: iostat
!!    character(len=:),allocatable :: line
!!       open(unit=stdin,pad='yes')
!!       INFINITE: do while (getline(line,iostat=iostat)==0)
!!          write(*,'(a)')'['//line//']'
!!       enddo INFINITE
!!       if(iostat /= iostat_end)then
!!          write(*,*)'error reading input:',trim(line)
!!       endif
!!    end program demo_getline
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function getline(line,lun,iostat) result(ier)
implicit none

! ident_11="@(#) M_io getline(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,intent(out),optional             :: iostat
integer                                  :: ier
character(len=4096)                      :: message

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=buflen)                    :: buffer
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   if(present(lun))then
      lun_local=lun
   else
      lun_local=stdin
   endif

   INFINITE: do                                                   ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no', &
      & size=isize,iomsg=message) buffer                          ! read next buffer (might use stream I/O for files
                                                                  ! other than stdin so system line limit is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)          ! append what was read to result
      if(is_iostat_eor(ier))then                                  ! if hit EOR reading is complete unless backslash ends the line
         ier=0                                                    ! hitting end of record is not an error for this routine
         exit INFINITE                                            ! end of reading line
     elseif(ier /= 0)then                                         ! end of file or error
        line=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   line=line_local                                                ! trim line
   if(present(iostat))iostat=ier
end function getline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     read_line(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                     string up to line length limit cleaning up input line
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function read_line(line,lun,ios) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,optional                         :: ios
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!
!!    Read a line of any length up to the programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function to
!!    work properly, which is typically true but can be set on an open file.
!!
!!    o Append lines that end in a backslash with next line
!!    o Expand tabs
!!    o Replace unprintable characters with spaces
!!    o Remove trailing carriage return characters and white space
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a time
!!    could (depending on the programming environment used) be inefficient,
!!    as it could reallocate and allocate memory used for the output string
!!    with each buffer read.
!!
!!##OPTIONS
!!    LINE   the line read from the file.
!!    LUN    The LUN (logical unit) to read from. Defaults to stdin.
!!    IOS    status returned by READ(IOSTAT=IOS). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!           This is the same value as returned by the function. See the
!!           example program for a usage case.
!!##RETURNS
!!    IER    status returned by READ(IOSTAT=IER). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!   Checking the error message and counting lines:
!!
!!     program demo_read_line
!!     use,intrinsic :: iso_fortran_env, only : stdin  => input_unit
!!     use,intrinsic :: iso_fortran_env, only : stderr => error_unit
!!     use,intrinsic :: iso_fortran_env, only : iostat_end, iostat_eor
!!     use M_io, only : read_line
!!     implicit none
!!     character (len =: ), allocatable :: line
!!     integer                          :: stat
!!     integer                          :: icount=0
!!        open(unit=stdin,pad='yes')
!!        INFINITE: do while (read_line(line,ios=stat) == 0)
!!           icount=icount
!!           write (*, '(*(g0))') icount,' [',line,']'
!!        enddo INFINITE
!!        if ( .not.is_iostat_end(stat) ) then
!!           write (stderr, '(*(g0))') &
!!           & 'error: line ',icount,'==>',trim (line)
!!        endif
!!     end program demo_read_line
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function read_line(line,lun,ios) result(ier)
implicit none

! ident_12="@(#) M_io read_line(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,optional                         :: ios
integer                                  :: ier

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=256)                       :: message
integer                                  :: biggest
character(len=buflen)                    :: buffer
integer                                  :: last
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   lun_local=merge(lun,stdin,present(lun))
   INFINITE: do                                                           ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no',size=isize,iomsg=message) buffer ! read next buffer (might use stream I/O for
                                                                          ! files other than stdin so system line limit
                                                                          ! is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)   ! append what was read to result
      if(is_iostat_eor(ier))then                            ! if hit EOR reading is complete unless backslash ends the line
         last=len(line_local)
         if(last /= 0)then
            if(line_local(last:last) == '\')then            ! if line ends in backslash it is assumed a continued line
               line_local=line_local(:last-1)               ! remove backslash
               cycle INFINITE                               ! continue on and read next line and append to result
            endif
         endif
         ier=0                                              ! hitting end of record is not an error for this routine
         exit INFINITE                                      ! end of reading line
     elseif(ier /= 0)then                                   ! end of file or error
        line_local=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   biggest=8*len(line_local)                                ! worst case is raw line is all tab characters
   if(allocated(line))deallocate(line)
   allocate(character(len=biggest) :: line)
   call notabs(line_local,line,last)                        ! expand tabs, trim carriage returns, remove unprintable characters
   line=noesc(line)
   line=trim(line(:last))                                   ! trim line
   if(present(ios))then
      ios=ier
   endif
end function read_line
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      get_tmp(3f) - [M_io:QUERY] Return the name of the scratch directory
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!     function get_tmp() result(tname)
!!
!!      character(len=:),allocatable :: tname
!!##DESCRIPTION
!!
!!    Return the name of the scratch directory set by the most common
!!    environment variables used to designate a scratch directory.
!!    $TMPDIR is the canonical environment variable in Unix and POSIX[1]
!!    to use to specify a temporary directory for scratch space. If $TMPDIR
!!    is not set, $TEMP, $TEMPDIR, and $TMP are examined in that order. If
!!    nothing is set "/tmp/" is returned. The returned value always ends in
!!    "/". No test is made that the directory exists or is writable.
!!
!!##EXAMPLE
!!
!!
!!   Sample:
!!
!!     program demo_get_tmp
!!     use M_io, only : get_tmp, uniq
!!     implicit none
!!     character(len=:),allocatable :: answer
!!        answer=get_tmp()
!!        write(*,*)'result is ',answer
!!        answer=get_tmp()//uniq('_scratch',create=.false.)
!!        write(*,*)'the file ',answer, &
!!        & ' was a good scratch file name, at least a moment ago'
!!     end program demo_get_tmp
!!
!!   Sample Results:
!!
!!     > result is /cygdrive/c/Users/JSU/AppData/Local/Temp/
!!     >
!!     > the file /cygdrive/c/Users/JSU/AppData/Local/Temp/_scratch
!!     > was a good scratch file name, at least a moment ago
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function get_tmp() result(tname)

! ident_13="@(#) M_io get_tmp(3f) Return the name of the scratch directory"

character(len=:),allocatable :: tname
integer                      :: lngth
character(len=10),parameter  :: names(*)=["TMPDIR    ","TEMP      ","TEMPDIR   ","TMP       "]
integer                      :: i
character(len=1)             :: sep
   sep=separator()
   tname=''
   do i=1,size(names)
      call get_environment_variable(name=names(i), length=lngth)
      if(lngth /= 0)then
         if(allocated(tname))deallocate(tname)
         allocate(character(len=lngth) :: tname)
         call get_environment_variable(name=names(i), value=tname)
         exit
      endif
   enddo
   if(lngth == 0)then
      tname='/tmp'
      lngth=len_trim(tname)
   endif
   if(scan(tname(lngth:lngth),'/\') == 0)then
      tname=tname//sep
   endif
end function get_tmp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! rd(3f) - [M_io:READ] ask for string from standard input with user-definable prompt
!! (LICENSE:PD)
!!
!!   function rd(prompt,default) result(out)
!!
!!    character(len=*),intent(in)              :: prompt
!!
!!   One of
!!
!!    character(len=*),intent(in)              :: default
!!    character(len=:),allocatable,intent(out) :: out
!!
!!    integer,intent(in)                       :: default
!!    integer,intent(out)                      :: out
!!
!!    real,intent(in)                          :: default
!!    real,intent(out)                         :: out
!!
!!    doubleprecision,intent(in)               :: default
!!    doubleprecision,intent(out)              :: out
!!
!!    logical,intent(in)                       :: default
!!    logical,intent(out)                      :: out
!!
!!
!!##DESCRIPTION
!!    Ask for string or value from standard input with user-definable prompt
!!    up to 20 times.
!!
!!    Do not use the function in an I/O statement as not all versions of
!!    Fortran support this form of recursion. Numeric values may be input
!!    in standard INTEGER, REAL, and DOUBLEPRECISION formats or as whole
!!    numbers in base 2 to 36 in the format BASE#VALUE.
!!
!!##OPTIONS
!!    prompt    Prompt string; displayed on same line as input is read from
!!    default   default answer on carriage-return. The type of the default
!!              determines the type of the output.
!!##RETURNS
!!    out       returned string or value. If an end-of-file or system error
!!              is encountered the string "EOF" is returned, or a "Nan"
!!              REAL numeric value, or huge(0), or .false. .
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_rd
!!    use M_io, only : rd
!!    implicit none
!!    character(len=:),allocatable :: mystring
!!    doubleprecision              :: d
!!    real                         :: r
!!    integer                      :: i
!!    logical                      :: l
!!
!!    INFINITE: do
!!       mystring=rd('Enter string or "STOP":',default='Today')
!!       if(mystring == 'STOP')stop
!!       i=rd('Enter integer:',default=huge(0))
!!       r=rd('Enter real:',default=huge(0.0))
!!       d=rd('Enter double:',default=huge(0.0d0))
!!       l=rd('Enter logical:',default=.false.)
!!
!!       write(*,*)'I=', i, 'R=', r, 'D=',d,  'MYSTRING=', mystring
!!       write(*,*)'L=', l
!!    enddo INFINITE
!!
!!    end program demo_rd
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!!    Public Domain
function rd_logical(prompt,default) result(out)
! 1995 John S. Urban
!
implicit none

! ident_14="@(#) M_io rd_logical(3fp) ask for logical value from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
logical,intent(in)           :: default
logical                      :: out

integer                      :: prompt_len
integer                      :: igot
integer                      :: ierr
integer                      :: icount
integer                      :: ios
character(:),allocatable     :: response
character(len=256)           :: iomsg
   out=.false.
   response=''
   prompt_len=len(prompt)
   do icount=1,20                                                 ! prevent infinite loop on error or end-of-file
      if(prompt_len > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(response,stdin)                                ! get back string
      igot=len(response)
      if(ierr /= 0)then
         cycle
      elseif(igot == 0.and.prompt_len > 0)then
         out=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         response=response//' '
         select case(response(1:1))
         case('y','Y')
            out=.true.
         case('n','N')
            out=.false.
         case default
            read(response,*,iostat=ios,iomsg=iomsg)out
            if(ios /= 0)then
               write(*,*)trim(iomsg)
               cycle
            endif
         end select
         exit
      endif
   enddo
end function rd_logical
!===================================================================================================================================
function rd_character(prompt,default) result(strout)
! 1995 John S. Urban
!
implicit none

! ident_15="@(#) M_io rd_character(3fp) ask for string from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
character(len=*),intent(in)  :: default
character(len=:),allocatable :: strout

integer                      :: len_default
integer                      :: igot
integer                      :: ierr
integer                      :: icount
!===================================================================================================================================
   len_default=len(prompt)
!===================================================================================================================================
   do icount=1,20                                                  ! prevent infinite loop on error or end-of-file
      if(len_default > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(strout,stdin)                                  ! get back string
      igot=len(strout)
      if(ierr /= 0)then
         strout='EOF'
         cycle
      elseif(igot == 0.and.len_default > 0)then
         strout=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         exit
      endif
   enddo
end function rd_character
!===================================================================================================================================
function rd_doubleprecision(prompt,default,iostat) result(dvalue)
implicit none

! ident_16="@(#) M_io rd_doubleprecision(3fp) ask for number from standard input with user-definable prompt"

doubleprecision              :: dvalue
integer                      :: ivalue
character(len=*),intent(in)  :: prompt
doubleprecision,intent(in)   :: default
integer,intent(out),optional :: iostat
character(len=:),allocatable :: strout
character(len=:),allocatable :: message
integer                      :: itest

   iostat=0
   dvalue=default
   strout=adjustl(rd_character(prompt,'NaN'))

   ! 1 for an integer [-+]NNNNN
   ! 2 for a whole number [-+]NNNNN.
   ! 3 for a real value [-+]NNNNN.MMMM
   ! 4 for a exponential value [-+]NNNNN.MMMM[-+]LLLL [-+]NNNNN.MMMM[ed][-+]LLLL
   ! values less than 1 represent an error
   if(strout == 'NaN')then
      dvalue=default
   elseif(index(strout,'#') /= 0)then
      if( decodebase(strout,0,ivalue))then
         dvalue=ivalue
      else
         iostat=-1
         write(*,*)'ERROR> could not convert ',strout
      endif
   else
      itest=isnumber(strout,message)
      if(itest > 0)then
         dvalue=s2v(strout,ierr=iostat)
      else
         iostat=-2
         write(*,*)' ERROR> for ',strout,' ',itest,':',trim(message)
      endif
   endif
end function rd_doubleprecision
!===================================================================================================================================
function rd_real(prompt,default,iostat) result(rvalue)
implicit none

! ident_17="@(#) M_io rd_real(3fp) ask for number from standard input with user-definable prompt"

real                         :: rvalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
real,intent(in)              :: default
integer,intent(out),optional :: iostat
   !*! what about Nan, Inf, -Inf? Likely place for compiler bugs
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      rvalue=huge(0.0)
   else
      rvalue=real(dvalue)
   endif
end function rd_real
!===================================================================================================================================
function rd_integer(prompt,default,iostat) result(ivalue)
implicit none

! ident_18="@(#) M_io rd_integer(3fp) ask for number from standard input with user-definable prompt"

integer                      :: ivalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
integer,intent(in)           :: default
integer,intent(out),optional :: iostat
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   !*! what about Nan, Inf, -Inf?
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      ivalue=huge(0)
   elseif(dvalue > huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] greater than ', huge(0)
      ivalue=huge(0)
   elseif(dvalue < 1-huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] less than ', 1-huge(0)
      ivalue=1-huge(0)
   else
      ivalue=nint(dvalue)
   endif
end function rd_integer
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getname(3f) - [M_io:QUERY] get name of the current executable
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getname() result(name)
!!
!!     character(len=:),allocatable         :: getname
!!
!!##DESCRIPTION
!!    getname(3f) returns the name of the current executable using
!!    get_command_argument(3f) and inquire(3f).
!!
!!##EXAMPLE
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getname
!!      use M_io, only : getname
!!      implicit none
!!         write(*,'(*(a))')'Running ',getname()
!!      end program demo_getname
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getname() result(name)
! get the pathname of arg0
implicit none
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: ios
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=ios)
   if(ios == 0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=ios)
      if(ios == 0)then
         inquire(file=arg0,iostat=ios,name=long_name)
         if(ios == 0)then
            name=trim(long_name)
         else
            name=arg0
         endif
      else
         arg0=''
      endif
   else
      arg0=''
   endif
end function getname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     which(3f) - [M_io:SCANNAMES] given a command name find the pathname
!!                 by searching the directories in the environment variable
!!                 $PATH
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function which(command) result(pathname)
!!
!!    character(len=*),intent(in)  :: command
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a command name find the first file with that name in the directories
!!    specified by the environment variable $PATH.
!!
!!##OPTIONS
!!    COMMAND   the command to search for
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the command is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_which
!!     use M_io, only : which
!!     implicit none
!!        write(*,*)'ls is ',which('ls')
!!        write(*,*)'dir is ',which('dir')
!!        write(*,*)'install is ',which('install')
!!     end program demo_which
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function which(command) result(pathname)
character(len=*),intent(in)     :: command
character(len=:),allocatable    :: pathname, checkon, paths(:), exts(:)
integer                         :: i, j
   pathname=''
   call split(get_env('PATH'),paths,delimiters=merge(';',':',separator() == '\'))
   SEARCH: do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),command))
      select case(separator())
      case('/')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
      case('\')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
         if(exists(checkon//'.bat'))then
            pathname=checkon//'.bat'
            exit SEARCH
         endif
         if(exists(checkon//'.exe'))then
            pathname=checkon//'.exe'
            exit SEARCH
         endif
         call split(get_env('PATHEXT'),exts,delimiters=';')
         do j=1,size(exts)
            if(exists(checkon//'.'//trim(exts(j))))then
               pathname=checkon//'.'//trim(exts(j))
               exit SEARCH
            endif
         enddo
      end select
   enddo SEARCH
contains
logical function exists(filename) result(r)
character(len=*), intent(in) :: filename
    inquire(file=filename, exist=r)
end function exists
end function which
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     lookfor(3f) - [M_io:SCANNAMES] look for a filename in a number
!!                   of directories specified by an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function lookfor(basename,env) result(pathname)
!!
!!    character(len=:),intent(in)  :: basename
!!    character(len=:),intent(in)  :: env
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a base filename find the first file with that name in the directories
!!    specified by the environment variable ENV
!!
!!##OPTIONS
!!    BASENAME   the file to search for
!!    ENV        environment variable name. Separator between directory names is
!!               assumed to be a colon on ULS (Unix-Like Systems) and semi-colon on
!!               MS-Windows machines.
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the file is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_lookfor
!!     use M_io, only : lookfor
!!     implicit none
!!     character(len=:),allocatable :: returned
!!        returned=lookfor('ls','PATH')
!!        write(*,*)'ls is ',returned
!!        returned=lookfor('dir.exe','PATH')
!!        write(*,*)'dir is ',returned
!!     end program demo_lookfor
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function lookfor(basename,env) result(pathname)
character(len=*),intent(in)     :: basename
character(len=*),intent(in)     :: env
character(len=:),allocatable    :: pathname, checkon, paths(:)
integer                         :: i
logical                         :: r
   pathname=''
   call split(get_env(env),paths,delimiters=merge(';',':',separator() == '\'))
   if(size(paths) == 0)then
      paths=['']
   endif
   do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),basename))
      inquire(file=checkon, exist=r)
      if(r)then
         pathname=checkon
         exit
      endif
   enddo
end function lookfor
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_env(3f) - [M_io:QUERY] a function returning the value of
!!                   an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    function get_env(NAME,DEFAULT,IERR=IERR) result(VALUE)
!!
!!     character(len=*),intent(in)            :: NAME
!!
!!     ! ONE OF ...
!!     o character(len=*),intent(in),optional :: DEFAULT
!!     o real,intent(in),optional             :: DEFAULT
!!     o integer,intent(in),optional          :: DEFAULT
!!     o doubleprecision,intent(in),optional  :: DEFAULT
!!     o logical,intent(in),optional          :: DEFAULT
!!
!!     integer,intent(out),optional           :: IERR
!!
!!     ! ONE OF THE FOLLOWING, MATCHING TYPE OF DEFAULT
!!     o character(len=:),allocatable         :: VALUE
!!     o integer                              :: VALUE
!!     o real                                 :: VALUE
!!     o doubleprecision                      :: VALUE
!!     o logical                              :: VALUE
!!
!!##DESCRIPTION
!!     Get the value of an environment variable or optionally return a
!!     default value when the environment variable is not set or is set
!!     to a blank string.
!!
!!     The type returned is the same as the type of the default value.
!!
!!
!!##OPTIONS
!!    NAME     name of environment variable
!!    DEFAULT  value to return if environment variable is not set or set
!!             to an empty string. May be CHARACTER, REAL, INTEGER,
!!             LOGICAL or DOUBLEPRECISION. Defaults to a null CHARACTER value.
!!##RETURNS
!!    VALUE    the value of the environment variable or the default.
!!             The type is the same as DEFAULT. If an error occurs and it
!!             is numeric, huge(0|0.0|0.0d0) is returned.
!!
!!             For a LOGICAL type, Any environment variable value starting
!!             with F,f,N or n is .FALSE. and any value starting with
!!             Y,y,T or t is true. A leading period (".") is ignored.
!!             Anything else returns .false. .
!!
!!    IERR     return error code. Must be specified with a keyword.
!!             It is zero if no error occurred.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_env
!!    use M_io, only : get_env, getname
!!    character(len=*),parameter :: g='(*(g0))'
!!    integer :: ierr
!!    character(len=:),allocatable :: HOME
!!      !Basics
!!       HOME=get_env('HOME','UNKNOWN')
!!       write(*,'(a)')HOME
!!       write(*,'(a)')Get_env('PATH')
!!
!!      !call this program setting STOP=RUN unless STOP=RUN
!!      !otherwise print various environment variable values
!!      !converted to various types
!!       if(get_env('STOP').eq.'RUN')then
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER','string')
!!          write(*,g)get_env('INTEGER',100)
!!          write(*,g)get_env('REAL',200.0)
!!          write(*,g)get_env('DOUBLE',300.0d0)
!!          write(*,g)get_env('LOGICAL',.true.)
!!
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER','string',ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('INTEGER',100,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('REAL',200.0,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('DOUBLE',300.0d0,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('LOGICAL',.true.)
!!          write(*,*)'ierr=',ierr
!!
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER')
!!          write(*,g)get_env('HOME')
!!        else
!!          write(*,g)repeat('-',80)
!!          call execute_command_line('env STOP=RUN '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=aaaa &
!!          & INTEGER=1 REAL=2.3 DOUBLE=444444444444 '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=bbbb &
!!          & INTEGER=1 REAL=2.3 DOUBLE=44.555 '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=cccc &
!!          & INTEGER=asdf REAL=asdf DOUBLE=adsf '//getname())
!!          write(*,g)repeat('-',80)
!!          stop
!!       endif
!!
!!    end program demo_get_env
!!
!!##SEE ALSO
!!    This duplicates system_getenv(3m_system) in most respects but avoids
!!    some interdependencies as M_system(3) currently requires a POSIX
!!    programming environment.
!!
!!    get_environment_variable(3fortran), system_getenv(3m_system),
!!    set_environment_variable(3m_system), system_putenv(3m_system),
!!    system_clearenv(3m_system), system_initenv(3m_system),
!!    system_getenv(3m_system), system_unsetenv(3m_system)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function get_env_character(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
implicit none
character(len=*),intent(in)                :: NAME
character(len=*),intent(in),optional       :: DEFAULT
type(force_keywd_hack),optional,intent(in) :: force_keywd
integer,intent(out),optional               :: ierr
character(len=:),allocatable               :: VALUE
character(len=255)                         :: errmsg
integer                                    :: howbig
integer                                    :: stat
integer                                    :: length
   ! get length required to hold value
   length=0
   errmsg=''
   stat=0
   if(NAME.ne.'')then
      call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
         !*!print *, NAME, " is not defined in the environment. Strange..."
         VALUE=''
         stat=0
      case (2)
         !*!print *, "This processor doesn't support environment variables. Boooh!"
         VALUE=''
      case default
         ! make string to hold value of sufficient size
         allocate(character(len=max(howbig,1)) :: VALUE)
         ! get value
         call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)
         if(stat.ne.0)VALUE=''
      end select
   else
      VALUE=''
   endif
   if(VALUE.eq.''.and.present(DEFAULT))VALUE=DEFAULT
   if(present(ierr))then
      ierr=stat
   elseif(stat.ne.0)then
      !write(stderr,'(a)')trim(errmsg)
   endif
end function get_env_character

function get_env_real(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
real,intent(in)               :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
real                          :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
   else
      write(fmt,'(*(g0))')'(g',max(1,len(string)),'.0)'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0.0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_real

function get_env_double(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
doubleprecision,intent(in)    :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
doubleprecision               :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
   else
      write(fmt,'(*(g0))')'(g',max(1,len(string)),'.0)'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0.0d0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_double

function get_env_integer(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
integer,intent(in)            :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
integer                       :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
      iostat=0
   else
      write(fmt,'(*(g0))')'(i',max(1,len(string)),')'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_integer

function get_env_logical(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
logical,intent(in)            :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
logical                       :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
character(len=1)              :: ch
   STRING=get_env_character(NAME,'',ierr=iostat)
   if(iostat.ne.0)then
      VALUE=.false.
   elseif(STRING.eq.'')then
      VALUE=DEFAULT
      iostat=0
   else
      string=string//'  '
      ch=string(1:1)
      if(ch.eq.'.')ch=string(2:2)
      select case(ch)
      case('t','T','y','Y')
         value=.true.
      case('f','F','n','N')
         value=.false.
       case default
         value=.false.
      end select
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_logical

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   is_hidden_file(3f) - [M_io:QUERY]  determine if a pathname points to a
!!   hidden file, which is defined as a file basename starting with a period.
!!   (LICENSE:PD)
!!
!!##SYNTAX
!!     impure elemental function is_hidden_file(PATH) result(YESNO)
!!
!!      character(len=*),intent(in) :: PATH
!!      logical                     :: YESNO
!!
!!##DESCRIPTION
!!    Given a pathname determine if it is a hidden file. This is simply
!!    assumed to be a basename that does not begin with a period and is not
!!    a single or double period, assumed to represent the current directory
!!    and parent directory.
!!
!!##LIMITATIONS
!!    Pathnames are not expanded to a canonical form, so if the basename is
!!    '.' or '..' and those point to a hidden directory name the return
!!    value will still be .FALSE. . Filenames are assumed to not contain
!!    leading or trailing spaces.
!!
!!##OPTIONS
!!    PATH     pathname to classify. It need not exist.
!!
!!##RETURNS
!!    YESNO    true if pathname points to a hidden file, otherwise it
!!             is false.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!       program demo_is_hidden_file
!!       use M_io, only : is_hidden_file, basename
!!          call showit('.abc')
!!          call showit('./.')
!!          call showit('..')
!!          call showit('...')
!!          call showit('/abc/def/notes.txt')
!!          call showit('/abc/def/.hide')
!!       contains
!!       subroutine showit(path)
!!       character(len=*),intent(in) :: path
!!          write(*,*)is_hidden_file(path), &
!!           & ' ,path=',path
!!       end subroutine showit
!!       end program demo_is_hidden_file
!!
!!    Results:
!!
!!     >  T  ,path=.abc
!!     >  F  ,path=./.
!!     >  F  ,path=..
!!     >  T  ,path=...
!!     >  F  ,path=/abc/def/notes.txt
!!     >  T  ,path=/abc/def/.hide
!!
!!##SEE ALSO
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental function is_hidden_file(path) result(yesno)
character(*), intent(in) :: path
logical :: yesno
character(len=:), allocatable :: base

   base = basename(path,suffix=char(0))//'  '
   select case (base)
   case ('.', '..');  yesno = .false.
   case default;      yesno = merge(.true., .false., base(1:1) == '.')
   end select

end function is_hidden_file
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_next_char(3f) - [M_io:READ] read from a file one character at a time
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    subroutine get_next_char(fd,c,ios)
!!
!!     integer,intent(in)    :: fd
!!     character,intent(out) :: c
!!     integer,intent(out)   :: ios
!!
!!
!!##DESCRIPTION
!!    This reads a file opened with stream access one character at a
!!    time, much like ""read(fd,iostat=ios) c" but with buffering, which
!!    I have found to be up to sixty times faster than such a plain read,
!!    although this varies depending on how or if the programming environment
!!    implements I/O buffering itself.
!!
!!    IT USES SAVED VARIABLES AND CAN ONLY BE USED ON ONE FILE AT A TIME
!!    IN THE CURRENT FORM. A user type including the saved values and the
!!    LUN could easily resolve this.
!!
!!##OPTIONS
!!    FD    A Fortran unit number of a file opened for stream access
!!    C     The next returned character if IOS=0
!!    IOS   The error status returned by the last read. It is zero (0) if
!!          no error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_next_char
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : get_next_char
!!    implicit none
!!    character(len=4096) :: filename ! filename to read
!!    character(len=256)  :: message  ! returned error messages
!!    integer             :: fd       ! file descriptor for input file
!!    integer             :: ios,ios1 ! hold I/O error flag
!!    character           :: c1       ! current character read
!!       filename='test.in'
!!       open(unit=fd,file=trim(filename),access='stream',status='old',&
!!       & iostat=ios,action='read',form='unformatted',iomsg=message)
!!       if(ios /= 0)then
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: could not open '//&
!!          trim(filename)
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: '//trim(message)
!!          stop 5
!!       endif
!!       ! loop through read of file one character at a time
!!       ONE_CHAR_AT_A_TIME: do
!!          ! get next character from buffered read from file
!!          call get_next_char(fd,c1,ios1)
!!          if(ios1 == iostat_end)then
!!             ! reached end of file so stop
!!             stop
!!          elseif(ios1 /= 0 )then
!!             ! error on file read
!!             write(*,*)&
!!          '*demo_get_next_char* ERROR: before end of '//&
!!          trim(filename)
!!             stop 1
!!          endif
!!          ! do something with the characters
!!          write(*,'(a)',advance='no')c1
!!       enddo ONE_CHAR_AT_A_TIME
!!    end program demo_get_next_char
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine get_next_char(fd,c,ios)
! replace "read(fd,iostat=ios) c" because gfortran on CygWin sixty times slower with plain read (no system buffering?)
! quick buffering read
implicit none
integer,intent(in)          :: fd
character,intent(out)       :: c
integer,intent(out)         :: ios
integer,parameter           :: bufsize=1048576
character(len=1),save       :: buff(bufsize)
integer,save                :: point=0
integer,save                :: filepoint=1
integer,save                :: sz=bufsize

ios=0

do
select case(point)
case(0)                                            ! read a buffer
   read(fd,iostat=ios,pos=filepoint) buff(1:sz)
   if(is_iostat_end(ios))then                      ! this is the last buffer
      if(sz /= 1)then                              ! try again with a smaller buffer
         sz=sz/2
         sz=max(1,sz)
         cycle
      endif
   elseif(ios == 0)then                            ! no error occurred so successfully read a buffer
      c=buff(1)
      filepoint=filepoint+sz
      point=sz-1
   endif
case(1:)                                           ! getting a character from a previous buffer
   point=point-1
   c=buff(sz-point)
case default
   write(*,*)'*get_next_char* internal error '
   read(fd,iostat=ios) c
end select
! assume if IOS is not zero, not called again until new file is started
   if(ios /= 0)then
      filepoint=1
      point=0
      sz=bufsize
   endif
   exit
enddo
end subroutine get_next_char
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:FILENAME] generate a filename containing a number
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       function filename_generator(head,tail,num,lenlimit) result(filename)
!!       character(len=*),intent(in)  :: head
!!       character(len=*),intent(in)  :: tail
!!       integer,intent(in) :: num
!!       integer,intent(in) :: lenlimit
!!       character(len=:),allocatable :: filename
!!
!!##DESCRIPTION
!!
!!    Generate a filename containing a representation of the specified
!!    whole number. This is useful for generating a series of filenames
!!    differing by a number such as "file1.txt", "file2.txt",
!!    ... .
!!
!!##OPTIONS
!!
!!    head      filename prefix.
!!    tail      filename suffix.
!!    num       number to represent as a string between HEAD and TAIL.
!!    lenlimit  number of digits up to which to zero-pad the string
!!              representing NUM.
!!
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!       program demo_filename_generator
!!       use,intrinsic::iso_fortran_env,only:int8,int16,int32,int64
!!       use M_io, only : filename_generator
!!       implicit none
!!
!!           ! no zero-fill
!!           write(*,*) filename_generator("file_",".dat",11)
!!           ! zero-fill till 3 digits
!!           write(*,*) filename_generator("file_",".dat",11,3)
!!           ! zero-fill till 9 digits
!!           write(*,*) filename_generator("file_",".dat",11,9)
!!           ! same as default (no zero-fill)
!!           write(*,*) filename_generator("file_",".dat",11,0)
!!
!!       end program demo_filename_generator
!!
!!    Results
!!
!!       > file_11.dat
!!       > file_011.dat
!!       > file_000000011.dat
!!       > file_11.dat
!!
!!##AUTHOR
!!    Zh, Niu; with modifications by John S. Urban
!!##LICENSE
!!    Public Domain

function filename_generator(head, tail, num, lenlimit) result(filename)
character(*),intent(in)      :: head
character(*),intent(in)      :: tail
integer,intent(in)           :: num
integer,intent(in),optional  :: lenlimit
character(len=:),allocatable :: filename

character(30)                :: fmt
integer                      :: local_lenlimit

   if ( present(lenlimit) ) then
      local_lenlimit = lenlimit
   else
      local_lenlimit = 0
   endif

   fmt = ""
   write(fmt, '("(a,i0.",i2.2,",a)")' ) local_lenlimit
   filename=repeat(' ', len(head) + len(tail) + max(19,local_lenlimit) )
   write(filename(:),fmt) trim(adjustl(head)), num, trim(adjustl(tail))
   filename=trim(filename)
end function filename_generator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! routines from other modules to make this one stand-alone
!     XX                    XX       X
!      X                     X                              X
!      X                     X                              X
!  XXXXX  XX  XX  XXXXXX     X     XXX     XXXXX   XXXX    XXXX    XXXXX   XXXXX
! X    X   X   X   X    X    X       X    X     X      X    X     X     X X     X
! X    X   X   X   X    X    X       X    X        XXXXX    X     XXXXXXX  XXX
! X    X   X   X   X    X    X       X    X       X    X    X     X           XX
! X    X   X  XX   X    X    X       X    X     X X    X    X  X  X     X X     X
!  XXXXXX   XX XX  XXXXX   XXXXX   XXXXX   XXXXX   XXXX X    XX    XXXXX   XXXXX
!                  X
!                 XXX
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lenset(line,length) result(strout)

!character(len=*),parameter::ident_36="@(#)M_strings::lenset(3f): return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

!character(len=*),parameter::ident_41="@(#)M_strings::a2i(3fp): subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         write(*,*)'sc','*a2i*','- value too large',valu8,'>',huge(valu)
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

!character(len=*),parameter::ident_42="@(#)M_strings::a2d(3fp): subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         write(*,*)'sc','*a2d* - cannot produce number from string ['//trim(chars)//']'
         if(msg /= '')then
            write(*,*)'*a2d* - ['//trim(msg)//']'
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

!character(len=*),parameter::ident_43="@(#)M_strings::s2v(3f): returns doubleprecision number from string"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
!===================================================================================================================================
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
!===================================================================================================================================
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
!===================================================================================================================================
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
function s2vs(string,delim) result(darray)

!character(len=*),parameter::ident_55="@(#)M_strings::s2vs(3f): function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
logical function decodebase(string,basein,out_baseten)
implicit none

!character(len=*),parameter::ident_72="@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine trimzeros(string)

!character(len=*),parameter::ident_50="@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.') == 0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i <= 1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine substitute(targetline,old,new,ierr,start,end)

!character(len=*),parameter::ident_11="@(#)M_strings::substitute(3f): Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichar
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option !! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichar=len_new + original_input_length
      if(ichar > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichar=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichar-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichar:)=targetline(ic:ind-1)
         ichar=ichar+ladd
      endif
      if(ichar-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichar:)=new(:len_new)
         ichar=ichar+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      write(*,*)'*substitute* new line will be too long'
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichar+ladd > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichar:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    isnumber(3f) - [M_strings:NUMERIC] determine if a string represents a number
!    (LICENSE:PD)
!
! SYNOPSIS
!    function isnumber(str,msg)
!
!     character(len=*),intent(in)  :: str
!     character(len=:),intent(out),allocatable,optional  :: msg
!
! DESCRIPTION
!     ISNUMBER(3f) returns a value greater than zero if the string represents
!     a number, and a number less than or equal to zero if it is a bad number.
!     Blank characters are ignored.
!
! OPTIONS
!     str  the string to evaluate as to whether it represents a numeric value
!          or not
!     msg  An optional message describing the string
!
! RETURNS
!     isnumber  the following values are returned
!
!                1 for an integer             [-+]NNNNN
!                2 for a whole number         [-+]NNNNN.
!                3 for a real value           [-+]NNNNN.MMMM
!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!
!               values less than 1 represent an error
!
! EXAMPLES
!   As the example shows, you can use an internal READ(3f) along with the
!   IOSTAT= parameter to check (and read) a string as well.
!
!     program demo_isnumber
!     use M_strings, only : isnumber
!     implicit none
!     character(len=256) :: line
!     real               :: value
!     integer            :: ios
!     integer            :: answer
!     character(len=256) :: message
!     character(len=:),allocatable :: description
!        write(*,*)'Begin entering values, one per line'
!        do
!           read(*,'(a)',iostat=ios)line
!           !
!           ! try string as number using list-directed input
!           line=''
!           read(line,*,iostat=ios,iomsg=message) value
!           if(ios == 0)then
!              write(*,*)'VALUE=',value
!           elseif( is_iostat_end(ios) ) then
!              stop 'end of file'
!           else
!              write(*,*)'ERROR:',ios,trim(message)
!           endif
!           !
!           ! try string using isnumber(3f)
!           answer=isnumber(line,msg=description)
!           if(answer > 0)then
!              write(*,*) &
!              & ' for ',trim(line),' ',answer,':',description
!           else
!              write(*,*) &
!              & ' ERROR for ',trim(line),' ',answer,':',description
!           endif
!           !
!        enddo
!     end program demo_isnumber
!
!  Example run
!
!    > Begin entering values
!    > ERROR:          -1 End of file
!    >  ERROR for            -1 :null string
!    >10
!    > VALUE=   10.0000000
!    >  for 10            1 :integer
!    >20
!    > VALUE=   20.0000000
!    >  for 20            1 :integer
!    >20.
!    > VALUE=   20.0000000
!    >  for 20.            2 :whole number
!    >30.1
!    > VALUE=   30.1000004
!    >  for 30.1            3 :real number
!    >3e1
!    > VALUE=   30.0000000
!    >  for 3e1            4 :value with exponent
!    >1-2
!    > VALUE=   9.99999978E-03
!    >  for 1-2            4 :value with exponent
!    >100.22d-4
!    > VALUE=   1.00220004E-02
!    >  for 100.22d-4            4 :value with exponent
!    >1--2
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1--2           -5 :bad number
!    >e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e           -6 :missing leading value before exponent
!    >e1
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e1           -6 :missing leading value before exponent
!    >1e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e           -3 :missing exponent
!    >1e+
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+           -4 :missing exponent after sign
!    >1e+2.0
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+2.0           -5 :bad number
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function isNumber(string,msg,verbose)
implicit none

! ident_1="@(#)M_strings::isnumber(3f): Determines if a string is a number of not."

character(len=*),intent(in)    :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                      :: verbose
integer                      :: isnumber

integer             :: i,iend
character(len=1),allocatable :: z(:)
character(len=:),allocatable :: message
logical                      :: founddigit
logical                      :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=s2a(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function isdigit(ch) result(res)

! ident_2="@(#)M_strings::isdigit(3f): Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!    input string
!    (LICENSE:PD)
!
! SYNOPSIS
!    function nospace(str) - remove all whitespace from input string
!
!     character(len=*),intent(in)          :: str
!     character(len=:),allocatable         :: nospace
!
! DESCRIPTION
!    nospace(3f) removes space, tab, carriage return, new line, vertical
!    tab, formfeed and null characters (called "whitespace"). The output
!    is returned trimmed.
!
! EXAMPLES
!   Sample program:
!
!     program demo_nospace
!     use M_strings, only: nospace
!     implicit none
!     character(len=:),allocatable  :: s
!        s='  This     is      a     test  '
!        write(*,*) 'original input string is ....',s
!        write(*,*) 'processed output string is ...',nospace(s)
!        if(nospace(s) == 'Thisisatest')then
!           write(*,*)'nospace test passed'
!        else
!           write(*,*)'nospace test error'
!        endif
!     end program demo_nospace
!
!   Expected output
!
!     original input string is ....  This     is      a     test
!     processed output string is ...Thisisatest
!     nospace test passed
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function nospace(line)

! ident_3="@(#)M_strings::nospace(3f): remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & ichar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_63="@(#)M_strings::isspace(3f): true if null,space,tab,return,new line,vertical tab, or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

!character(len=*),parameter::ident_7="&
!&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: ilen                   ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len(input_line)                                           ! ILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ilen)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (:0)                                                      ! command was totally blank
!-----------------------------------------------------------------------------------------------------------------------------------
   case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,ilen,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iterm(i30)=ilen                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))
               IF(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > ilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function upper(str,begin,end) result (string)

!character(len=*),parameter::ident_21="@(#)M_strings::upper(3f): Changes a string to uppercase"

character(*), intent(In)      :: str                 ! inpout string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
   string = str                                      ! initialize output string to input string

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = char(iachar(str(i:i))-32)    ! change miniscule letter to uppercase
       end select
   end do

end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function lower(str,begin,end) result (string)

!character(len=*),parameter::ident_22="@(#)M_strings::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
   string = str

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)     ! change letter to miniscule
      case default
      end select
   end do

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

!character(len=*),parameter::ident_24="@(#)M_strings::s2a(3fp): function to copy string(1:Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

!character(len=*),parameter::ident_47="@(#)M_strings::i2s(3fp): private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

!character(len=*),parameter::ident_40="@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         write(*,*)'*value_to_string* UNKNOWN TYPE'
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
      !! cannot currently do I/O from a function being called from I/O
      !!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

!character(len=*),parameter::ident_37="@(#)M_strings::merge_str(3f): pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in)     :: str1
character(len=*),intent(in)     :: str2
logical,intent(in)              :: expr
character(len=:),allocatable    :: strout
integer                         :: big
   big=max(len(str1),len(str2))
   strout=trim(merge(lenset(str1,big),lenset(str2,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine notabs(INSTR,OUTSTR,ILEN)

!character(len=*),parameter::ident_31="&
!&@(#)M_strings::notabs(3f): convert tabs to spaces while maintaining columns, remove CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=*),INTENT(OUT)  :: outstr       ! tab-expanded version of INSTR produced
INTEGER,INTENT(OUT)           :: ilen         ! column position of last character put into output string
                                              ! that is, ILEN holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
INTEGER,PARAMETER             :: tabsize=8    ! assume a tab stop is set every 8th column
INTEGER                       :: ipos         ! position in OUTSTR to put next character of INSTR
INTEGER                       :: lenin        ! length of input string trimmed of trailing spaces
INTEGER                       :: lenout       ! number of characters output string can hold
INTEGER                       :: istep        ! counter that advances thru input string INSTR one character at a time
CHARACTER(LEN=1)              :: c            ! character in input line being processed
INTEGER                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   IPOS=1                                     ! where to put next character in output string OUTSTR
   lenin=LEN(instr)                           ! length of character variable INSTR
   lenin=LEN_TRIM(instr(1:lenin))             ! length of INSTR trimmed of trailing spaces
   lenout=LEN(outstr)                         ! number of characters output string OUTSTR can hold
   OUTSTR=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: DO istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=ICHAR(c)                        ! get ADE of the character
         expand_tabs : SELECT CASE (iade)     ! take different actions depending on which character was found
         CASE(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (MOD(ipos-1,tabsize)))
         CASE(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         CASE DEFAULT                         ! c is anything else other than a tab,newline,or return  insert it in output string
            IF(ipos > lenout)THEN
               write(*,*)"*notabs* output string overflow"
               EXIT
            ELSE
               outstr(ipos:ipos)=c
               ipos=ipos+1
            ENDIF
         END SELECT expand_tabs
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=MIN(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      ilen=LEN_TRIM(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
END SUBROUTINE notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function noesc(INSTR)
! ident_48="@(#) M_strings noesc(3f) convert non-printable characters to a space"
character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)
! ident_2="@(#)M_journal::where_write_message(3fp): basic message routine used for journal files"
character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to my_stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O
character(len=4096)                :: mssge
   adv='yes'
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)trim(msg)
         endif
      case('S','s')
         write(my_stdout,'(a)',advance=adv)trim(msg)
         times=times+1
      case('E','e')
         write(stderr,'(a)',advance=adv)trim(msg)
         times=times+1
      case('+'); adv='no'
      case('>'); debug=.true.
      case('<'); debug=.false.
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
end subroutine where_write_message

subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep)
implicit none
! ident_5="@(#)M_journal::where_write_message_all(3f): writes a message to a string composed of any standard scalar types"
character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
character(len=*),intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,sep))
end subroutine where_write_message_all

subroutine write_message_only(message)
! ident_6="@(#)M_journal::write_message_only(3fp): calls JOURNAL('sc',message)"
character(len=*),intent(in)          :: message
   call where_write_message('sc',trim(message))
end subroutine write_message_only

function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
! ident_2="@(#)M_io::msg_scalar(3fp): writes a message to a string composed of any standard scalar types"
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
         increment=len(sep)+1
         sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   msg_scalar=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic

      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic

      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function msg_scalar

function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
! ident_3="@(#)M_io::msg_one(3fp): writes a message to a string composed of any standard one dimensional types"
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:),allocatable  :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic

      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic

      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic

end function msg_one
!===================================================================================================================================
function crop(strin) result (strout)

! ident_19="@(#) M_strings crop(3f) trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(strin))
end function crop
!===================================================================================================================================
end module m_io
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================


!>>>>> build/dependencies/M_framework/src/M_framework__msg.F90

module M_framework__msg
use,intrinsic :: iso_fortran_env, only : ERROR_UNIT,OUTPUT_UNIT    ! access computing environment
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
private
!-----------------------------------------------------------------------------------------------------------------------------------
! USED SO FREQUENTLY IN OTHER MODULES PUT IN THIS ONE WITH NO DEPENDENCIES TO PREVENT CIRCULAR DEPENDENCY
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_1="@(#) M_framework__msg str(3f) {msg_scalar msg_one}"

public str
public stderr
public wrt
public fmt
public set
public pdec
public assert
!!public :: a,i,f,g

interface str
   module procedure msg_scalar, msg_one
end interface str

interface set
   module procedure set_scalar
   module procedure set_single
end interface set

type :: force_kwargs_hack ! force keywords, using @awvwgk method
end type force_kwargs_hack
! so then any argument that comes afer "force_kwargs" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_kwargs_hack), optional, intent(in) :: force_kwargs

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    str(3f) - [M_framework__msg] converts up to twenty standard scalar
!!    type values to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!                      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if)
!!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!      logical,intent(in),optional          :: if
!!      character(len=*),intent(in),optional :: sep
!!      character,len=(:),allocatable        :: str
!!
!!##DESCRIPTION
!!    str(3f) builds a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   Optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!                Optionally, all the generic values can be
!!                single-dimensioned arrays. Currently, mixing scalar
!!                arguments and array arguments is not supported.
!!
!!    sep         separator string used between values. Defaults to a space.
!!                Must be specified with a keyword.
!!    if          If false return a null string.
!!                Must be specified with a keyword.
!!
!!##RETURNS
!!    str     description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_str
!!    use M_framework__msg, only : str
!!    implicit none
!!    character(len=:),allocatable :: pr
!!    character(len=:),allocatable :: frmt
!!    integer                      :: biggest
!!
!!    pr=str('HUGE(3f) integers',huge(0),&
!!    &'and real',huge(0.0),'and double',huge(0.0d0))
!!    write(*,'(a)')pr
!!    pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!    write(*,'(a)')pr
!!    pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!    write(*,'(a)')pr
!!    pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!    write(*,'(a)')pr
!!
!!    ! create a format on the fly
!!    biggest=huge(0)
!!    ! +0 for gfortran-11 bug
!!    frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
!!    write(*,*)'format=',frmt
!!
!!    ! although it will often work, using str(3f)
!!    ! in an I/O statement is not recommended
!!    ! because if an error occurs str(3f) will try
!!    ! to write while part of an I/O statement
!!    ! which not all compilers can handle and is currently non-standard
!!    write(*,*)str('program will now stop')
!!
!!    end program demo_str
!!
!!  Output
!!
!!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 ...
!!    and double 1.7976931348623157E+308
!!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...
!!    12345.678900000001 2.2250738585072014E-308
!!    complex         : (3.40282347E+38,1.17549435E-38)
!!     format=(*(i9:,1x))
!!     program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                       & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                       & force_kwargs,sep,if)
implicit none

! ident_2="@(#) M_framework__msg msg_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=:),allocatable  :: msg_scalar
type(force_kwargs_hack), optional, intent(in) :: force_kwargs
character(len=*),intent(in),optional :: sep
logical,intent(in),optional   :: if
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=:),allocatable  :: sep_local

   if(present(if))then
      if(.not.if)then
         msg_scalar=''
         return
      endif
   endif

   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      increment=2
      sep_local=' '
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic

      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic

      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,&
                    & generica,genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj,&
                    & force_kwargs,sep,if)
implicit none

! ident_3="@(#) M_framework__msg msg_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
class(*),intent(in),optional  :: generica(:), genericb(:), genericc(:), genericd(:), generice(:)
class(*),intent(in),optional  :: genericf(:), genericg(:), generich(:), generici(:), genericj(:)
type(force_kwargs_hack), optional, intent(in) :: force_kwargs
character(len=*),intent(in),optional :: sep
logical,intent(in),optional          :: if
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment

   if(present(if))then
      if(.not.if)then
         msg_one=''
         return
      endif
   endif

   if(present(sep))then
      increment=1+len(sep)
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_one=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic

      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic

      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         !error_stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment+1
   line=trim(line)//']'//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmt(3f) - [M_framework__msg] convert any intrinsic to a string using specified format
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function fmt(value,format) result(string)
!!
!!     class(*),intent(in),optional :: value
!!     character(len=*),intent(in),optional :: format
!!     character(len=:),allocatable :: string
!!##DESCRIPTION
!!    FMT(3f) converts any standard intrinsic value to a string using the specified
!!    format.
!!##OPTIONS
!!    value    value to print the value of. May be of type INTEGER, LOGICAL,
!!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    format   format to use to print value. It is up to the user to use an
!!             appropriate format. The format does not require being
!!             surrounded by parenthesis. If not present a default is selected
!!             similar to what would be produced with free format, with
!!             trailing zeros removed.
!!##RETURNS
!!    string   A string value
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_fmt
!!     use :: M_framework__msg, only : fmt
!!     implicit none
!!     character(len=:),allocatable :: output
!!
!!        output=fmt(10,"'[',i0,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(10.0/3.0,"'[',g0.5,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(.true.,"'The final answer is [',g0,']'")
!!        write(*,*)'result is ',output
!!
!!     end program demo_fmt
!!
!!   Results:
!!
!!     result is [10]
!!     result is [3.3333]
!!     result is The final answer is [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive function fmt(generic,format) result (line)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

! ident_4="@(#) M_framework__msg fmt(3f) convert any intrinsic to a string using specified format"

class(*),intent(in)                   :: generic
character(len=*),intent(in),optional  :: format
character(len=:),allocatable          :: line
character(len=:),allocatable          :: fmt_local
character(len=:),allocatable          :: re,im
integer                               :: iostat
character(len=255)                    :: iomsg
character(len=1),parameter            :: null=char(0)
integer                               :: ilen
logical                               :: trimit
   if(present(format))then
      fmt_local=format
      trimit=.false.
   else
      fmt_local=''
      trimit=.true.
   endif
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local == '')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'

         type is (real(kind=real128));     fmt_local='(1pg0,a)'

         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
      end select
   else
      if(format(1:1) == '(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   iostat=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int16));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int32));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int64));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real32));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real64));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null

      type is (real(kind=real128));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null

      type is (logical);                write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (character(len=*));       write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (complex);
              if(trimit)then
                 re=fmt(generic%re)
                 im=fmt(generic%im)
                 call trimzeros_(re)
                 call trimzeros_(im)
                 fmt_local='("(",g0,",",g0,")",a)'
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) trim(re),trim(im),null
                 trimit=.false.
              else
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
              endif
   end select
   if(iostat /= 0)then
      line='<ERROR>'//trim(iomsg)
   else
      ilen=index(line,null,back=.true.)
      if(ilen == 0)ilen=len(line)
      line=line(:ilen-1)
   endif

   if(index(line,'.') /= 0 .and. trimit) call trimzeros_(line)

end function fmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_framework__msg:TYPE] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       !use M_framework__msg, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          string= '123.450000000000'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.00e3'
!!          call trimzeros_(string)
!!          write(*,*)string
!!       end program demo_trimzeros_
!!
!!   Results:
!!
!!     > 123.45
!!     > 12345
!!     > 12345
!!     > 12345e3
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_5="@(#) M_framework__msg trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)               :: string
character(len=len(string) + 2) :: str
character(len=len(string))     :: exp        ! the exponent string if present
integer                        :: ipos       ! where exponent letter appears if present
integer                        :: i, ii
   str = string                              ! working copy of string
   ipos = scan(str, 'eEdD')                  ! find end of real number if string uses exponent notation
   if (ipos > 0) then                        ! letter was found
      exp = str(ipos:)                       ! keep exponent string so it can be added back as a suffix
      str = str(1:ipos - 1)                  ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if (index(str, '.') == 0) then            ! if no decimal character in original string add one to end of string
      ii = len_trim(str)
      str(ii + 1:ii + 1) = '.'               ! add decimal to end of string
   endif
   do i = len_trim(str), 1, -1               ! scanning from end find a non-zero character
      select case (str(i:i))
      case ('0')                             ! found a trailing zero so keep trimming
         cycle
      case ('.')                             ! found a decimal character at end of remaining string
         if (i <= 1) then
            str = '0'
         else
            str = str(1:i - 1)
         endif
         exit
      case default
         str = str(1:i)                      ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if (ipos > 0) then                        ! if originally had an exponent place it back on
      string = trim(str)//trim(exp)
   else
      string = str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stderr(3f) - [M_framework__msg] write message to stderr
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine stderr(msg,[generic(s)])
!!
!!     class(*),intent(in),optional :: msg
!!     class(*),intent(in),optional :: &
!!                     & generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: &
!!                     & generic5,generic6,generic7,generic8,generic9
!!     class(*),intent(in),optional :: &
!!                     & generica,genericb,genericc,genericd,generice
!!     class(*),intent(in),optional :: &
!!                     & genericf,genericg,generich,generici,genericj
!!##DESCRIPTION
!!    STDERR(3f) writes a message to standard error using a standard
!!    f2003 method.  Up to twenty generic options are available.
!!##OPTIONS
!!    msg           - description to print
!!    generic[0-j]  - optional value to print the value of after the
!!                    message. May be of type INTEGER, LOGICAL, REAL,
!!                    DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_stderr
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32
!!    use M_framework__msg, only: stderr
!!    implicit none
!!
!!    call stderr('A simple message')
!!    call stderr('error: RVALUE=',3.0/4.0)
!!    call stderr('error: IVALUE=',123456789)
!!    call stderr('error: LVALUE=',.true.)
!!
!!    SEVERAL: block
!!    integer :: least=10, most=999, ival=-10
!!    call stderr('error: value',ival, &
!!            & 'should be between',least,'and',most)
!!    endblock SEVERAL
!!
!!    call stderr('real32  :',huge(0.0_real32),0.0_real32, &
!!            & 12345.6789_real32,tiny(0.0_real32))
!!    call stderr('real64  :',huge(0.0_real64),0.0_real64, &
!!            & 12345.6789_real64,tiny(0.0_real64))
!!    !#ifdef __NVCOMPILER
!!    !#else
!!    call stderr('real128 :',huge(0.0_real128),0.0_real128, &
!!            & 12345.6789_real128,tiny(0.0_real128))
!!    !#endif
!!    call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real)))
!!
!!    call stderr('error: program will now stop')
!!    stop 1
!!
!!    end program demo_stderr
!!
!!   Results:
!!     A simple message
!!     error: RVALUE= 0.750000000
!!     error: IVALUE= 123456789
!!     error: LVALUE= T
!!     error: value -10 should be between 10 and 999
!!     real32  : 3.40282347E+38 ...
!!               0.00000000 ...
!!               12345.6787 ...
!!               1.17549435E-38
!!     real64  : 1.7976931348623157E+308 ...
!!               0.0000000000000000 ...
!!               12345.678900000001 ...
!!               2.2250738585072014E-308
!!     real128 : 1.18973149535723176508575932662800702E+4932 ...
!!               0.00000000000000000000000000000000000  ...
!!               12345.6789000000000000000000000000002 ...
!!               3.36210314311209350626267781732175260E-4932
!!     complex : (3.40282347E+38,1.17549435E-38)
!!     error: program will now stop
!!     STOP 1
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine stderr(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
implicit none

! ident_6="@(#) M_framework__msg stderr(3f) writes a message to standard error using a standard f2003 method"

class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer                      :: ios
   write(error_unit,'(a)',iostat=ios) str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
   flush(unit=output_unit,iostat=ios)
   flush(unit=error_unit,iostat=ios)
end subroutine stderr
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wrt(3f) - [M_framework__msg] write multiple scalar values to any
!!    number of files
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine wrt(luns,generic(s),iostat)
!!
!!     integer,intent(in)           :: luns(:)
!!     class(*),intent(in),optional :: &
!!                     & generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: &
!!                     & generic5,generic6,generic7,generic8,generic9
!!     class(*),intent(in),optional :: &
!!                     & generica,genericb,genericc,genericd,generice
!!     class(*),intent(in),optional :: &
!!                     & genericf,genericg,generich,generici,genericj
!!     integer,intent(out),optional :: iostat
!!     character(len=*),intent(in)  :: types(*)
!!##DESCRIPTION
!!    WRT(3f) writes a list of scalar values  to the list of unit numbers
!!    in LUNS(:).
!!##OPTIONS
!!    LUNS            Unit numbers to write to. If of size zero no output
!!                    is generated
!!    generic[1-20]   optional value to print the value of after the
!!                    message. May be of type INTEGER, LOGICAL, REAL,
!!                    DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    TYPES           one for each lun. '' for ASCII, 'CSV' for
!!                    comma-separated.
!!##RETURNS
!!    IOSTAT          The value of the last non-zero IOSTAT value. Returns
!!                    zero if no errors occurred.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wrt
!!    use, intrinsic :: iso_fortran_env, only : &
!!     & stdin=>input_unit, &
!!     & stdout=>output_unit, &
!!     & stderr=>error_unit
!!    use M_framework__msg, only: wrt, fmt
!!    implicit none
!!    integer,allocatable :: luns(:)
!!    integer :: iostat=0
!!    integer,parameter :: ints(3)=[1,2,3]
!!
!!    ! a null list allows for turning off verbose or debug mode output
!!    luns=[integer ::]
!!    call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! multiple files can be used to create a log file, for example
!!    luns=[stderr,stdout]
!!    call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! using fmt
!!    call wrt([stdout,stdout,stdout],'USING FMT :', &
!!     & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat)
!!
!!
!!    end program demo_wrt
!!
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!  IOSTAT=           0
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!  IOSTAT=           0
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine wrt(luns,g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat)
implicit none

! ident_7="@(#) M_framework__msg write(3f) writes a message to any number of open files with any scalar values"

integer,intent(in)           :: luns(:)
class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer,intent(out),optional :: iostat
integer                      :: i
integer                      :: ios, ios2
character(len=256)           :: msg
   ios2=0
   do i=1,size(luns)
      write(luns(i),'(a)',iostat=ios,iomsg=msg)str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)
      if(ios /= 0)then
         ios2=ios
         call stderr('<ERROR>*write*:',msg)
         if(.not.present(iostat))stop 1
      endif
   enddo
   if(present(iostat))iostat=ios2

end subroutine wrt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set(3f) - [M_msg] set scalars from an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, &
!!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk)
!!      class(*),intent(in)           :: g0
!!      class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga
!!      class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk
!!
!!##DESCRIPTION
!!    set(3f) sets up to twenty scalars to elements from an array.
!!
!!##OPTIONS
!!    g0(:)       array to read values from. Can be of type INTEGER or REAL
!!    g[1-9a-k]   optional values to set to an array element. Can
!!                be of type INTEGER or REAL
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_set
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use M_framework__msg, only : set
!!    implicit none
!!    real(kind=real32)    :: a; namelist /all/a
!!    real(kind=real64)    :: b; namelist /all/b
!!    real(kind=real128)   :: c; namelist /all/c
!!    integer(kind=int8)   :: i; namelist /all/i
!!    integer(kind=int16)  :: j; namelist /all/j
!!    integer(kind=int32)  :: k; namelist /all/k
!!    integer(kind=int64)  :: l; namelist /all/l
!!       call set([1,2,3,4,5,6,7],a,b,c,i,j,k,l)
!!       write(*,nml=all)
!!       call set(10,a)
!!       call set(100,l)
!!       write(*,nml=all)
!!    end program demo_set
!!
!!   Results:
!!
!!     &ALL
!!     A       =   1.000000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                     7
!!     /
!!     &ALL
!!     A       =   10.00000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                   100
!!     /
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine set_single(generic0, generic1)
implicit none
class(*),intent(in)            :: generic0
class(*),intent(out)           :: generic1
   call set_generic(generic1)
contains
subroutine set_generic(gen)
class(*),intent(out) :: gen
   select type(generic0)

   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select

   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0

         type is (real(kind=real128));     gen=generic0

      end select

   end select
end subroutine set_generic
end subroutine set_single
subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
          & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick)
implicit none

! ident_7="@(#)M_framework__msg::set_scalar(3fp): set scalars from array elements"

class(*),intent(in)            :: generic0(:)
class(*),intent(out),optional  ::           generic1, generic2, generic3, generic4
class(*),intent(out),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(out),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(out),optional  :: genericf, genericg, generich, generici, genericj
class(*),intent(out),optional  :: generick

   if(present(generic1))call set_generic(generic1,1)
   if(present(generic2))call set_generic(generic2,2)
   if(present(generic3))call set_generic(generic3,3)
   if(present(generic4))call set_generic(generic4,4)
   if(present(generic5))call set_generic(generic5,5)
   if(present(generic6))call set_generic(generic6,6)
   if(present(generic7))call set_generic(generic7,7)
   if(present(generic8))call set_generic(generic8,8)
   if(present(generic9))call set_generic(generic9,9)
   if(present(generica))call set_generic(generica,10)
   if(present(genericb))call set_generic(genericb,11)
   if(present(genericc))call set_generic(genericc,12)
   if(present(genericd))call set_generic(genericd,13)
   if(present(generice))call set_generic(generice,14)
   if(present(genericf))call set_generic(genericf,15)
   if(present(genericg))call set_generic(genericg,16)
   if(present(generich))call set_generic(generich,17)
   if(present(generici))call set_generic(generici,18)
   if(present(genericj))call set_generic(genericj,19)
   if(present(generick))call set_generic(generick,20)
contains
!===================================================================================================================================
subroutine set_generic(gen,i)
class(*),intent(out) :: gen
integer,intent(in)   :: i
   if(size(generic0) < i)then
      write(ERROR_UNIT,'()')'<ERROR> i=',i,' is out of bounds (<',size(generic0),')'
      stop 1
   endif
   select type(generic0)
   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select

   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)

         type is (real(kind=real128));     gen=generic0(i)

      end select

   end select
end subroutine set_generic
!===================================================================================================================================
end subroutine set_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      pdec(3f) - [M_framework__msg] write out string with ASCII decimal
!!      equivalent vertically under it
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Usage:
!!
!!     subroutine pdec(string)
!!     character(len=*),intent(in) :: string
!!
!!##DESCRIPTION
!!
!!    Given a string to print, PDEC() writes out the ASCII Decimal equivalent
!!    of the string directly underneath it. This can help you to locate
!!    unprintable characters or non-standard white-space such as a backspace
!!    character or tab character in input strings that your program could
!!    not interpret. On output, non-printable characters are replaced with
!!    a space, and trailing spaces are ignored.
!!
!!    You read the numbers vertically.
!!
!!    1. ignore trailing spaces
!!    2. print the character if it has an ADE of 32 on up
!!    3. print a space if it has an ADE of less than 32
!!    4. underneath each character print the ADE value vertically
!!
!!##EXAMPLES
!!
!!
!!    Sample program:
!!
!!       program demo_pdec
!!       use M_framework__msg, only : pdec
!!       call pdec(' ABCDEFG abcdefg    ')
!!       end program demo_pdec
!!
!!    would produce (notice trailing space is trimmed):
!!
!!      > ABCDEFG abcdefg
!!      >0000000000001111
!!      >3666667739990000
!!      >2567890127890123
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine pdec(string)

! ident_8="@(#) M_framework__msg pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string"

character(len=*),intent(in) :: string   ! the string to print
integer                     :: ilen     ! number of characters in string to print
integer                     :: i        ! counter used to step thru string

   ilen=len_trim(string(:len(string)))  ! get trimmed length of input string

   write(*,101)(char(max(32,ichar(string(i:i)))),i=1,ilen) ! replace lower unprintable characters with spaces

   ! print ADE value of character underneath it
   write(*,202)     (ichar(string(i:i))/100,    i=1,ilen)
   write(*,202)(mod( ichar(string(i:i)),100)/10,i=1,ilen)
   write(*,202)(mod((ichar(string(i:i))),10),   i=1,ilen)
! strings are assumed under 32767+1 characters in length because format integer constants > 32767+1 are not supported on HP-UX
! when newer compilers are available use unlimited
!101   format(32767a1:)  ! format for printing string characters
!202   format(32767i1:)  ! format for printing ADE values
101   format(*(a1:))  ! format for printing string characters
202   format(*(i1:))  ! format for printing ADE values
end subroutine pdec
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    assert(3f) - [M_framework__msg] print filename, linenumber, and
!!    message to stderr and stop program
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function assert(file,linenum,expr,g1,g2,g3,g4,g5,g6,g7,g8,g9, &
!!                    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)
!!
!!     character(len=*),intent(in)  :: file
!!     character(len=*),intent(in)  :: linenum
!!     logical,intent(in)           :: expr
!!     class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!##DESCRIPTION
!!    assert(3f) prints strings to stderr and then stops program with exit
!!    code 1 It labels the first string as the filename, the next integer
!!    parameter as the linenumber, and then up to twenty scalar values.
!!
!!    It is primarily intended for use by the prep(1) preprocessor $ASSERT
!!    directive
!!
!!##OPTIONS
!!
!!    filename   a string assumed to be the current filename when compiling
!!    linenum    assumed to be the line number of the source code the ASSERT(3f)
!!               procedure was called at.
!!    expr       logical value
!!    g[1-9a-j]  optional value(s) to print as a message before stopping. May
!!               be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!               or CHARACTER.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_assert
!!    use M_framework__msg, only : assert
!!    implicit none
!!    real :: a, toobig=1024
!!    a=2000
!!    call assert('myroutine', 101, a > toobig, &
!!            & 'The value is too large', a, ' > ', toobig)
!!    end program demo_assert
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine assert(filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
implicit none

! ident_9="@(#) M_framework__msg assert(3f) writes a message to a string composed of any standard scalar types"

character(len=*), intent(in)   :: filename
integer, intent(in)            :: linen
logical, intent(in)            :: expr
class(*), intent(in), optional  :: g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*), intent(in), optional  :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj

   ! write message to standard error
   if (.not. expr) then
      call stderr('ERROR:filename:', filename, ':line number:', linen, ':', &
      & str( g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj ) )
      stop 1
   endif

end subroutine assert
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__msg


!>>>>> build/dependencies/M_framework/src/M_framework__utility.f90

module M_framework__utility
use, intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env,  only : real32, real64, real128
use, intrinsic :: iso_fortran_env,  only : ERROR_UNIT,OUTPUT_UNIT
implicit none
private
public :: fstop
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fstop(3f) - [M_framework__utility] call stop with both a number and
!!    a message
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine fstop(ierr,stdout,stderr)
!!
!!     integer,intent(in)                   :: ierr
!!     character(len=*),intent(in),optional :: stdout
!!     character(len=*),intent(in),optional :: stderr
!!##DESCRIPTION
!!    FSTOP(3f) call STOP(3f). What a call to STOP does is very system
!!    dependent, so using an abstraction layer is useful, as it allows just
!!    the fstop() routine to be changed; and STOP does not allow a variable
!!    to be used on the numeric access status (this has changed at f2015).
!!
!!##OPTIONS
!!    ierr    - value in range 0 to 32
!!    stdout  - description to be printed to standard output
!!    stderr  - description to be printed to standard error
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_fstop
!!    use M_framework__utility, only: fstop
!!    implicit none
!!    integer :: int
!!    !*!write(*,*)'Enter stop value'
!!    !*!read(*,*) int
!!    int=25
!!    select case(int)
!!    case(10) ; call fstop(int)
!!    case(20) ; call fstop(int,stderr='error: program will now stop')
!!    case(25) ; call fstop(int,stdout='stdout message', &
!!                    & stderr='stderr message')
!!    case(30) ; call fstop(int,stdout='error: program will now stop')
!!    case default
!!               call fstop(int)
!!    endselect
!!
!!    end program demo_fstop
!!
!!   Results:
!!
!!##SEE ALSO
!!   Look for common extensions, such as abort(3f), backtrace(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine fstop(ierr,stdout,stderr)

! ident_1="@(#) M_framework__utility fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message"

integer,intent(in)                   :: ierr
character(len=*),optional,intent(in) :: stdout
character(len=*),optional,intent(in) :: stderr
character(len=132)                   :: message
! The standard states:
!   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the
!   processor supports that concept. If the integer stop-code is used as the process exit status, the processor
!   might be able to interpret only values within a limited range, or only a limited portion of the integer value
!   (for example, only the least-significant 8 bits).

!   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed,
!   it is recommended that the value zero be supplied as the process exit status, if the processor supports that
!   concept.
!   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement.
!
! Conforming variants I have encountered include
!    o printing a message such as 'STOP nnn' when the integer value is called
!    o having a limit on the length of the message string passed
!    o prefixing the message with the string 'STOP '
!    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument
!      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...)
!    o whether messages appear on stdout or stderr.
!    o no value being returned to the system at all.
!
!  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported.
!  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated?
!
!  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value.
!  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system,
!  but I sometimes want to return variables.
!
!  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message
!  to appear when using integer values
!
!  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky
!  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran
!  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a
!  value to the system and Fortran does not, but I do not recommend it.
!
!  Note that the C function "exit(int signal)" not only works more consistently but that the global values EXIT_SUCCESS and
!  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant.
!
!  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure.
!-----------------------------------------------------------------------------------------------------------------------------------
!STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'
!-----------------------------------------------------------------------------------------------------------------------------------
if(present(stderr))then       ! write message to stderr, assuming string length is allowed
   if(stderr /= '')then
      write(error_unit,'(a)')trim(stderr)
   endif
!f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED)
!f2015!      case(0); allstop 0
!f2015!      case(1); allstop 1
!f2015!      case(2); allstop 2
!f2015!      case(3); allstop 3
!f2015!      case(4); allstop 4
!f2015!      case(5); allstop 5
!f2015!      case(6); allstop 6
!f2015!      case(7); allstop 7
!f2015!      case(8); allstop 8
!f2015!      case(9); allstop 8
!f2015!      case(10); allstop 10
!f2015!      case(11); allstop 11
!f2015!      case(12); allstop 12
!f2015!      case(13); allstop 13
!f2015!      case(14); allstop 14
!f2015!      case(15); allstop 15
!f2015!      case(16); allstop 16
!f2015!      case(17); allstop 17
!f2015!      case(18); allstop 18
!f2015!      case(19); allstop 19
!f2015!      case(20); allstop 20
!f2015!      case(21); allstop 21
!f2015!      case(22); allstop 22
!f2015!      case(23); allstop 23
!f2015!      case(24); allstop 24
!f2015!      case(25); allstop 25
!f2015!      case(26); allstop 26
!f2015!      case(27); allstop 27
!f2015!      case(28); allstop 28
!f2015!      case(29); allstop 29
!f2015!      case(30); allstop 30
!f2015!      case(31); allstop 31
!f2015!      case(32); allstop 32
!f2015!   case default
!f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system'
!f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error
!f2015!      allstop 1
!f2015!   end select
endif
if(present(stdout))then       ! write message to stdout, assuming string length is allowed
   if(stdout /= '')then
      write(*,'(a)')trim(stdout)
   endif
endif
select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED)
   case(0); stop 0
   case(1); stop 1
   case(2); stop 2
   case(3); stop 3
   case(4); stop 4
   case(5); stop 5
   case(6); stop 6
   case(7); stop 7
   case(8); stop 8
   case(9); stop 8
   case(10); stop 10
   case(11); stop 11
   case(12); stop 12
   case(13); stop 13
   case(14); stop 14
   case(15); stop 15
   case(16); stop 16
   case(17); stop 17
   case(18); stop 18
   case(19); stop 19
   case(20); stop 20
   case(21); stop 21
   case(22); stop 22
   case(23); stop 23
   case(24); stop 24
   case(25); stop 25
   case(26); stop 26
   case(27); stop 27
   case(28); stop 28
   case(29); stop 29
   case(30); stop 30
   case(31); stop 31
   case(32); stop 32
case default
   write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system'
   write(error_unit,'(a)')trim(message) ! write message to standard error
   stop 1
end select
end subroutine fstop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__utility


!>>>>> build/dependencies/M_strings/src/M_strings.F90

!>
!!##NAME
!!    M_strings(3f) - [M_strings::INTRO] Fortran string module
!!
!!##DESCRIPTION
!!    The M_strings(3fm) module is a collection of Fortran procedures
!!    that supplement the built-in intrinsic string routines. Routines
!!    for parsing, tokenizing, changing case, substituting new strings for
!!    substrings, locating strings with simple wildcard expressions, removing
!!    tabs and line terminators and other string manipulations are included.
!!
!!    M_strings__oop(3fm) is a companion module that provides an OOP
!!    interface to the M_strings module.
!!
!!##SYNOPSIS
!!
!!  public entities:
!!
!!      use M_strings,only : split, slice, sep, delim, chomp, strtok
!!      use M_strings,only : split2020, find_field
!!      use M_strings,only : substitute, change, modif, transliterate, &
!!              & reverse, squeeze
!!      use M_strings,only : replace, join
!!      use M_strings,only : upper, lower, upper_quoted
!!      use M_strings,only : rotate13, percent_encode, percent_decode
!!      use M_strings,only : adjustc, compact, nospace, indent
!!      use M_strings,only : crop, clip, unquote, quote, matching_delimiter
!!      use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &
!!              & stretch, lenset, merge_str
!!      use M_strings,only : switch, s2c, c2s
!!      use M_strings,only : noesc, notabs, dilate, expand, visible
!!      use M_strings,only : longest_common_substring
!!      use M_strings,only : string_to_value, string_to_values, s2v, s2vs
!!      use M_strings,only : int, real, dble, nint
!!      use M_strings,only : atoi, atol, aton
!!      use M_strings,only : value_to_string, v2s, str, fmt
!!      use M_strings,only : listout, getvals
!!      use M_strings,only : glob, ends_with
!!      use M_strings,only : paragraph
!!      use M_strings,only : base, decodebase, codebase, base2
!!      use M_strings,only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings,only : isgraph, islower, isprint, ispunct
!!      use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings,only : isnumber
!!      use M_strings,only : fortran_name
!!      use M_strings,only : describe
!!      use M_strings,only : edit_distance
!!      use M_strings,only : bundle
!!
!!   TOKENS
!!
!!       split   subroutine parses string using specified delimiter characters
!!               and stores tokens into an array
!!       sep     function interface to split(3f)
!!       slice   subroutine parses string using specified delimiter characters
!!               and stores beginning and ending positions in arrays
!!       delim   subroutine parses string using specified delimiter characters
!!               and store tokens into an array and records beginning and end
!!       chomp   function consumes input line as it returns next token in a
!!               string using specified delimiters
!!       paragraph    convert a string into a paragraph
!!       strtok  tokenize a string like C strtok(3c) routine
!!
!!       CONTRIBUTIONS
!!
!!       split2020   split a string using prototype of proposed standard
!!                   procedure
!!       find_field  token a string
!!
!!   EDITING
!!
!!       substitute      subroutine non-recursively globally replaces old
!!                       substring with new substring
!!       replace         function non-recursively globally replaces old
!!                       substring with new substring using allocatable string
!!                       (version of substitute(3f) without limitation on
!!                       length of output string)
!!       change          subroutine non-recursively globally replaces old
!!                       substring with new substring with a directive like
!!                       line editor
!!       modif           subroutine modifies a string with a directive like the
!!                       XEDIT line editor MODIFY command
!!       transliterate   replace characters found in set one with characters
!!                       from set two
!!       reverse         reverse character order in a string
!!       join            join an array of CHARACTER variables with specified
!!                       separator
!!       rotate13        apply trivial encryption algorithm ROT13 to a string
!!       percent_encode  apply percent-encryption (aka. URL encryption) to characters
!!       percent_decode  apply percent-decryption (aka. URL decryption) to characters
!!       squeeze         delete adjacent duplicate characters from a string
!!
!!   CASE
!!
!!       upper           function converts string to uppercase
!!       lower           function converts string to miniscule
!!       upper_quoted    function converts string to uppercase skipping strings
!!                       quoted per Fortran rules
!!
!!   STRING LENGTH AND PADDING
!!
!!       len_white  find location of last non-whitespace character
!!       lenset     return a string of specified length
!!       pad        return a string of at least specified length
!!       zpad       pad integer or string to length with zero characters
!!                  on left
!!       lpad       convert scalar intrinsic to a string padded on left to
!!                  specified length
!!       cpad       convert scalar intrinsic to a centered string of the
!!                  specified length
!!       rpad       convert scalar intrinsic to a string padded on right to
!!                  specified length
!!       stretch    return a string of at least specified length with suffix
!!       merge_str  make strings of equal length and then call MERGE(3f)
!!                  intrinsic
!!   WHITE SPACE
!!
!!       adjustc  elemental function centers text within the length of the
!!                input string
!!       compact  left justify string and replace duplicate whitespace with
!!                single characters or nothing
!!       nospace  function replaces whitespace with nothing
!!       indent   find number of leading spaces
!!       crop     function trims leading and trailing spaces and control
!!                characters
!!       clip     trim leading and trailings spaces or set of characters
!!                from string
!!
!!       See Also: squeeze
!!
!!   QUOTES
!!
!!       matching_delimiter  find position of matching delimiter
!!       unquote  remove quotes from string as if read with list-directed input
!!       quote    add quotes to string as if written with list-directed output
!!
!!
!!   CHARACTER ARRAY VERSUS STRING
!!
!!       switch  switch between a string and an array of single characters
!!       s2c     convert string to array of single characters and add null
!!               terminator for passing to C
!!       c2s     convert null-terminated array of single characters to
!!               string for converting strings returned from C
!!
!!   NONALPHA
!!
!!       noesc    convert non-printable ASCII8 characters to a space
!!       notabs   convert tabs to spaces while maintaining columns,
!!                assuming tabs are set every 8 characters
!!       dilate   function to convert tabs to spaces assuming tabs are set
!!                every 8 characters
!!       expand   expand escape sequences in a string
!!       visible  expand escape sequences in a string to "control" and
!!                meta-control representations
!!
!!   NUMERIC STRINGS
!!
!!       string_to_value   generic subroutine returns numeric value (REAL,
!!                         DOUBLEPRECISION, INTEGER) from string
!!       string_to_values  subroutine reads an array of numbers from a string
!!       getvals           subroutine reads a relatively arbitrary number
!!                         of values from a string using list-directed read
!!       s2v               function returns DOUBLEPRECISION numeric value
!!                         from string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       atoi              function returns INTEGER(kind=int32)  from a string
!!       atol              function returns INTEGER(kind=int64)  from a string
!!       aton              changes string to numeric value
!!
!!       str               append the values of up to twenty values into
!!                         a string, including user-specified separator
!!                         and a CSV-style option
!!       fmt               return string from generic  intrinsic value
!!                         using optionally specified format.
!!       value_to_string   generic subroutine returns string given numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )
!!       v2s               generic function returns string from numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER )
!!       listout           expand a list of numbers where negative numbers
!!                         denote range ends (1 -10 means 1 thru 10)
!!       isnumber          determine if string represents a number
!!
!!   CHARACTER TESTS
!!
!!       glob        compares given string for match to pattern which may
!!                   contain wildcard characters
!!       ends_with   test whether strings ends with one of the specified suffixes
!!
!!       o isalnum   returns .true. if character is a letter or digit
!!       o isalpha   returns .true. if character is a letter and
!!                   .false. otherwise
!!       o iscntrl   returns .true. if character is a delete character or
!!                   ordinary control character
!!       o isdigit   returns .true. if character is a digit (0,1,...,9)
!!                   and .false. otherwise
!!       o isgraph   returns .true. if character is a printable character
!!                   except a space is considered non-printable
!!       o islower   returns .true. if character is a miniscule letter (a-z)
!!       o isprint   returns .true. if character is an ASCII printable
!!                   character
!!       o ispunct   returns .true. if character is a printable punctuation
!!                   character
!!       o isspace   returns .true. if character is a null, space, tab,
!!                   carriage return, new line, vertical tab, or formfeed
!!       o isupper   returns .true. if character is an uppercase letter (A-Z)
!!       o isascii   returns .true. if the character is in the range char(0)
!!                   to char(127)
!!       o isblank   returns .true. if character is a blank character
!!                   (space or horizontal tab.
!!       o isxdigit  returns .true. if character is a hexadecimal digit
!!                   (0-9, a-f, or A-F).
!!
!!       fortran_name   returns .true. if input string is a valid Fortran name
!!
!!   BASE CONVERSION
!!
!!       base       convert whole number string in base [2-36] to string
!!                  in alternate base [2-36]
!!       base2      convert INTEGER to a string representing a binary value
!!       codebase   convert whole number string in base [2-36] to base
!!                  10 number
!!       decodebase convert whole number in base 10 to string in base [2-36]
!!
!!   MISCELLANEOUS
!!
!!       bundle         return up to twenty strings of arbitrary length as
!!                      an array
!!       describe       returns a string describing the name of a single
!!                      character
!!       edit_distance  returns a naive edit distance using the Levenshtein
!!                      distance algorithm
!!       longest_common_substring  function that returns the longest common
!!                                 substring of two strings.
!!
!!   INTRINSICS
!!
!!    The M_strings(3fm) module supplements and works in combination with
!!    the Fortran built-in intrinsics. Stand-alone Fortran lets you access
!!    the characters in a string using ranges much like they are character
!!    arrays, assignment, comparisons with standard operators, supports
!!    dynamically allocatable strings and supports concatenation using the //
!!    operator, as well as a number of intrinsic string routines:
!!
!!        adjustl             Left adjust a string
!!        adjustr             Right adjust a string
!!        index               Position of a substring within a string
!!        repeat              Repeated string concatenation
!!        scan                Scan a string for the presence of a set
!!                            of characters
!!        trim                Remove trailing blank characters of a string
!!        verify              Scan a string for the absence of a set of
!!                            characters
!!        len                 It returns the length of a character string
!!        achar               converts an integer into a character
!!        iachar              converts a character into an integer
!!        len_trim            finds length of string with trailing spaces
!!                            ignored
!!        new_line            Newline character
!!        selected_char_kind  Choose character kind
!!        lge                 Lexical greater than or equal
!!        lgt                 Lexical greater than
!!        lle                 Lexical less than or equal
!!        llt                 Lexical less than
!!
!!   OOPS INTERFACE
!!
!!    The M_strings__oop(3fm) module (included with the M_strings(3fm)
!!    module) provides an OOP (Object-Oriented Programming) interface to
!!    the M_strings(3fm) module.
!!
!!##SEE ALSO
!!    There are additional routines in other GPF modules for working with
!!    expressions (M_calculator), time strings (M_time), random strings
!!    (M_random, M_uuid), lists (M_list), and interfacing with the C regular
!!    expression library (M_regex).
!!
!!##EXAMPLES
!!
!!    Each of the procedures includes an [example](example/) program in
!!    the corresponding man(1) page for the function.
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_M_strings
!!      use M_strings,only : split, slice, sep, delim, chomp, strtok
!!      use M_strings,only : split2020, find_field
!!      use M_strings,only : substitute, change, modif, transliterate, &
!!              & reverse, squeeze
!!      use M_strings,only : replace, join
!!      use M_strings,only : upper, lower, upper_quoted
!!      use M_strings,only : rotate13, percent_encode, percent_decode
!!      use M_strings,only : adjustc, compact, nospace, indent
!!      use M_strings,only : crop, clip, unquote, quote, matching_delimiter
!!      use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &
!!              & stretch, lenset, merge_str
!!      use M_strings,only : switch, s2c, c2s
!!      use M_strings,only : noesc, notabs, dilate, expand, visible
!!      use M_strings,only : longest_common_substring
!!      use M_strings,only : string_to_value, string_to_values, s2v, s2vs
!!      use M_strings,only : int, real, dble, nint
!!      use M_strings,only : atoi, atol, aton
!!      use M_strings,only : value_to_string, v2s, str, fmt
!!      use M_strings,only : listout, getvals
!!      use M_strings,only : glob, ends_with
!!      use M_strings,only : paragraph
!!      use M_strings,only : base, decodebase, codebase, base2
!!      use M_strings,only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings,only : isgraph, islower, isprint, ispunct
!!      use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings,only : isnumber
!!      use M_strings,only : fortran_name
!!      use M_strings,only : describe
!!      use M_strings,only : edit_distance
!!      use M_strings,only : bundle
!!      character(len=:),allocatable :: string
!!      character(len=:),allocatable :: array(:) ! output array of tokens
!!      character(len=*),parameter   :: gen='(*(g0))'
!!      character(len=*),parameter   :: genx='(*("[",g0,"] ":))'
!!      string='abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890'
!!      write(*,gen)string
!!      write(*,gen)upper(string)
!!      write(*,gen)lower(string)
!!      call split(string,array)
!!      write(*,genx)array
!!      write(*,gen)replace(string,'qrs','--RePlace--',ignorecase=.true.)
!!      end program demo_M_strings
!!
!! Results:
!!
!!  > abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890
!!  > ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890
!!  > abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 01234567890
!!  > [abcdefghijklmnopqrstuvwxyz] [ABCDEFGHIJKLMNOPQRSTUVWXYZ] [01234567890               ]
!!  > abcdefghijklmnop--RePlace--tuvwxyz ABCDEFGHIJKLMNOP--RePlace--TUVWXYZ 01234567890
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
MODULE M_strings !
use,intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none

! ident_1="@(#) M_strings(3f) Fortran module containing routines that deal with character strings"

!-----------------------------------------------------------------------------------------------------------------------------------
private

!-------------------------# TOKENS
public split              !  subroutine parses a string on specified delimiter characters and store tokens into an allocatable array
public slice              !  subroutine parses a string on specified delimiter characters and stores positions into arrays
public sep                !  function interface to split
public chomp              !  function consumes input line as it returns next token in a string using specified delimiters
public delim              !  subroutine parses a string using specified delimiter characters and store tokens into an array
public strtok             !  gets next token. Used by change(3f)
public paragraph          !  convert a long string into a paragraph
!-------------------------# EDITING
public substitute         !  subroutine non-recursively globally replaces old substring with new substring in string
public replace            !  function non-recursively globally replaces old substring with new substring in string
public change             !  replaces old substring with new substring in string with a directive like a line editor
public modif              !  change string using a directive using rules similar to XEDIT line editor MODIFY command
public transliterate      !  when characters in set one are found replace them with characters from set two
public reverse            !  elemental function reverses character order in a string
public join               !  append an array of character variables with specified separator into a single CHARACTER variable
public squeeze            !  delete adjacent duplicate characters from a string
public rotate13           !  apply trivial encryption algorithm ROT13 to string
public percent_encode     !  percent-encode characters or a string
interface percent_encode;    module procedure percent_encode_string, percent_encode_characters;  end interface
public percent_decode     !  percent-decode characters or a string
interface percent_decode;    module procedure percent_decode_string, percent_decode_characters;  end interface
!-------------------------# CHARACTER ARRAY VERSUS STRING
public switch             !  generic switch between a string and an array of single characters (a2s,s2a)
private a2s               !  function to copy char array to string
private s2a               !  function to copy string(1:Clen(string)) to char array
public s2c                !  convert character variable to array of character(len=1) with null terminator for C compatibility
public c2s                !  convert null-terminated array of character(len=1) to string for strings returned by C
!-------------------------# CASE
public upper              !  elemental function converts string to uppercase
interface upper;    module procedure upper_all, upper_range;  end interface
public lower              !  elemental function converts string to miniscule
public upper_quoted       !  elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules
!-------------------------# WHITE SPACE
public adjustc            !  elemental function centers string within the length of the input string
public compact            !  left justify string and replace duplicate whitespace with single characters or nothing
public nospace            !  function replaces whitespace with nothing
public indent             !  count number of leading spaces
public crop               !  function trims leading and trailing spaces and control characters
public clip               !  function trims leading and trailing spaces or set of characters from string
!-------------------------# QUOTES
public matching_delimiter !  find position of matching delimiter
public unquote            !  remove quotes from string as if read with list-directed input
public quote              !  add quotes to string as if written with list-directed output
!-------------------------# STRING LENGTH
public lenset             !  return a string as specified length
public pad                !  return a string of at least specified length
public zpad               !  return a string of at least specified length padded on left with zeros
interface zpad;    module procedure zpad_scalar, zpad_vector;  end interface
public lpad               !  convert value to a string of at least specified length padded on left with zeros
interface lpad;    module procedure lpad_scalar, lpad_vector;  end interface
public cpad               !  convert value to a centered string of at least specified length
interface cpad;    module procedure cpad_scalar, cpad_vector;  end interface
public rpad               !  convert value to a string of at least specified length padded on right with zeros
interface rpad;    module procedure rpad_scalar, rpad_vector;  end interface
public stretch            !  return a string of at least specified length with suffix
public merge_str          !  make strings of equal length and then call MERGE(3f) intrinsic
public len_white          !  find location of last non-whitespace character
!-------------------------# NONALPHA
public noesc              !  elemental function converts non-printable ASCII8 characters to a space
public notabs             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public dilate             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public expand             !  expand escape sequences in a string
public visible            !  expand escape sequences in a string to control and meta-control representations
!-------------------------# NUMERIC STRINGS
public string_to_value    !  generic subroutine returns REAL|DOUBLEPRECISION|INTEGER value from string (a2d,a2r,a2i)
 private a2d              !  subroutine returns double value from string
 private a2r              !  subroutine returns real value from string
 private a2i              !  subroutine returns integer value from string
public string_to_values   !  subroutine returns values from a string
public getvals            !  subroutine returns values from a string
public s2v                !  function returns doubleprecision value from string
public s2vs               !  function returns a doubleprecision array of numbers from a string
                          !  NOT USING INTERNAL READ FOR CONVERSION
public atoi               !   function returns an INTEGER(kind=int32) value from a string
public atol               !   function returns an INTEGER(kind=int64) value from a string
public aton               !   function returns true or false as to whether string converts to numeric value, and numeric value
!------------------------------------------------------------------------------------------------------------
public str                !  function returns a string representing up to twenty scalar intrinsic values, including CSV style
public fmt                !  function returns a string representing an intrinsic value using optionally specified format
public value_to_string    !  generic subroutine returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
public v2s                !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
 private d2s              !  function returns string from doubleprecision value
 private r2s              !  function returns string from real value
 private i2s              !  function returns string from integer value
 private l2s              !  function returns string from logical value
public isnumber           !  determine if string represents a number
 private trimzeros_       !  Delete trailing zeros from numeric decimal string
public listout            !  expand a list of numbers where  negative numbers denote range ends (1 -10 means 1 thru 10)
!-----------------------------------------------------------------------------------------------------------------------------------
!
! extend intrinsics to accept CHARACTER values
!
public int, real, dble, nint

interface int;     module procedure atoi;              end interface
interface real;    module procedure real_s2v;          end interface
interface dble;    module procedure dble_s2v;          end interface
interface nint;    module procedure nint_s2v;          end interface

interface aton
module procedure ator_real32
module procedure ator_real64
module procedure atoi_int8
module procedure atoi_int16
module procedure atoi_int32
module procedure atoi_int64
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!----------------------# BIT ROUTINES
public setbits8        !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits16       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits32       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits64       !  use a string representing a positive binary value to fill the bits of an INTEGER value
!----------------------# BASE CONVERSION
public base            !  convert whole number string in base [2-36] to string in alternate base [2-36]
public codebase        !  convert whole number string in base [2-36] to base 10 number
public decodebase      !  convert whole number in base 10 to string in base [2-36]
public base2           !  convert INTEGER to a string representing a binary value
!----------------------# LOGICAL TESTS
public glob            !  compares given string for match to pattern which may contain wildcard characters
public ends_with       !  test whether strings ends with one of the specified suffix
public isalnum         !  elemental function returns .true. if CHR is a letter or digit
public isalpha         !  elemental function returns .true. if CHR is a letter and .false. otherwise
public isascii         !  elemental function returns .true. if the low order byte of c is in the range char(0) to char(127)
public isblank         !  elemental function returns .true. if CHR is a blank character (space or horizontal tab.
public iscntrl         !  elemental function returns .true. if CHR is a delete character or ordinary control character
public isdigit         !  elemental function returns .true. if CHR is a digit (0,1,...,9) and .false. otherwise
public isgraph         !  elemental function true if CHR is an ASCII printable character except considers a space non-printable
public islower         !  elemental function returns .true. if CHR is a miniscule letter (a-z)
public isprint         !  elemental function determines if CHR is an ASCII printable character
public ispunct         !  elemental function returns .true. if CHR is a printable punctuation character
public isspace         !  elemental function true if CHR is a null, space, tab, carriage return, new line, vertical tab, or formfeed
public isupper         !  elemental function returns .true. if CHR is an uppercase letter (A-Z)
public isxdigit        !  elemental function returns .true. if CHR is a hexadecimal digit (0-9, a-f, or A-F).
!----------------------#
!-------------------------------#
public fortran_name             !  elemental function returns .true. if LINE is a valid Fortran name
public describe                 !  returns a string describing character
public edit_distance            !  returns a naive edit distance using the Levenshtein distance algorithm
public bundle                   !  return up to twenty strings of arbitrary length as an array
public longest_common_substring !  function that returns the longest common substring of two strings.
!-------------------------------#

!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_strings switch(3f) toggle between string and array of characters; generic{a2s s2a}"

interface switch
   module procedure a2s, s2a
end interface switch
! note how returned result is "created" by the function
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_3="@(#) M_strings string_to_value(3f) Generic subroutine converts numeric string to a number (a2d a2r a2i)"

interface string_to_value
   module procedure a2d, a2r, a2i
end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_4="@(#) M_strings v2s(3f) Generic function returns string given REAL|INTEGER|DOUBLEPRECISION value(d2s r2s i2s)"

interface v2s
   module procedure d2s, r2s, i2s, l2s
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!-!interface setbits ! boz
!-!        module procedure setbits8, setbits16, setbits32, setbits64
!-!end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_5="@(#) M_strings str(3f) convert up to twenty scalar values to a (CSV) string. Alternatively can also handle one-dimensional arrays"

interface str
   module procedure str_scalar, str_one
end interface str
!-----------------------------------------------------------------------------------------------------------------------------------
! ASCII character constants
character, public, parameter :: ascii_nul = char(0)   ! null
character, public, parameter :: ascii_bel = char(7)   ! bell
character, public, parameter :: ascii_bs  = char(8)   ! backspace
character, public, parameter :: ascii_ht  = char(9)   ! horizontal tab
character, public, parameter :: ascii_lf  = char(10)  ! line feed or newline
character, public, parameter :: ascii_ff  = char(12)  ! form feed or newpage
character, public, parameter :: ascii_cr  = char(13)  ! carriage return
character, public, parameter :: ascii_esc = char(27)  ! escape
!-----------------------------------------------------------------------------------------------------------------------------------
interface ends_with
    procedure :: ends_with_str
    procedure :: ends_with_any
end interface ends_with
!-----------------------------------------------------------------------------------------------------------------------------------
public :: split2020, string_tokens
public :: find_field

interface split2020
   module procedure :: split_tokens, split_first_last, split_pos
end interface split2020
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
!This contains a conditionally built mini-version of M_journal which allows the M_strings.f90 module
!to be built using make as a stand-alone distribution but still have make.shell build a true version
!
!This is so when built with make.shell(1) or fpm(1) it will use the
!real M_journal.f90 file but that fpm(1) will not auto-discover the mini
!M_journal.f90 file and build it and cause duplicates.

interface journal
   module procedure flush_trail                    ! journal()        ! no options
   module procedure write_message_only             ! journal(c)       ! must have one string
   module procedure where_write_message            ! journal(where,c)
end interface journal

!$@(#) M_journal::journal(3fg): provides public message routine, no paging or graphic mode change

! global variables

integer,save,private :: stdout=OUTPUT_UNIT
logical,save         :: debug=.false.
integer,save         :: last_int=0
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
! for compatibility allow old name for renamed procedures
interface matchw;   module procedure  glob;                end interface
interface atleast;  module procedure  pad;                 end interface
interface cc;       module procedure  bundle;              end interface
interface msg;      module procedure  str_scalar,str_one;  end interface  msg
public matchw          !  clone of glob -- for backward compatibiity
public atleast         !  clone of pad -- for backward compatibiity
public cc              !  clone of pad -- for backward compatibiity
public msg             !  function returns a string representing up to twenty scalar intrinsic values, including CSV style
!-----------------------------------------------------------------------------------------------------------------------------------
CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob(3f) compares an (entire) STRING for a match to a PATTERN which
!!    may contain basic wildcard "globbing" characters.
!!
!!    "*" matches any string. "?" matches any single character.
!!
!!    In this version to get a match the entire string must be described by
!!    PATTERN. Trailing whitespace is significant, so trim the input string
!!    to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the first
!!    match found is not at the end of the string so 'baba' does not match
!!    'babababa'. So the algorithm is said to find an early match.
!!
!!    To skip over the early matches insert an extra character at the end of
!!    the string and pattern that does not occur in the pattern. Typically a
!!    NULL is used (char(0)). So searching for b*ba\0 in babababa\0 matches
!!    the entire string.
!!
!!##OPTIONS
!!    string   the input string to be tested for a match to the pattern.
!!    pattern  the globbing pattern to search for. The following simple
!!             globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or trimmed
!!               before the comparison.
!!             o There is no escape character, so matching strings with
!!               a literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    implicit none
!!    ! This main() routine passes a bunch of test strings
!!    ! into the above code.  In performance comparison mode,
!!    ! it does that over and over. Otherwise, it does it just
!!    ! once. Either way, it outputs a passed/failed result.
!!    !
!!    integer :: nReps
!!    logical :: allpassed
!!    integer :: i
!!    allpassed = .true.
!!
!!    nReps = 10000
!!    ! Can choose as many repetitions as you're expecting
!!    ! in the real world.
!!    nReps = 1
!!
!!    do i=1,nReps
!!       ! Cases with repeating character sequences.
!!       allpassed= test("a*abab",      "a*b",   .true.)  .and. allpassed
!!       allpassed= test("ab",          "*?",    .true.)  .and. allpassed
!!       allpassed= test("abc",         "*?",    .true.)  .and. allpassed
!!       allpassed= test("abcccd",      "*ccd",  .true.)  .and. allpassed
!!       allpassed= test("bLah",        "bLaH",  .false.) .and. allpassed
!!       allpassed= test("mississippi", "*sip*", .true.)  .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("mississipissippi", "*issip*ss*", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) .and. allpassed
!!       allpassed= test("xyxyxyzyxyz", "xy*z*xyz", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",   .true.)  .and. allpassed
!!       allpassed= test("mississippi", "mi*sip*",  .true.)  .and. allpassed
!!       allpassed= test("ababac",      "*abac*",   .true.)  .and. allpassed
!!       allpassed= test("aaazz",       "a*zz*",    .true.)  .and. allpassed
!!       allpassed= test("a12b12",      "*12*23",   .false.) .and. allpassed
!!       allpassed= test("a12b12",      "a12b",     .false.) .and. allpassed
!!       allpassed= test("a12b12",      "*12*12*",  .true.)  .and. allpassed
!!
!!       ! Additional cases where the '*' char appears in the tame string.
!!       allpassed= test("*",     "*",      .true.)  .and. allpassed
!!       allpassed= test("a*r",   "a*",     .true.)  .and. allpassed
!!       allpassed= test("a*ar",  "a*aar",  .false.) .and. allpassed
!!
!!       ! More double wildcard scenarios.
!!       allpassed= test("XYXYXYZYXYz", "XY*Z*XYz",  .true.)  .and. allpassed
!!       allpassed= test("missisSIPpi", "*SIP*",     .true.)  .and. allpassed
!!       allpassed= test("mississipPI", "*issip*PI", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",    .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*sip*",   .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*Sip*",   .false.) .and. allpassed
!!       allpassed= test("abAbac",      "*Abac*",    .true.)  .and. allpassed
!!       allpassed= test("aAazz",       "a*zz*",     .true.)  .and. allpassed
!!       allpassed= test("A12b12",      "*12*23",    .false.) .and. allpassed
!!       allpassed= test("a12B12",      "*12*12*",   .true.)  .and. allpassed
!!       allpassed= test("oWn",         "*oWn*",     .true.)  .and. allpassed
!!
!!       ! Completely tame (no wildcards) cases.
!!       allpassed= test("bLah", "bLah", .true.) .and. allpassed
!!
!!       ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
!!       allpassed= test("a", "*?", .true.) .and. allpassed
!!
!!       ! More mixed wildcard tests including coverage for false positives.
!!       allpassed= test("a",      "??",         .false.) .and. allpassed
!!       allpassed= test("ab",     "?*?",        .true.)  .and. allpassed
!!       allpassed= test("ab",     "*?*?*",      .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*?",     .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*&?",    .false.) .and. allpassed
!!       allpassed= test("abcd",   "?b*??",      .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?a*??",      .false.) .and. allpassed
!!       allpassed= test("abcd",   "?**?c?",     .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?**?d?",     .false.) .and. allpassed
!!       allpassed= test("abcde",  "?*b*?*d*?",  .true.)  .and. allpassed
!!
!!       ! Single-character-match cases.
!!       allpassed= test("bLah",   "bL?h",  .true.)  .and. allpassed
!!       allpassed= test("bLaaa",  "bLa?",  .false.) .and. allpassed
!!       allpassed= test("bLah",   "bLa?",  .true.)  .and. allpassed
!!       allpassed= test("bLaH",   "?Lah",  .false.) .and. allpassed
!!       allpassed= test("bLaH",   "?LaH",  .true.)  .and. allpassed
!!
!!       allpassed= test('abcdefghijk' ,  '?b*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c',      .false.) .and.  allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*k',    .true.)  .and. allpassed
!!       allpassed= test('LS'          ,  '?OW',     .false.) .and.  allpassed
!!       allpassed= test('teztit'      ,  'tez*t*t', .true.)  .and. allpassed
!!         ! Two pattern match problems that might pose difficulties
!!       allpassed= test('e '           , '*e* ',      .true.) .and. allpassed
!!       allpassed= test('abcde       ' , '*e      *', .true.) .and. allpassed
!!       allpassed= test('bababa'       , 'b*ba',      .true.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*ax',      .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*ax',      .false.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*a',       .false.) .and. allpassed
!!       allpassed= test(''             , 'b*',        .false.) .and. allpassed
!!       allpassed= test(''             , '*',         .true.) .and.  allpassed
!!       allpassed= test('b'            , '',          .false.) .and. allpassed
!!       allpassed= test('3'            , '??',        .false.) .and. allpassed
!!       ! known flaws
!!       allpassed= test(''             , '',          .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*a',       .true.) .and. allpassed
!!       ! add unused character to work around
!!       allpassed= test(''//char(0),      ''//char(0),   .true.).and.allpassed
!!       allpassed= test('baaaaa'//char(0),'b*a'//char(0),.true.).and.allpassed
!!
!!       ! Many-wildcard scenarios.
!!       allpassed= test(&
!!       &"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!!       &aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&
!!       &"a*a*a*a*a*a*aa*aaa*a*a*b",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacac&
!!       &adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacaca&
!!       &cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("aaabbaabbaab","*aabbaa*a*",.true.).and.allpassed
!!       allpassed= &
!!       test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",&
!!       &"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       & "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&
!!       &*abc*abc*abc*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc*abcd*abcd*abc*abcd",&
!!       &"abc*abc*abc*abc*abc", .false.) .and. allpassed
!!       allpassed= test( "abc*abcd*abcd*abc*abcd*abcd&
!!       &*abc*abcd*abc*abc*abcd", &
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc",&
!!       &"********a********b********c********", .true.) .and. allpassed
!!       allpassed=&
!!       &test("********a********b********c********", "abc",.false.)&
!!       & .and.allpassed
!!       allpassed= &
!!       &test("abc", "********a********b********b********",.false.)&
!!       & .and.allpassed
!!       allpassed= test("*abc*", "***a*b*c***", .true.) .and. allpassed
!!
!!       ! A case-insensitive algorithm test.
!!       ! allpassed=test("mississippi", "*issip*PI", .true.) .and. allpassed
!!     enddo
!!
!!     if (allpassed)then
!!        write(*,'(*(g0,1x))')"Passed",nReps
!!     else
!!        write(*,'(a)')"Failed"
!!     endif
!!    contains
!!    ! This is a test program for wildcard matching routines.
!!    ! It can be used either to test a single routine for correctness,
!!    ! or to compare the timings of two (or more) different wildcard
!!    ! matching routines.
!!    !
!!    function test(tame, wild, bExpectedResult) result(bPassed)
!!    use M_strings, only : glob
!!       character(len=*) :: tame
!!       character(len=*) :: wild
!!       logical          :: bExpectedResult
!!       logical          :: bResult
!!       logical          :: bPassed
!!       bResult = .true.    ! We'll do "&=" cumulative checking.
!!       bPassed = .false.   ! Assume the worst.
!!       write(*,*)repeat('=',79)
!!       bResult = glob(tame, wild) ! Call a wildcard matching routine.
!!
!!       ! To assist correctness checking, output the two strings in any
!!       ! failing scenarios.
!!       if (bExpectedResult .eqv. bResult) then
!!          bPassed = .true.
!!          if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
!!       else
!!          if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
!!       endif
!!
!!    end function test
!!    end program demo_glob
!!
!!   Expected output
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCES
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob(tame,wild)

! ident_6="@(#) M_strings glob(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                      :: glob
character(len=*)             :: tame       ! A string without wildcards
character(len=*)             :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1)   :: tametext
character(len=len(wild)+1)   :: wildtext
character(len=1),parameter   :: NULL=char(0)
integer                      :: wlen
integer                      :: ti, wi
integer                      :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi) == '*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi) == NULL) then        ! "x" matches "*"
            glob=.true.
            return
         endif
         if(wildtext(wi:wi)  /=  '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti)  /=  wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti) == NULL)then
                  glob=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark /= NULL) then
            if(wildtext(wi:) /=  wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti)  /=  wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti) /= NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti > len(tametext)) then
         glob=.false.
         return
      elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi) /= NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi) == NULL)exit
            enddo
         endif
         if (wildtext(wi:wi) == NULL)then
            glob=.true.
            return                               ! "x" matches "x"
         endif
         glob=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    ends_with(3f) - [M_strings:COMPARE] test if string ends with specified
!!                    suffix(es)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function ends_with(source_string[,suffix][,ignorecase])
!!
!!     character(len=*),intent(in) :: source_string
!!     character(len=*),intent(in) :: suffix(..)
!!     logical,intent(in),optional :: ignorecase
!!     logical                     :: ends_with
!!
!!##DESCRIPTION
!!
!!    ends_with(3f) tests if a string ends with any specified suffix. Differs
!!    from using index(3f) in that the input file and multiple suffices
!!    are trimmed by ends_with(3f),
!!
!!##OPTIONS
!!     SOURCE_STRING  string to search
!!     SUFFIX         list of separator strings. May be scalar or an array.
!!                    Trailing spaces in SUFFIX are ignored.
!!     IGNORECASE     If .true. case is ignored.
!!
!!##RETURNS
!!     ENDS_WITH      returns .TRUE. if one of the suffix match the end
!!                    of SOURCE_STRING.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_ends_with
!!    use M_strings, only : ends_with
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!    character(len=:),allocatable :: line, pattern
!!    !
!!       write(*,*)'basic usage'
!!       write(stdout,*)ends_with('prog.a','.a'), 'should be true'
!!       write(stdout,*)ends_with('prog.a','.o'), 'should be false'
!!       write(stdout,*)ends_with('prog.a',['.o','.i','.s'])
!!       write(stdout,*)ends_with('prog.f90',['.F90','.f90','.f  ','.F  '])
!!       !
!!       write(*,*)'ignored case'
!!       write(stdout,*)ends_with('prog.F90',['.f90','.f  '],ignorecase=.true.)
!!       !
!!       write(*,*)'trailing whitespace is ignored'
!!       write(stdout,*)ends_with('prog.pdf','.pdf')
!!       write(stdout,*)ends_with('prog.pdf','.pdf ')
!!       write(stdout,*)ends_with('prog.pdf ','.pdf ')
!!       write(stdout,*)ends_with('prog.pdf  ','.pdf ')
!!       !
!!       write(*,*)'equivalent using index(3f)'
!!       line=   'myfile.doc  '
!!       pattern='.doc        '
!!       write(stdout,*)&
!!       &index(trim(line),trim(pattern),back=.true.)==len_trim(line)-len_trim(pattern)+1
!!       write(stdout,*)ends_with(line,pattern)
!!    end program demo_ends_with
!!
!! Results:
!!
!!     >  basic usage
!!     >  T should be true
!!     >  F should be false
!!     >  F
!!     >  T
!!     >  ignored case
!!     >  T
!!     >  trailing whitespace is ignored
!!     >  T
!!     >  T
!!     >  T
!!     >  T
!!     >  equivalent using index(3f)
!!     >  T
!!     >  T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function ends_with_str(string, ending,ignorecase) result(matched)
character(*), intent(in)     :: string, ending
logical,intent(in),optional  :: ignorecase
integer                      :: n1, n2
logical                      :: matched
logical                      :: ignorecase_local
   if(present(ignorecase))then
           ignorecase_local=ignorecase
   else
           ignorecase_local=.false.
   endif
   n1 = len_trim(string) - len_trim(ending) + 1
   n2 = len_trim(string)
   if (n1 < 1) then
       matched = .false.
   else
       if(ignorecase_local)then
          matched = (upper(string(n1:n2)) == upper(ending))
       else
          matched = (string(n1:n2) == ending)
       endif
   endif
end function ends_with_str
!-----------------------------------------------------------------------------------------------------------------------------------
pure function ends_with_any(string, endings,ignorecase) result(matched)
character(*), intent(in)     :: string
character(*), intent(in)     :: endings(:)
logical,intent(in),optional  :: ignorecase
logical                      :: matched
integer                      :: i
   matched = .true.
   FINDIT: block
   do i=1, size(endings)
       if( ends_with_str(string,endings(i),ignorecase) ) exit FINDIT
   enddo
   matched = .false.
   endblock FINDIT
end function ends_with_any
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sep(3f) - [M_strings:TOKENS] function to parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function sep(input_line,delimiters,nulls)
!!
!!     character(len=*),intent(in)          :: input_line
!!     character(len=*),optional,intent(in) :: delimiters
!!     character(len=*),optional,intent(in) :: nulls
!!     character(len=:),allocatable         :: sep(:)
!!
!!##DESCRIPTION
!!     sep(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!    ORDER='ASCENDING'|'DESCENDING'  by default the tokens are returned from
!!                                    last to first; order='ASCENDING' returns
!!                                    them from first to last (left to right).
!!##RETURNS
!!    SEP       Output array of tokens
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_sep
!!    use M_strings, only: sep
!!    character(len=*),parameter :: fo='(/,a,*(/,"[",g0,"]":,","))'
!!    character(len=*),parameter :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!       write(*,'(a)') 'INPUT LINE:['//LINE//']'
!!       write(*,fo) 'typical call:',sep(line)
!!       write(*,fo) 'delimiters ":|":',sep(line,':|')
!!       write(*,fo) 'count null fields ":|":',sep(line,':|','return')
!!    end program demo_sep
!!
!!  Output
!!
!!    INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!
!!    typical call:
!!    [cc        ],
!!    [B         ],
!!    [a         ],
!!    [333|333   ],
!!    [1:|:2     ],
!!    [qrstuvwxyz],
!!    [ghijklmnop],
!!    [aBcdef    ]
!!
!!    delimiters ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!    count null fields ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [                                   ],
!!    [                                   ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sep(input_line,delimiters,nulls,order)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_7="@(#) M_strings sep(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=*),optional,intent(in)     :: order       ! return strings composed of delimiters or not ignore|return|ignoreend

character(len=:),allocatable             :: sep(:)      ! output array of tokens
integer                                  :: isize
   call split(input_line,sep,delimiters,'right',nulls)
   if(present(order))then
   select case(order)
   case('ascending','ASCENDING')
    isize=size(sep)
    if(isize > 1)then
       sep=sep(isize:1:-1)
    endif
   end select
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!
!!##DESCRIPTION
!!     SPLIT(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!                (This can be accomplished with array syntax in modern
!!                Fortran, but was more useful pre-fortran90).
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_split
!!    use M_strings, only: split
!!    implicit none
!!    integer                      :: i
!!    character(len=*),parameter   :: title='(80("="),t1,a)'
!!    character(len=*),parameter   :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!    character(len=:),allocatable :: array(:) ! output array of tokens
!!       write(*,*)'INPUT LINE:['//line//']'
!!       !
!!       write(*,title)'typical call: '
!!       call split(line,array)
!!       call printme()
!!       !
!!       write(*,title)'custom delimiters=":|" : '
!!       call split(line,array,delimiters=':|',&
!!       & order='sequential',nulls='ignore')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'delimiters=":|",reverse array order and count null fields:'
!!       call split(line,array,delimiters=':|',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'default delimiters, reverse array order and return null fields:'
!!       call split(line,array,delimiters='',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!    contains
!!    subroutine printme()
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!    end subroutine printme
!!    end program demo_split
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  > 1 ==> aBcdef
!!  > 2 ==> ghijklmnop
!!  > 3 ==> qrstuvwxyz
!!  > 4 ==> 1:|:2
!!  > 5 ==> 333|333
!!  > 6 ==> a
!!  > 7 ==> B
!!  > 8 ==> cc
!!  >  SIZE:           8
!!  > custom delimiters=":|" : =============================================
!!  > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  > 2 ==> 2     333
!!  > 3 ==> 333 a B cc
!!  >  SIZE:           3
!!  > delimiters=":|",reverse array order and count null fields:============
!!  > 1 ==> 333 a B cc
!!  > 2 ==> 2     333
!!  > 3 ==>
!!  > 4 ==>
!!  > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  >  SIZE:           5
!!  > default delimiters, reverse array order and return null fields:=======
!!  > 1 ==>
!!  > 2 ==>
!!  > 3 ==>
!!  > 4 ==> cc
!!  > 5 ==> B
!!  > 6 ==> a
!!  > 7 ==> 333|333
!!  > 8 ==>
!!  > 9 ==>
!!  > 10 ==>
!!  > 11 ==>
!!  > 12 ==> 1:|:2
!!  > 13 ==>
!!  > 14 ==> qrstuvwxyz
!!  > 15 ==> ghijklmnop
!!  > 16 ==>
!!  > 17 ==>
!!  > 18 ==> aBcdef
!!  > 19 ==>
!!  > 20 ==>
!!  >  SIZE:          20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_8="@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iend(:)                ! positions in input string where tokens end
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: i20                    ! loop counters
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   call  slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=trim(lower(adjustl(nulls))); else; nlls='ignore'    ; endif ! optional parameter
   if(present(order))then; ordr=trim(lower(adjustl(order))); else; ordr='sequential'; endif ! decide on value for ORDER parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ordr)                                             ! decide which order to store tokens
   case ('reverse','right') ; ii=size(ibegin) ; iiii=-1           ! last to first
   case default             ; ii=1            ; iiii=1            ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   imax=maxval(iend-ibegin+1)
   allocate(character(len=imax) :: array(size(ibegin)))           ! allocate the array to return
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,size(ibegin)                                          ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (nlls)
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iend(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    slice(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!!
!!     character(len=*),intent(in)          :: input_line
!!     integer,allocatable,intent(out)      :: ibegin(:),iend(:)
!!     character(len=*),optional,intent(in) :: delimiters
!!     character(len=*),optional,intent(in) :: nulls
!!
!!##DESCRIPTION
!!     slice(3f) parses a string using specified delimiter characters and
!!     store token beginning and ending positions into allocatable arrays
!!
!!##OPTIONS
!!    INPUT_LINE   Input string to tokenize
!!
!!    IBEGIN,IEND  arrays containing start and end positions of tokens.
!!                 IEND(I)<IBEGIN(I) designates a null token.
!!
!!    DELIMITERS   List of delimiter characters.
!!                 The default delimiters are the "whitespace" characters
!!                 (space, tab,new line, vertical tab, formfeed, carriage
!!                 return, and null). You may specify an alternate set of
!!                 delimiter characters.
!!
!!                 Multi-character delimiters are not supported (Each
!!                 character in the DELIMITERS list is considered to be
!!                 a delimiter).
!!
!!                 Quoting of delimiter characters is not supported.
!!
!!    NULLS="IGNORE"|"RETURN"|"IGNOREEND"  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_slice
!!     use M_strings, only: slice
!!     implicit none
!!     integer                    :: i
!!     character(len=*),parameter :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     integer,allocatable        :: ibegin(:), iend(:) ! output arrays of positions
!!     character(len=*),parameter :: title='(80("="),t1,a)'
!!        write(*,*)'INPUT LINE:['//line//']'
!!        !
!!        write(*,title)'typical call: '
!!        call slice(line,ibegin,iend)
!!        call printme()
!!        !
!!        write(*,title)'custom list of delimiters=":|" : '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='ignore')
!!        call printme()
!!        !
!!        write(*,title)'delimiters=":|", and count null fields: '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='return')
!!        call printme()
!!        !
!!        write(*,title)'default delimiters and return null fields: '
!!        call slice(line,ibegin,iend,delimiters='',nulls='return')
!!        call printme()
!!     contains
!!     subroutine printme()
!!        write(*,'((*(:/,3x,"[",g0,"]")))')&
!!                & (line(ibegin(i):iend(i)),i=1,size(ibegin))
!!        write(*,'(*(g0,1x))')'SIZE:',size(ibegin)
!!     end subroutine printme
!!     end program demo_slice
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  >
!!  >    [aBcdef]
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    [1:|:2]
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  > SIZE: 8
!!  > custom list of delimiters=":|" : =====================================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 3
!!  > delimiters=":|", and count null fields: ==============================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    []
!!  >    []
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 5
!!  > default delimiters and return null fields: ===========================
!!  >
!!  >    []
!!  >    []
!!  >    [aBcdef]
!!  >    []
!!  >    []
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    []
!!  >    [1:|:2]
!!  >    []
!!  >    []
!!  >    []
!!  >    []
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  >    []
!!  >    []
!!  >    []
!!  > SIZE: 20
!! ======================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_9="@(#) M_strings slice(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
integer,allocatable,intent(out)          :: ibegin(:)   ! positions in input string where tokens start
integer,allocatable,intent(out)          :: iend(:)     ! positions in input string where tokens end
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
!-----------------------------------------------------------------------------------------------------------------------------------
integer                         :: n                      ! max number of strings INPUT_LINE could slice into if all delimiter
character(len=:),allocatable    :: dlim                   ! string containing delimiter characters
character(len=:),allocatable    :: nlls                   ! string containing nulls keyword
integer                         :: icount                 ! number of tokens found
integer                         :: ii                     ! loop parameters used to control print order
integer                         :: lgth                   ! length of input string with trailing spaces trimmed
integer                         :: i10,i20,i30            ! loop counters
integer                         :: icol                   ! pointer into input string as it is being parsed
integer                         :: idlim                  ! number of delimiter characters
integer                         :: ifound                 ! where next delimiter character is found in remaining input string data
integer                         :: inotnull               ! count strings not composed of delimiters
integer                         :: ireturn                ! number of tokens returned
integer                         :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could slice into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ?
   if(allocated(iend))deallocate(iend)      !x! intel compiler says allocated already ?
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iend(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iend(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   lgth=len(input_line)                                           ! lgth is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lgth > 0)then                                              ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,lgth,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iend(i30)=lgth                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               IF(ifound > 0)then
                  iend(i30)=min(iend(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iend(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iend(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iend(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > lgth)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   ii=0
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            ii=ii+1
            ibegin(ii)=ibegin(i20)
            iend(ii)=iend(i20)
         end select
      else
         ii=ii+1
         ibegin(ii)=ibegin(i20)
         iend(ii)=iend(i20)
      endif
   enddo
   ibegin=ibegin(:ii)
   iend=iend(:ii)
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine slice
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    chomp(3f) - [M_strings:TOKENS] Tokenize a string, consuming it one
!!    token per call
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function chomp(source_string,token[,delimiters])
!!
!!     character(len=*)                     :: source_string
!!     character(len=:),intent(out)         :: token
!!     character(len=:),intent(in),optional :: delimiters
!!     integer                              :: chomp
!!
!!##DESCRIPTION
!!    The CHOMP(3f) function is used to isolate sequential tokens in a
!!    string, SOURCE_STRING. These tokens are delimited in the string by at
!!    least one of the characters in DELIMITERS. This routine consumes the
!!    source_string one token per call. It returns -1 when complete. The
!!    default delimiter list is "space,tab,carriage return,newline".
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     DELIMITERS     list of separator characters
!!
!!##RETURNS
!!     TOKEN          returned token
!!     CHOMP          status flag. 0 = success, -1 = no tokens remain
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_chomp
!!
!!    use M_strings, only : chomp
!!    implicit none
!!    character(len=100)            :: inline
!!    character(len=:),allocatable  :: token
!!    character(len=*),parameter    :: delimiters=' ;,'
!!    integer                       :: iostat
!!    integer                       :: icount
!!    integer                       :: itoken
!!       icount=0
!!       do        ! read lines from stdin until end-of-file or error
!!          read (unit=*,fmt="(a)",iostat=iostat) inline
!!          if(iostat /= 0)stop
!!          icount=icount+1
!!          itoken=0
!!          write(*,*)'INLINE ',trim(inline)
!!          do while ( chomp(inline,token,delimiters) >=  0)
!!             itoken=itoken+1
!!             print *, itoken,'TOKEN=['//trim(token)//']'
!!          enddo
!!       enddo
!!
!!    end program demo_chomp
!!
!!   sample input file
!!
!!     this is a test of chomp; A:B :;,C;;
!!
!!   sample output file
!!
!!     > INLINE     this is a test of chomp; A:B :;,C;;
!!     >           1 TOKEN=[this]
!!     >           2 TOKEN=[is]
!!     >           3 TOKEN=[a]
!!     >           4 TOKEN=[test]
!!     >           5 TOKEN=[of]
!!     >           6 TOKEN=[chomp]
!!     >           7 TOKEN=[A:B]
!!     >           8 TOKEN=[:]
!!     >           9 TOKEN=[C]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION chomp(source_string,token,delimiters)

! ident_10="@(#) M_strings chomp(3f) Tokenize a string JSU- 20151030"

character(len=*)                         :: source_string    ! string to tokenize
character(len=:),allocatable,intent(out) :: token            ! returned token
character(len=*),intent(in),optional     :: delimiters       ! list of separator characters
integer                                  :: chomp            ! returns copy of shifted source_string
character(len=:),allocatable             :: delimiters_local
integer                                  :: token_start      ! beginning of token found if function result is .true.
integer                                  :: token_end        ! end of token found if function result is .true.
integer                                  :: isource_len
!-----------------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(present(delimiters))then
      delimiters_local=delimiters
   else                                          ! increment start to previous end + 1
      delimiters_local=char(32)//char(09)//char(10)//char(13) ! space,horizontal tab, newline, carriage return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   token_start=1
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)                         ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
   !write(*,*)'TOKEN_START ',token_start
   !write(*,*)'TOKEN_END   ',token_end
   chomp=isource_len-token_end
   if(chomp >= 0)then
      token=source_string(token_start:token_end)
      source_string=source_string(token_end+1:)
   else
      token=''
      source_string=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function chomp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      delim(3f) - [M_strings:TOKENS] parse a string and store tokens into
!!      an array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)
!!
!!     character(len=*),intent(in)  :: line
!!     integer,integer(in)          :: n
!!     integer,intent(out)          :: icount
!!     character(len=*)             :: array(n)
!!     integer,intent(out)          :: ibegin(n)
!!     integer,intent(out)          :: iterm(n)
!!     integer,intent(out)          :: lgth
!!     character(len=*)             :: dlim
!!
!!##DESCRIPTION
!!      Given a LINE of structure " par1 par2 par3 ... parn "
!!      store each par(n) into a separate variable in ARRAY (UNLESS
!!      ARRAY(1) == '#N#')
!!
!!      Also set ICOUNT to number of elements of array initialized, and
!!      return beginning and ending positions for each element in IBEGIN(N)
!!      and ITERM(N).
!!
!!      Return position of last non-blank character (even if more
!!      than N elements were found) in lgth
!!
!!      No quoting or escaping of delimiter is allowed, so the delimiter
!!      character can not be placed in a token.
!!
!!      No checking for more than N parameters; If any more they are ignored.
!!
!!      This routine originates pre-Fortran90. A version using optional parameters
!!      and allocatable arrays is on the TODO list.
!!
!!##OPTIONS
!!    LINE       input string to parse into tokens
!!    ARRAY(N)   array that receives tokens
!!    N          size of arrays ARRAY, IBEGIN, ITERM
!!    ICOUNT     number of tokens found
!!    IBEGIN(N)  starting columns of tokens found
!!    ITERM(N)   ending columns of tokens found
!!    LGTH       position of last non-blank character in input string LINE
!!    DLIM       delimiter characters
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_delim
!!
!!     use M_strings, only: delim
!!     implicit none
!!     character(len=80) :: line
!!     character(len=80) :: dlm
!!     integer,parameter :: n=80
!!     character(len=20) :: array(n)=' '
!!     integer           :: ibegin(n),iterm(n)
!!     integer           :: i20, icount, lgth, i10,i30
!!     line=' first  second 10.3 words_of_stuff  '
!!     do i20=1,4
!!        ! change delimiter list and what is calculated or parsed
!!        if(i20 == 1)dlm=' '
!!        if(i20 == 2)dlm='o'
!!        if(i20 == 3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
!!        if(i20 == 3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
!!        if(i20 == 4)line='AAAaBBBBBBbIIIIIi  J K L'
!!
!!        ! write out a break line composed of =========== ..
!!        write(*,'(57("="))')
!!        ! show line being parsed
!!        write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
!!        ! call parsing procedure
!!        call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
!!        write(*,*)'number of tokens found=',icount
!!        write(*,*)'last character in column ',lgth
!!        if(icount > 0)then
!!           if(lgth /= iterm(icount))then
!!              write(*,*)'ignored from column ',iterm(icount)+1,' to ',lgth
!!           endif
!!           do i10=1,icount
!!              ! check flag to see if ARRAY() was set
!!              if(array(1) /= '#N#')then
!!                 ! from returned array
!!                 write(*,'(a,a,a)',advance='no')&
!!                 &'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
!!              endif
!!           enddo
!!           ! using start and end positions in IBEGIN() and ITERM()
!!           write(*,*)
!!           do i10=1,icount
!!              ! from positions in original line
!!              write(*,'(a,a,a)',advance='no')&
!!              &'[',line(ibegin(i10):iterm(i10)),']'
!!           enddo
!!           write(*,*)
!!        endif
!!     enddo
!!        line='four    score and   seven  years ago'
!!        call delim(line,["#N#"],n,icount,ibegin,iterm,lgth,' ')
!!        do i30=1,icount
!!           write(*,*)ibegin(i30),iterm(i30),&
!!           & '['//line(ibegin(i30):iterm(i30))//']'
!!        enddo
!!
!!     end program demo_delim
!!
!! Results:
!!
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [first][second][10.3][words_of_stuff]
!!  > [first][second][10.3][words_of_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on o
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on  aeiou
!!  >  number of tokens found=          10
!!  >  last character in column           34
!!  >
!!  > [f][rst][s][c][nd][10.3][w][rds_][f_st][ff]
!!  > =========================================================
!!  > PARSING=[AAAaBBBBBBbIIIIIi  J K L] on  aeiou
!!  >  number of tokens found=           5
!!  >  last character in column           24
!!  >
!!  > [AAA][BBBBBBbIIIII][J][K][L]
!!  >            1           4 [four]
!!  >            9          13 [score]
!!  >           15          17 [and]
!!  >           21          25 [seven]
!!  >           28          32 [years]
!!  >           34          36 [ago]
!! ================================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)

! ident_11="@(#) M_strings delim(3f) parse a string and store tokens into an array"

!
!     given a line of structure " par1 par2 par3 ... parn "
!     store each par(n) into a separate variable in array.
!
!     IF ARRAY(1) == '#N#' do not store into string array  (KLUDGE))
!
!     also count number of elements of array initialized, and
!     return beginning and ending positions for each element.
!     also return position of last non-blank character (even if more
!     than n elements were found).
!
!     no quoting of delimiter is allowed
!     no checking for more than n parameters, if any more they are ignored
!
character(len=*),intent(in)    :: line
integer,intent(in)             :: n
character(len=*)               :: array(n)
integer,intent(out)            :: icount
integer,intent(out)            :: ibegin(n)
integer,intent(out)            :: iterm(n)
integer,intent(out)            :: lgth
character(len=*),intent(in)    :: dlim
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(line)):: line_local
logical             :: lstore
integer             :: i10
integer             :: iarray
integer             :: icol
integer             :: idlim
integer             :: iend
integer             :: ifound
integer             :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
      icount=0
      lgth=len_trim(line)
      line_local=line

      idlim=len(dlim)
      if(idlim > 5)then
         idlim=len_trim(dlim)      ! dlim a lot of blanks on some machines if dlim is a big string
         if(idlim == 0)then
            idlim=1     ! blank string
         endif
      endif

      if(lgth == 0)then                                        ! command was totally blank
         return
      endif
!
!     there is at least one non-blank character in the command
!     lgth is the column position of the last non-blank character
!     find next non-delimiter
      icol=1

      if(array(1) == '#N#')then                                ! special flag to not store into character array
         lstore=.false.
      else
         lstore=.true.
      endif

      do iarray=1,n,1                                          ! store into each array element until done or too many words
         NOINCREMENT: do
            if(index(dlim(1:idlim),line_local(icol:icol)) == 0)then  ! if current character is not a delimiter
               istart=icol                                     ! start new token on the non-delimiter character
               ibegin(iarray)=icol
               iend=lgth-istart+1+1                            ! assume no delimiters so put past end of line
               do i10=1,idlim
                  ifound=index(line_local(istart:lgth),dlim(i10:i10))
                  if(ifound > 0)then
                     iend=min(iend,ifound)
                  endif
               enddo
               if(iend <= 0)then                               ! no remaining delimiters
                 iterm(iarray)=lgth
                 if(lstore)then
                    array(iarray)=line_local(istart:lgth)
                 endif
                 icount=iarray
                 return
               else
                 iend=iend+istart-2
                 iterm(iarray)=iend
                 if(lstore)then
                    array(iarray)=line_local(istart:iend)
                 endif
               endif
               icol=iend+2
               exit NOINCREMENT
            endif
            icol=icol+1
         enddo NOINCREMENT
!        last character in line was a delimiter, so no text left
!        (should not happen where blank=delimiter)
         if(icol > lgth)then
           icount=iarray
           if( (iterm(icount)-ibegin(icount)) < 0)then         ! last token was all delimiters
              icount=icount-1
           endif
           return
         endif
      enddo
      icount=n  ! more than n elements
end subroutine delim
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_strings:EDITING] function replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! syntax:
!!
!!      function replace(targetline,old,new,cmd,&
!!       & occurrence, &
!!       & repeat, &
!!       & ignorecase, &
!!       & ierr) result (newline)
!!      character(len=*)                     :: targetline
!!      character(len=*),intent(in),optional :: old
!!      character(len=*),intent(in),optional :: new
!!      character(len=*),intent(in),optional :: cmd
!!      integer,intent(in),optional          :: occurrence
!!      integer,intent(in),optional          :: repeat
!!      logical,intent(in),optional          :: ignorecase
!!      integer,intent(out),optional         :: ierr
!!      character(len=:),allocatable         :: newline
!!
!!##DESCRIPTION
!!    Replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     cmd         alternate way to specify old and new string, in
!!                 the form c/old/new/; where "/" can be any character
!!                 not in "old" or "new".
!!     occurrence  if present, start changing at the Nth occurrence of the
!!                 OLD string. If negative start replacing from the left
!!                 end of the string.
!!     repeat      number of replacements to perform. Defaults to a global
!!                 replacement.
!!     ignorecase  whether to ignore ASCII case or not. Defaults
!!                 to .false. .
!!##RETURNS
!!     newline     allocatable string returned
!!     ierr        error code. iF ier = -1 bad directive, >= 0 then
!!                 count of changes made.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_replace
!!    use M_strings, only : replace
!!    implicit none
!!    character(len=:),allocatable :: line
!!
!!    write(*,*)replace('Xis is Xe string','X','th')
!!    write(*,*)replace('Xis is xe string','x','th',ignorecase=.true.)
!!    write(*,*)replace('Xis is xe string','X','th',ignorecase=.false.)
!!
!!    ! a null old substring means "at beginning of line"
!!    write(*,*) replace('my line of text','','BEFORE:')
!!
!!    ! a null new string deletes occurrences of the old substring
!!    write(*,*) replace('I wonder i ii iii','i','')
!!
!!    ! Examples of the use of RANGE
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=1,repeat=1)
!!    write(*,*)'replace first a with A ['//line//']'
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=3,repeat=3)
!!    write(*,*)'replace a with A for 3rd to 5th occurrence ['//line//']'
!!
!!    line=replace('ababababa','a','',occurrence=3,repeat=3)
!!    write(*,*)'replace a with null instances 3 to 5 ['//line//']'
!!
!!    line=replace( &
!!     & 'a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!     & 'aa','CCCC',occurrence=-1,repeat=1)
!!    write(*,*)'replace lastaa with CCCC ['//line//']'
!!
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-1,repeat=1)
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-2,repeat=2)
!!
!!    end program demo_replace
!!
!!   Results:
!!
!!     this is the string
!!     this is the string
!!     this is xe string
!!     BEFORE:my line of text
!!     I wonder
!!     replace first a with A [Aaaaaaaaa]
!!     replace a with A for 3rd to 5th occurrence [aaAAAaaaa]
!!     replace a with null instances 3 to 5 [ababbb]
!!     replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC]
!!     myf90stuff.f90.for
!!     myforstuff.for.f90
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine crack_cmd(cmd,old,new,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)              :: cmd
character(len=:),allocatable,intent(out) :: old,new                ! scratch string buffers
integer                                  :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=1)                         :: delimiters
integer                                  :: itoken
integer,parameter                        :: id=2                   ! expected location of delimiter
logical                                  :: ifok
integer                                  :: lmax                   ! length of target string
integer                                  :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   old=''
   new=''
   lmax=len_trim(cmd)                       ! significant length of change directive

   if(lmax >= 4)then                      ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)               ! find delimiter in expected location
      itoken=0                            ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*crack_cmd* incorrect change directive -too short')
   endif

end subroutine crack_cmd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function replace(targetline,old,new,cmd,occurrence,repeat,ignorecase,ierr) result (newline)

! ident_12="@(#) M_strings replace(3f) replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in),optional   :: old          ! old substring to replace
character(len=*),intent(in),optional   :: new          ! new substring
character(len=*),intent(in),optional   :: cmd          ! contains the instructions changing the string
integer,intent(in),optional            :: occurrence   ! Nth occurrence of OLD string to start replacement at
integer,intent(in),optional            :: repeat       ! how many replacements
logical,intent(in),optional            :: ignorecase
integer,intent(out),optional           :: ierr         ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
character(len=:),allocatable  :: new_local, old_local, old_local_for_comparison
integer                       :: icount,ichange,ier2
integer                       :: original_input_length
integer                       :: len_old, len_new
integer                       :: ladd
integer                       :: left_margin, right_margin
integer                       :: ind
integer                       :: ic
integer                       :: ichr
integer                       :: range_local(2)
character(len=:),allocatable  :: targetline_for_comparison   ! input line to be changed
logical                       :: ignorecase_local
logical                       :: flip
character(len=:),allocatable  :: targetline_local   ! input line to be changed
!-----------------------------------------------------------------------------------------------------------------------------------
   flip=.false.
   ignorecase_local=.false.
   original_input_length=len_trim(targetline)          ! get non-blank length of input line

!  get old_local and new_local from cmd or old and new
   if(present(cmd))then
      call crack_cmd(cmd,old_local,new_local,ier2)
      if(ier2 /= 0)then
         newline=targetline  ! if no changes are made return original string on error
         if(present(ierr))ierr=ier2
         return
      endif
   elseif(present(old).and.present(new))then
      old_local=old
      new_local=new
   else
      newline=targetline  ! if no changes are made return original string on error
      call journal('sc','*replace* must specify OLD and NEW or CMD')
      return
   endif
   if(present(ignorecase))then
      ignorecase_local=ignorecase
   else
      ignorecase_local=.false.
   endif
   if(present(occurrence))then
      range_local(1)=abs(occurrence)
   else
      range_local(1)=1
   endif
   if(present(repeat))then
      range_local(2)=range_local(1)+repeat-1
   else
      range_local(2)=original_input_length
   endif
   if(ignorecase_local)then
      targetline_for_comparison=lower(targetline)
      old_local_for_comparison=lower(old_local)
   else
      targetline_for_comparison=targetline
      old_local_for_comparison=old_local
   endif
   if(present(occurrence))then
      if(occurrence < 0)then
         flip=.true.
         targetline_for_comparison=reverse(targetline_for_comparison)
         targetline_local=reverse(targetline)
         old_local_for_comparison=reverse(old_local_for_comparison)
         old_local=reverse(old_local)
         new_local=reverse(new_local)
      else
         targetline_local=targetline
      endif
   else
      targetline_local=targetline
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   len_old=len(old_local)                              ! length of old substring to be replaced
   len_new=len(new_local)                              ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(len_new > 0)then
         newline=new_local(:len_new)//targetline_local(left_margin:original_input_length)
      else
         newline=targetline_local(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      if(flip) newline=reverse(newline)
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=left_margin                                    ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
                                                       ! try finding start of OLD in remaining part of input in change window
      ind=index(targetline_for_comparison(ic:),old_local_for_comparison(:len_old))+ic-1
      if(ind == ic-1.or.ind > right_margin)then       ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:ichr-1)//targetline_local(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(icount >= range_local(1).and.icount <= range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new /= 0)then                                          ! put in new string
            newline=newline(:ichr-1)//new_local(:len_new)
            ichr=ichr+len_new
         endif
      else
         if(len_old /= 0)then                                          ! put in copy of old string
            newline=newline(:ichr-1)//old_local(:len_old)
            ichr=ichr+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline_local                         ! if no changes made output should be input
   case default
      if(ic <= len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:ichr-1)//targetline_local(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
   if(flip) newline=reverse(newline)
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes
!!    one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!
!!##DESCRIPTION
!!    Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_substitute
!!    use M_strings, only : substitute
!!    implicit none
!!    ! must be long enough to hold changed line
!!    character(len=80) :: targetline
!!
!!    targetline='this is the input string'
!!    write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!    ! changes the input to 'THis is THe input string'
!!    call substitute(targetline,'th','TH')
!!    write(*,*)'th => TH    : '//trim(targetline)
!!
!!    ! a null old substring means "at beginning of line"
!!    ! changes the input to 'BEFORE:this is the input string'
!!    call substitute(targetline,'','BEFORE:')
!!    write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!    ! a null new string deletes occurrences of the old substring
!!    ! changes the input to 'ths s the nput strng'
!!    call substitute(targetline,'i','')
!!    write(*,*)'i => ""     : '//trim(targetline)
!!
!!    end program demo_substitute
!!
!!   Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine substitute(targetline,old,new,ierr,start,end)

! ident_13="@(#) M_strings substitute(3f) Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option ! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(ichr > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichr-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichr+ladd > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    change(3f) - [M_strings:EDITING] change old string to new string with
!!    a directive like a line editor
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine change(target_string,cmd,ierr)
!!
!!     character(len=*),intent(inout) :: target_string
!!     character(len=*),intent(in)    :: cmd
!!     integer                        :: ierr
!!
!!##DESCRIPTION
!!    change an old substring into a new substring in a character variable
!!    like a line editor. Primarily used to create interactive utilities
!!    such as input history editors for interactive line-mode programs. The
!!    output string is assumed long enough to accommodate the change.
!!    a directive resembles a line editor directive of the form
!!
!!       C/old_string/new_string/
!!
!!    where / may be any character which is not included in old_string
!!    or new_string.
!!
!!    a null old_string implies "beginning of string".
!!
!!##OPTIONS
!!    target_string  line to be changed
!!    cmd            contains instructions to change the string
!!    ierr           error code.
!!
!!       o =-1 bad directive
!!       o =0 no changes made
!!       o >0 count of changes made
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_change
!!
!!     use M_strings, only : change
!!     implicit none
!!     character(len=132) :: line='This is a test string to change'
!!     integer            :: ierr
!!        write(*,*)trim(line)
!!        ! change miniscule a to uppercase A
!!        call change(line,'c/a/A/',ierr)
!!        write(*,*)trim(line)
!!        ! put string at beginning of line
!!        call change(line,'c//prefix: /',ierr)
!!        write(*,*)trim(line)
!!        ! remove blanks
!!        call change(line,'c/ //',ierr)
!!        write(*,*)trim(line)
!!    end program demo_change
!!
!!   Expected output
!!
!!     This is a test string to change
!!     This is A test string to chAnge
!!     prefix: This is A test string to chAnge
!!     prefix:ThisisAteststringtochAnge
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine change(target_string,cmd,ierr)
! Change a string assumed long enough to accommodate the change, with a directive that resembles a line editor directive of the form
!    C/old_string/new_string/
! where / may be any character which is not included in old_string or new_string.
! a null old_string implies "beginning of string"
!===================================================================================================================================

! ident_14="@(#) M_strings change(3f) change a character string like a line editor"

character(len=*),intent(inout)   :: target_string          ! line to be changed
character(len=*),intent(in)      :: cmd                    ! contains the instructions changing the string
character(len=1)                 :: delimiters
integer                          :: ierr                   ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made
integer                          :: itoken
integer,parameter                :: id=2                   ! expected location of delimiter
character(len=:),allocatable     :: old,new                ! scratch string buffers
logical                          :: ifok
integer                          :: lmax                   ! length of target string
integer                          :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   lmax=len_trim(cmd)                                                          ! significant length of change directive
   if(lmax >= 4)then                         ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)                                                    ! find delimiter in expected location
      itoken=0                                                                 ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))    ! change old substrings to new substrings
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine change
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     strtok(3f) - [M_strings:TOKENS] Tokenize a string
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!  function strtok(source_string,itoken,token_start,token_end,delimiters)
!!  result(strtok_status)
!!
!!   ! returned value
!!   logical                      :: strtok_status
!!   ! string to tokenize
!!   character(len=*),intent(in)  :: source_string
!!   ! token count since started
!!   integer,intent(inout)        :: itoken
!!   ! beginning of token
!!   integer,intent(out)          :: token_start
!!   ! end of token
!!   integer,intent(inout)        :: token_end
!!   ! list of separator characters
!!   character(len=*),intent(in)  :: delimiters
!!
!!##DESCRIPTION
!!     The STRTOK(3f) function is used to isolate sequential tokens in a
!!     string, SOURCE_STRING. These tokens are delimited in the string by
!!     at least one of the characters in DELIMITERS. The first time that
!!     STRTOK(3f) is called, ITOKEN should be specified as zero. Subsequent
!!     calls, wishing to obtain further tokens from the same string,
!!     should pass back in TOKEN_END  and ITOKEN until the function result
!!     returns .false.
!!
!!     This routine assumes no other calls are made to it using any other
!!     input string while it is processing an input line.
!!
!!##OPTIONS
!!     source_string  input string to parse
!!     itoken         token count should be set to zero for a new string
!!     delimiters     characters used to determine the end of tokens
!!
!!##RETURNS
!!     token_start    beginning position in SOURCE_STRING where token was found
!!     token_end      ending position in SOURCE_STRING where token was found
!!     strtok_status
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_strtok
!!     use M_strings, only : strtok
!!     implicit none
!!     character(len=264)          :: inline
!!     character(len=*),parameter  :: delimiters=' ;,'
!!     integer                     :: iostat, itoken, ibegin, iend
!!        do ! read lines from stdin until end-of-file or error
!!           read (unit=*,fmt="(a)",iostat=iostat) inline
!!           if(iostat /= 0)stop
!!           ! must set ITOKEN=0 before looping on strtok(3f)
!!           ! on a new string.
!!           itoken=0
!!           do while &
!!           &( strtok(inline,itoken,ibegin,iend,delimiters) )
!!              print *, itoken,&
!!              & 'TOKEN=['//(inline(ibegin:iend))//']',ibegin,iend
!!           enddo
!!        enddo
!!     end program demo_strtok
!!
!!     sample input file
!!
!!      this is a test of strtok; A:B :;,C;;
!!
!!     sample output file
!!
!!     1  TOKEN=[this]    2   5
!!     2  TOKEN=[is]      7   8
!!     3  TOKEN=[a]       10  10
!!     4  TOKEN=[test]    12  15
!!     5  TOKEN=[of]      17  18
!!     6  TOKEN=[strtok]  20  25
!!     7  TOKEN=[A:B]     28  30
!!     8  TOKEN=[:]       32  32
!!     9  TOKEN=[C]       35  35
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

! ident_15="@(#) M_strings strtok(3f) Tokenize a string"

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer,save                 :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken <= 0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start > isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start  >  isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    modif(3f) - [M_strings:EDITING] emulate the MODIFY command from the
!!    line editor XEDIT
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine modif(cline,cmod)
!!
!!     character(len=*) :: cline ! input string to change
!!     ! directive provides directions on changing string
!!     character(len=*) :: cmod
!!
!!##DESCRIPTION
!!   MODIF(3f) Modifies the line currently pointed at using a directive
!!   that acts much like a line editor directive.
!!   Primarily used to create interactive utilities such as input history
!!   editors for interactive line-mode programs.
!!
!!   the modify directives are as follows-
!!
!!    DIRECTIVE EXPLANATION
!!
!!    ^STRING#   Causes the string of characters between the ^ and the
!!               next # to be inserted before the characters pointed to
!!               by the ^. an ^ or & within the string is treated as a
!!               regular character. If the closing # is not specified,
!!               MODIF(3f) inserts the remainder of the line as if a # was
!!               specified after the last nonblank character.
!!
!!               There are two exceptions. the combination ^# causes a #
!!               to be inserted before the character pointed to by the
!!               ^, and an ^ as the last character of the directives
!!               causes a blank to be inserted.
!!
!!    #          (When not the first # after an ^) causes the character
!!               above it to be deleted.
!!
!!    &          Replaces the character above it with a space.
!!
!!    (SPACE)    A space below a character leaves it unchanged.
!!
!!    Any other character replaces the character above it.
!!
!!##EXAMPLES
!!
!!   Example input/output:
!!
!!    THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
!!    THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
!!    ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!!
!!   Sample program:
!!
!!    program demo_modif
!!    use M_strings, only : modif
!!    implicit none
!!    character(len=256)           :: line
!!    integer                      :: iostat
!!    integer                      :: count
!!    integer                      :: COMMAND_LINE_LENGTH
!!    character(len=:),allocatable :: COMMAND_LINE
!!       ! get command name length
!!       call get_command_argument(0,length=count)
!!       ! get command line length
!!       call get_command(length=COMMAND_LINE_LENGTH)
!!       ! allocate string big enough to hold command line
!!       allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
!!       ! get command line as a string
!!       call get_command(command=COMMAND_LINE)
!!       ! trim leading spaces just in case
!!       COMMAND_LINE=adjustl(COMMAND_LINE)
!!       ! remove command name
!!       COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
!!       INFINITE: do
!!          read(*,'(a)',iostat=iostat)line
!!          if(iostat /= 0)exit
!!          call modif(line,COMMAND_LINE)
!!          write(*,'(a)')trim(line)
!!       enddo INFINITE
!!    end program demo_modif
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine modif(cline,mod)

!$@(#) M_strings::modif(3f): Emulate the MODIFY command from the line editor XEDIT

!
! MODIF
! =====
! ACTION- Modifies the line currently pointed at. The input string CLINE
!         is assumed to be long enough to accommodate the changes.
!         The MODIFY directives are as follows-
!
!   DIRECTIVE                       EXPLANATION
!   ---------                       ------------
!   ^STRING#   Causes the string of characters between the ^ and the
!              next  # to be inserted before the characters pointed to
!              by the ^. An ^ or & within the string is treated as a
!              regular character. If the closing # is not specified,
!              MODIF(3f) inserts the remainder of the line as if a # was
!              specified after the last nonblank character.
!
!              There are two exceptions. The combination ^# causes a #
!              to be inserted before the character pointed to by the
!              ^,  and an ^ as the last character of the directives
!              causes a blank to be inserted.
!
!   #          (When not the first # after an ^) causes the character
!              above it to be deleted.
!
!   &          Replaces the character above it with a space.
!
!   (SPACE)    A Space below a character leaves it unchanged.
!
!   Any other character replaces the character above it.
!
! EXAMPLE-
! THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
! THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
! ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
character(len=*)            :: cline           !STRING TO BE MODIFIED
character(len=*),intent(in) :: mod             !STRING TO DIRECT MODIFICATION
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'         !ASSIGN DEFAULT EDIT CHARACTERS
integer                     :: maxscra         !LENGTH OF SCRATCH BUFFER
character(len=len(cline))   :: dum2            !SCRATCH CHARACTER BUFFER
logical                     :: linsrt          !FLAG FOR INSERTING DATA ON LINE
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(mod)
   lmax=min0(len(cline),maxscra)               !DETERMINE MAXIMUM LINE LENGTH
   lmx1=lmax-1                                 !MAX LINE LENGTH -1
   dum2=' '                                    !INITIALIZE NEW LINE
   linsrt=.false.                              !INITIALIZE INSERT MODE
   iend=len_trim(cmod)                         !DETERMINE END OF MODS
   i=0                                         !CHAR COUNTER FOR MOD LINE CMOD
   ic=0                                        !CHAR COUNTER FOR CURRENT LINE CLINE
   ichr=0                                      !CHAR COUNTER NEW LINE DUM2
   INFINITE: do
      if(i >= lmax)exit INFINITE               !CHECK FOR END OF LINE REACHED
      i=i+1                                    !NEXT CHAR IN MOD LINE
      if(ichr > lmx1)exit INFINITE             !IF TOO MANY CHARS IN NEW LINE
      if(linsrt) then                          !IF INSERTING NEW CHARS
         if(i > iend) cmod(i:i)=c(1:1)         !FORCE END OF INSERT MODE
         if(cmod(i:i) == c(1:1))then           !IF END OF INSERT MODE
            linsrt=.false.                     !RESET INSERT MODE FLAG
            if(ic+1 == i)then                  !NULL INSERT STRING
               ichr=ichr+1                     !INCREMENT COUNTER FOR NEW LINE
               dum2(ichr:ichr)=c(1:1)          !INSERT INSERT MODE TERMINATOR
            endif
            do j=ic,i                          !LOOP OF NUMBER OF CHARS INSERTED
               ichr=ichr+1                     !INCREMENT COUNTER FOR NEW LINE
               if(ichr > lmax)exit INFINITE    !IF AT BUFFER LIMIT, QUIT
               dum2(ichr:ichr)=cline(j:j)      !APPEND CHARS FROM ORIG LINE
            enddo                              !...WHICH ALIGN WITH INSERTED CHARS
            ic=i                               !RESET CHAR COUNT TO END OF INSERT
            cycle INFINITE                     !CHECK NEW LINE LENGTH AND CYCLE
         endif                                 !END OF TERMINATED INSERT LOGIC
         ichr=ichr+1                           !INCREMENT NEW LINE COUNT
         dum2(ichr:ichr)=cmod(i:i)             !SET NEWLINE CHAR TO INSERTED CHAR
      else                                     !IF NOT INSERTING CHARACTERS
         ic=ic+1                               !INCREMENT ORIGINAL LINE COUNTER
         if(cmod(i:i) == c(1:1))cycle INFINITE !IF DELETE CHAR. NO COPY AND CYCLE
         if(cmod(i:i) == c(3:3))then           !IF BEGIN INSERT MODE
            linsrt=.true.                      !SET INSERT FLAG TRUE
            cycle INFINITE                     !CHECK LINE LENGTH AND CONTINUE
         endif                                 !IF NOT BEGINNING INSERT MODE
         ichr=ichr+1                           !INCREMENT NEW LINE COUNTER
         if(cmod(i:i) == c(2:2))then           !IF REPLACE WITH BLANK
            dum2(ichr:ichr)=' '                !SET NEWLINE CHAR TO BLANK
            cycle INFINITE                     !CHECK LINE LENGTH AND CYCLE
         endif                                 !IF NOT REPLACE WITH BLANK
         if(cmod(i:i) == ' ')then              !IF BLANK, KEEP ORIGINAL CHARACTER
            dum2(ichr:ichr)=cline(ic:ic)       !SET NEW CHAR TO ORIGINAL CHAR
         else                                  !IF NOT KEEPING OLD CHAR
            dum2(ichr:ichr)=cmod(i:i)          !REPLACE ORIGINAL CHAR WITH NEW
         endif                                 !END CHAR KEEP OR REPLACE
      endif                                    !END INSERT OR NO-INSERT
   enddo INFINITE
                                               !AND CYCLE IF OK
   cline=dum2                                  !SET ORIGINAL CHARS TO NEW CHARS
end subroutine modif                           !RETURN
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      len_white(3f) - [M_strings:LENGTH] get length of string trimmed
!!      of whitespace.
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    integer function len_white(string)
!!
!!     character(len=*) :: string
!!
!!##DESCRIPTION
!!      len_white(3f) returns the position of the last character in
!!      string that is not a whitespace character. The Fortran90 intrinsic
!!      LEN_TRIM() should be used when trailing whitespace can be assumed
!!      to always be spaces.
!!
!!      This procedure was heavily used in the past because ANSI FORTRAN
!!      77 character objects are fixed length and blank padded and the
!!      LEN_TRIM() intrinsic did not exist. It should now be used only when
!!      whitespace characters other than blanks are likely.
!!
!!##OPTIONS
!!      string     input string whose trimmed length is being calculated
!!                 ignoring all trailing whitespace characters.
!!##RETURNS
!!      len_white  the number of characters in the trimmed string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_len_white
!!
!!      use M_strings, only : len_white
!!      implicit none
!!      character(len=80) :: s
!!      integer           :: lgth, lastnb
!!      intrinsic len
!!
!!      s=' ABCDEFG abcdefg '
!!      lgth = len(s)
!!      lastnb = len_white(s)
!!
!!      write(*,*) 'total length of variable is ',lgth
!!      write(*,*) 'trimmed length of variable is ',lastnb
!!      write(*,*) 'trimmed string=[',s(:lastnb),']'
!!
!!     end program demo_len_white
!!
!!   Results:
!!
!!     total length of variable is           80
!!     trimmed length of variable is           16
!!     trimmed string=[ ABCDEFG abcdefg]
!!
!!##NOTES
!!
!! o len_white
!!
!!      is a resource-intensive routine. Once the end of
!!      the string is found, it is probably best to keep track of it in
!!      order to avoid repeated calls to len_white. Because they
!!      might be more efficient, consider looking for vendor-supplied or
!!      system-optimized equivalents. For example:
!!
!!         o lnblnk - Solaris f77
!!         o len_trim - FORTRAN 90
!!
!! o Some compilers seem to have trouble passing a string of variable
!!   length properly. To be safe, use something like this:
!!
!!       subroutine message(s)
!!        character(len=*) :: s ! s is of variable length
!!           lgth=len(s)        ! get total length of variable
!!           ! explicitly specify a substring instead of just variable name
!!           lastnb = len_white(s(:lgth))
!!           write(*,*)'error:[',s(:lastnb),']'
!!       end subroutine messages
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental integer function len_white(string)
!  DEPRECATED. Use len_trim(3f),trim(3f) unless you might have trailing nulls (common when interacting with C procedures)"
!  John S. Urban, 1984, 1997-12-31
!  Note that if the string is blank, a length of 0 is returned; which is not a legal string length in Fortran77.
!  this routine used to return one instead of zero.
!   - mod 1:     1994
!                added null (char(0)) because HP and some Suns not padding
!                strings with blank, but with null characters; 1994 JSU
!   - mod 2:     1999
!                update syntax with INTENT(), ENDDO, no RETURN
!                still need instead of LEN_TRIM() because some systems stil pad CHARACTER with NULL
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_16="@(#) M_strings len_white(3f) return position of last non-blank/non-null character in string"

character(len=*),intent(in):: string ! input string to determine length of
integer                    :: i10
intrinsic len
   len_white=0
   do i10=len(string),1,-1
      select case(string(i10:i10))
      case(' ')                 ! space(32)
      case(char(0))             ! null(0)
      case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13)
      case default
         len_white=i10
         exit
      end select
   enddo
end function len_white
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    crop(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!               and control characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function crop(strin) result (strout)
!!
!!     character(len=*),intent(in)  :: strin
!!     character(len=:),allocatable :: strout
!!
!!##DESCRIPTION
!!    Tabs are expanded assuming a stop every eight characters.  All other
!!    control characters throughout the string are replaced with spaces
!!    and leading and trailing spaces are trimmed from the resulting string.
!!
!!    This means trailing characters like linefeed and carriage returns are
!!    removed. If this is not desired, see clip(3f).
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing space and control
!!            characters from
!!
!!##RETURNS
!!    strout  cropped version of input string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_crop
!!    use M_strings, only: crop
!!    implicit none
!!    character(len=20) :: untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'cropped string=[',crop(untrimmed),']'
!!    end program demo_crop
!!
!!   Expected output
!!
!!      untrimmed string=[   ABCDEFG abcdefg                      ]
!!      cropped string=[ABCDEFG abcdefg]
!!##SEE ALSO
!!    clip(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function crop(strin) result (strout)

! ident_17="@(#) M_strings crop(3f) replace control characters with whitespace and trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(noesc(dilate(strin))))
end function crop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    clip(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!    or set of characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function clip(strin,set) result (strout)
!!
!!     character(len=*),intent(in)          :: strin
!!     character(len=*),intent(in),optional :: set
!!     character(len=:),allocatable         :: strout
!!
!!##DESCRIPTION
!!    leading and trailing spaces or set of characters are trimmed from
!!    the input string.
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing characters from
!!    set     set of characters to trim. Defaults to a space.
!!
!!##RETURNS
!!    strout  clipped version of input string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_clip
!!    use M_strings, only: clip
!!    implicit none
!!    character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'clipped string=[',clip(untrimmed),']'
!!       ! which is equivalent to
!!       write(*,*) 'clipped string=[',trim(adjustl(untrimmed)),']'
!!       write(*,*)'non-space:'
!!       write(*,*) '['//clip('----single-character----',set='-')//']'
!!       write(*,*) '['//clip('  ... . .multi-character . ...',set='. ')//']'
!!    end program demo_clip
!!
!!   Results:
!!
!!       >  untrimmed string=[   ABCDEFG abcdefg  ]
!!       >  clipped string=[ABCDEFG abcdefg]
!!       >  clipped string=[ABCDEFG abcdefg]
!!       >  non-space:
!!       >  [single-character]
!!       >  [multi-character]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function clip(string,set) result(lopped)

! ident_18="@(#) M_strings clip(3f) trim leading and trailings spaces or set of characters from string"

logical,parameter                     :: T=.true.,F=.false.
character(len=*),intent(in)           :: string
character(len=*),intent(in),optional  :: set
character(len=:),allocatable          :: lopped
integer                               :: ends(2)

   ! find first and last non-blank character positions, or the same for specified character set
   if(present(set))then
      ends=verify(string, set=set, back=[F,T]) ! Position of a character in a string that does not appear in given set
   else
      ends=verify(string, set=' ', back=[F,T])
   endif

   if(ends(1) == 0)then
      lopped=""
   else
      lopped=string(ends(1):ends(2))
   endif

end function clip
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    transliterate(3f) - [M_strings:EDITING] replace characters from old
!!                        set with new set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function transliterate(instr,old_set,new_set) result(outstr)
!!
!!     character(len=*),intent(in)  :: instr
!!     character(len=*),intent(in)  :: old_set
!!     character(len=*),intent(in)  :: new_set
!!     character(len=len(instr))    :: outstr
!!
!!##DESCRIPTION
!!    Translate, squeeze, and/or delete characters from the input string.
!!
!!##OPTIONS
!!    instr    input string to change
!!    old_set  list of letters to change in INSTR if found
!!
!!             Each character in the input string that matches a character
!!             in the old set is replaced.
!!
!!    new_set  list of letters to replace letters in OLD_SET with.
!!
!!             If the new_set is the empty set the matched characters
!!             are deleted.
!!
!!             If the new_set is shorter than the old set the last character
!!             in the new set is used to replace the remaining characters
!!             in the new set.
!!
!!##RETURNS
!!    outstr   instr with substitutions applied
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_transliterate
!!
!!     use M_strings, only : transliterate
!!     implicit none
!!     character(len=80)   :: STRING
!!
!!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
!!     write(*,'(a)') STRING
!!
!!     ! convert a string to uppercase:
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
!!
!!     ! change all miniscule letters to a colon (":"):
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz',':')
!!
!!     ! delete all miniscule letters
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','')
!!
!!    end program demo_transliterate
!!
!!    Expected output
!!
!!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
!!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
!!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
!!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
PURE FUNCTION transliterate(instr,old_set,new_set) RESULT(outstr)

! ident_19="@(#) M_strings transliterate(3f) replace characters from old set with new set"

!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=*),INTENT(IN)  :: instr                  ! input string to change
CHARACTER(LEN=*),intent(in)  :: old_set                ! set of characters to replace
CHARACTER(LEN=*),intent(in)  :: new_set                ! new characters to replace old characcters
!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=LEN(instr))    :: outstr                 ! output string to generate
!-----------------------------------------------------------------------------------------------------------------------------------
INTEGER                      :: i10                    ! loop counter for stepping thru string
INTEGER                      :: ii,jj
!-----------------------------------------------------------------------------------------------------------------------------------
   jj=LEN(new_set)
   IF(jj /= 0)THEN
      outstr=instr                                     ! initially assume output string equals input string
      stepthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))              ! see if current character is in old_set
         IF (ii /= 0)THEN
            if(ii <= jj)then                           ! use corresponding character in new_set
               outstr(i10:i10) = new_set(ii:ii)
            else
               outstr(i10:i10) = new_set(jj:jj)        ! new_set not as long as old_set; use last character in new_set
            endif
         ENDIF
      ENDDO stepthru
   else                                                ! new_set is null string so delete characters in old_set
      outstr=' '
      hopthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))              ! see if current character is in old_set
         IF (ii == 0)THEN                              ! only keep characters not in old_set
            jj=jj+1
            outstr(jj:jj) = instr(i10:i10)
         ENDIF
      ENDDO hopthru
   endif
END FUNCTION transliterate
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    rotate13(3f) - [M_strings:ENCODE] apply trivial ROT13 encryption to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    rotate13(input) result(output)
!!
!!     character(len=*),intent(in) :: input
!!     character(len=len(input))   :: output
!!
!!##DESCRIPTION
!!    ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple
!!    letter substitution cipher that replaces a letter with the 13th letter
!!    after it in the alphabet; wrapping around if necessary.
!!
!!    The transformation can be done using a lookup table, such as the
!!    following:
!!
!!       Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
!!       Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
!!
!!    ROT13 is used in online forums as a means of hiding spoilers,
!!    punchlines, puzzle solutions, and offensive materials from the casual
!!    glance. ROT13 has inspired a variety of letter and word games on-line,
!!    and is frequently mentioned in newsgroup conversations.
!!
!!    The algorithm provides virtually no cryptographic security, and is
!!    often cited as a canonical example of weak encryption.
!!
!!    ROT13 is a special case of the Caesar cipher which was developed in
!!    ancient Rome.
!!
!!    ALGORITHM
!!
!!    Applying ROT13 to a piece of text merely requires examining its
!!    alphabetic characters and replacing each one by the letter 13 places
!!    further along in the alphabet, wrapping back to the beginning if
!!    necessary. A becomes N, B becomes O, and so on up to M, which becomes
!!    Z, then the sequence continues at the beginning of the alphabet: N
!!    becomes A, O becomes B, and so on to Z, which becomes M. Only those
!!    letters which occur in the English alphabet are affected; numbers,
!!    symbols, whitespace, and all other characters are left unchanged.
!!
!!    SAME ALGORITHM FOR ENCODING AND DECODING
!!
!!    Because there are 26 letters in the English alphabet and 26 = 2 x 13,
!!    the ROT13 function is its own inverse: so the same action can be used
!!    for encoding and decoding. In other words, two successive applications
!!    of ROT13 restore the original text (in mathematics, this is sometimes
!!    called an involution; in cryptography, a reciprocal cipher).
!!
!!    TRIVIAL SECURITY
!!
!!    The use of a constant shift means that the encryption effectively
!!    has no key, and decryption requires no more knowledge than the fact
!!    that ROT13 is in use. Even without this knowledge, the algorithm is
!!    easily broken through frequency analysis.
!!
!!    In encrypted normal English-language text of any significant size,
!!    ROT13 is recognizable from some letter/word patterns. The words "n",
!!    "V" (capitalized only), and "gur" (ROT13 for "a", "I", and "the"),
!!    and words ending in "yl" ("ly") are examples.
!!
!!##REFERENCES
!!    Wikipedia, the free encyclopedia
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_rotate13
!!    use M_strings, only : rotate13
!!    implicit none
!!    character(len=256) :: line
!!    integer            :: iostat
!!    do
!!       read(*,'(a)',iostat=iostat)line
!!       if(iostat /= 0)exit
!!       write(*,'(a)')rotate13(line)
!!    enddo
!!    end program demo_rotate13
!!
!!  Sample usage:
!!
!!    demo_rotate13
!!    United we stand, divided we fall.
!!    Havgrq jr fgnaq, qvivqrq jr snyy.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rotate13 (input)

! ident_20="@(#) M_strings rotate13(3f) converts a character to its ROT13 equivalent which is a trivial encryption."

character(len=*),intent(in) :: input
character(len=len(input))   :: rotate13
integer                     :: itemp
integer                     :: i
   rotate13=' '
   do i=1,len_trim(input)
      itemp = iachar(input(i:i))
      select case(itemp)
       case(65:77,97:109)
         itemp = itemp + 13
       case(78:90,110:122)
         itemp = itemp - 13
      end select
      rotate13(i:i) = char ( itemp )
   enddo

end function rotate13
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    percent_encode(3f) - [M_strings:ENCODE] percent-encode strings and
!!    character arrays
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     function percent_encode(text)
!!
!!      character(len=1),intent(in)  :: text(:)
!!      character(len=;),allocatable :: percent_encode
!!
!!     or
!!
!!     function percent_encode(text)
!!
!!      character(len=*),intent(in)  :: text
!!      character(len=;),allocatable :: percent_encode
!!
!!##DESCRIPTION
!!
!!    This function percent-encodes ASCII strings or ASCII character arrays.
!!    "Reserved" characters are encoded.
!!
!!    URI containing spaces or most other non-alphanumeric characters must
!!    be encoded using percent encoding (aka. URL encoding).
!!
!!    The characters allowed in a URI are either reserved or unreserved
!!    (or a percent character as part of a percent-encoding). Reserved
!!    characters are those characters that sometimes have special meaning,
!!    while unreserved characters have no such meaning. Using percent-encoding,
!!    characters which otherwise would not be allowed are represented using
!!    allowed characters. The sets of reserved and unreserved characters and
!!    the circumstances under which certain reserved characters have special
!!    meaning have changed slightly with each revision of specifications that
!!    govern URIs and URI schemes.
!!
!!    According to RFC 3986, the characters in a URL have to be taken from
!!    a defined set of unreserved and reserved ASCII characters. Any other
!!    characters are not allowed in a URL.
!!
!!    The unreserved characters can be encoded, but should not be. The
!!    unreserved characters are:
!!
!!       > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!       > abcdefghijklmnopqrstuvwxyz
!!       > 0123456789-_.~
!!
!!    The reserved characters have to be encoded only under certain
!!    circumstances. The reserved characters are:
!!
!!       >  * ' ( ) ; : @ & = + $ , / ? % # [ ]
!!
!!##OPTIONS
!!     SOURCE_STRING   string or character array to encode
!!
!!##RETURNS
!!     percent_encode  a string holding a percent-encoded copy of the input
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_percent_encode
!!    use M_strings, only : percent_encode
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!       write(*,*)percent_encode('[this is a string]')
!!    end program demo_percent_encode
!!
!! Results:
!!
!!  >  %5Bthis%20is%20a%20string%5D
!!
!!##AUTHOR
!!    John S. Urban
function percent_encode_string(text)
character(len=*),intent(in)  :: text
character(len=:),allocatable :: percent_encode_string
   percent_encode_string=percent_encode_characters(switch(text))
end function percent_encode_string
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_encode_characters(text)
character(len=1),intent(in)          :: text(:)
character(len=:),allocatable         :: percent_encode_characters
integer                              :: i,pos
allocate(character(len=3*size(text)) :: percent_encode_characters )
percent_encode_characters(:)=repeat(' ',len(percent_encode_characters))
   pos=1
   do i=1,size(text)
      select case(text(i))
      case('a':'z','A':'Z','0':'9','-','_','.','~')
         percent_encode_characters(pos:pos)=text(i)
         pos=pos+1
      case default
         write(percent_encode_characters(pos:pos+2),'(a1,z2.2)')'%',text(i)
         pos=pos+3
      end select
   enddo
   percent_encode_characters=trim(percent_encode_characters)
end function percent_encode_characters
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    percent_decode(3f) - [M_strings:ENCODE] percent-decode strings and
!!    character arrays
!!    (LICENSE:ISC)
!!
!!##SYNOPSIS
!!
!!
!!     function percent_decode(text,exit_code)
!!
!!      character(len=1),intent(in)  :: text(:)
!!      integer,optional,intent(out) :: exit_code
!!      character(len=:),allocatable :: percent_decode
!!
!!     or
!!
!!     function percent_decode(text,exit_code)
!!
!!      character(len=*),intent(in)  :: text
!!      integer,optional,intent(out) :: exit_code
!!      character(len=:),allocatable :: percent_decode
!!
!!##DESCRIPTION
!!
!!    percent_decode(3f) percent-decodes percent-encoded strings or character
!!    arrays.
!!
!!    URI containing spaces or most other non-alphanumeric characters must
!!    be encoded using percent encoding (aka. URL encoding). This procedure
!!    unwinds the encryption.
!!
!!    The characters allowed in a URI are either reserved or unreserved
!!    (or a percent character as part of a percent-encoding). Reserved
!!    characters are those characters that sometimes have special meaning,
!!    while unreserved characters have no such meaning. Using percent-encoding,
!!    characters which otherwise would not be allowed are represented using
!!    allowed characters. The sets of reserved and unreserved characters and
!!    the circumstances under which certain reserved characters have special
!!    meaning have changed slightly with each revision of specifications that
!!    govern URIs and URI schemes.
!!
!!    According to RFC 3986, the characters in a URL have to be taken from
!!    a defined set of unreserved and reserved ASCII characters. Any other
!!    characters are not allowed in a URL.
!!
!!    The unreserved characters can be encoded, but should not be. The
!!    unreserved characters are:
!!
!!       > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!       > abcdefghijklmnopqrstuvwxyz
!!       > 0123456789-_.~
!!
!!    The reserved characters have to be encoded only under certain
!!    circumstances. The reserved characters are:
!!
!!       >  * ' ( ) ; : @ & = + $ , / ? % # [ ]
!!
!!##OPTIONS
!!     SOURCE_STRING   string or character array to decode
!!     EXIT_CODE       non-zero if decoding failed
!!
!!##RETURNS
!!     percent_decode  a string holding a percent-decoded copy of the input
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_percent_decode
!!       use M_strings, only : percent_encode, percent_decode
!!       implicit none
!!       character(len=:),allocatable :: input,output
!!       character(len=*),parameter   :: see='(g0,*("""",g0,"""":))'
!!       character(len=*),parameter   :: expected='&
!!       &%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%&
!!       &16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2&
!!       &B%2C-.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWX&
!!       &YZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%7F%80%81%&
!!       &82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%9&
!!       &7%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC&
!!       &%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%&
!!       &C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D&
!!       &7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC&
!!       &%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF%20'
!!       integer                      :: j
!!          input='[this is a string]'
!!          write(*,see)'INPUT=',input
!!          output=percent_encode(input)
!!          write(*,see)'ENCODED=',output
!!          output=percent_decode(output)
!!          write(*,see)'DECODED=',output
!!          input=repeat(' ',256)
!!          do j=0,255
!!                input(j:j)=char(j)
!!          enddo
!!          output=percent_encode(input)
!!          write(*,*)'ENCODING PASSED:',output==expected
!!          output=percent_decode(output)
!!          write(*,*)'DECODING PASSED:',input == output
!!       end program demo_percent_decode
!!
!! Results:
!!
!!     > INPUT="[this is a string]"
!!     > ENCODED="%5Bthis%20is%20a%20string%5D"
!!     > DECODED="[this is a string]"
!!     >  ENCODING PASSED: T
!!     >  DECODING PASSED: T
!!
!!##AUTHOR
!!    o based on dm_cgi_encode.f90, Copyright (c) 2023, Philipp Engel
!!    o Modified to be more aligned with percent_encode(3f), John S. Urban, 2024
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_decode_characters(text,exit_code)
character(len=1),intent(in)  :: text(:)
integer,intent(out),optional :: exit_code
character(len=:),allocatable :: percent_decode_characters
   percent_decode_characters=percent_decode_string(switch(text),exit_code)
end function percent_decode_characters
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_decode_string(input, exit_code) result(output)
!! Unwinds percent-encoding in given input string.
!
! based on dm_cgi_encode.f90
! Copyright (c) 2023, Philipp Engel
! modified 2024-06-22, JSU

! Original Copyright:
! Permission to use, copy, modify, and/or distribute this software for any
! purpose with or without fee is hereby granted, provided that the above
! copyright notice and this permission notice appear in all copies.
!
! THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!
character(len=*), intent(in)   :: input  !! Encoded input string.
character(len=:), allocatable  :: output !! Decoded output string.
integer,intent(out),optional   :: exit_code
character(len=2)  :: hex
integer           :: input_col, output_col, hex_chars, input_len, output_len
integer           :: iostat
integer,parameter :: ERROR_BOUNDS=1, ERROR_NONE=0
   if(present(exit_code))then
      exit_code = ERROR_BOUNDS ! initially assume an error has occurred if return
   endif
   input_len = len_trim(input)
   output=repeat(' ',len(input)) ! output should be at most length of input
   output_len = len(output)
   if (output_len < input_len) return ! should not occur in this version
   input_col = 1
   output_col = 1
   do
      if (input_col > input_len) exit
      if (output_col > output_len) return
      CONVERT: select case (input(input_col:input_col))
      case ('%')
         if (input_col + 2 > input_len) exit CONVERT ! ignoring, which is probably not right
         hex = input(input_col + 1:input_col + 2)
         read (hex, '(z2)', iostat=iostat) hex_chars
         if (iostat == 0) then
            output(output_col:output_col) = achar(hex_chars)   ! Bytes are in hex.
            input_col = input_col + 2
         else
            output(output_col:output_col) = input(input_col:input_col) ! Bytes are not in hex.
         endif
      case ('+')
         output(output_col:output_col) = ' '
      case default
         output(output_col:output_col) = input(input_col:input_col)
      end select CONVERT
      input_col = input_col + 1
      output_col = output_col + 1
   enddo
   output=output(:output_col-1)
   if(present(exit_code))then
      exit_code = ERROR_NONE
   endif
end function percent_decode_string
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    join(3f) - [M_strings:EDITING] append CHARACTER variable array into
!!    a single CHARACTER variable with specified separator
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function join(str,sep,trm,left,right,start,end) result (string)
!!
!!     character(len=*),intent(in)          :: str(:)
!!     character(len=*),intent(in),optional :: sep
!!     logical,intent(in),optional          :: trm
!!     character(len=*),intent(in),optional :: right
!!     character(len=*),intent(in),optional :: left
!!     character(len=*),intent(in),optional :: start
!!     character(len=*),intent(in),optional :: end
!!     character(len=:),allocatable         :: string
!!
!!##DESCRIPTION
!!   JOIN(3f) appends the elements of a CHARACTER array into a single
!!   CHARACTER variable, with elements 1 to N joined from left to right.
!!   By default each element is trimmed of trailing spaces and the
!!   default separator is a null string.
!!
!!##OPTIONS
!!      STR(:)  array of CHARACTER variables to be joined
!!      SEP     separator string to place between each variable. defaults
!!              to a null string.
!!      LEFT    string to place at left of each element
!!      RIGHT   string to place at right of each element
!!      START   prefix string
!!      END     suffix string
!!      TRM     option to trim each element of STR of trailing
!!              spaces. Defaults to .TRUE.
!!
!!##RETURNS
!!      STRING  CHARACTER variable composed of all of the elements of STR()
!!              appended together with the optional separator SEP placed
!!              between the elements.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_join
!!     use M_strings, only: join
!!     implicit none
!!     character(len=:),allocatable  :: s(:)
!!       s=[character(len=10) :: 'United','we','stand,', &
!!       & 'divided','we fall.']
!!
!!       write(*,'(a)') 'SIMPLE JOIN:                  ',&
!!          join(s)
!!       write(*,'(a)') 'SIMPLE JOIN WITH SEPARATOR:   ',&
!!          join(s,sep=' ')
!!       write(*,'(a)') 'CUSTOM SEPARATOR:             ',&
!!          join(s,sep='==>')
!!       write(*,'(a)') 'LEFT AND RIGHT AND SEPARATOR: ',&
!!          join(s,sep=';',left='[',right=']')
!!       write(*,'(a)') 'NO TRIMMING:                  ',&
!!          join(s,trm=.false.)
!!       write(*,'(a)') 'LEFT AND RIGHT:               ',&
!!          join(s,left='[',right=']')
!!       write(*,'(a)') 'START,END AND EVERYTHING:     ',&
!!          join(s,trm=.false.,sep=',',start='[',end=']',left='"',right='"')
!!
!!       write(*,'(a)') 'TABLE'
!!       call line()
!!       write(*,'(a)') join(s(1:3),trm=.false.,sep='|',start='|',end='|')
!!       write(*,'(a)') join([s(4:5),repeat(' ',len(s))],&
!!       & trm=.false.,sep='|',start='|',end='|')
!!       call line()
!!     contains
!!     subroutine line()
!!     integer :: i
!!       write(*,'(a)') join([(repeat('-',len(s)),i=1,3)],&
!!       & sep='#',start='#',end='#')
!!     end subroutine line
!!     end program demo_join
!!
!! Results:
!!
!!  > SIMPLE JOIN:
!!  > Unitedwestand,dividedwe fall.
!!  > SIMPLE JOIN WITH SEPARATOR:
!!  > United we stand, divided we fall.
!!  > CUSTOM SEPARATOR:
!!  > United==>we==>stand,==>divided==>we fall.
!!  > LEFT AND RIGHT AND SEPARATOR:
!!  > [United];[we];[stand,];[divided];[we fall.]
!!  > NO TRIMMING:
!!  > United    we        stand,    divided   we fall.
!!  > LEFT AND RIGHT:
!!  > [United][we][stand,][divided][we fall.]
!!  > START,END AND EVERYTHING:
!!  > ["United    ","we        ","stand,    ","divided   ","we fall.  "]
!!  > TABLE
!!  > #----------#----------#----------#
!!  > |United    |we        |stand,    |
!!  > |divided   |we fall.  |          |
!!  > #----------#----------#----------#
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function join(str,sep,trm,left,right,start,end) result (string)

! ident_21="@(#) M_strings join(3f) merge string array into a single CHARACTER value adding specified separators caps prefix and suffix"

character(len=*),intent(in)          :: str(:)
character(len=*),intent(in),optional :: sep, right, left, start, end
logical,intent(in),optional          :: trm
character(len=:),allocatable         :: sep_local, left_local, right_local
character(len=:),allocatable         :: string
logical                              :: trm_local
integer                              :: i
   if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif
   if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif
   if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif
   if(present(right))then ; right_local=right ; else ; right_local=''   ; endif
   string=''
   if(size(str) == 0)then
      string=string//left_local//right_local
   else
      do i = 1,size(str)-1
         if(trm_local)then
            string=string//left_local//trim(str(i))//right_local//sep_local
         else
            string=string//left_local//str(i)//right_local//sep_local
         endif
      enddo
      if(trm_local)then
         string=string//left_local//trim(str(i))//right_local
      else
         string=string//left_local//str(i)//right_local
      endif
   endif
   if(present(start))string=start//string
   if(present(end))string=string//end
end function join
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      reverse(3f) - [M_strings:EDITING] Return a string reversed
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function reverse(str) result (string)
!!
!!     character(*), intent(in) :: str
!!     character(len(str))      :: string
!!
!!##DESCRIPTION
!!      reverse(string) returns a copy of the input string with
!!      all characters reversed from right to left.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_reverse
!!       use M_strings, only: reverse
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          write(*,*)'REVERSE STRINGS:',reverse('Madam, I''m Adam')
!!          s='abcdefghijklmnopqrstuvwxyz'
!!          write(*,*) 'original input string is ....',s
!!          write(*,*) 'reversed output string is ...',reverse(s)
!!       end program demo_reverse
!!
!!  Results:
!!
!!      >  REVERSE STRINGS:madA m'I ,madaM
!!      >  original input string is ....abcdefghijklmnopqrstuvwxyz
!!      >  reversed output string is ...zyxwvutsrqponmlkjihgfedcba
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function reverse(string) result (rev)

! ident_22="@(#) M_strings reverse(3f) Return a string reversed"

character(len=*),intent(in)    :: string   ! string to reverse
character(len=len(string))     :: rev      ! return value (reversed string)
integer                        :: length
integer                        :: i
   length = len(string)

   do i = 1,length
      rev(i:i)=string(length-i+1:length-i+1)
   enddo
end function reverse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper_quoted(3f) - [M_strings:CASE] elemental function converts string to
!!                uppercase skipping strings quoted per Fortran syntax rules
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper_quoted(str) result (string)
!!
!!     character(*), intent(in)    :: str
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!    upper_quoted(string) returns a copy of the input string with all not-quoted
!!    characters converted to uppercase, assuming ASCII character sets
!!    are being used. The quoting rules are the same as for Fortran source.
!!    Either a single or double quote starts a quoted string, and a quote
!!    character of the same type is doubled when it appears internally in
!!    the quoted string. If a double quote quotes the string single quotes
!!    may appear in the quoted string as single characters, and vice-versa
!!    for single quotes.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!
!!##RETURNS
!!    upper  copy of the input string with all unquoted characters converted
!!           to uppercase
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_upper_quoted
!!     use M_strings, only: upper_quoted
!!     implicit none
!!     character(len=:),allocatable  :: s
!!     s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with ""&
!!        & Quote" everything else'
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper_quoted(s)
!!        write(*,'(1x,a,*(a:,"+"))') 'upper_quoted(3f) is elemental ==>', &
!!        & upper_quoted(["abc","def","ghi"])
!!     end program demo_upper_quoted
!!
!!    Expected output:
!!
!!     mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" everything else
!!     upper-case output string is ... ABCDEFG ABCDEFG "Double-Quoted"
!!     'Single-Quoted' "with "" Quote" EVERYTHING ELSE
!!     upper_quoted(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function upper_quoted(str) result (string)

! ident_23="@(#) M_strings upper_quoted(3f) elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules"

character(len=*), intent(in)   :: str     ! The input string
character(len=len(str))        :: string  ! The output string
logical                        :: toggle
character(len=1)               :: togglechar
integer                        :: irnk
integer                        :: i
character(len=26), parameter   :: large="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(len=26), parameter   :: small="abcdefghijklmnopqrstuvwxyz"

   string=str
   toggle = .TRUE.
   do i = 1, len_trim(string)
      if(toggle) then
         if(string(i:i) == '"' .or. string(i:i) == "'") then
            toggle = .not. toggle
            togglechar = string(i:i)
         endif
         irnk = index(small, string(i:i))
         if(irnk > 0) then
            string(i:i) = large(irnk:irnk)
         endif
      else
         if(string(i:i) == togglechar) toggle = .not. toggle
      endif
   enddo
end function upper_quoted
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper(3f) - [M_strings:CASE] changes a string to uppercase
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper(str,begin,end) result (string)
!!
!!     character(*), intent(in)    :: str
!!     integer,optional,intent(in) :: begin,end
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!      upper(string) returns a copy of the input string with all characters
!!      converted in the optionally specified range to uppercase, assuming
!!      ASCII character sets are being used. If no range is specified the
!!      entire string is converted to uppercase.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!    begin  optional starting position in "str" to begin converting to
!!           uppercase
!!    end    optional ending position in "str" to stop converting to
!!           uppercase
!!
!!##RETURNS
!!    upper  copy of the input string with all characters converted to
!!           uppercase over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_upper
!!     use M_strings, only: upper
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper(s)
!!        write(*,*) 'make first character uppercase  ... ',&
!!        & upper('this is a sentence.',1,1)
!!        write(*,'(1x,a,*(a:,"+"))') 'UPPER(3f) is elemental ==>',&
!!        & upper(["abc","def","ghi"])
!!     end program demo_upper
!!
!!    Expected output
!!
!!     mixed-case input string is .... ABCDEFG abcdefg
!!     upper-case output string is ... ABCDEFG ABCDEFG
!!     make first character uppercase  ... This is a sentence.
!!     UPPER(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
! Timing
!
!    Several different methods have been proposed for changing case.
!    A simple program that copies a large file and converts it to
!    uppercase was timed and compared to a simple copy. This was used
!    to select the default function.
!
! NULL:    83.41user  9.25system 1:37.94elapsed 94%CPU
! upper:  101.44user 10.89system 1:58.36elapsed 94%CPU
! upper2: 105.04user 10.69system 2:04.17elapsed 93%CPU
! upper3: 267.21user 11.69system 4:49.21elapsed 96%CPU
elemental pure function upper_all(str) result (string)

! ident_24="@(#) M_strings upper_all(3f) returns an uppercase string"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
! note using kind=int8 is faster than int32 in gfortran
integer(kind=int8), parameter :: ade_a = iachar('a'), ade_z = iachar('z')
integer(kind=int8), parameter :: diff = iachar('A',kind=int8) - iachar('a',kind=int8)
integer(kind=int8)            :: ade_char

   do concurrent(i=1:len(str))                       ! step thru each letter in the string in specified range
      ade_char = iachar(str(i:i), int8)              ! ASCII Decimal Equivalent
      if (ade_char >= ade_a .and. ade_char <= ade_z) ade_char = ade_char + diff
      string(i:i) = achar(ade_char)
   enddo

   if(len(str).eq.0)string = str

end function upper_all
elemental pure function upper_range(str,begin,end) result (string)

! ident_25="@(#) M_strings upper_range(3f) returns a string with the specified range converted to uppercase"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
integer, intent(in)           :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
! note using kind=int8 is faster than int32 in gfortran
integer(kind=int8), parameter :: diff = iachar('A',kind=int8) - iachar('a',kind=int8)

   iend=len(str)
   if(iend.ne.0.and.(end.le.iend.and.end.ge.1).and.(begin.ge.1.and.begin.le.iend))then
      ibegin=begin
      iend=end
      string = str                                      ! initialize output string to input string
      ! note doing everything in a loop instead of just assigning string=str and then doing just changed values in loop is faster!
      do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
          select case (str(i:i))
          case ('a':'z')                                ! located miniscule letter
             string(i:i) = achar(iachar(str(i:i),kind=int8) + diff)    ! change miniscule letter to majascule
          case default
             string(i:i) = str(i:i)
          end select
      enddo
   else
      string=str
   endif
end function upper_range
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lower(3f) - [M_strings:CASE] changes a string to lowercase over
!!    specified range
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower(str,begin,end) result (string)
!!
!!     character(*), intent(in) :: str
!!     integer,optional         :: begin, end
!!     character(len(str))      :: string  ! output string
!!
!!##DESCRIPTION
!!      lower(str) returns a copy of the ASCII input string with all
!!      characters converted to miniscule (ie. "lowercase") over the
!!      specified range, If no range is specified the entire string is
!!      converted to miniscule.
!!
!!##OPTIONS
!!    str    string to convert to miniscule
!!    begin  optional starting position in "str" to begin converting to
!!           miniscule. Defaults to the beginning of the string (ie. "1").
!!    end    optional ending position in "str" to stop converting to
!!           miniscule. Defaults to the end of the string (ie. "len(str)").
!!
!!##RETURNS
!!    lower  copy of the entire input string with all characters converted to
!!           miniscule over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days
!!    of the mechanical printing press. Individual metal alloy casts of
!!    each needed letter or punctuation symbol were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These metal
!!    casts were stored and organized in wooden cases. The more-often-needed
!!    miniscule letters were placed closer to hand, in the lower cases of
!!    the work bench. The less often needed, capitalized, majuscule letters,
!!    ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_lower
!!       use M_strings, only: lower
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          s=' ABCDEFG abcdefg '
!!          write(*,*) 'mixed-case input string is ....',s
!!          write(*,*) 'lower-case output string is ...',lower(s)
!!       end program demo_lower
!!
!!    Expected output
!!
!!       mixed-case input string is .... ABCDEFG abcdefg
!!       lower-case output string is ... abcdefg abcdefg
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function lower(str,begin,end) result (string)

! ident_26="@(#) M_strings lower(3f) Changes a string to lowercase over specified range"

character(*), intent(in)    :: str
character(len(str))         :: string
integer,intent(in),optional :: begin, end
integer                     :: i
integer                     :: ibegin, iend
integer,parameter           :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                    ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    switch(3f) - [M_strings:ARRAY] converts between CHARACTER scalar and
!!    array of single characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function switch(array) result (string)
!!
!!     character(len=1),intent(in) :: array(:)
!!     character(len=SIZE(array))  :: string
!!
!!      or
!!
!!    pure function switch(string) result (array)
!!
!!     character(len=*),intent(in) :: string
!!     character(len=1)            :: array(len(string))
!!
!!##DESCRIPTION
!!    SWITCH(3f): generic function that switches CHARACTER string to an array
!!    of single characters or an array of single characters to a CHARACTER
!!    string. Useful in passing strings to C. New Fortran features may
!!    supersede these routines.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_switch
!!    use M_strings, only : switch, isalpha, islower, nospace
!!    character(len=*),parameter :: &
!!    & dashes='-----------------------------------'
!!    character(len=*),parameter :: string='This is a string'
!!    character(len=1024)        :: line
!!
!!    ! First, examples of standard Fortran features
!!    ! returns array [F,T,T,T,T,T]
!!    write(*,*)['A','=','=','=','=','='] == '='
!!    ! this would return T
!!    write(*,*)all(['=','=','=','=','=','='] == '=')
!!    ! this would return F
!!    write(*,*)all(['A','=','=','=','=','='] == '=')
!!
!!    ! so to test if the string DASHES is all dashes
!!    ! using SWITCH(3f) is
!!    if(all(switch(dashes) == '-'))then
!!       write(*,*)'DASHES is all dashes'
!!    endif
!!
!!    ! so to test is a string is all letters
!!    ! isalpha(3f) returns .true. only if character is a letter
!!    ! false because dashes are not a letter
!!    write(*,*) all(isalpha(switch(dashes)))
!!    ! false because of spaces
!!    write(*,*) all(isalpha(switch(string)))
!!    ! true because removed whitespace
!!    write(*,*) all(isalpha(switch(nospace(string))))
!!
!!    ! to see if a string is all uppercase
!!    ! show the string
!!    write(*,*) string
!!    ! converted to character array
!!    write(*,'(1x,*("[",a,"]":))') switch(string)
!!    write(*,'(*(l3))') islower(switch(string))
!!
!!    ! we need a string that is all letters
!!    line=nospace(string)
!!    write(*,*)'LINE=',trim(line)
!!    ! all true except first character
!!    write(*,*) islower(switch(nospace(string)))
!!    ! should be false
!!    write(*,*) all(islower(switch(nospace(string))))
!!    ! should be true
!!    write(*,*) all(islower(switch(nospace(string(2:)))))
!!
!!    end program demo_switch
!!
!!  Expected output
!!
!!     > F T T T T T
!!     > T
!!     > F
!!     > DASHES is all dashes
!!     > F
!!     > F
!!     > T
!!     > This is a string
!!     > [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g]
!!     >  F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T
!!     > LINE=Thisisastring
!!     > F T T T T T T T T T T T T
!!     > F
!!     > T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function a2s(array)  result (string)

! ident_27="@(#) M_strings a2s(3fp) function to copy char array to string"

character(len=1),intent(in) :: array(:)
character(len=SIZE(array))  :: string
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall( i = 1:size(array)) string(i:i) = array(i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  string=transfer(array,string)
end function a2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

! ident_28="@(#) M_strings s2a(3fp) function to copy string(1 Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  array=transfer(string,array)
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2c(3f) - [M_strings:ARRAY] convert character variable to array of
!!      characters with last element set to null
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2c(string)
!!
!!     character(len=*),intent=(in)  :: string
!!     character(len=1),allocatable  :: s2c(:)
!!
!!##DESCRIPTION
!!    Given a character variable convert it to an array of single-character
!!    character variables with the last element set to a null character.
!!    This is generally used to pass character variables to C procedures.
!!
!!##EXAMPLES
!!
!!
!! character(len=3),allocatable :: array(:)
!! integer                      :: i
!!    ! put one character into each 3-character element of array
!!    array = [(string(i:i),i=1,len(string))]
!!    ! write array with ASCII Decimal Equivalent below it except show
!!    ! unprintable characters like NULL as "XXX"
!!    write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!    write(*,g) iachar(array(:)(1:1))
!!
!!    Sample Program:
!!
!!     program demo_s2c
!!     use M_strings, only : s2c
!!     implicit none
!!     character(len=*),parameter   :: string="single string"
!!     character(len=*),parameter   :: g= '(1x,*("[",g3.3,"]":))'
!!     character(len=3),allocatable :: array(:)
!!        write(*,*)'INPUT STRING ',trim(string)
!!        ! put one character into each 3-character element of array
!!        array=s2c(string)
!!        ! write array with ASCII Decimal Equivalent below it except show
!!        ! unprintable characters like NULL as "XXX"
!!        write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!        write(*,g) iachar(array(:)(1:1))
!!     end program demo_s2c
!!
!!   Expected output:
!!
!!    INPUT STRING single string
!!    [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
!!    [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function s2c(string)  RESULT (array)
use,intrinsic :: ISO_C_BINDING, only : C_CHAR

! ident_29="@(#) M_strings s2c(3f) copy string(1 Clen(string)) to char array with null terminator"

character(len=*),intent(in)     :: string

! This is changing, but currently the most portable way to pass a CHARACTER variable to C is to convert it to an array of
! character variables with length one and add a null character to the end of the array. The s2c(3f) function helps do this.
character(kind=C_CHAR,len=1)    :: array(len_trim(string)+1)
integer                         :: i
   do i = 1,size(array)-1
      array(i) = string(i:i)
   enddo
   array(size(array):)=achar(0)
end function s2c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      c2s(3f) - [M_strings:ARRAY] convert C string pointer to Fortran
!!      character string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function c2s(c_string_pointer) result(f_string)
!!
!!     type(c_ptr), intent(in)       :: c_string_pointer
!!     character(len=:), allocatable :: f_string
!!
!!##DESCRIPTION
!!    Given a C pointer to a character string return a Fortran character
!!    string.
!!
!!##OPTIONS
!!    c_string_pointer  C pointer to convert
!!
!!##RETURNS
!!    f_string          Fortran character variable to return
!!
!!##EXAMPLES
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function c2s(c_string_pointer) result(f_string)
! gets a C string (pointer), and returns the corresponding Fortran string;
! If the C string is null, it returns "NULL", similar to C's "(null)" printed in similar cases:
use, intrinsic :: iso_c_binding, only: c_ptr,c_f_pointer,c_char,c_null_char

! ident_30="@(#) M_strings c2s(3f) copy pointer to C char array till a null is encountered to a Fortran string up to 4096 characters"

integer,parameter                             :: max_length=4096
type(c_ptr), intent(in)                       :: c_string_pointer
character(len=:), allocatable                 :: f_string
character(kind=c_char), dimension(:), pointer :: char_array_pointer => null()
character(len=max_length)                     :: aux_string
integer                                       :: i,length=0

   call c_f_pointer(c_string_pointer,char_array_pointer,[max_length])
   if (.not.associated(char_array_pointer)) then
     allocate(character(len=4)::f_string)
     f_string="NULL"
     return
   endif
   aux_string=" "
   do i=1,max_length
     if (char_array_pointer(i)==c_null_char) then
       length=i-1
       exit
     endif
     aux_string(i:i)=char_array_pointer(i)
   enddo
   allocate(character(len=length)::f_string)
   f_string=aux_string(1:length)

end function c2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      indent(3f) - [M_strings:WHITESPACE] count number of leading spaces
!!      in a string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function indent(line)
!!
!!     integer                        :: indent
!!     character(len=*),intent(in)    :: line
!!
!!##DESCRIPTION
!!    Count number of leading spaces in a CHARACTER variable.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_indent
!!    !  test filter to count leading spaces in a character variable
!!    !  might want to call notabs(3f) to expand tab characters
!!    use M_strings, only : indent
!!    implicit none
!!    character(len=1024) :: in
!!    integer             :: iostat
!!       READFILE: do
!!          read(*,'(A)',iostat=iostat)in
!!          if(iostat /= 0) exit READFILE
!!          write(*,'(i3,"",a)')indent(in),trim(in)
!!       enddo READFILE
!!    end program demo_indent
!!
!! Results:
!!
!!      > 3   a b c
!!      > 0a b c
!!      > 6      a b c
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function indent(line)

! ident_31="@(#) M_strings indent(3f) find number of leading spaces in a string"

integer                        :: indent
character(len=*),intent(in)    :: line
integer                        :: i
   indent=0
   NOTSPACE: block
      SCAN: do i=1,len(line)
         if(line(i:i) /= ' ')then
            indent=i-1
            exit NOTSPACE
         endif
      enddo SCAN
      indent=len(line)
   endblock NOTSPACE
end function indent
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    visible(3f) - [M_strings:NONALPHA] expand a string to control and
!!    meta-control representations
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function visible(input) result(output)
!!
!!     character(len=*),intent(in)           :: input
!!     character(len=:),allocatable          :: output
!!
!!##DESCRIPTION
!!     visible(3f) expands characters to commonly used sequences used
!!     to represent the characters as control sequences or meta-control
!!     sequences.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_visible
!!     use M_strings, only : visible
!!     integer :: i
!!        do i=0,255
!!           write(*,'(i0,1x,a)')i,visible(char(i))
!!        enddo
!!     end program demo_visible
!!##BUGS
!!     The expansion is not reversible, as input sequences such as "M-" or
!!     "^a" will look like expanded sequences.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function visible(input) result(output)
character(len=*),intent(in)  :: input
character(len=:),allocatable :: output

! ident_32="@(#) M_strings visible(3f) expand escape sequences in a string to control and meta-control representations"

integer                      :: i
character(len=1)             :: c

character(len=*),parameter :: chars(0:255)= [ &
'^@  ', '^A  ', '^B  ', '^C  ', '^D  ', '^E  ', '^F  ', '^G  ', '^H  ', '^I  ', &
'^J  ', '^K  ', '^L  ', '^M  ', '^N  ', '^O  ', '^P  ', '^Q  ', '^R  ', '^S  ', &
'^T  ', '^U  ', '^V  ', '^W  ', '^X  ', '^Y  ', '^Z  ', '^[  ', '^\  ', '^]  ', &
'^^  ', '^_  ', '    ', '!   ', '"   ', '#   ', '$   ', '%   ', '&   ', '''   ', &
'(   ', ')   ', '*   ', '+   ', ',   ', '-   ', '.   ', '/   ', '0   ', '1   ', &
'2   ', '3   ', '4   ', '5   ', '6   ', '7   ', '8   ', '9   ', ':   ', ';   ', &
'<   ', '=   ', '>   ', '?   ', '@   ', 'A   ', 'B   ', 'C   ', 'D   ', 'E   ', &
'F   ', 'G   ', 'H   ', 'I   ', 'J   ', 'K   ', 'L   ', 'M   ', 'N   ', 'O   ', &
'P   ', 'Q   ', 'R   ', 'S   ', 'T   ', 'U   ', 'V   ', 'W   ', 'X   ', 'Y   ', &
'Z   ', '[   ', '\   ', ']   ', '^   ', '_   ', '`   ', 'a   ', 'b   ', 'c   ', &
'd   ', 'e   ', 'f   ', 'g   ', 'h   ', 'i   ', 'j   ', 'k   ', 'l   ', 'm   ', &
'n   ', 'o   ', 'p   ', 'q   ', 'r   ', 's   ', 't   ', 'u   ', 'v   ', 'w   ', &
'x   ', 'y   ', 'z   ', '{   ', '|   ', '}   ', '~   ', '^?  ', 'M-^@', 'M-^A', &
'M-^B', 'M-^C', 'M-^D', 'M-^E', 'M-^F', 'M-^G', 'M-^H', 'M-^I', 'M-^J', 'M-^K', &
'M-^L', 'M-^M', 'M-^N', 'M-^O', 'M-^P', 'M-^Q', 'M-^R', 'M-^S', 'M-^T', 'M-^U', &
'M-^V', 'M-^W', 'M-^X', 'M-^Y', 'M-^Z', 'M-^[', 'M-^\', 'M-^]', 'M-^^', 'M-^_', &
'M-  ', 'M-! ', 'M-" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', &
'M-* ', 'M-+ ', 'M-, ', 'M-- ', 'M-. ', 'M-/ ', 'M-0 ', 'M-1 ', 'M-2 ', 'M-3 ', &
'M-4 ', 'M-5 ', 'M-6 ', 'M-7 ', 'M-8 ', 'M-9 ', 'M-: ', 'M-; ', 'M-< ', 'M-= ', &
'M-> ', 'M-? ', 'M-@ ', 'M-A ', 'M-B ', 'M-C ', 'M-D ', 'M-E ', 'M-F ', 'M-G ', &
'M-H ', 'M-I ', 'M-J ', 'M-K ', 'M-L ', 'M-M ', 'M-N ', 'M-O ', 'M-P ', 'M-Q ', &
'M-R ', 'M-S ', 'M-T ', 'M-U ', 'M-V ', 'M-W ', 'M-X ', 'M-Y ', 'M-Z ', 'M-[ ', &
'M-\ ', 'M-] ', 'M-^ ', 'M-_ ', 'M-` ', 'M-a ', 'M-b ', 'M-c ', 'M-d ', 'M-e ', &
'M-f ', 'M-g ', 'M-h ', 'M-i ', 'M-j ', 'M-k ', 'M-l ', 'M-m ', 'M-n ', 'M-o ', &
'M-p ', 'M-q ', 'M-r ', 'M-s ', 'M-t ', 'M-u ', 'M-v ', 'M-w ', 'M-x ', 'M-y ', &
'M-z ', 'M-{ ', 'M-| ', 'M-} ', 'M-~ ', 'M-^?']
output=''
do i=1,len(input)
   c=input(i:i)
   if(c == ' ')then
      output=output//' '
   else
      output=output//trim(chars(iachar(c)))
   endif
enddo
end function visible
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    expand(3f) - [M_strings:NONALPHA] expand C-like escape sequences
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function expand(line,escape) result(lineout)
!!
!!    character(len=*)                      :: line
!!    character(len=1),intent(in),optional  :: escape
!!    character(len=:),allocatable          :: lineout
!!
!!##DESCRIPTION
!!     EXPAND() expands sequences used to represent commonly used escape
!!     sequences or control characters. By default ...
!!
!!     Escape sequences
!!
!!       \      backslash
!!       a      alert (BEL) -- g is an alias for a
!!       b      backspace
!!       c      suppress further output
!!       e      escape
!!       f      form feed
!!       n      new line
!!       r      carriage return
!!       t      horizontal tab
!!       v      vertical tab
!!       oNNN   byte with octal value NNN (3 digits)
!!       dNNN   byte with decimal value NNN (3 digits)
!!       xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
!!
!!     The default escape character is the backslash, but this may be
!!     changed using the optional parameter ESCAPE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_expand
!!       ! demonstrate filter to expand C-like escape sequences in input lines
!!       use M_strings, only : expand
!!       integer,parameter     :: iwidth=1024
!!       integer               :: i
!!       character(len=iwidth),parameter :: input(*)=[ character(len=iwidth) :: &
!!          '\e[H\e[2J',&   ! home cursor and clear screen on ANSI terminals
!!          '\tABC\tabc',&  ! write some tabs in the output
!!          '\tA\a',&       ! ring bell at end if supported
!!          '\nONE\nTWO\nTHREE',&  ! place one word per line
!!          '\\']
!!          write(*,'(a)')(trim(expand(input(i))),i=1,size(input))
!!    end program demo_expand
!!
!! Results (with nonprintable characters shown visible):
!!
!!     > ^[[H^[[2J
!!     > ^IABC^Iabc
!!     > ^IA^G
!!     >
!!     > ONE
!!     > TWO
!!     > THREE
!!     > !!

!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function expand(line,escape) result(lineout)
!x!USE ISO_C_BINDING ,ONLY: c_horizontal_tab

! ident_33="@(#) M_strings expand(3f) return string with escape sequences expanded"

character(len=*),parameter            :: c_horizontal_tab=char(9)
character(len=*),intent(in)           :: line
character(len=1),intent(in),optional  :: escape ! escape character. Default is backslash
! expand escape sequences found in input string
! Escape sequences
!    %%      escape character           %a     alert (BEL) -- gi is an alias for a
!    %b      backspace                  %c     suppress further output
!    %e      escape                     %E     escape
!    %f      form feed                  %n     new line
!    %r      carriage return            %t     horizontal tab
!    %v      vertical tab
!    %oNNN   byte with octal value NNN (3 digits)
!    %dNNN   byte with decimal value NNN (3 digits)
!    %xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
character(len=1)                      :: esc    ! escape character. Default is %
character(len=:),allocatable          :: lineout
integer                               :: i
integer                               :: lgth
character(len=3)                      :: thr
integer                               :: xxx
integer                               :: iostat
   i=0 ! pointer into input

   lgth=len_trim(line)
   lineout=''

   if(lgth == 0)return

   if (present(escape))then
      esc=escape
   else
      esc=char(92)
   endif

   EXP: do
      i=i+1
      if(i > lgth)exit
      if(line(i:i) == esc)then
         i=i+1
         if(i > lgth)exit
         if(line(i:i) /= esc)then
            BACKSLASH: select case(line(i:i))
            case('a','A','g','G');lineout=lineout//char(  7) ! %a     alert (BEL)
            case('b','B');lineout=lineout//char(  8)         ! %b     backspace
            case('c','C');exit EXP                           ! %c     suppress further output
            case('d','D')                                    ! %d     Dnnn decimal value
                      thr=line(i+1:)
                   read(thr,'(i3)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('e','E');lineout=lineout//char( 27)         ! %e     escape
            case('f','F');lineout=lineout//char( 12)         ! %f     form feed
            case('n','N');lineout=lineout//char( 10)         ! %n     new line
           !case('n','N');lineout=lineout//new_line('A')     ! %n     new line
            case('o','O')
                      thr=line(i+1:)
                   read(thr,'(o3)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('r','R');lineout=lineout//char( 13)         ! %r     carriage return
            case('t','T');lineout=lineout//c_horizontal_tab  ! %t     horizontal tab
            case('v','V');lineout=lineout//char( 11)         ! %v     vertical tab
            case('x','X','h','H')                            ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits)
                      thr=line(i+1:)
                   read(thr,'(z2)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+2
            end select BACKSLASH
         else
            lineout=lineout//esc                             ! escape character, defaults to backslash
         endif
      else
         lineout=lineout//line(i:i)
      endif
      if(i >= lgth)exit EXP
   enddo EXP

end function expand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notabs(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine notabs(INSTR,OUTSTR,lgth)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=*),intent=(out) :: OUTSTR
!!     integer,intent=(out)          :: lgth
!!
!!##DESCRIPTION
!!     NOTABS() converts tabs in INSTR to spaces in OUTSTR while maintaining
!!     columns. It assumes a tab is set every 8 characters. Trailing spaces
!!     are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!     What are some reasons for removing tab characters from an input line?
!!     Some Fortran compilers have problems with tabs, as tabs are not
!!     part of the Fortran character set. Some editors and printers will
!!     have problems with tabs. It is often useful to expand tabs in input
!!     files to simplify further processing such as tokenizing an input line.
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RETURNS
!!     outstr    Output string with tabs expanded. Assumed to be of sufficient
!!               length
!!     lgth      Significant length of returned string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_notabs
!!
!!    !  test filter to remove tabs and trailing white space from input
!!    !  on files up to 1024 characters wide
!!    use M_strings, only : notabs
!!    character(len=1024) :: in,out
!!    integer             :: iostat,iout
!!       do
!!          read(*,'(A)',iostat=iostat)in
!!          if(iostat /= 0) exit
!!          call notabs(in,out,iout)
!!          write(*,'(a)')out(:iout)
!!       enddo
!!    end program demo_notabs
!!
!!##SEE ALSO
!!     GNU/Unix commands expand(1) and unexpand(1)
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental impure subroutine notabs(instr,outstr,lgth)

! ident_34="@(#) M_strings notabs(3f) convert tabs to spaces while maintaining columns remove CRLF chars"

character(len=*),intent(in)   :: instr        ! input line to scan for tab characters
character(len=*),intent(out)  :: outstr       ! tab-expanded version of INSTR produced
integer,intent(out)           :: lgth         ! column position of last character put into output string
                                              ! that is, lgth holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
integer,parameter             :: tabsize=8    ! assume a tab stop is set every 8th column
integer                       :: ipos         ! position in OUTSTR to put next character of INSTR
integer                       :: lenin        ! length of input string trimmed of trailing spaces
integer                       :: lenout       ! number of characters output string can hold
integer                       :: istep        ! counter that advances thru input string INSTR one character at a time
character(len=1)              :: c            ! character in input line being processed
integer                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   ipos=1                                     ! where to put next character in output string OUTSTR
   lenin=len_trim(instr( 1:len(instr) ))      ! length of INSTR trimmed of trailing spaces
   lenout=len(outstr)                         ! number of characters output string OUTSTR can hold
   outstr=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: do istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=iachar(c)                       ! get ADE of the character
         EXPAND_TABS : select case (iade)     ! take different actions depending on which character was found
         case(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         case default                         ! c is anything else other than a tab,newline,or return  insert it in output string
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select EXPAND_TABS
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=min(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      lgth=len_trim(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
end subroutine notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dilate(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dilate(INSTR) result(OUTSTR)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=:),allocatable  :: OUTSTR
!!
!!##DESCRIPTION
!!     dilate() converts tabs in INSTR to spaces in OUTSTR.  It assumes a
!!     tab is set every 8 characters. Trailing spaces are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RETURNS
!!     outstr    Output string with tabs expanded.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dilate
!!
!!    use M_strings, only : dilate, visible
!!    implicit none
!!    character(len=:),allocatable :: in
!!    integer                      :: i
!!       in='  this is my string  '
!!       ! change spaces to tabs to make a sample input
!!       do i=1,len(in)
!!          if(in(i:i) == ' ')in(i:i)=char(9)
!!       enddo
!!       write(*,'("[",a,"]")')visible(in)
!!       write(*,'("[",a,"]")')visible(dilate(in))
!!    end program demo_dilate
!!
!!   Results:
!!
!!    > [^I^Ithis^Iis^Imy^Istring^I^I]
!!    > [                this    is      my      string]
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dilate(INSTR) result(OUTSTR)

! ident_35="@(#) M_strings dilate(3f) convert tabs to spaces and trims line removing CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=:),allocatable  :: outstr       ! tab-expanded version of INSTR produced
integer                       :: i
integer                       :: icount
integer                       :: lgth
   icount=0
   do i=1,len(instr)
      if(instr(i:i) == char(9))icount=icount+1
   enddo
   allocate(character(len=(len(instr)+8*icount)) :: outstr)
   call notabs(instr,outstr,lgth)
   outstr=outstr(:lgth)

END function dilate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    adjustc(3f) - [M_strings:WHITESPACE] center text
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   pure function adjustc(string[,length])
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in),optional  :: length
!!    character(len=:),allocatable :: adjustc
!!
!!##DESCRIPTION
!!     Centers input text in a string of the length specified. Returns a
!!     string of length LENGTH if LENGTH is present. Otherwise returns a
!!     string of the length of the input string.
!!
!!##OPTIONS
!!     string  input string to trim and center
!!     length  line length to center text in, optional.
!!
!!##RETURNS
!!     adjustc  centered output string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_adjustc
!!    use M_strings, only : adjustc
!!    !  using length of the input string
!!       write(*,'(a)')       '================================'
!!       write(*,'(a)')adjustc('centered string                 ')
!!       write(*,'(a)')adjustc('                 centered string')
!!       write(*,'(a)')adjustc('  centered string               ')
!!    !  using explicit output string length
!!       write(*,'(a)')repeat('=',50)
!!       write(*,'(a)')adjustc('this is a centered string',50)
!!       write(*,'(a)')repeat('=',50)
!!    end program demo_adjustc
!!
!!   Expected output
!!
!!    ================================
!!            centered string
!!            centered string
!!            centered string
!!    ==================================================
!!                this is a centered string
!!    ==================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function adjustc(string,length)

! ident_36="@(#) M_strings adjustc(3f) center text"

!>
!! PROCEDURE:   adjustc(3f)
!! DESCRIPTION: center text using implicit or explicit length
!!##VERSION:     2.0, 20160711
!! AUTHOR:      John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: string         ! input string to trim and center
integer,intent(in),optional  :: length         ! line length to center text in
character(len=:),allocatable :: adjustc        ! output string
integer                      :: inlen
integer                      :: ileft          ! left edge of string if it is centered
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(length))then                     ! optional length
      inlen=length                             ! length will be requested length
      if(inlen <= 0)then                       ! bad input length
         inlen=len(string)                     ! could not use input value, fall back to length of input string
      endif
   else                                        ! output length was not explicitly specified, use input string length
      inlen=len(string)
   endif
   allocate(character(len=inlen):: adjustc)    ! create output at requested length
   adjustc(1:inlen)=' '                        ! initialize output string to all blanks
!-----------------------------------------------------------------------------------------------------------------------------------
   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it
   if(ileft > 0)then                          ! if string will fit centered in output
      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string
   else                                        ! input string will not fit centered in output string
      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can
   endif
end function adjustc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!!    input string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function nospace(str) - remove all whitespace from input string
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),allocatable :: nospace
!!
!!##DESCRIPTION
!!    nospace(3f) removes space, tab, carriage return, new line, vertical
!!    tab, formfeed and null characters (called "whitespace"). The output
!!    is returned trimmed.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_nospace
!!     use M_strings, only: nospace
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s='  This     is      a     test  '
!!        write(*,*) 'original input string is ....',s
!!        write(*,*) 'processed output string is ...',nospace(s)
!!        if(nospace(s) == 'Thisisatest')then
!!           write(*,*)'nospace test passed'
!!        else
!!           write(*,*)'nospace test error'
!!        endif
!!     end program demo_nospace
!!
!!   Expected output
!!
!!     original input string is ....  This     is      a     test
!!     processed output string is ...Thisisatest
!!     nospace test passed
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function nospace(line)

! ident_37="@(#) M_strings nospace(3f) remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stretch(3f) - [M_strings:LENGTH] return string padded to at least
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function stretch(str,length,pattern,suffix) result(strout)
!!
!!     character(len=*),intent(in)         :: str
!!     integer,intent(in)                  :: length
!!     character(len=*)intent(in),optional :: pattern
!!     character(len=*)intent(in),optional :: suffix
!!     character(len=:),allocatable        :: strout
!!
!!##DESCRIPTION
!!    stretch(3f) pads a string with spaces to at least the specified
!!    length. If the trimmed input string is longer than the requested
!!    length the original string is returned trimmed of trailing spaces.
!!
!!##OPTIONS
!!    str      the input string to return trimmed, but then padded to
!!             the specified length if shorter than length
!!    length   The minimum string length to return
!!    pattern  optional string to use as padding. Defaults to a space.
!!    suffix   optional string to append to output string
!!
!!##RETURNS
!!    strout  The input string padded to the requested length or
!!            the trimmed input string if the input string is
!!            longer than the requested length.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!   program demo_stretch
!!    use M_strings, only : stretch
!!    implicit none
!!    character(len=10)            :: string='abcdefghij'
!!    character(len=:),allocatable :: answer
!!    integer                      :: i
!!       answer=stretch(string,5)
!!       write(*,'("[",a,"]")') answer
!!       answer=stretch(string,20)
!!       write(*,'("[",a,"]")') answer
!!       i=30
!!       write(*,*)
!!       write(*,'(1x,a,i0)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,'(1x,a,i7)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,*) &
!!        & stretch('CHAPTER 1 : The beginning ',i,suffix=': '), 1
!!       write(*,*) &
!!        & stretch('CHAPTER 2 : The end ',i,suffix=': '),1234
!!       write(*,*) &
!!        & stretch('APPENDIX ',i,suffix=': '),           1235
!!   end program demo_stretch
!!
!!   Results:
!!
!!    [abcdefghij]
!!    [abcdefghij          ]
!!
!!     CHAPTER 1 : The beginning ....1
!!     CHAPTER 2 : The end ..........1234
!!     APPENDIX .....................1235
!!
!!     CHAPTER 1 : The beginning ....      1
!!     CHAPTER 2 : The end ..........   1234
!!     APPENDIX .....................   1235
!!
!!     CHAPTER 1 : The beginning     :            1
!!     CHAPTER 2 : The end           :         1234
!!     APPENDIX                      :         1235
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function stretch(line,length,pattern,suffix) result(strout)

! ident_38="@(#) M_strings stretch(3f) return string padded to at least specified length"

character(len=*),intent(in)                  :: line
integer,intent(in)                           :: length
character(len=*),intent(in),optional         :: pattern
character(len=*),intent(in),optional         :: suffix
!-!character(len=max(length,len(trim(line)))) :: strout
character(len=:),allocatable                 :: strout
   if(present(pattern))then
      strout=pad(line,length,pattern)
   else
      strout=pad(line,length)
   endif
   if(present(suffix))then
      strout=strout//suffix
   endif
end function stretch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    rpad(3f) - [M_strings:LENGTH] convert to a string and pad on the right
!!    to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function rpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    rpad(3f) converts a scalar intrinsic value to a string and then pads
!!    it on the right with spaces to at least the specified length. If the
!!    trimmed input string is longer than the requested length the string
!!    is returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the right with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_rpad
!!       use M_strings, only : rpad
!!       implicit none
!!          write(*,'("[",a,"]")') rpad( 'my string', 20)
!!          write(*,'("[",a,"]")') rpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') rpad( valuein=1.0/9.0 , length=20)
!!      end program demo_rpad
!!
!!  Results:
!!
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [42     ]
!!      > [0.111111112         ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rpad_scalar(valuein,length) result(strout)

! ident_39="@(#) M_strings rpad_scalar(3f) return value padded to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present(length))then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = pad(valuein,local_length,' ',clip=.true.)
         return
      class default
         stop '<ERROR>*rpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true. )
   else
      strout = crop( line )
   endif

end function rpad_scalar
!===================================================================================================================================
function rpad_vector(valuein,length) result(strout)

! ident_40="@(#) M_strings rpad_vector(3f) return strings or arguments converted to string right-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(rpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function rpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    cpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    centers the string to specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function cpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    cpad(3f) converts a scalar value to a cropped string and then pads
!!    it with spaces to center it to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded with spaces to
!!             center it at the the specified length if shorter than
!!             length. The input may be any intrinsic scalar which is
!!             converted to a cropped string much as if written with
!!             list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string center-padded to the requested length
!!            with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_cpad
!!       use M_strings, only : cpad
!!       implicit none
!!          write(*,'("[",a,"]")') cpad( 'my string', 20)
!!          write(*,'("[",a,"]")') cpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') cpad( valuein=1.0/9.0 , length=20)
!!      end program demo_cpad
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function cpad_scalar(valuein,length) result(strout)

! ident_41="@(#) M_strings cpad_scalar(3f) convert value to string center-padded to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write( line, '(i0)' ) valuein
      type is (integer(kind=int16));   write( line, '(i0)' ) valuein
      type is (integer(kind=int32));   write( line, '(i0)' ) valuein
      type is (integer(kind=int64));   write( line, '(i0)' ) valuein
      type is (real(kind=real32));     write( line, '(1pg0)' ) valuein
      type is (real(kind=real64));     write( line, '(1pg0)' ) valuein
      type is (logical);               write( line, '(l1)' ) valuein
      type is (complex);               write( line, '("(",1pg0,",",1pg0,")")' ) valuein
      type is (character(len = *))
         if(present( length ) )then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = adjustc( crop(valuein), local_length )
         return
      class default
         stop '<ERROR>*cpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = adjustc( crop(line), length )
   else
      strout = crop( line )
   endif

end function cpad_scalar
!===================================================================================================================================
function cpad_vector(valuein,length) result(strout)

! ident_42="@(#) M_strings cpad_vector(3f) return strings or arguments converted to string center-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(cpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function cpad_vector
!===================================================================================================================================
!>
!!
!!##NAME
!!    lpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    blank-pad on the left to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    lpad(3f) converts a scalar value to a cropped string and then pads
!!    it on the left with spaces to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the left with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_lpad
!!       use M_strings, only : lpad
!!       implicit none
!!          write(*,'("[",a,"]")') lpad( 'my string', 20)
!!          write(*,'("[",a,"]")') lpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') lpad( valuein=1.0/9.0 , length=20)
!!      end program demo_lpad
!!
!! Results:
!!
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [     42]
!!     > [         0.111111112]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lpad_scalar(valuein,length) result(strout)

! ident_43="@(#) M_strings lpad_scalar(3f) convert value to string padded on left to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present( length ))then
            local_length=length
         else
            local_length=len( valuein )
         endif
         strout = pad( valuein, local_length, ' ', right=.false., clip=.true. )
         return
      class default
         stop '<ERROR>*lpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true., right=.false. )
   else
      strout = crop( line )
   endif

end function lpad_scalar
!===================================================================================================================================
function lpad_vector(valuein,length) result(strout)

! ident_44="@(#) M_strings lpad_vector(3f) return vector of strings or arguments converted to string left-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(lpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function lpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    zpad(3f) - [M_strings:LENGTH] pad a string on the left with zeros to
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function zpad(valuein,length) result(strout)
!!
!!     class*,intent(in)           :: valuein(..)
!!     integer,intent(in),optional :: length
!!
!!##DESCRIPTION
!!    zpad(3f) crops the input string (or integer, which will be converted
!!    to a string) and then pads it on the left with zeros to the specified
!!    length.
!!
!!    Note that if the trimmed input string is already as long or longer
!!    than the requested length the trimmed original string is returned.
!!
!!    For strings representing unsigned numbers this is basically an
!!    alias for
!!
!!        strout=pad(str,length,'0',clip=.true.,right=.false.)
!!
!!    For integers the same is often done with internal WRITE(3f) statements
!!    such as
!!
!!        write(strout,'(i5.5)')ivalue
!!
!!    but unlike internal I/O the function call can be used in expressions
!!    or passed as a procedure argument.
!!
!!##OPTIONS
!!    valuein  The input value to left-pad. May be a scalar or vector
!!             string or integer. If the leftmost non-blank character is
!!             a sign character it is moved to the left-most position of
!!             the output.
!!    length   The minimum string length to return. If not present, the
!!             length of the input parameter VALUEIN is used. If the input
!!             value VALUEIN is an integer no zero padding occurs if LENGTH
!!             is not supplied.
!!
!!##RETURNS
!!    strout  A trimmed string padded on the left with zeros to
!!            the requested length
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_zpad
!!       use M_strings, only : zpad
!!       implicit none
!!       character(len=*),parameter :: boxed='("[",a,"]",*(g0,1x))'
!!       integer :: lun, i
!!          print boxed, zpad( '111', 5),'basic use'
!!          print boxed, zpad( valuein=42 , length=7),'by argument name'
!!          print boxed, zpad( '  34567  ', 7),'cropped before padding'
!!          print boxed, zpad( '123456789', 5),'input longer than length'
!!          print boxed, zpad( '  +34567  ', 7),'starts with plus sign'
!!          print boxed, zpad( '  -34567  ', 7),'starts with minus sign'
!!          print boxed, zpad(1234),'some integers instead of strings'
!!          print boxed, zpad(-1234)
!!          print boxed, zpad(1234,8)
!!          print boxed, zpad(-1234,8)
!!          print boxed, zpad(''),'a null gets you nothing'
!!          print boxed, zpad('0'),'but blanks are used for default length'
!!          print boxed, zpad('0    ')
!!          print boxed, zpad('     ')
!!          print *, 'input value may be an array:'
!!          print '("[",a,"]")', zpad([1,10,100,1000,10000,100000],8)
!!
!!          ! example usage:
!!          ! open output_00085.dat
!!          i=85
!!          open(newunit=lun,file='output_'//zpad(i,5)//'.dat')
!!          close(unit=lun,status='delete')
!!
!!      end program demo_zpad
!!
!! Results:
!!
!!     > [00111]basic use
!!     > [0000042]by argument name
!!     > [0034567]cropped before padding
!!     > [123456789]input longer than length
!!     > [+0034567]starts with plus sign
!!     > [-0034567]starts with minus sign
!!     > [1234]some integers instead of strings
!!     > [-1234]
!!     > [00001234]
!!     > [-00001234]
!!     > []a null gets you nothing
!!     > [0]but blanks are used for default length
!!     > [00000]
!!     > [00000]
!!     >  input value may be an array:
!!     > [00000001]
!!     > [00000010]
!!     > [00000100]
!!     > [00001000]
!!     > [00010000]
!!     > [00100000]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function zpad_scalar(valuein,length) result(strout)

! ident_45="@(#) M_strings zpad_vector(3f) return string or argument converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout
character(len=4096)              :: line
integer                          :: local_length
   if(present(length))then
      local_length=length
   else
      local_length=-1
   endif
   select type(valuein)
      type is (integer(kind=int8));     write(line,'(i0)') valuein
      type is (integer(kind=int16));    write(line,'(i0)') valuein
      type is (integer(kind=int32));    write(line,'(i0)') valuein
      type is (integer(kind=int64));    write(line,'(i0)') valuein
      type is (real(kind=real32));      write(line,'(1pg0)') valuein
      type is (real(kind=real64));      write(line,'(1pg0)') valuein
      type is (logical);                write(line,'(l1)') valuein
      type is (character(len=*));       line=valuein
         if(local_length==-1)local_length=len(valuein)
      type is (complex);                write(line,'("(",1pg0,",",1pg0,")")') valuein
   end select
   if(local_length == -1)then
     strout=clip(line)
   else
      line=clip(line)//'  '
      if(scan(line(1:1),'+-') == 1)then
         strout= line(1:1)//pad(line(2:),local_length,'0',clip=.true.,right=.false.)
      else
         strout= pad(line,local_length,'0',clip=.true.,right=.false.)
      endif
   endif
end function zpad_scalar
!===================================================================================================================================
function zpad_vector(valuein,length) result(strout)

! ident_46="@(#) M_strings zpad_vector(3f) return vector of strings or arguments converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(zpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function zpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   pad(3f) - [M_strings:LENGTH] return string padded to at least
!!   specified length
!!   (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   function pad(str,length,pattern,right,clip) result(strout)
!!
!!    character(len=*)                           :: str
!!    integer,intent(in)                         :: length
!!    character(len=max(length,len(trim(line)))) :: strout
!!    character(len=*),intent(in),optional       :: pattern
!!    logical,intent(in),optional                :: right
!!    logical,intent(in),optional                :: clip
!!
!!##DESCRIPTION
!!   pad(3f) pads a string with a pattern to at least the specified
!!   length. If the trimmed input string is longer than the requested
!!   length the trimmed string is returned.
!!
!!##OPTIONS
!!   str      the input string to return trimmed, but then padded to
!!            the specified length if shorter than length
!!   length   The minimum string length to return
!!   pattern  optional string to use as padding. Defaults to a space.
!!   right    if true pads string on the right, else on the left
!!   clip     trim spaces from input string but otherwise retain length.
!!            Except for simple cases you typically would trim the input
!!            yourself.
!!
!!##RETURNS
!!   strout  The input string padded to the requested length or
!!           the trimmed input string if the input string is
!!           longer than the requested length.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_pad
!!     use M_strings, only : pad
!!     implicit none
!!     character(len=10)            :: string='abcdefghij'
!!     character(len=:),allocatable :: answer
!!     integer                      :: i
!!     character(len=*),parameter   :: g='(*(g0))'
!!        answer=pad(string,5)
!!        write(*,'("[",a,"]")') answer
!!        answer=pad(string,20)
!!        write(*,'("[",a,"]")') answer
!!        i=30
!!        write(*,g)
!!        write(*,'(1x,a,1x,i0)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!        write(*,*)
!!        write(*,'(1x,a,i7)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!
!!         write(*,g)pad('12',5,'0',right=.false.)
!!
!!         write(*,g)pad('12345 ',30,'_',right=.false.)
!!         write(*,g)pad('12345 ',30,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.,clip=.true.)
!!    end program demo_pad
!!
!!  Results:
!!
!!  > [abcdefghij]
!!  > [abcdefghij          ]
!!  >
!!  >  CHAPTER 1 : The beginning .... 1
!!  >  CHAPTER 2 : The end .......... 1234
!!  >  APPENDIX ..................... 1235
!!  >
!!  >  CHAPTER 1 : The beginning ....      1
!!  >  CHAPTER 2 : The end ..........   1234
!!  >  APPENDIX .....................   1235
!!  > 00012
!!  > ________________________12345
!!  > _________________________12345
!!  > _12345
!!  > __12345
!!  > 12345
!!  > _12345
!!  > 12345
!!  > 12345
!!  > 12345
!!  > 12345
!!
!!##SEE ALSO
!!     adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f)
!!
!!     adjustc(3f), stretch(3f), lpad(3f), rpad(3f), cpad(3f), zpad(3f), lenset(3f)
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function pad(line,length,pattern,right,clip) result(strout)

!$@(#) M_strings::pad(3f): return string padded to at least specified length

character(len=*),intent(in)          :: line
integer,intent(in)                   :: length
character(len=*),intent(in),optional :: pattern
logical,optional,intent(in)          :: right
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: strout
logical                              :: local_right
logical                              :: local_clip
character(len=:),allocatable         :: local_pattern
character(len=:),allocatable         :: local_line

if(  present(right)    )then;  local_right=right;      else;  local_right=.true.;  endif
if(  present(clip)     )then;  local_clip=clip;        else;  local_clip=.false.;  endif
if(  present(pattern)  )then;  local_pattern=pattern;  else;  local_pattern=' ';   endif

if(len(local_pattern) == 0)then
   strout=line
else

   if(local_clip)then
      local_line=trim(adjustl(line))
      allocate(character(len=max(length,len(local_line))) :: strout)
   else
      local_line=line
      allocate(character(len=max(length,len(line))) :: strout)
   endif

   if(local_right)then
      strout(:)=local_line//repeat(local_pattern,len(strout)/len(local_pattern)+1)
   else
      strout(:)=repeat(local_pattern, ceiling(real(len(strout))/len(local_pattern)))
      strout(max(0,len(strout)-len(local_line))+1:)=local_line
   endif

endif
end function pad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lenset(3f) - [M_strings:LENGTH] return string trimmed or padded to
!!                 specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lenset(str,length) result(strout)
!!
!!     character(len=*)      :: str
!!     character(len=length) :: strout
!!     integer,intent(in)    :: length
!!
!!##DESCRIPTION
!!    lenset(3f) truncates a string or pads it with spaces to the specified
!!    length.
!!
!!##OPTIONS
!!    str     input string
!!    length  output string length
!!
!!##RETURNS
!!    strout  output string
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_lenset
!!      use M_strings, only : lenset
!!      implicit none
!!      character(len=10)            :: string='abcdefghij'
!!      character(len=:),allocatable :: answer
!!         answer=lenset(string,5)
!!         write(*,'("[",a,"]")') answer
!!         answer=lenset(string,20)
!!         write(*,'("[",a,"]")') answer
!!     end program demo_lenset
!!
!!    Expected output:
!!
!!     [abcde]
!!     [abcdefghij          ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lenset(line,length) result(strout)

! ident_47="@(#) M_strings lenset(3f) return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    merge_str(3f) - [M_strings:LENGTH] pads strings to same length and
!!    then calls MERGE(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function merge_str(str1,str2,expr) result(strout)
!!
!!     character(len=*),intent(in),optional :: str1
!!     character(len=*),intent(in),optional :: str2
!!     logical,intent(in)                   :: expr
!!     character(len=:),allocatable         :: strout
!!
!!##DESCRIPTION
!!    merge_str(3f) pads the shorter of str1 and str2 to the longest length
!!    of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr).
!!    It trims trailing spaces off the result and returns the trimmed
!!    string. This makes it easier to call MERGE(3f) with strings, as
!!    MERGE(3f) requires the strings to be the same length.
!!
!!    NOTE: STR1 and STR2 are always required even though declared optional.
!!          this is so the call "STR_MERGE(A,B,present(A))" is a valid call.
!!          The parameters STR1 and STR2 when they are optional parameters
!!          can be passed to a procedure if the options are optional on the
!!          called procedure.
!!
!!##OPTIONS
!!    STR1    string to return if the logical expression EXPR is true
!!    STR2    string to return if the logical expression EXPR is false
!!    EXPR    logical expression to evaluate to determine whether to return
!!            STR1 when true, and STR2 when false.
!!##RETURNS
!!     MERGE_STR  a trimmed string is returned that is otherwise the value
!!                of STR1 or STR2, depending on the logical expression EXPR.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_merge_str
!!     use M_strings, only : merge_str
!!     implicit none
!!     character(len=:), allocatable :: answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 == 10)
!!        write(*,'("[",a,"]")') answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 /= 10)
!!        write(*,'("[",a,"]")') answer
!!     end program demo_merge_str
!!
!!   Expected output
!!
!!     [first string]
!!     [second string is longer]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

! ident_48="@(#) M_strings merge_str(3f) pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in),optional :: str1
character(len=*),intent(in),optional :: str2
character(len=:),allocatable         :: str1_local
character(len=:),allocatable         :: str2_local
logical,intent(in)                   :: expr
character(len=:),allocatable         :: strout
integer                              :: big
   if(present(str2))then
      str2_local=str2
   else
      str2_local=''
   endif
   if(present(str1))then
      str1_local=str1
   else
      str1_local=''
   endif
   big=max(len(str1_local),len(str2_local))
   ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning ''
   strout=trim(merge(lenset(str1_local,big),lenset(str2_local,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    squeeze(3f) - [M_strings:EDITING] delete adjacent duplicate occurrences
!!    of a character from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function squeeze(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    squeeze(3f) reduces adjacent duplicates of the specified character
!!    to a single character
!!
!!##OPTIONS
!!    STR     input string in which to reduce adjacent duplicate characters
!!            to a single character
!!    CHAR    The character to remove adjacent duplicates of
!!
!!##RETURNS
!!    OUTSTR  string with all contiguous adjacent occurrences of CHAR removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_squeeze
!!    use M_strings, only : squeeze
!!    implicit none
!!    character(len=:),allocatable :: strings(:)
!!
!!    strings=[ character(len=72) :: &
!!    &'', &
!!    &'"If I were two-faced,&
!!    &would I be wearing this one?" --- Abraham Lincoln',  &
!!    &'..1111111111111111111&
!!    &111111111111111111111111111111111111111111117777888', &
!!    &'I never give ''em hell,&
!!    &I just tell the truth, and they think it''s hell.',&
!!    &'                                                  &
!!    & --- Harry S Truman'    &
!!    &]
!!       call printme( trim(strings(1)), ' ' )
!!       call printme( strings(2:4),     ['-','7','.'] )
!!       call printme( strings(5),       [' ','-','r'] )
!!    contains
!!    impure elemental subroutine printme(str,chr)
!!    character(len=*),intent(in) :: str
!!    character(len=1),intent(in) :: chr
!!    character(len=:),allocatable :: answer
!!       write(*,'(a)')repeat('=',11)
!!       write(*,'("IN:   <<<",g0,">>>")')str
!!       answer=squeeze(str,chr)
!!       write(*,'("OUT:  <<<",g0,">>>")')answer
!!       write(*,'("LENS: ",*(g0,1x))')"from",len(str),"to",len(answer), &
!!               & "for a change of",len(str)-len(answer)
!!       write(*,'("CHAR: ",g0)')chr
!!    end subroutine printme
!!    end program demo_squeeze
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function squeeze(str,charp) result (outstr)

character(len=*),intent(in)  :: str
character(len=1),intent(in)  :: charp
character(len=:),allocatable :: outstr
character(len=1)             :: ch, last_one
integer                      :: i, pio ! position in output

   outstr=repeat(' ',len(str))      ! start with a string big enough to hold any output
   if(len(outstr)==0)return         ! handle edge condition
   last_one=str(1:1)                ! since at least this long start output with first character
   outstr(1:1)=last_one
   pio=1

   do i=2,len(str)
      ch=str(i:i)
      pio=pio+merge(0,1, ch == last_one.and.ch == charp) ! decide whether to advance before saving
      outstr(pio:pio)=ch  ! store new one or overlay the duplcation
      last_one=ch
   enddo

   outstr=outstr(:pio)              ! trim the output string to just what was set
end function squeeze
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace
!!    to a single character (or nothing)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function compact(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    COMPACT(3f) converts multiple spaces, tabs and control characters
!!    (called "whitespace") to a single character or nothing. Leading
!!    whitespace is removed.
!!
!!##OPTIONS
!!    STR     input string to reduce or remove whitespace from
!!    CHAR    By default the character that replaces adjacent
!!            whitespace is a space. If the optional CHAR parameter is supplied
!!            it will be used to replace the whitespace. If a null character is
!!            supplied for CHAR whitespace is removed.
!!
!!##RETURNS
!!    OUTSTR  string of same length as input string but with all contiguous
!!            whitespace reduced to a single space and leading whitespace
!!            removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_compact
!!     use M_strings, only : compact
!!     implicit none
!!     ! produces 'This is a test               '
!!     write(*,*)compact('  This     is      a     test  ')
!!     ! produces 'Thisisatest                  '
!!     write(*,*)compact('  This     is      a     test  ',char='')
!!     ! produces 'This:is:a:test               '
!!     write(*,*)compact('  This     is      a     test  ',char=':')
!!     ! note CHAR is used to replace the whitespace, but if CHAR is
!!     ! in the original string it is just copied
!!     write(*,*)compact('A  AA    A   AAAAA',char='A')
!!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
!!     ! not 'A'
!!    end program demo_compact
!!
!!    Expected output
!!
!!     >This is a test
!!     >Thisisatest
!!     >This:is:a:test
!!     >AAAAAAAAAAAA
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

! ident_49="@(#) M_strings compact(3f) Converts white-space to single spaces; removes leading spaces"

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char) == 0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(iachar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output == 0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   enddo IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     noesc(3f) - [M_strings:NONALPHA] convert non-printable characters
!!     to a space
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental function noesc(INSTR)
!!
!!     character(len=*),intent(in) :: INSTR
!!     character(len=len(instr))   :: noesc
!!
!!##DESCRIPTION
!!      Convert non-printable characters to a space.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_noesc
!!
!!     use M_strings, only : noesc
!!     implicit none
!!     character(len=128) :: ascii
!!     character(len=128) :: cleared
!!     integer            :: i
!!     ! fill variable with base ASCII character set
!!     do i=1,128
!!        ascii(i:i)=char(i-1)
!!     enddo
!!     cleared=noesc(ascii)
!!     write(*,*)'characters and their ADE (ASCII Decimal Equivalent)'
!!     call ade(ascii)
!!     write(*,*)'Cleared of non-printable characters'
!!     call ade(cleared)
!!     write(*,*)'Cleared string:'
!!     write(*,*)cleared
!!     contains
!!       subroutine ade(string)
!!       implicit none
!!       ! the string to print
!!       character(len=*),intent(in) :: string
!!       ! number of characters in string to print
!!       integer :: lgth
!!       ! counter used to step thru string
!!       integer :: i
!!          ! get trimmed length of input string
!!          lgth=len_trim(string(:len(string)))
!!
!!          ! replace lower unprintable characters with spaces
!!          write(*,101)(merge(string(i:i),' ',&
!!          & iachar(string(i:i)) >= 32        &
!!          & .and.                            &
!!          & iachar(string(i:i)) <= 126)      &
!!          & ,i=1,lgth)
!!
!!          ! print ADE value of character underneath it
!!          write(*,202)     (iachar(string(i:i))/100,    i=1,lgth)
!!          write(*,202)(mod( iachar(string(i:i)),100)/10,i=1,lgth)
!!          write(*,202)(mod((iachar(string(i:i))),10),   i=1,lgth)
!!       ! format for printing string characters
!!       101   format(*(a1:))
!!       ! format for printing ADE values
!!       202   format(*(i1:))
!!       end subroutine ade
!!     end program demo_noesc
!!
!!    Expected output
!!
!!    The string is printed with the ADE value vertically beneath.
!!    The original string has all the ADEs from 000 to 127. After
!!    NOESC(3f) is called on the string all the "non-printable"
!!    characters are replaced with a space (ADE of 032).
!!
!!   characters and their ADE (ASCII Decimal Equivalent)
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    0000000000000000000000000000000000000000001111111111111111111111111111
!!    >00000000001111111111222222222233333333334444444444555555555566666666
!!    667777777777888888888899999999990000000000111111111122222222
!!    >012345678901234567890123456789012345678901234567890123456789012345678
!!    90123456789012345678901234567890123456789012345678901234567
!!
!!   Cleared of non-printable characters
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    000000000000000000000000000000000000000000111111111111111111111111111
!!    >3333333333333333333333333333333333333333444444444455555555
!!    556666666666777777777788888888889999999999000000000011111111112222222
!!    >2222222222222222222222222222222223456789012345678901234567
!!    890123456789012345678901234567890123456789012345678901234567890123456
!!
!!   Cleared string:
!!
!!    >                                  !"#$%&'()*+,-./0123456789:;<=>?@
!!    ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function noesc(INSTR)

! ident_50="@(#) M_strings noesc(3f) convert non-printable characters to a space"

character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
!-----------------------------------------------------------------------------------------------------------------------------------
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_value(3f) - [M_strings:TYPE] subroutine returns numeric
!!      value from string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine string_to_value(chars,valu,ierr)
!!
!!     character(len=*),intent(in)              :: chars   ! input string
!!     integer|real|doubleprecision,intent(out) :: valu
!!     integer,intent(out)                      :: ierr
!!
!!##DESCRIPTION
!!    Returns a numeric value from a numeric character string.
!!
!!    Works with any g-format input, including integer, real, and
!!    exponential. If the input string begins with "B", "Z", or "O"
!!    and otherwise represents a positive whole number it is assumed to
!!    be a binary, hexadecimal, or octal value. If the string contains
!!    commas they are removed. If the string is of the form NN:MMM... or
!!    NN#MMM then NN is assumed to be the base of the whole number.
!!
!!    If an error occurs in the READ, IOSTAT is returned in IERR and
!!    value is set to zero. if no error occurs, IERR=0.
!!
!!##OPTIONS
!!       CHARS  input string to read numeric value from
!!
!!##RETURNS
!!    VALU   numeric value returned. May be INTEGER, REAL, or
!!              DOUBLEPRECISION.
!!    IERR   error flag (0 == no error)
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_string_to_value
!!     use M_strings, only: string_to_value
!!     implicit none
!!     real :: value
!!     integer :: ierr
!!     character(len=80) :: string
!!        string=' -40.5e-2 '
!!        call string_to_value(string,value,ierr)
!!        write(*,*) 'value of string ['//trim(string)//'] is ',value
!!    end program demo_string_to_value
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine a2r(chars,valu,ierr)

! ident_51="@(#) M_strings a2r(3fp) subroutine returns real value from string"

character(len=*),intent(in) :: chars                      ! input string
real,intent(out)            :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(ierr == 0)then
      if(valu8 <= huge(valu))then
         valu=real(valu8)
      else
         call journal('sc','*a2r* - value too large'//str(valu8)//'>'//str(huge(valu)))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2r
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2i(chars,valu,ierr)

! ident_52="@(#) M_strings a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i* - value too large'//str(valu8)//'>'//str(huge(valu)))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_53="@(#) M_strings a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!    IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: iomsg                        ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   iomsg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=iomsg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=iomsg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(iomsg /= '')then
            call journal('sc','*a2d* - ['//trim(iomsg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    s2v(3f) - [M_strings:TYPE] function returns doubleprecision
!!    numeric value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2v(string[,ierr][,onerr])
!!
!!     character(len=*)             :: string
!!     doubleprecision              :: s2v
!!     integer,intent(out),optional :: ierr
!!     class(*),intent(in),optional :: onerr
!!
!!##DESCRIPTION
!!    This function converts a string to a DOUBLEPRECISION numeric value.
!!
!!    The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended
!!    to take CHARACTER variables. The KIND= keyword is not supported
!!    on the extensions.
!!
!!##OPTIONS
!!
!!     string   holds string assumed to represent a numeric value
!!     ierr     If an error occurs the program is stopped if the optional
!!              parameter IERR is not present. If IERR returns a non-zero
!!              value an error occurred.
!!     onerr    The value to return on error. A value of NaN is
!!              returned on error by default.
!!
!!##RETURNS
!!     s2v      numeric value read from string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_s2v
!!
!!     use M_strings, only: s2v, int, real, dble
!!     implicit none
!!     character(len=8)              :: s=' 10.345 '
!!     integer                       :: i
!!     character(len=14),allocatable :: strings(:)
!!     doubleprecision               :: dv
!!     integer                       :: errnum
!!
!!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!     strings=[&
!!     &' 10.345       ',&
!!     &'+10           ',&
!!     &'    -3        ',&
!!     &'    -4.94e-2  ',&
!!     &'0.1           ',&
!!     &'12345.678910d0',&
!!     &'              ',& ! Note: will return zero without an error message
!!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!     &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!     ! a numeric value is returned,
!!     ! so it can be used in numeric expression
!!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
!!     write(*,*)
!!     write(*,*)' STRING            VALUE                    ERROR_NUMBER'
!!     do i=1,size(strings)
!!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
!!        ! as it does I/O when errors occur, so called on a separate line
!!        dv=s2v(strings(i),errnum)
!!        write(*,*) strings(i)//'=',dv,errnum
!!     enddo
!!     write(*,*)"Extended intrinsics"
!!     write(*,*)'given inputs:',s,strings(:8)
!!     write(*,*)'INT(3f):',int(s),int(strings(:8))
!!     write(*,*)'REAL(3f):',real(s),real(strings(:8))
!!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
!!     write(*,*)"That's all folks!"
!!
!!     end program demo_s2v
!!
!!    Expected output
!!
!!     >1/2 value of string is    5.1725000000000003
!!     >
!!     > STRING            VALUE                    ERROR_NUMBER
!!     > 10.345       =   10.345000000000001                0
!!     >+10           =   10.000000000000000                0
!!     >    -3        =  -3.0000000000000000                0
!!     >    -4.94e-2  =  -4.9399999999999999E-002           0
!!     >0.1           =  0.10000000000000001                0
!!     >12345.678910d0=   12345.678910000001                0
!!     >              =   0.0000000000000000                0
!!     >1 2 1 2 1 . 0 =   12121.000000000000                0
!!     >*a2d* - cannot produce number from string [WHAT?]
!!     >*a2d* - [Bad value during floating point read]
!!     >WHAT?         =   0.0000000000000000             5010
!!     >Extended intrinsics
!!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1
!!     12345.678910d0 1 2 1 2 1 . 0
!!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121
!!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000
!!     -4.94000018E-02
!!     >          0.100000001 12345.6787 0.00000000 12121.0000
!!     >DBLE(3f): 10.345000000000001 10.345000000000001
!!     10.000000000000000
!!     >          -3.0000000000000000 -4.9399999999999999E-002
!!     0.10000000000000001
!!     >          12345.678910000001 0.0000000000000000
!!     12121.000000000000
!!     >That's all folks!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!!##PROCEDURE:
!! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs
!!##VERSION:     2.0, 20160704
!! AUTHOR:      John S. Urban
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

! ident_54="@(#) M_strings s2v(3f) returns doubleprecision number from string;zero if error occurs"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(stderr,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      dble(3f) - [M_strings:TYPE] overloads DBLE(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function dble(string)
!!
!!     character(len=*) :: string
!!     integer          :: dble
!!
!!##DESCRIPTION
!!    dble(3f) returns a DOUBLE value when given a numeric representation of a
!!    numeric value. This overloads the DBLE(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a dble value
!!
!!##RETURNS
!!    DBLE  double precision value represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_dble
!!      use M_strings, only: dble
!!      implicit none
!!      write(*,*)dble('100'),dble('20.4')
!!      write(*,*)'dble still works',dble(20),dble(20.4)
!!      write(*,*)'elemental',&
!!      & dble([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_dble
!!
!! Results:
!!
!!      >    100.00000000000000        20.399999999999999
!!      >  dble still works   20.000000000000000 20.399999618530273
!!      >  elemental   10.00000000000000  20.30000000000000
!!      >  20.50000000000000 20.60000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      real(3f) - [M_strings:TYPE] overloads REAL(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function real(string)
!!
!!     character(len=*) :: string
!!     integer          :: real
!!
!!##DESCRIPTION
!!    real(3f) returns a REAL value when given a numeric representation of a
!!    numeric value. This overloads the REAL(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a real value
!!
!!##RETURNS
!!       REAL  real value represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_real
!!      use M_strings, only: real
!!      implicit none
!!      write(*,*)real('100'),real('20.4')
!!      write(*,*)'real still works',real(20)
!!      write(*,*)'elemental',&
!!      & real([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_real
!!
!! Results:
!!
!!      >    100.000000       20.3999996
!!      >  real still works   20.0000000
!!      >  elemental   10.0000000  20.2999992  20.5000000  20.6000004
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      int(3f) - [M_strings:TYPE] overloads INT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function int(string)
!!
!!     character(len=*)    :: string
!!     integer(kind=int32) :: int
!!
!!##DESCRIPTION
!!    int(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the INT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an INT32 integer
!!
!!##RETURNS
!!       INT  integer represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_int
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: int
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)int('100'),int('20.4')
!!         write(*,g)'intrinsic int(3f) still works',int(20,int32)
!!         write(*,g)'elemental',&
!!         & int([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_int
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic int(3f) still works 20
!!     > elemental 10 20 20 20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      nint(3f) - [M_strings:TYPE] overloads NINT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function nint(string)
!!
!!     character(len=*) :: string
!!     integer          :: nint
!!
!!##DESCRIPTION
!!    nint(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the NINT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an integer
!!
!!##RETURNS
!!       NINT  integer represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_nint
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: nint
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)nint('100'),nint('20.4')
!!         write(*,g)'intrinsic nint(3f) still works',nint(20.4)
!!         write(*,g)'elemental',&
!!         & nint([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_nint
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic nint(3f) still works 20
!!     > elemental 10 20 21 21
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental integer function nint_s2v(chars)
character(len=*),intent(in) :: chars
   nint_s2v=nint(s2v(chars))
end function nint_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_strings:TYPE] return numeric string
!!      from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,lgth,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)           :: value
!!     real,intent(in)                      :: value
!!     integer,intent(in)                   :: value
!!     logical,intent(in)                   :: value
!!     !--------
!!     character(len=*),intent(out)         :: chars
!!     integer,intent(out),optional         :: lgth
!!     integer,optional                     :: ierr
!!     character(len=*),intent(in),optional :: fmt
!!     logical,intent(in)                   :: trimz
!!
!!##DESCRIPTION
!!    value_to_string(3f) returns a numeric representation of a numeric
!!    value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the string using internal writes. It
!!    then removes trailing zeros from non-zero values, and left-justifies
!!    the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT
!!               if longer.
!!       LGTH    position of last non-blank character in returned string;
!!               optional.
!!       IERR    If not zero, error occurred; optional.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_value_to_string
!!      use M_strings, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: lgth
!!         call value_to_string(3.0/4.0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(3.0/4.0,string,lgth,fmt='')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string&
!!         &(3.0/4.0,string,lgth,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1234,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

! ident_55="@(#) M_strings value_to_string(3fp) subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: iomsg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
       ! cannot currently do I/O from a function being called from I/O
       !write(stderr,'(a)')'*value_to_string* WARNING:['//trim(iomsg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(iomsg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      v2s(3f) - [M_strings:TYPE] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function v2s(value) result(outstr)
!!
!!        integer|real|doubleprecision|logical,intent(in ) :: value
!!        character(len=:),allocatable                     :: outstr
!!        character(len=*),optional,intent(in)             :: fmt
!!
!!##DESCRIPTION
!!    v2s(3f) returns a representation of a numeric value as a
!!    string when given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the strings using internal WRITE()
!!    statements. Trailing zeros are removed from non-zero values, and the
!!    string is left-justified.
!!
!!##OPTIONS
!!    VALUE   input value to be converted to a string
!!    FMT     format can be explicitly given, but is limited to
!!            generating a string of eighty or less characters.
!!
!!##RETURNS
!!    OUTSTR  returned string representing input value,
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_v2s
!!    use M_strings, only: v2s
!!    write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
!!    write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
!!    write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
!!    write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
!!    write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
!!    end program demo_v2s
!!
!!   Expected output
!!
!!     The value of 3.0/4.0 is [0.75]
!!     The value of 1234    is [1234]
!!     The value of 0d0     is [0]
!!     The value of .false. is [F]
!!     The value of .true. is  [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function d2s(dvalue,fmt) result(outstr)

! ident_56="@(#) M_strings d2s(3fp) private function returns string given doubleprecision value"

doubleprecision,intent(in)           :: dvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(dvalue,string,fmt=fmt)
   else
      call value_to_string(dvalue,string)
   endif
   outstr=trim(string)
end function d2s
!===================================================================================================================================
function r2s(rvalue,fmt) result(outstr)

! ident_57="@(#) M_strings r2s(3fp) private function returns string given real value"

real,intent(in)                      :: rvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(rvalue,string,fmt=fmt)
   else
      call value_to_string(rvalue,string)
   endif
   outstr=trim(string)
end function r2s
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

! ident_58="@(#) M_strings i2s(3fp) private function returns string given integer value"

integer,intent(in)                   :: ivalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
function l2s(lvalue,fmt) result(outstr)

! ident_59="@(#) M_strings l2s(3fp) private function returns string given logical value"

logical,intent(in)                   :: lvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(lvalue,string,fmt=fmt)
   else
      call value_to_string(lvalue,string)
   endif
   outstr=trim(string)
end function l2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isnumber(3f) - [M_strings:TYPE] determine if a string represents a number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function isnumber(str,msg)
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),intent(out),allocatable,optional  :: msg
!!
!!##DESCRIPTION
!!     ISNUMBER(3f) returns a value greater than zero if the string represents
!!     a number, and a number less than or equal to zero if it is a bad number.
!!     Blank characters are ignored.
!!
!!##OPTIONS
!!     str  the string to evaluate as to whether it represents a numeric value
!!          or not
!!     msg  An optional message describing the string
!!
!!##RETURNS
!!     isnumber  the following values are returned
!!
!!                1 for an integer             [-+]NNNNN
!!                2 for a whole number         [-+]NNNNN.
!!                3 for a real value           [-+]NNNNN.MMMM
!!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!!
!!               values less than 1 represent an error
!!
!!##EXAMPLES
!!
!!   As the example shows, you can use an internal READ(3f) along with the
!!   IOSTAT= parameter to check (and read) a string as well.
!!
!!     program demo_isnumber
!!     use M_strings, only : isnumber
!!     implicit none
!!     character(len=256)           :: line
!!     real                         :: value
!!     integer                      :: ios1, ios2
!!     integer                      :: answer
!!     character(len=256)           :: message
!!     character(len=:),allocatable :: description
!!        write(*,*)'Begin entering values, one per line'
!!        do
!!           read(*,'(a)',iostat=ios1)line
!!           !
!!           ! try string as number using list-directed input
!!           line=''
!!           read(line,*,iostat=ios2,iomsg=message) value
!!           if(ios2 == 0)then
!!              write(*,*)'VALUE=',value
!!           elseif( is_iostat_end(ios1) ) then
!!              stop 'end of file'
!!           else
!!              write(*,*)'ERROR:',ios2,trim(message)
!!           endif
!!           !
!!           ! try string using isnumber(3f)
!!           answer=isnumber(line,msg=description)
!!           if(answer > 0)then
!!              write(*,*) &
!!              & ' for ',trim(line),' ',answer,':',description
!!           else
!!              write(*,*) &
!!              & ' ERROR for ',trim(line),' ',answer,':',description
!!           endif
!!           !
!!        enddo
!!     end program demo_isnumber
!!
!!  Example run
!!
!!    > Begin entering values
!!    > ERROR:          -1 End of file
!!    >  ERROR for            -1 :null string
!!    >10
!!    > VALUE=   10.0000000
!!    >  for 10            1 :integer
!!    >20
!!    > VALUE=   20.0000000
!!    >  for 20            1 :integer
!!    >20.
!!    > VALUE=   20.0000000
!!    >  for 20.            2 :whole number
!!    >30.1
!!    > VALUE=   30.1000004
!!    >  for 30.1            3 :real number
!!    >3e1
!!    > VALUE=   30.0000000
!!    >  for 3e1            4 :value with exponent
!!    >1-2
!!    > VALUE=   9.99999978E-03
!!    >  for 1-2            4 :value with exponent
!!    >100.22d-4
!!    > VALUE=   1.00220004E-02
!!    >  for 100.22d-4            4 :value with exponent
!!    >1--2
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1--2           -5 :bad number
!!    >e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e           -6 :missing leading value before exponent
!!    >e1
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e1           -6 :missing leading value before exponent
!!    >1e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e           -3 :missing exponent
!!    >1e+
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+           -4 :missing exponent after sign
!!    >1e+2.0
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+2.0           -5 :bad number
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function isNumber(string,msg,verbose)

! ident_60="@(#) M_strings isnumber(3f) Determines if a string is a number of not."

character(len=*),intent(in)                       :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                       :: verbose
integer                                           :: isnumber

integer                                           :: i,iend
character(len=1),allocatable                      :: z(:)
character(len=:),allocatable                      :: message
logical                                           :: founddigit
logical                                           :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=switch(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_strings:TYPE] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       !use M_strings, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          string= '123.450000000000'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.00e3'
!!          call trimzeros_(string)
!!          write(*,*)string
!!       end program demo_trimzeros_
!!
!!   Results:
!!
!!     > 123.45
!!     > 12345
!!     > 12345
!!     > 12345e3
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_61="@(#) M_strings trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)               :: string
character(len=len(string) + 2) :: str
character(len=len(string))     :: exp        ! the exponent string if present
integer                        :: ipos       ! where exponent letter appears if present
integer                        :: i, ii
   str = string                              ! working copy of string
   ipos = scan(str, 'eEdD')                  ! find end of real number if string uses exponent notation
   if (ipos > 0) then                        ! letter was found
      exp = str(ipos:)                       ! keep exponent string so it can be added back as a suffix
      str = str(1:ipos - 1)                  ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if (index(str, '.') == 0) then            ! if no decimal character in original string add one to end of string
      ii = len_trim(str)
      str(ii + 1:ii + 1) = '.'               ! add decimal to end of string
   endif
   do i = len_trim(str), 1, -1               ! scanning from end find a non-zero character
      select case (str(i:i))
      case ('0')                             ! found a trailing zero so keep trimming
         cycle
      case ('.')                             ! found a decimal character at end of remaining string
         if (i <= 1) then
            str = '0'
         else
            str = str(1:i - 1)
         endif
         exit
      case default
         str = str(1:i)                      ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if (ipos > 0) then                        ! if originally had an exponent place it back on
      string = trim(str)//trim(exp)
   else
      string = str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    listout(3f) - [M_strings:NUMERIC] expand a list of numbers where negative
!!    numbers denote range ends (1 -10 means 1 thru 10)
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine listout(icurve_lists,icurve_expanded,inums,ierr)
!!
!!    integer,intent(in)    :: icurve_lists(:)
!!    integer,intent(out)   :: icurve_expanded(:)
!!    integer,intent(out)   :: inums
!!    integer,intent(out)   :: ierr
!!
!!##DESCRIPTION
!!    expand a list of whole numbers where negative numbers indicate a range.
!!    So [10,-20] would be expanded to [10,11,12,13,14,15,16,17,18,19,20].
!!
!!##OPTIONS
!!    icurve_lists(:)      input array
!!
!!##RETURNS
!!    icurve_expanded(:)   output array; assumed large enough to hold
!!                         returned list
!!    inums                number of icurve_expanded numbers on output
!!    ierr                 zero if no error occurred
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_listout
!!     use M_strings, only : listout
!!     implicit none
!!     integer,allocatable :: icurve_lists(:)
!!     integer :: icurve_expanded(1000)
!!     ! icurve_lists is input array
!!     integer :: inums
!!     ! icurve_expanded is output array
!!     integer :: i
!!     ! number of icurve_lists values on input,
!!     ! number of icurve_expanded numbers on output
!!     integer :: ierr
!!        icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
!!        inums=size(icurve_lists)
!!        call listout(icurve_lists,icurve_expanded,inums,ierr)
!!        if(ierr == 0)then
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        else
!!           write(*,'(a,i0)')'error occurred in *listout* ',ierr
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        endif
!!     end program demo_listout
!!
!! Results:
!!
!!     > 1 20 21 22 23
!!     > 24 25 26 27 28
!!     > 29 30 101 100 99
!!     > 100 101 102 103 104
!!     > 105 106 107 108 109
!!     > 110 111 112 113 114
!!     > 115 116 117 118 119
!!     > 120 222 221 220 219
!!     > 218 217 216 215 214
!!     > 213 212 211 210 209
!!     > 208 207 206 205 204
!!     > 203 202 201 200
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine listout(icurve_lists,icurve_expanded,inums_out,ierr)

! ident_62="@(#) M_strings listout(3f) copy icurve_lists to icurve_expanded expanding negative numbers to ranges (1 -10 means 1 thru 10)"

!   Created: 19971231
integer,intent(in)    :: icurve_lists(:)             ! input array
integer,intent(out)   :: icurve_expanded(:)          ! output array
integer,intent(out)   :: inums_out                   ! number of icurve_expanded numbers on output
integer,intent(out)   :: ierr                        ! status variable

character(len=80)     :: temp1
integer               :: i80, i90
integer               :: imin, imax
integer               :: idirection, icount
integer               :: iin
integer               :: inums_max

   ierr=0
   icurve_expanded=0                          ! initialize output array
   inums_out=0                                ! initialize number of significant values in output array

   inums_max=size(icurve_expanded)
   if(inums_max == 0)then
      ierr=-2
      return
   endif

   iin=size(icurve_lists)
   if(iin > 0)then
      icurve_expanded(1)=icurve_lists(1)
   endif

   icount=2
      do i90=2,iin
         if(icurve_lists(i90) < 0)then
            imax=abs(icurve_lists(i90))
            imin=abs(icurve_lists(i90-1))
            if(imin > imax)then
               idirection=-1
               imin=imin-1
            elseif(imax > imin)then
               idirection=1
               imin=imin+1
            else
               idirection=1
            endif
            do i80=imin,imax,idirection
               if(icount > inums_max) then
                  write(temp1,'(a,i5,a)')'*listout* only ',inums_max,' values allowed'
                  ierr=-1
                  call journal(temp1)
                  inums_out=icount-1
                  exit
               endif
               icurve_expanded(icount)=i80
               icount=icount+1
            enddo
         else
            icurve_expanded(icount)=icurve_lists(i90)
            icount=icount+1
         endif
      enddo
   inums_out=icount-1

end subroutine listout
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     quote(3f) - [M_strings:QUOTES] add quotes to string as if written
!!     with list-directed output
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed output. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str    input string to add quotes to, using the rules of
!!           list-directed output (single quotes are replaced by two
!!           adjacent quotes)
!!    mode   alternate quoting methods are supported:
!!
!!             DOUBLE   default. replace quote with double quotes
!!             ESCAPE   replace quotes with backslash-quote instead of
!!                      double quotes
!!
!!    clip   default is to trim leading and trailing spaces from the
!!           string. If CLIP is .FALSE. spaces are not trimmed
!!
!!##RETURNS
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_quote
!!    use M_strings, only : quote
!!    implicit none
!!    integer                      :: i
!!    character(len=*),parameter   :: f='(*(g0))'
!!    character(len=:),allocatable :: str
!!    character(len=80),parameter  :: data(3)=[character(len=80)::&
!!       'test string',&
!!       'quote="',&
!!       '"word1" "word2"']
!!       do i=1,size(data)
!!          ! the original string
!!          write(*,'(a)')'ORIGINAL      '//trim(data(i))
!!
!!          ! the string processed by quote(3f)
!!          str=quote(data(i))
!!          write(*,'(a)')'QUOTED        '//str
!!
!!          ! write the string list-directed to compare the results
!!          write(*,f,advance='no') 'LIST DIRECTED'
!!          ! default is often NONE or APOSTROPHE
!!          write(*,*,delim='quote') trim(data(i))
!!       enddo
!!    end program demo_quote
!!
!! Results:
!!
!!  > ORIGINAL      test string
!!  > QUOTED        "test string"
!!  > LIST DIRECTED "test string"
!!  > ORIGINAL      quote="
!!  > QUOTED        "quote="""
!!  > LIST DIRECTED "quote="""
!!  > ORIGINAL      "word1" "word2"
!!  > QUOTED        """word1"" ""word2"""
!!  > LIST DIRECTED """word1"" ""word2"""
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(clip))then
      if(clip)then
         quoted_str=adjustl(str)
      else
         quoted_str=str
      endif
   else
      quoted_str=str
   endif

   local_mode=merge_str(mode,'DOUBLE',present(mode))

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace(quoted_str,'"','\"'))//double_quote
   case default
      call journal('sc','*quote* ERROR: unknown quote mode '//local_mode)
      quoted_str=str
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     unquote(3f) - [M_strings:QUOTES] remove quotes from string as if
!!     read with list-directed input
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!
!!##RETURNS
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unquote
!!       use M_strings, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: iomsg
!!       integer                      :: iostat
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=iostat,iomsg=iomsg)quoted_str
!!          if(iostat /= 0)then
!!             write(*,*)trim(iomsg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=iostat,iomsg=iomsg)dummy
!!          if(iostat /= 0)then
!!             write(*,*)trim(iomsg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!    end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=iachar(esc)                            ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen >= 1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1) == single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before == iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current == quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    edit_distance(3f) - [M_strings:DESCRIBE] returns a naive edit distance using
!!    the Levenshtein distance algorithm
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function edit_distance(str1,str2) result (distance)
!!
!!     character(len=*),intent(in)   :: str1, str2
!!     integer :: distance
!!
!!##DESCRIPTION
!!
!!   The Levenshtein distance function returns how many edits (deletions,
!!   insertions, transposition) are required to turn one string into another.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_edit_distance
!!    use M_strings, only : edit_distance
!!       write(*,*)edit_distance('kittens','sitting')==3
!!       write(*,*)edit_distance('geek','gesek')==1
!!       write(*,*)edit_distance('Saturday','Sunday')==3
!!    end program demo_edit_distance
!!
!!   Expected output
!!
!!     > T
!!     > T
!!     > T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
! The Levenshtein distance function returns how many edits (deletions,
! insertions, transposition) are required to turn one string into another.

pure elemental integer function edit_distance (a,b)
character(len=*), intent(in) :: a, b
integer                      :: len_a, len_b, i, j, cost
! matrix for calculating Levenshtein distance
!integer                      :: matrix(0:len_trim(a), 0:len_trim(b)) ! not supported by all compilers yet
integer,allocatable          :: matrix(:,:)
   len_a = len_trim(a)
   len_b = len_trim(b)
   !-------------------------------------- ! required by older compilers instead of above declaration
   if(allocated(matrix))deallocate(matrix)
   allocate(matrix(0:len_a,0:len_b))
   !--------------------------------------
   matrix(:,0) = [(i,i=0,len_a)]
   matrix(0,:) = [(j,j=0,len_b)]
   do i = 1, len_a
      do j = 1, len_b
         cost=merge(0,1,a(i:i)==b(j:j))
         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)
      enddo
   enddo
   edit_distance = matrix(len_a,len_b)
end function edit_distance
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    bundle(3f) - [M_strings:ARRAY] return up to twenty strings of arbitrary length
!!                 as an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function bundle(str1,str2,...str20,len) result (vec)
!!
!!     character(len=*),intent(in),optional   :: str1, str2 ... str20
!!     integer,intent(in),optional            :: len
!!
!!##DESCRIPTION
!!    Given a list of up to twenty strings create a string array. The
!!    length of the variables will be the same as the maximum length
!!    of the input strings unless explicitly specified via LEN.
!!
!!    This is an alternative to the syntax
!!
!!      [ CHARACTER(LEN=NN) :: str1, str2, ... ]
!!
!!    that by default additionally calculates the minimum length required
!!    to prevent truncation.
!!
!!##OPTIONS
!!    str1,str2, ... str20  input strings to combine into a vector
!!    len   length of returned array variables
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_bundle
!!    use M_strings, only: bundle
!!    implicit none
!!       print "(*('""',a,'""':,',',1x))", bundle("one")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two","three")
!!       print "(*('""',a,'""':,',',1x))", bundle("one","two","three",&
!!               & "four","five","six","seven")
!!    end program demo_bundle
!!
!!   Expected output
!!
!!    "one"
!!    "one", "two"
!!    "one  ", "two  ", "three"
!!    "one  ", "two  ", "three", "four ", "five ", "six  ", "seven"
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function bundle(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,len) result(vec)
! return character array containing present arguments
character(len=*),intent(in),optional  :: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
character(len=*),intent(in),optional  :: x11,x12,x13,x14,x15,x16,x17,x18,x19,x20
integer,intent(in),optional           :: len
character(len=:),allocatable          :: vec(:)
integer                               :: ilen, icount, iset
   ilen=0
   icount=0
   iset=0
   call increment(x1)
   call increment(x2)
   call increment(x3)
   call increment(x4)
   call increment(x5)
   call increment(x6)
   call increment(x7)
   call increment(x8)
   call increment(x9)
   call increment(x10)
   call increment(x11)
   call increment(x12)
   call increment(x13)
   call increment(x14)
   call increment(x15)
   call increment(x16)
   call increment(x17)
   call increment(x18)
   call increment(x19)
   call increment(x20)

   if(present(len)) ilen=len
   allocate (character(len=ilen) :: vec(icount))

   call set(x1)
   call set(x2)
   call set(x3)
   call set(x4)
   call set(x5)
   call set(x6)
   call set(x7)
   call set(x8)
   call set(x9)
   call set(x10)
   call set(x11)
   call set(x12)
   call set(x13)
   call set(x14)
   call set(x15)
   call set(x16)
   call set(x17)
   call set(x18)
   call set(x19)
   call set(x20)

contains

subroutine increment(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      ilen=max(ilen,len_trim(str))
      icount=icount+1
   endif
end subroutine increment

subroutine set(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      iset=iset+1
      vec(iset)=str
   endif
end subroutine set

end function bundle
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    describe(3f) - [M_strings:DESCRIBE] returns a string describing the name of
!!    a single character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function describe(ch) result (string)
!!
!!     character(len=1),intent(in)   :: ch
!!     character(len=:),allocatable  :: string
!!
!!##DESCRIPTION
!!    describe(3f) returns a string describing long name of a single
!!    character
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_describe
!!     use M_strings, only : describe
!!     implicit none
!!     integer :: i
!!        do i=1,128  ! fill variable with base ASCII character set
!!           write(*,*)describe(char(i-1))
!!        enddo
!!    end program demo_describe
!!
!!   Expected output
!!
!!     ctrl-@ or ctrl-? (NUL) null
!!     ctrl-A (SOH) start of heading
!!     ctrl-B (STX) start of text
!!     ctrl-C (ETX) end of text
!!     ctrl-D (EOT) end of transmission
!!     ctrl-E (ENQ) enquiry
!!     ctrl-F (ACK) acknowledge
!!     ctrl-G (BEL) bell
!!     ctrl-H (BS) backspace
!!     ctrl-I (HT) horizontal tabulation
!!     ctrl-J (LF) line feed
!!     ctrl-K (VT) vertical tabulation
!!     ctrl-L (FF) form feed
!!     ctrl-M (CR) carriage return
!!     ctrl-N (SO) shift out
!!     ctrl-O (SI) shift in
!!     ctrl-P (DLE) data link escape
!!     ctrl-Q (DC1) device control 1
!!     ctrl-R (DC2) device control 2
!!     ctrl-S (DC3) device control 3
!!     ctrl-T (DC4) device control 4
!!     ctrl-U (NAK) negative acknowledge
!!     ctrl-V (SYN) synchronous idle
!!     ctrl-W (ETB) end of transmission block
!!     ctrl-X (CAN) cancel
!!     ctrl-Y (EM) end of medium
!!     ctrl-Z (SUB) substitute
!!     ctrl-[ (ESC) escape
!!     ctrl-\ or ctrl-@ (FS) file separator
!!     ctrl-] (GS) group separator
!!     ctrl-^ or ctrl-= (RS) record separator
!!     ctrl-_ (US) unit separator
!!     space
!!     ! exclamation point
!!     " quotation marks
!!     # number sign
!!     $ currency symbol
!!     % percent
!!     & ampersand
!!     ' apostrophe
!!     ( left parenthesis
!!     ) right parenthesis
!!     * asterisk
!!     + plus
!!     , comma
!!     - minus
!!     . period
!!     / slash
!!     0 zero
!!     1 one
!!     2 two
!!     3 three
!!     4 four
!!     5 five
!!     6 six
!!     7 seven
!!     8 eight
!!     9 nine
!!     : colon
!!     ; semicolon
!!     < less than
!!     = equals
!!     > greater than
!!     ? question mark
!!     @ at sign
!!     majuscule A
!!     majuscule B
!!     majuscule C
!!     majuscule D
!!     majuscule E
!!     majuscule F
!!     majuscule G
!!     majuscule H
!!     majuscule I
!!     majuscule J
!!     majuscule K
!!     majuscule L
!!     majuscule M
!!     majuscule N
!!     majuscule O
!!     majuscule P
!!     majuscule Q
!!     majuscule R
!!     majuscule S
!!     majuscule T
!!     majuscule U
!!     majuscule V
!!     majuscule W
!!     majuscule X
!!     majuscule Y
!!     majuscule Z
!!     [ left bracket
!!     \ backslash
!!     ] right bracket
!!     ^ caret
!!     _ underscore
!!     ` grave accent
!!     miniscule a
!!     miniscule b
!!     miniscule c
!!     miniscule d
!!     miniscule e
!!     miniscule f
!!     miniscule g
!!     miniscule h
!!     miniscule i
!!     miniscule j
!!     miniscule k
!!     miniscule l
!!     miniscule m
!!     miniscule n
!!     miniscule o
!!     miniscule p
!!     miniscule q
!!     miniscule r
!!     miniscule s
!!     miniscule t
!!     miniscule u
!!     miniscule v
!!     miniscule w
!!     miniscule x
!!     miniscule y
!!     miniscule z
!!     { left brace
!!     | vertical line
!!     } right brace
!!     ~ tilde
!!     ctrl-? (DEL) delete
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function describe(ch) result (string)

! ident_63="@(#) M_strings describe(3f) return string describing long name of a single character"

character(len=1),intent(in)   :: ch
character(len=:),allocatable  :: string
! LATER: add hex, octal, decimal, key-press description, alternate names
!  ASCII character codes
   select case (iachar(ch))
   case(     0  ); STRING="ctrl-@ or ctrl-? (NUL) null"
   case(     1  ); STRING="ctrl-A (SOH) start of heading"
   case(     2  ); STRING="ctrl-B (STX) start of text"
   case(     3  ); STRING="ctrl-C (ETX) end of text"
   case(     4  ); STRING="ctrl-D (EOT) end of transmission"
   case(     5  ); STRING="ctrl-E (ENQ) enquiry"
   case(     6  ); STRING="ctrl-F (ACK) acknowledge"
   case(     7  ); STRING="ctrl-G (BEL) bell"
   case(     8  ); STRING="ctrl-H (BS) backspace"
   case(     9  ); STRING="ctrl-I (HT) horizontal tabulation"
   case(    10  ); STRING="ctrl-J (LF) line feed"
   case(    11  ); STRING="ctrl-K (VT) vertical tabulation"
   case(    12  ); STRING="ctrl-L (FF) form feed"
   case(    13  ); STRING="ctrl-M (CR) carriage return"
   case(    14  ); STRING="ctrl-N (SO) shift out"
   case(    15  ); STRING="ctrl-O (SI) shift in"
   case(    16  ); STRING="ctrl-P (DLE) data link escape"
   case(    17  ); STRING="ctrl-Q (DC1) device control 1"
   case(    18  ); STRING="ctrl-R (DC2) device control 2"
   case(    19  ); STRING="ctrl-S (DC3) device control 3"
   case(    20  ); STRING="ctrl-T (DC4) device control 4"
   case(    21  ); STRING="ctrl-U (NAK) negative acknowledge"
   case(    22  ); STRING="ctrl-V (SYN) synchronous idle"
   case(    23  ); STRING="ctrl-W (ETB) end of transmission block"
   case(    24  ); STRING="ctrl-X (CAN) cancel"
   case(    25  ); STRING="ctrl-Y (EM) end of medium"
   case(    26  ); STRING="ctrl-Z (SUB) substitute"
   case(    27  ); STRING="ctrl-[ (ESC) escape"
   case(    28  ); STRING="ctrl-\ or ctrl-@ (FS) file separator"
   case(    29  ); STRING="ctrl-] (GS) group separator"
   case(    30  ); STRING="ctrl-^ or ctrl-= (RS) record separator"
   case(    31  ); STRING="ctrl-_ (US) unit separator"
   case(    32  ); STRING="space"
   case(    33  ); STRING="! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)"
   case(    34  ); STRING=""" quotation marks"
   case(    35  ); STRING="# number sign (hash, pound sign, hashtag)"
   case(    36  ); STRING="$ currency symbol"
   case(    37  ); STRING="% percent"
   case(    38  ); STRING="& ampersand"
   case(    39  ); STRING="' apostrophe"
   case(    40  ); STRING="( left parenthesis"
   case(    41  ); STRING=") right parenthesis"
   case(    42  ); STRING="* asterisk"
   case(    43  ); STRING="+ plus"
   case(    44  ); STRING=", comma"
   case(    45  ); STRING="- minus"
   case(    46  ); STRING=". period"
   case(    47  ); STRING="/ slash"
   case(    48  ); STRING="0 zero"
   case(    49  ); STRING="1 one"
   case(    50  ); STRING="2 two"
   case(    51  ); STRING="3 three"
   case(    52  ); STRING="4 four"
   case(    53  ); STRING="5 five"
   case(    54  ); STRING="6 six"
   case(    55  ); STRING="7 seven"
   case(    56  ); STRING="8 eight"
   case(    57  ); STRING="9 nine"
   case(    58  ); STRING=": colon"
   case(    59  ); STRING="; semicolon"
   case(    60  ); STRING="< less than"
   case(    61  ); STRING="= equals"
   case(    62  ); STRING="> greater than"
   case(    63  ); STRING="? question mark"
   case(    64  ); STRING="@ at (at cost of, at sign, each at, commercial at, commat, rollmop, monkey|pigs|elephant tail,&
                   & snail, arroba, strudel, asperand, ampersat, rose, cabbage, swirl, whorl)"
   case(    65  ); STRING="A majuscule A"
   case(    66  ); STRING="B majuscule B"
   case(    67  ); STRING="C majuscule C"
   case(    68  ); STRING="D majuscule D"
   case(    69  ); STRING="E majuscule E"
   case(    70  ); STRING="F majuscule F"
   case(    71  ); STRING="G majuscule G"
   case(    72  ); STRING="H majuscule H"
   case(    73  ); STRING="I majuscule I"
   case(    74  ); STRING="J majuscule J"
   case(    75  ); STRING="K majuscule K"
   case(    76  ); STRING="L majuscule L"
   case(    77  ); STRING="M majuscule M"
   case(    78  ); STRING="N majuscule N"
   case(    79  ); STRING="O majuscule O"
   case(    80  ); STRING="P majuscule P"
   case(    81  ); STRING="Q majuscule Q"
   case(    82  ); STRING="R majuscule R"
   case(    83  ); STRING="S majuscule S"
   case(    84  ); STRING="T majuscule T"
   case(    85  ); STRING="U majuscule U"
   case(    86  ); STRING="V majuscule V"
   case(    87  ); STRING="W majuscule W"
   case(    88  ); STRING="X majuscule X"
   case(    89  ); STRING="Y majuscule Y"
   case(    90  ); STRING="Z majuscule Z"
   case(    91  ); STRING="[ left bracket"
   case(    92  ); STRING="\ backslash"
   case(    93  ); STRING="] right bracket"
   case(    94  ); STRING="^ caret"
   case(    95  ); STRING="_ underscore"
   case(    96  ); STRING="` grave accent"
   case(    97  ); STRING="a miniscule a"
   case(    98  ); STRING="b miniscule b"
   case(    99  ); STRING="c miniscule c"
   case(   100  ); STRING="d miniscule d"
   case(   101  ); STRING="e miniscule e"
   case(   102  ); STRING="f miniscule f"
   case(   103  ); STRING="g miniscule g"
   case(   104  ); STRING="h miniscule h"
   case(   105  ); STRING="i miniscule i"
   case(   106  ); STRING="j miniscule j"
   case(   107  ); STRING="k miniscule k"
   case(   108  ); STRING="l miniscule l"
   case(   109  ); STRING="m miniscule m"
   case(   110  ); STRING="n miniscule n"
   case(   111  ); STRING="o miniscule o"
   case(   112  ); STRING="p miniscule p"
   case(   113  ); STRING="q miniscule q"
   case(   114  ); STRING="r miniscule r"
   case(   115  ); STRING="s miniscule s"
   case(   116  ); STRING="t miniscule t"
   case(   117  ); STRING="u miniscule u"
   case(   118  ); STRING="v miniscule v"
   case(   119  ); STRING="w miniscule w"
   case(   120  ); STRING="x miniscule x"
   case(   121  ); STRING="y miniscule y"
   case(   122  ); STRING="z miniscule z"
   case(   123  ); STRING="{ left brace"
   case(   124  ); STRING="| vertical line"
   case(   125  ); STRING="} right brace"
   case(   126  ); STRING="~ tilde"
   case(   127  ); STRING="ctrl-? (DEL) delete"
   case default
         STRING='UNKNOWN'//v2s(IACHAR(ch))
   end select
end function describe
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getvals(3f) - [M_strings:TYPE] read arbitrary number of REAL values
!!    from a character variable up to size of VALUES() array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine getvals(line,values,icount,ierr)
!!
!!     character(len=*),intent(in)  :: line
!!     class(*),intent(out)         :: values(:)
!!     integer,intent(out)          :: icount
!!     integer,intent(out),optional :: ierr
!!
!!##DESCRIPTION
!!   GETVALS(3f) reads a relatively arbitrary number of numeric values from
!!   a character variable into a REAL array using list-directed input.
!!
!!   NOTE: In this version null values are skipped instead of meaning to leave
!!         that value unchanged
!!
!!        1,,,,,,,2 / reads VALUES=[1.0,2.0]
!!
!!   Per list-directed rules when reading values, allowed delimiters are
!!   comma, semi-colon and space.
!!
!!   the slash separator can be used to add inline comments.
!!
!!        10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
!!
!!   Repeat syntax can be used up to the size of the output array. These are
!!   equivalent input lines:
!!
!!        4*10.0
!!        10.0, 10.0, 10.0, 10.0
!!
!!##OPTIONS
!!   LINE      A character variable containing the characters representing
!!             a list of numbers
!!
!!##RETURNS
!!   VALUES()  array holding numbers read from string. May be of type
!!             INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the
!!             strings are returned as simple words instead of numeric values.
!!   ICOUNT    number of defined numbers in VALUES(). If ICOUNT reaches
!!             the size of the VALUES() array parsing stops.
!!   IERR      zero if no error occurred in reading numbers. Optional.
!!             If not present and an error occurs the program is terminated.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_getvals
!!       use M_strings, only: getvals
!!       implicit none
!!       integer,parameter  :: longest_line=256
!!       character(len=longest_line) :: line
!!       real               :: values(longest_line/2+1)
!!       integer            :: iostat,icount,ierr
!!       INFINITE: do
!!          read(*,'(a)',iostat=iostat) line
!!          if(iostat /= 0)exit INFINITE
!!          call getvals(line,values,icount,ierr)
!!          write(*,'(4(g0,1x))')'VALUES=',values(:icount)
!!       enddo INFINITE
!!       end program demo_getvals
!!
!!  Sample input lines
!!
!!        10,20 30.4
!!        1 2 3
!!        1
!!
!!        3 4*2.5 8
!!        32.3333 / comment 1
!!        30e3;300,    30.0, 3
!!        even 1 like this! 10
!!        11,,,,22,,,,33
!!
!!  Expected output:
!!
!!     VALUES=   10.0000000       20.0000000       30.3999996
!!     VALUES=   1.00000000       2.00000000       3.00000000
!!     VALUES=   1.00000000
!!     VALUES=
!!     VALUES=   3.00000000       2.50000000       2.50000000
!!     2.50000000       2.50000000       8.00000000
!!     VALUES=   32.3333015
!!     VALUES=   30000.0000       300.000000       30.0000000
!!     3.00000000
!!     *getvals* WARNING:[even] is not a number
!!     *getvals* WARNING:[like] is not a number
!!     *getvals* WARNING:[this!] is not a number
!!     VALUES=   1.00000000       10.0000000
!!     VALUES=   11.0000000       22.0000000       33.0000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine getvals(line,values,icount,ierr)

! ident_64="@(#) M_strings getvals(3f) read arbitrary number of values from a character variable"

! JSU 20170831

character(len=*),intent(in)  :: line
class(*),intent(out)         :: values(:)
integer,intent(out)          :: icount
integer,intent(out),optional :: ierr

character(len=:),allocatable :: buffer
character(len=len(line))     :: words(size(values))
integer                      :: iostat, i, ierr_local,isize

   isize=0
   select type(values)
   type is (integer);          isize=size(values)
   type is (real);             isize=size(values)
   type is (doubleprecision);  isize=size(values)
   type is (character(len=*)); isize=size(values)
   end select

   ierr_local=0

   words=' '                            ! make sure words() is initialized to null+blanks
   buffer=trim(unquote(line))//"/"      ! add a slash to the end so how the read behaves with missing values is clearly defined
   read(buffer,*,iostat=iostat) words      ! undelimited strings are read into an array
   icount=0
   do i=1,isize                         ! loop thru array and convert non-blank words to numbers
      if(words(i) == ' ')cycle

      select type(values)
      type is (integer);          read(words(i),*,iostat=iostat)values(icount+1)
      type is (real);             read(words(i),*,iostat=iostat)values(icount+1)
      type is (doubleprecision);  read(words(i),*,iostat=iostat)values(icount+1)
      type is (character(len=*)); values(icount+1)=words(i)
      end select

      if(iostat == 0)then
         icount=icount+1
      else
         ierr_local=iostat
         write(stderr,*)'*getvals* WARNING:['//trim(words(i))//'] is not a number of specified type'
      endif
   enddo

   if(present(ierr))then
      ierr=ierr_local
   elseif(ierr_local /= 0)then        ! error occurred and not returning error to main program to print message and stop program
      write(stderr,*)'*getval* error reading line ['//trim(line)//']'
      stop 2
   endif

end subroutine getvals
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_values(3f) - [M_strings:TYPE] read a string representing
!!      numbers into a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine string_to_values(line,iread,values,inums,delims,ierr)
!!
!!        character(len=*) :: line
!!        integer          :: iread
!!        real             :: values(*)
!!        integer          :: inums
!!        character(len=*) :: delims
!!        integer          :: ierr
!!
!!##DESCRIPTION
!!    This routine can take a string representing a series of numbers and
!!    convert it to a numeric array and return how many numbers were found.
!!
!!##OPTIONS
!!       LINE     Input string containing numbers
!!       IREAD    maximum number of values to try to read from input string
!!
!!##RETURNS
!!       VALUES   real array to be filled with numbers
!!       INUMS    number of values successfully read (before error occurs
!!                if one does)
!!       DELIMS   delimiter character(s), usually a space. must not be a
!!                null string. If more than one character, a space must
!!                not be the last character or it will be ignored.
!!       IERR     error flag (0=no error, else column number string starts
!!                at that error occurred on).
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!      program demo_string_to_values
!!       use M_strings, only : string_to_values
!!       implicit none
!!       character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!       integer,parameter  :: isz=10
!!       real               :: array(isz)
!!       integer            :: inums, ierr, ii
!!
!!       call string_to_values(s,10,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       contains
!!          subroutine reportit()
!!             write(*,*)'string_to_values:'
!!             write(*,*)'input string.............',trim(s)
!!             write(*,*)'number of values found...',inums
!!             write(*,*)'values...................',(array(ii),ii=1,inums)
!!          end subroutine reportit
!!      end program demo_string_to_values
!!
!!    Expected output
!!
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000  20000.0000  3.45000005
!!     -4.00299978  1234.00000  5678.00000
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           3
!!     values...................   10.0000000  2.29999995  3.14159989
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine string_to_values(line,iread,values,inums,delims,ierr)
!----------------------------------------------------------------------------------------------------------------------------------
!   1989,1997-12-31,2014 John S. Urban

!   given a line of structure , string , string , string process each
!   string as a numeric value and store into an array.
!   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS.
!   There is no direct checking for more values than can fit in VALUES.
!   Quits if encounters any errors in read.
!----------------------------------------------------------------------------------------------------------------------------------

! ident_65="@(#) M_strings string_to_values(3f) reads an array of numbers from a numeric string"

character(len=*),intent(in)  :: line          ! input string
integer,intent(in)           :: iread         ! maximum number of values to try to read into values
real,intent(inout)           :: values(iread) ! real array to be filled with values
integer,intent(out)          :: inums         ! number of values successfully read from string
character(len=*),intent(in)  :: delims        ! allowed delimiters
integer,intent(out)          :: ierr          ! 0 if no error, else column number undecipherable string starts at
!----------------------------------------------------------------------------------------------------------------------------------
character(len=256)           :: delims_local        ! mutable copy of allowed delimiters
integer                      :: ibegin,iend,lgth,icol
integer                      :: i10,i20,i40
real                         :: rval
integer                      :: ier
integer                      :: delimiters_length
!----------------------------------------------------------------------------------------------------------------------------------
      delims_local=delims                                 ! need a mutable copy of the delimiter list
      if(delims_local == '')then                          ! if delimiter list is null or all spaces make it a space
         delims_local=' '                                 ! delimiter is a single space
         delimiters_length=1                        ! length of delimiter list
      else
         delimiters_length=len_trim(delims)         ! length of variable WITH TRAILING WHITESPACE TRIMMED
      endif
!----------------------------------------------------------------------------------------------------------------------------------
      ierr=0                                        ! initialize error code returned
      inums=0                                       ! initialize count of values successfully returned
      ibegin=0
!----------------------------------------------------------------------------------------------------------------------------------
      lgth=0                                        ! lgth will be the position of the right-most non-delimiter in the input line
      do i20=len(line),1,-1                         ! loop from end of string to beginning to find right-most non-delimiter
         if(index(delims_local(:delimiters_length),line(i20:i20)) == 0)then   ! found a non-delimiter
            lgth=i20
            exit
         endif
      enddo
      if(lgth == 0)then                             ! command was totally composed of delimiters
         call journal('*string_to_values* blank line passed as a list of numbers')
         return
      endif
!----------------------------------------------------------------------------------------------------------------------------------
!     there is at least one non-delimiter sub-string
!     lgth is the column position of the last non-delimiter character
!     now, starting at beginning of string find next non-delimiter
      icol=1                                                     ! pointer to beginning of unprocessed part of LINE
      LOOP: dO i10=1,iread,1                                     ! each pass should find a value
         if(icol > lgth) EXIT LOOP                              ! everything is done
         INFINITE: do
            if(index(delims_local(:delimiters_length),line(icol:icol)) == 0)then           ! found non-delimiter
               ibegin=icol
               iend=0                                            ! FIND END OF SUBSTRING
               do i40=ibegin,lgth                                ! look at each character starting at left
                  if(index(delims_local(:delimiters_length),line(i40:i40)) /= 0)then       ! determine if character is a delimiter
                     iend=i40                                    ! found a delimiter. record where it was found
                     EXIT                                        ! found end of substring so leave loop
                  endif
               enddo
              if(iend == 0)iend=lgth+1                           ! no delimiters found, so this substring goes to end of line
               iend=iend-1                                       ! do not want to pass delimiter to be converted
               rval=0.0
               call string_to_value(line(ibegin:iend),rval,ier)  ! call procedure to convert string to a numeric value
               if(ier == 0)then                                  ! a substring was successfully converted to a numeric value
                  values(i10)=rval                               ! store numeric value in return array
                  inums=inums+1                                  ! increment number of values converted to a numeric value
               else                                              ! an error occurred converting string to value
                  ierr=ibegin                                    ! return starting position of substring that could not be converted
                  return
               endif
               icol=iend+2                                       ! set to next character to look at
               CYCLE LOOP                                        ! start looking for next value
            else                                                 ! this is a delimiter so keep looking for start of next string
               icol=icol+1                                       ! increment pointer into LINE
               CYCLE INFINITE
            endif
         enddo INFINITE
      enddo LOOP
!     error >>>>> more than iread numbers were in the line.
end subroutine string_to_values
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2vs(3f) - [M_strings:TYPE] given a string representing numbers
!!      return a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function s2vs(line[,delim])
!!
!!        character(len=*) :: line
!!        doubleprecision,allocatable :: s2vs(:)
!!
!!##DESCRIPTION
!!    The function S2VS(3f) takes a string representing a series of numbers
!!    and converts it to a numeric doubleprecision array. The string values
!!    may be delimited by spaces, semi-colons, and commas by default.
!!
!!##OPTIONS
!!       LINE   Input string containing numbers
!!       DELIM  optional list of delimiter characters. If a space is
!!              included, it should appear as the left-most character
!!              in the list. The default is " ;," (spaces, semi-colons,
!!              and commas).
!!
!!##RETURNS
!!       S2VS   doubleprecision array
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_s2vs
!!      use M_strings, only : s2vs
!!      implicit none
!!      character(len=80) :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!      real,allocatable :: values(:)
!!      integer,allocatable :: ivalues(:)
!!      integer :: ii
!!
!!      values=s2vs(s)
!!      ivalues=int(s2vs(s))
!!      call reportit()
!!
!!      contains
!!        subroutine reportit()
!!          write(*,*)'S2VS:'
!!          write(*,*)'input string.............',&
!!           & trim(s)
!!          write(*,*)'number of values found...',&
!!           & size(values)
!!          write(*,*)'values...................',&
!!           & (values(ii),ii=1,size(values))
!!          write(*,'(*(g0,1x))')'ivalues..................',&
!!           & (ivalues(ii),ii=1,size(values))
!!        end subroutine reportit
!!      end program demo_s2vs
!!
!!   Expected output
!!
!!     S2VS:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000 20000.0000 3.45000005
!!     -4.00299978 1234.00000 5678.00000
!!    ivalues.................. 10 20000 3 -4 1234 5678
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function s2vs(string,delim) result(darray)

! ident_66="@(#) M_strings s2vs(3f) function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isprint(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     ASCII printable character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isprint(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isprint
!!
!!##DESCRIPTION
!!     isprint(3f) returns .true. if character is an ASCII printable character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isprint  logical value returns true if character is a
!!             printable ASCII character else false.
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isprint
!!    use M_strings, only : isprint
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISPRINT: ',pack( string, isprint(string) )
!!    end program demo_isprint
!!
!!   Results:
!!
!!    ISPRINT:  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEF
!!    GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
!!    opqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isprint(onechar)

! ident_67="@(#) M_strings isprint(3f) indicates if input character is a printable ASCII character"

character,intent(in) :: onechar
logical              :: isprint
   select case (onechar)
      case (' ':'~')   ; isprint=.TRUE.
      case default     ; isprint=.FALSE.
   end select
end function isprint
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isgraph(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable character except a space is considered non-printable
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isgraph(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isgraph
!!
!!##DESCRIPTION
!!    isgraph(3f) returns .true. if character is a printable character
!!    except a space is considered non-printable
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isgraph   logical value returns true if character is a printable
!!              non-space character
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isgraph
!!    use M_strings, only : isgraph
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISGRAPH: ',pack( string, isgraph(string) )
!!    end program demo_isgraph
!!
!!   Results:
!!
!!    ISGRAPH: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
!!    HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
!!    pqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isgraph(onechar)

! ident_68="@(#) M_strings isgraph(3f) indicates if character is printable ASCII character excluding space"

character,intent(in) :: onechar
logical              :: isgraph
   select case (iachar(onechar))
   case (33:126)
     isgraph=.TRUE.
   case default
     isgraph=.FALSE.
   end select
end function isgraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalpha(3f) - [M_strings:COMPARE] returns .true. if character is a
!!    letter and .false. otherwise
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   elemental function isalpha(onechar)
!!
!!    character,intent(in) :: onechar
!!    logical              :: isalpha
!!
!!##DESCRIPTION
!!    isalpha(3f) returns .true. if character is a letter and
!!    .false. otherwise
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isalpha  logical value returns .true. if character is a ASCII letter
!!             or false otherwise.
!!##EXAMPLES
!!
!!
!!   Sample program
!!
!!     program demo_isalpha
!!     use M_strings, only : isalpha
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISGRAPH: ',pack( string, isalpha(string) )
!!     end program demo_isalpha
!!
!!   Results:
!!
!!    ISGRAPH: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm
!!    nopqrstuvwxyz
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function isalpha(ch) result(res)

! ident_69="@(#) M_strings isalpha(3f) Return .true. if character is a letter and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z','a':'z')
     res=.true.
   case default
     res=.false.
   end select
end function isalpha
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isxdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     hexadecimal digit (0-9, a-f, or A-F).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isxdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isxdigit
!!
!!##DESCRIPTION
!!     isxdigit(3f) returns .true. if character is a hexadecimal digit (0-9,
!!     a-f, or A-F).
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isxdigit  logical value returns true if character is a hexadecimal digit
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     program demo_isxdigit
!!     use M_strings, only : isxdigit
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISXDIGIT: ',pack( string, isxdigit(string) )
!!     end program demo_isxdigit
!!
!!   Results:
!!
!!    ISXDIGIT: 0123456789ABCDEFabcdef
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isxdigit(ch) result(res)

! ident_70="@(#) M_strings isxdigit(3f) returns .true. if c is a hexadecimal digit (0-9 a-f or A-F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'F','a':'f','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isxdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     digit (0,1,...,9) and .false. otherwise
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isdigit
!!
!!##DESCRIPTION
!!     isdigit(3f) returns .true. if character is a digit (0,1,...,9)
!!     and .false. otherwise
!!
!!##EXAMPLES
!!
!!
!!  Sample Program:
!!
!!     program demo_isdigit
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!            & all(isdigit(switch(string(i))).or.&
!!            & isspace(switch(string(i))))
!!        enddo
!!     end program demo_isdigit
!!
!!  Expected output:
!!
!!        For string[1 2 3 4 5 ] T
!!        For string[letters   ] F
!!        For string[1234567890] T
!!        For string[both 8787 ] F
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isdigit(ch) result(res)

! ident_71="@(#) M_strings isdigit(3f) Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isblank(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     blank character (space or horizontal tab).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isblank(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isblank
!!
!!##DESCRIPTION
!!     isblank(3f) returns .true. if character is a blank character (space
!!     or horizontal tab).
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isblank  logical value returns true if character is a "blank"
!!             ( an ASCII  space or horizontal tab character).
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_isblank
!!     use M_strings, only : isblank
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(*(g0,1x))')'ISXBLANK: ',&
!!        & iachar(pack( string, isblank(string) ))
!!     end program demo_isblank
!!
!!   Results:
!!
!!    ISXBLANK:  9 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isblank(ch) result(res)

! ident_72="@(#) M_strings isblank(3f) returns .true. if character is a blank (space or horizontal tab)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ',char(9))
     res=.true.
   case default
     res=.false.
   end select
end function isblank
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isascii(3f) - [M_strings:COMPARE] returns .true. if the character is
!!     in the range char(0) to char(256)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isascii(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isascii
!!
!!##DESCRIPTION
!!     isascii(3f) returns .true. if the character is in the range char(0)
!!     to char(127)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isupper  logical value returns true if character is an ASCII
!!             character.
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_isascii
!!     use M_strings, only : isascii
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,255)]
!!        write(*,'(10(g0,1x))')'ISASCII: ', &
!!        & iachar(pack( string, isascii(string) ))
!!     end program demo_isascii
!!
!!  Results:
!!
!!    ISASCII:  0 1 2 3 4 5 6 7 8
!!    9 10 11 12 13 14 15 16 17 18
!!    19 20 21 22 23 24 25 26 27 28
!!    29 30 31 32 33 34 35 36 37 38
!!    39 40 41 42 43 44 45 46 47 48
!!    49 50 51 52 53 54 55 56 57 58
!!    59 60 61 62 63 64 65 66 67 68
!!    69 70 71 72 73 74 75 76 77 78
!!    79 80 81 82 83 84 85 86 87 88
!!    89 90 91 92 93 94 95 96 97 98
!!    99 100 101 102 103 104 105 106 107 108
!!    109 110 111 112 113 114 115 116 117 118
!!    119 120 121 122 123 124 125 126 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isascii(ch) result(res)

! ident_73="@(#) M_strings isascii(3f) returns .true. if character is in the range char(0) to char(127)"

character,intent(in) :: ch
logical              :: res
   select case(iachar(ch))
   case(0:127)
     res=.true.
   case default
     res=.false.
   end select
end function isascii
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & iachar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_74="@(#) M_strings isspace(3f) true if null space tab return new line vertical tab or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     iscntrl(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     delete character or ordinary control character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function iscntrl(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: iscntrl
!!
!!##DESCRIPTION
!!     iscntrl(3f) returns .true. if character is a delete character or
!!     ordinary control character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    iscntrl  logical value returns true if character is a control character
!!
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_iscntrl
!!     use M_strings, only : iscntrl
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISCNTRL: ', &
!!        & iachar(pack( string, iscntrl(string) ))
!!     end program demo_iscntrl
!!
!!   Results:
!!
!!    ISCNTRL:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
!!    20 21 22 23 24 25 26 27 28 29 30 31 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function iscntrl(ch) result(res)

! ident_75="@(#) M_strings iscntrl(3f) true if a delete or ordinary control character(0x7F or 0x00-0x1F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(char(127),char(0):char(31))
     res=.true.
   case default
     res=.false.
   end select
end function iscntrl
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     ispunct(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable punctuation character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function ispunct(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: ispunct
!!
!!##DESCRIPTION
!!     ispunct(3f) returns .true. if character is a printable punctuation
!!     character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    ispunct  logical value returns true if character is a printable
!!             punctuation character.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_ispunct
!!     use M_strings, only : ispunct
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & iachar(pack( string, ispunct(string) ))
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & pack( string, ispunct(string) )
!!     end program demo_ispunct
!!   Results:
!!
!!    ISPUNCT:  33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61
!!    62 63 64 91 92 93 94 95 96 123 124 125 126
!!    ISPUNCT:  ! " # $ % & ' ( ) * + , - . / : ; < =
!!    > ? @ [ \ ] ^ _ ` { | } ~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function ispunct(ch) result(res)

! ident_76="@(#) M_strings ispunct(3f) true if a printable punctuation character (isgraph(c)&&!isalnum(c))"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case (char(33):char(47), char(58):char(64), char(91):char(96), char(123):char(126))
     res=.true.
!  case(' ','0':'9','A':'Z','a':'z',char(128):)
!    res=.true.
!  case(char(0):char(31),char(127))
!    res=.true.
   case default
     res=.false.
   end select
end function ispunct
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     fortran_name(3f) - [M_strings:COMPARE] test if string meets criteria
!!     for being a fortran name
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     elemental function fortran_name(line) result (lout)
!!
!!      character(len=*),intent(in)  :: line
!!      logical                      :: lout
!!
!!##DESCRIPTION
!!     Determines if a string is an allowed Fortran name. To pass the input
!!     string must be composed of 1 to 63 ASCII characters and start with a
!!     letter and be composed entirely of alphanumeric characters [a-zA-Z0-9]
!!     and underscores.
!!
!!##OPTIONS
!!     LINE   input string to test. Leading spaces are significant but
!!            trailing spaces are ignored.
!!
!!##RETURNS
!!     LOUT   a logical value indicating if the input string passed or failed
!!            the test to see if it is a valid Fortran name or not.
!!
!!##EXAMPLES
!!
!!    Sample program
!!
!!      program demo_fortran_name
!!      use M_strings, only : fortran_name
!!      implicit none
!!      character(len=20),parameter :: names(*)=[character(len=20) ::  &
!!       & '_name',         'long_variable_name', 'name_',         &
!!       & '12L',           'a__b__c  ',          'PropertyOfGas', &
!!       & '3%3',           '$NAME',              ' ',             &
!!       & 'Variable-name', 'A',                  'x@x' ]
!!      integer :: i
!!         write(*,'(i3,1x,a20,1x,l1)')&
!!         & (i,names(i),fortran_name(names(i)),i=1,size(names))
!!      end program demo_fortran_name
!!
!!    Results:
!!
!!      >  1 _name                F
!!      >  2 long_variable_name   T
!!      >  3 name_                T
!!      >  4 12L                  F
!!      >  5 a__b__c              T
!!      >  6 PropertyOfGas        T
!!      >  7 3%3                  F
!!      >  8 $NAME                F
!!      >  9                      F
!!      > 10 Variable-name        F
!!      > 11 A                    T
!!      > 12 x@x                  F
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function fortran_name(line) result (lout)

! ident_77="@(#) M_strings fortran_name(3f) Return .true. if name is a valid Fortran name"

! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)
character(len=*),parameter   :: int='0123456789'
character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character(len=*),parameter   :: allowed=upper//lower//int//'_'

character(len=*),intent(in)  :: line
character(len=:),allocatable :: name
logical                      :: lout
   name=trim(line)
   if(len(name) /= 0)then
      lout = verify(name(1:1), lower//upper) == 0  &  ! first character is a letter
       & .and. verify(name,allowed) == 0           &  ! composed of alphanumeric and underscore in its entirety
       & .and. len(name) <= 63                        ! length less than 64 characters
   else
      lout = .false.
   endif
end function fortran_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isupper(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     uppercase letter (A-Z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isupper(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isupper
!!
!!##DESCRIPTION
!!     isupper(3f) returns .true. if character is an uppercase letter (A-Z)
!!
!!##OPTIONS
!!    onechar  character to test
!!##RETURNS
!!    isupper  logical value returns true if character is an uppercase
!!             ASCII character else false.
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_isupper
!!     use M_strings, only : isupper
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & iachar(pack( string, isupper(string) ))
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & pack( string, isupper(string) )
!!     end program demo_isupper
!!
!!  Results:
!!
!!     > ISUPPER:  65 66 67 68 69 70 71 72 73
!!     > 74 75 76 77 78 79 80 81 82 83
!!     > 84 85 86 87 88 89 90
!!     > ISUPPER:  A B C D E F G H I
!!     > J K L M N O P Q R S
!!     > T U V W X Y Z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
pure elemental function isupper(ch) result(res)

! ident_78="@(#) M_strings isupper(3f) returns true if character is an uppercase letter (A-Z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z'); res=.true.
   case default;  res=.false.
   end select
end function isupper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     islower(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     miniscule letter (a-z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function islower(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: islower
!!
!!##DESCRIPTION
!!     islower(3f) returns .true. if character is a miniscule letter (a-z)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    islower  logical value returns true if character is a lowercase
!!             ASCII character else false.
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_islower
!!     use M_strings, only : islower
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & iachar(pack( string, islower(string) ))
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & pack( string, islower(string) )
!!     end program demo_islower
!!   Results:
!!
!!    ISLOWER:  97 98 99 100 101 102 103 104 105 106 107 108 109 110
!!    111 112 113 114 115 116 117 118 119 120 121 122
!!    ISLOWER:  a b c d e f g h i j k l m n
!!    o p q r s t u v w x y z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function islower(ch) result(res)

! ident_79="@(#) M_strings islower(3f) returns true if character is a miniscule letter (a-z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('a':'z'); res=.true.
   case default;  res=.false.
   end select
end function islower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalnum,isalpha,iscntrl,isdigit,isgraph,islower,
!!    isprint,ispunct,isspace,isupper,
!!    isascii,isblank,isxdigit(3f) - [M_strings:COMPARE] test membership in
!!    subsets of ASCII set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Where "FUNCNAME" is one of the function names in the group, the
!!    functions are defined by
!!
!!     elemental function FUNCNAME(onechar)
!!     character,intent(in) :: onechar
!!     logical              :: FUNC_NAME
!!##DESCRIPTION
!!
!!       These elemental functions test if a character belongs to various
!!       subsets of the ASCII character set.
!!
!!       isalnum    returns .true. if character is a letter (a-z,A-Z)
!!                  or digit (0-9)
!!       isalpha    returns .true. if character is a letter and
!!                  .false. otherwise
!!       isascii    returns .true. if character is in the range char(0)
!!                  to char(127)
!!       isblank    returns .true. if character is a blank (space or
!!                  horizontal tab).
!!       iscntrl    returns .true. if character is a delete character or
!!                  ordinary control character (0x7F or 0x00-0x1F).
!!       isdigit    returns .true. if character is a digit (0,1,...,9)
!!                  and .false. otherwise
!!       isgraph    returns .true. if character is a printable ASCII
!!                  character excluding space
!!       islower    returns .true. if character is a miniscule letter (a-z)
!!       isprint    returns .true. if character is a printable ASCII character
!!       ispunct    returns .true. if character is a printable punctuation
!!                  character (isgraph(c) && !isalnum(c)).
!!       isspace    returns .true. if character is a null, space, tab,
!!                  carriage return, new line, vertical tab, or formfeed
!!       isupper    returns .true. if character is an uppercase letter (A-Z)
!!       isxdigit   returns .true. if character is a hexadecimal digit
!!                  (0-9, a-f, or A-F).
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isdigit
!!
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!           all(isdigit(switch(string(i))) .or. &
!!           & isspace(switch(string(i))))
!!        enddo
!!
!!     end program demo_isdigit
!!
!!   Expected output:
!!
!!    For string[1 2 3 4 5 ] T
!!    For string[letters   ] F
!!    For string[1234567890] T
!!    For string[both 8787 ] F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental function isalnum(ch) result(res)

! ident_80="@(#) M_strings isalnum(3f) returns true if character is a letter (a-z A-Z) or digit(0-9)"

character,intent(in)       :: ch
logical                    :: res
   select case(ch)
   case('a':'z','A':'Z','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isalnum
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base(3f) - [M_strings:BASE] convert whole number string in base [2-36]
!!    to string in alternate base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   elemental impure logical function base(x,b,y,a)
!!
!!    character(len=*),intent(in)  :: x
!!    character(len=*),intent(out) :: y
!!    integer,intent(in)           :: b,a
!!##DESCRIPTION
!!
!!    Convert a numeric string from base B to base A. The function returns
!!    FALSE if B is not in the range [2..36] or if string X contains invalid
!!    characters in base B or if result Y is too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in a base > 10.
!!
!!##OPTIONS
!!    x   input string representing numeric whole value
!!    b   assumed base of input string
!!    y   output string.
!!        Y is assumed long enough to hold the computed value.
!!        If an error occurs Y is filled with asterisks (*).
!!    a   base specified for output string
!!##RETURNS
!!        Returns .TRUE. if no error occurred, else returns .FALSE. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_base
!!    use M_strings, only: base
!!    implicit none
!!    integer           :: ba, bd, i
!!    character(len=40) :: x, y
!!    character(len=*), parameter :: input(*) = [character(len=80) :: &
!!       '10 12345 10', &
!!       '2 10111 10', &
!!       '10 12345 20', &
!!       '10 abcdef 2', &
!!       '0 0 0']
!!    character(len=:),allocatable :: line
!!       print *, 'Base Conversion using base(3f)'
!!       do i = 1, size(input)
!!          line=input(i)
!!          read (line, *) bd, x, ba
!!          if (x == '0') exit
!!          if (base(x, bd, y, ba)) then
!!          else
!!             print *, 'Error in decoding/encoding numbers'
!!          end if
!!          write (*, '(a," in base ",i0," is ",a," in base ",i0)')&
!!          & trim(x),bd,trim(y),ba
!!       end do
!!    end program demo_base
!!
!! Results:
!!
!!    >  Base Conversion using base(3f)
!!    > 12345 in base 10 is 12345 in base 10
!!    > 10111 in base 2 is 23 in base 10
!!    > 12345 in base 10 is 1AH5 in base 20
!!    >  Error in decoding/encoding numbers
!!    > abcdef in base 10 is **************************************** in base 2
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental impure logical function base(x, b, y, a)
character(len=*), intent(in)  :: x
character(len=*), intent(out) :: y
integer, intent(in)           :: b, a
integer                       :: tempx
integer                       :: iostat

! ident_81="@(#) M_strings base(3f) convert whole number string in base [2-36] to string in alternate base [2-36]"

! Y is assumed long enough to hold the computed value

   base = .true.
   if (decodebase(x, b, tempx)) then
      if (codebase(tempx, a, y)) then
      else
         flush(unit=output_unit,iostat=iostat)
         write(stderr,'(*(g0))') 'Error in coding number ',trim(x),' in base ',a
         flush(unit=stderr,iostat=iostat)
         base = .false.
         y=repeat('*',len(y))
      endif
   else
      flush(unit=output_unit,iostat=iostat)
      write(stderr,'(*(g0))') 'Error in decoding number ',trim(x),' in base ',b
      flush(unit=stderr,iostat=iostat)
      base = .false.
      y=repeat('*',len(y))
   endif

end function base
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base2(3f) - [M_strings:BASE] convert whole number to string in base 2
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function base2(int)
!!
!!     integer,intent(in)           :: int
!!     character(len=:),allocatable :: base2
!!
!!##DESCRIPTION
!!
!!    Convert a whole number to a string in base 2.
!!
!!    This is often done with the B edit descriptor and
!!    an internal WRITE() statement, but is done without
!!    calling the I/O routines, and as a function.
!!
!!##OPTIONS
!!    int   input string representing numeric whole value
!!
!!##RETURNS
!!    base2   string representing input value in base 2
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!      program demo_base2
!!      use M_strings, only : base2
!!      implicit none
!!         write(*,'(a)') base2(huge(0))
!!         write(*,'(a)') base2(0)
!!         write(*,'(a)') base2(64)
!!         write(*,'(a)') base2(-64)
!!         write(*,'(a)') base2(-huge(0)-1)
!!      end program demo_base2
!!
!! Results:
!!
!!     > 1111111111111111111111111111111
!!     > 0
!!     > 1000000
!!     > 11111111111111111111111111000000
!!     > 10000000000000000000000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2(x) result(str)
!  return string representing number as a binary number.  Fixed-length string:
integer, intent(in)                        :: x
integer                                    :: i
character(len=max(1,bit_size(x)-leadz(x))) :: str
    associate(n => len(str))
      str = repeat('0',n)
      do i = 0,n-1
        if (btest(x,i)) str(n-i:n-i) = '1'
      end do
    end associate
end function base2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_strings:BASE] convert whole number string in base
!!    [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##RETURNS
!!    Returns .true. if no error occurred, else returns .false. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_decodebase
!!    use M_strings, only : codebase, decodebase
!!    implicit none
!!    integer           :: bd, i, r
!!    character(len=40) :: x
!!    character(len=*), parameter :: input(*) = [character(len=80) :: &
!!       '10  12345',   &
!!       '2   10111',   &
!!       '6   12345',   &
!!       '10  abcdef',  &
!!       '0   0']
!!    character(len=:),allocatable :: line
!!       print *, 'Base Conversion using decodebase(3f)'
!!       do i = 1, size(input)
!!          line=input(i)
!!          read (line, *) bd, x
!!          if (x == '0') exit
!!          if(.not.decodebase(x,bd,r)) then
!!            print *,'Error in decoding number.'
!!          endif
!!          write (*, '(a," in base ",i0," becomes ",i0," in base 10")')&
!!          & trim(x),bd,r
!!       end do
!!    end program demo_decodebase
!!
!! Results:
!!
!!  >  Base Conversion using decodebase(3f)
!!  > 12345 in base 10 becomes 12345 in base 10
!!  > 10111 in base 2 becomes 23 in base 10
!!  > 12345 in base 6 becomes 1865 in base 10
!!  >  Error in decoding number.
!!  > abcdef in base 10 becomes 0 in base 10
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================
logical function decodebase(string,basein,out_baseten)

! ident_82="@(#) M_strings decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  ::  string
integer,intent(in)           ::  basein
integer,intent(out)          ::  out_baseten
character(len=len(string))   ::  string_local
integer                      ::  long, i,  j,  k
real(kind=real64)            ::  y
real(kind=real64)            ::  mult
character(len=1)             ::  ch
real(kind=real64),parameter  ::  XMAXREAL=huge(1.0)
integer                      ::  out_sign
integer                      ::  basein_local
integer                      ::  ipound
integer                      ::  ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                   ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=huge(0)
  y=0.0_real64
  ALL: if(basein_local<2.or.basein_local>36) then
    write(stderr,*) '(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
    out_baseten=huge(0)
  else ALL
     out_baseten=0;y=0.0_real64; mult=1.0_real64
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(stderr,*)'*decodebase* ERROR: invalid character ',ch
           out_baseten=huge(0)
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    codebase(3f) - [M_strings:BASE] convert whole number in base 10 to
!!    string in base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function codebase(in_base10,out_base,answer,uc)
!!
!!    integer,intent(in)           :: in_base10
!!    integer,intent(in)           :: out_base
!!    character(len=*),intent(out) :: answer
!!    logical,intent(in),optional  :: uc
!!
!!##DESCRIPTION
!!    Convert a number from base 10 to base OUT_BASE. The function returns
!!    .FALSE. if OUT_BASE is not in the range [2..36] or if number IN_BASE10
!!    is too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    in_base10   whole number to convert to an alternate base
!!    out_base    the desired base of the output
!!    answer      the input value converted to a string representing
!!                the original number IN_BASE10 in base OUT_BASE.
!!    uc          returned letters are uppercase if .true., lowercase
!!                if .false.
!!
!!##RETURNS
!!    Returns .true. if no error occurred, else returns .false. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_codebase
!!    use M_strings, only : codebase
!!    implicit none
!!    character(len=20) :: answer
!!    integer           :: i, j
!!    logical           :: ierr
!!    do j=1,100
!!       do i=2,36
!!          ierr=codebase(j,i,answer)
!!          write(*,*)'VALUE=',j,' BASE=',i,' ANSWER=',answer
!!       enddo
!!    enddo
!!    end program demo_codebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!     Ref.: "Math matiques en Turbo-Pascal by
!!            M. Ducamp and A. Reverchon (2),
!!            Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function codebase(inval10,outbase,answer,uc)

! ident_83="@(#) M_strings codebase(3f) convert whole number in base 10 to string in base [2-36]"

use,intrinsic :: iso_fortran_env, only : stderr=>error_unit
use,intrinsic :: iso_fortran_env, only : int8,int16,int32,int64,real32,real64
integer,intent(in)           :: inval10, outbase
logical,intent(in),optional  :: uc
character(len=*),intent(out) :: answer
real(kind=real64)            :: inval10_local
integer(kind=int64)          :: i, j, n, outbase_local, in_sign
integer,parameter            :: i0=ichar('0')
integer                      :: iA
  if(present(uc))then
     ia=merge(ichar('A'),ichar('a'),uc)
  else
     ia=ichar('A')
  endif
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
     write(stderr,*) '*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
     codebase=.false.
  else
     i=0
     j=len(answer)
     do while(inval10_local>0.0 )
        n=int(inval10_local-outbase_local*int(inval10_local/outbase_local))
        i=i+1
        if(i.gt.j)then
           write(stderr,*) '*codebase* ERROR: output longer than return string',i,j
           codebase=.false.
           exit
        endif
        if(n<10) then
           answer=achar(i0+n)//answer
        else
           answer=achar(iA+n-10)//answer
        endif
        !inval10_local=floor(inval10_local/outbase_local)
        inval10_local=int(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign == -1)then
     answer='-'//trim(answer)
  endif
  if(answer == '')then
     answer='0'
  endif
end function codebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function todecimal(base, instr)

! ident_84="@(#) M_strings todecimal(3f) given string and base return decimal integer"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function tobase(base, number)

! ident_85="@(#) M_strings tobase(3f) given integer and base return string"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

!SUBROUTINE DectoBase(decimal, string, base)
! CHARACTER string
!    string = '0'
!    temp = decimal
!    length = CEILING( LOG(decimal+1, base) )   !<<<<<<<< INTERESTING
!    DO i = length, 1, -1
!      n = MOD( temp, base )
!      string(i) = "0123456789abcdefghijklmnopqrstuvwxyz"(n+1)
!      temp = INT(temp / base)
!    ENDDO
! END
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    paragraph(3f) - [M_strings:TOKENS] break a long line into a paragraph
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function paragraph(source_string,length)
!!
!!    character(len=*),intent(in)       :: source_string
!!    integer,intent(in)                :: length
!!    character(allocatable(len=length)    :: paragraph(:)
!!
!!##DESCRIPTION
!!    paragraph(3f) breaks a long line into a simple paragraph of specified
!!    line length.
!!
!!    Given a long string break it on spaces into an array such that no
!!    variable is longer than the specified length. Individual words longer
!!    than LENGTH will be placed in lines by themselves and the paragraph
!!    width will be increased to the length of the longest word.
!!
!!##OPTIONS
!!     SOURCE_STRING  input string to break into an array of shorter strings
!!                    on blank delimiters
!!     LENGTH         length of lines to break the string into.
!!
!!##RETURNS
!!     PARAGRAPH  character array filled with data from source_string
!!                broken at spaces into variables of length LENGTH.
!!
!!##EXAMPLES
!!
!!  sample program
!!
!!    program demo_paragraph
!!    use M_strings, only : paragraph
!!    implicit none
!!    character(len=:),allocatable :: paragrph(:)
!!    character(len=*),parameter    :: string= '&
!!     &one two three four five &
!!     &six seven eight &
!!     &nine ten eleven twelve &
!!     &thirteen fourteen fifteen sixteen &
!!     &seventeen'
!!
!!    write(*,*)'LEN=',len(string)
!!    write(*,*)'INPUT:'
!!    write(*,*)string
!!
!!    paragrph=paragraph(string,40)
!!    write(*,*)'LEN=',len(paragrph),' SIZE=',size(paragrph)
!!    write(*,*)'OUTPUT:'
!!    write(*,'(a)')paragrph
!!
!!    write(*,'(a)')paragraph(string,0)
!!    write(*,'(3x,a)')paragraph(string,47)
!!
!!    end program demo_paragraph
!!
!!   Results:
!!
!!     LEN=         106
!!     INPUT:
!!     one two three four five six seven eight nine ten eleven twelve
!!     thirteen fourteen fifteen sixteen seventeen
!!     LEN=          40  SIZE=           3
!!     OUTPUT:
!!    one two three four five six seven eight
!!    nine ten eleven twelve thirteen fourteen
!!    fifteen sixteen seventeen
!!    one
!!    two
!!    three
!!    four
!!    five
!!    six
!!    seven
!!    eight
!!    nine
!!    ten
!!    eleven
!!    twelve
!!    thirteen
!!    fourteen
!!    fifteen
!!    sixteen
!!    seventeen
!!       one two three four five six seven eight nine
!!       ten eleven twelve thirteen fourteen fifteen
!!       sixteen seventeen
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function paragraph(source_string,length)

! ident_86="@(#) M_strings paragraph(3f) wrap a long string into a paragraph"

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: ibegin
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: paragraph(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
!-----------------------------------------------------------------------------------------------------------------------------------
!  parse string once to find out how big to make the returned array, then redo everything but store the data
!  could store array of endpoints and leave original whitespace alone or many other options
   do i=1,2
      iword_max=0                                  ! length of longest token
      ilines=1                                     ! number of output line output will go on
      ilength=0                                    ! length of output line so far
      itoken=0                                     ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
      do while ( strtok(source_string,itoken,ibegin,iend,delimiters) )
         iword=iend-ibegin+1
         iword_max=max(iword_max,iword)
         if(iword > length)then                   ! this token is longer than the desired line length so put it on a line by itself
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then     ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph
               paragraph(ilines)=source_string(ibegin:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then       ! this word will fit on current line
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=ilength+iword+1
         else                                      ! adding this word would make line too long so start new line
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then                                 ! determined number of lines needed so allocate output array
         allocate(character(len=max(length,iword_max)) :: paragraph(ilines))
         paragraph=' '
      endif
   enddo
   paragraph=paragraph(:ilines)
end function paragraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function setbits8(string) result(answer)
integer(kind=int8)          :: answer
character(len=8),intent(in) :: string
integer                     :: pos
integer                     :: lgth
   answer=0_int8
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits8* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,lgth
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits8* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits8
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits16(string) result(answer)
integer(kind=int16)          :: answer
character(len=16),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int16
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits16* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits16* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits16
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits32(string) result(answer)
integer(kind=int32)          :: answer
character(len=32),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int32
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits32* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits32* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits32
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits64(string) result(answer)
integer(kind=int64)          :: answer
character(len=64),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int64
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits64* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits64* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     str(3f) - [M_strings:TYPE] converts multiple values to a (CSV) string
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!     function str( g1,g2,g3,g4,g5,g6,g7,g8,g9,g10, &
!!                 & g11,g12,g13,g14,g15,g16,g17,g18,g19,g20,sep,csv)
!!
!!      class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,g10
!!      class(*),intent(in),optional  :: g11,g12,g13,g14,g15,g16,g17,g18,g19,g20
!!      character(len=*),intent(in),optional :: sep
!!      logical,intent(in),optional :: csv
!!      character(len=:),allocatable :: str
!!
!!##DESCRIPTION
!!     str(3f) builds a string from up to twenty scalar values.
!!
!!##OPTIONS
!!     g[1-20]  optional value to print the value of after the message. May
!!              be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!              or CHARACTER.
!!     sep      separator between values. Defaults to a space
!!     csv      write output conforming to RFC 1080 for CSV (Comma-Separated
!!              Values) files
!!
!!##RETURNS
!!     str      description to print
!!
!!##EXAMPLES
!!
!!
!!   Sample program:
!!
!!        program demo_str
!!        use M_strings, only : str, quote
!!        implicit none
!!        character(len=:),allocatable :: pr
!!        character(len=:),allocatable :: frmt
!!        integer                      :: biggest
!!
!!        pr=str('HUGE(3f) integers',huge(0),&
!!        & 'and real',huge(0.0),'and double',huge(0.0d0))
!!        write(*,'(a)')pr
!!        pr=str('real            :',&
!!         & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!        write(*,'(a)')pr
!!        pr=str('doubleprecision :',&
!!         & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!        write(*,'(a)')pr
!!        pr=str('complex         :',&
!!         & cmplx(huge(0.0),tiny(0.0)) )
!!        write(*,'(a)')pr
!!
!!        ! create a format on the fly
!!        biggest=huge(0)
!!        ! +0 for gfortran-11 bug
!!        frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
!!        write(*,*)'format=',frmt
!!
!!        ! compound output
!!        pr=str(10,100.0,"string",(11.0,22.0),.false.)
!!        write(*,'(a)')pr
!!        ! a separator and also use of quote(3f)
!!        pr=str(10,100.0,quote("string"),(11.0,22.0),.false.,sep=';')
!!        write(*,'(a)')pr
!!        ! CSV mode
!!        pr=str(10,100.0,"string",(11.0,22.0),.false.,csv=.true.)
!!        write(*,'(a)')pr
!!        ! everything a vector instead of a scalar
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.])
!!        write(*,'(a)')pr
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.],sep='|')
!!        write(*,'(a)')pr
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.],csv=.true.)
!!        write(*,'(a)')pr
!!
!!        ! although it will often work, using str(3f) in an I/O statement
!!        ! is not recommended
!!        write(*,*)str('program will now attempt to stop')
!!
!!        end program demo_str
!!
!! Results:
!!
!!  > HUGE(3f) integers 2147483647 and real 3.40282347E+38 and ...
!!  > ... double 1.7976931348623157E+308
!!  > real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!  > doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...
!!  > ... 12345.678900000001 2.2250738585072014E-308
!!  > complex         : (3.40282347E+38,1.17549435E-38)
!!  >  format=(*(i9:,1x))
!!  > 10 100.000000 string (11.0000000,22.0000000) F
!!  > 10;100.000000;"string";(11.0000000,22.0000000);F
!!  > 10,100.000000,"string",11.0000000,22.0000000,F
!!  >  program will now attempt to stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function str_scalar(g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, sep, csv)

! ident_87="@(#) M_strings str_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20
character(len=*),intent(in),optional :: sep
logical,intent(in),optional   :: csv
character(len=:),allocatable  :: sep_local
logical                       :: csv_local
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment

   if(present(csv))then
      csv_local=csv
   else
      csv_local=.false.
   endif

   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=merge(',',' ',csv_local)
      increment=2
   endif

   ibegin=1
   line=' '
   if(present(g1))call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(g10))call print_generic(g10)
   if(present(g11))call print_generic(g11)
   if(present(g12))call print_generic(g12)
   if(present(g13))call print_generic(g13)
   if(present(g14))call print_generic(g14)
   if(present(g15))call print_generic(g15)
   if(present(g16))call print_generic(g16)
   if(present(g17))call print_generic(g17)
   if(present(g18))call print_generic(g18)
   if(present(g19))call print_generic(g19)
   if(present(g20))call print_generic(g20)
   str_scalar=trim(line)
   if(sep_local.ne.'')str_scalar=str_scalar(:len(str_scalar)-1)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int16));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int32));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int64));    write(line(ibegin:),'(i0)') generic
      type is (real(kind=real32));      write(line(ibegin:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'(1pg0)') generic
      type is (logical);                write(line(ibegin:),'(l1)') generic
      type is (character(len=*))
         if(csv_local)then
            write(line(ibegin:),'(a)') quote(trim(generic))
         else
            write(line(ibegin:),'(a)') trim(generic)
         endif
      type is (complex)
         if(csv_local)then
            write(line(ibegin:),'(1pg0,a,1pg0)') generic%re,sep_local,generic%im
         else
            write(line(ibegin:),'("(",1pg0,",",1pg0,")")') generic
         endif
   end select
   ibegin=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end function str_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str_one(g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, sep, csv)

! ident_88="@(#) M_strings str_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)                  :: g1(:)
class(*),intent(in),optional         :: g2(:),g3(:),g4(:),g5(:),g6(:),g7(:),g8(:),g9(:),g10(:)
class(*),intent(in),optional         :: g11(:),g12(:),g13(:),g14(:),g15(:),g16(:),g17(:),g18(:),g19(:),g20(:)
character(len=*),intent(in),optional :: sep
logical,intent(in),optional          :: csv
character(len=:),allocatable         :: sep_local
logical                              :: csv_local
character(len=:), allocatable        :: str_one
character(len=4096)                  :: line
integer                              :: ibegin
integer                              :: increment

   if(present(csv))then
      csv_local=csv
   else
      csv_local=.false.
   endif

   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=merge(',',' ',csv_local)
      increment=2
   endif

   ibegin=1
   line=' '
   call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(g10))call print_generic(g10)
   if(present(g11))call print_generic(g11)
   if(present(g12))call print_generic(g12)
   if(present(g13))call print_generic(g13)
   if(present(g14))call print_generic(g14)
   if(present(g15))call print_generic(g15)
   if(present(g16))call print_generic(g16)
   if(present(g17))call print_generic(g17)
   if(present(g18))call print_generic(g18)
   if(present(g19))call print_generic(g19)
   if(present(g20))call print_generic(g20)
   str_one=trim(line)
   if(sep_local.ne.'')str_one=str_one(:len(str_one)-1)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in),optional :: generic(:)
integer :: i
   if(csv_local)then
      select type(generic)
         type is (integer(kind=int8));     write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int16));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int32));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int64));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (real(kind=real32));      write(line(ibegin:),'(*(1pg0:,","))') generic
         type is (real(kind=real64));      write(line(ibegin:),'(*(1pg0:,","))') generic
         !x!type is (real(kind=real128));     write(line(ibegin:),'(*(1pg0:,","))') generic
         !x!type is (real(kind=real256));     write(line(ibegin:),'(*(1pg0:,","))') generic
         type is (logical);                write(line(ibegin:),'(*(l1:,","))') generic
         type is (character(len=*));       write(line(ibegin:),'(:*(a:,","))') (quote(trim(generic(i))),i=1,size(generic))
         type is (complex);                write(line(ibegin:),'(*(1pg0,",",1pg0:))') generic
      end select
      ibegin=len_trim(line)+increment
      line=trim(line)//sep_local
   else
      select type(generic)
         type is (integer(kind=int8));     write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int16));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int32));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int64));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (real(kind=real32));      write(line(ibegin:),'("[",*(1pg0:,","))') generic
         type is (real(kind=real64));      write(line(ibegin:),'("[",*(1pg0:,","))') generic
         !x!type is (real(kind=real128));     write(line(ibegin:),'("[",*(1pg0:,","))') generic
         !x!type is (real(kind=real256));     write(line(ibegin:),'("[",*(1pg0:,","))') generic
         type is (logical);                write(line(ibegin:),'("[",*(l1:,","))') generic
         type is (character(len=*));       write(line(ibegin:),'("[",:*(:"""",a,"""":,","))') (trim(generic(i)),i=1,size(generic))
         type is (complex);                write(line(ibegin:),'("[",*(:"(",1pg0,",",1pg0,")":,","))') generic
      end select
      line=trim(line)//"]"
      ibegin=len_trim(line)+increment
      line=trim(line)//sep_local
   endif
end subroutine print_generic

end function str_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmt(3f) - [M_strings] convert any intrinsic to a string using specified format
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function fmt(value,format) result(string)
!!
!!     class(*),intent(in),optional         :: value
!!     character(len=*),intent(in),optional :: format
!!     character(len=:),allocatable         :: string
!!##DESCRIPTION
!!    FMT(3f) converts any standard intrinsic value to a string using the specified
!!    format.
!!##OPTIONS
!!    value    value to print the value of. May be of type INTEGER, LOGICAL,
!!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    format   format to use to print value. It is up to the user to use an
!!             appropriate format. The format does not require being
!!             surrounded by parenthesis. If not present a default is selected
!!             similar to what would be produced with free format, with
!!             trailing zeros removed.
!!##RETURNS
!!    string   A string value
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_fmt
!!     use :: M_strings, only : fmt
!!     implicit none
!!     character(len=:),allocatable :: output
!!
!!        output=fmt(10,"'[',i0,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(10.0/3.0,"'[',g0.5,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(.true.,"'The final answer is [',g0,']'")
!!        write(*,*)'result is ',output
!!
!!     end program demo_fmt
!!
!!   Results:
!!
!!     result is [10]
!!     result is [3.3333]
!!     result is The final answer is [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive function fmt(generic,format) result (line)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

! ident_89="@(#) M_strings fmt(3f) convert any intrinsic to a string using specified format"

class(*),intent(in)                  :: generic
character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: line
character(len=:),allocatable         :: fmt_local
character(len=:),allocatable         :: re,im
integer                              :: iostat
character(len=255)                   :: iomsg
character(len=1),parameter           :: null=char(0)
integer                              :: ilen
logical                              :: trimit
   if(present(format))then
      fmt_local=format
      trimit=.false.
   else
      fmt_local=''
      trimit=.true.
   endif
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local == '')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'

         type is (real(kind=real128));     fmt_local='(1pg0,a)'

         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
      end select
   else
      if(format(1:1) == '(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   iostat=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int16));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int32));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int64));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real32));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real64));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null

      type is (real(kind=real128));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null

      type is (logical);                write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (character(len=*));       write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (complex);
              if(trimit)then
                 re=fmt(generic%re)
                 im=fmt(generic%im)
                 call trimzeros_(re)
                 call trimzeros_(im)
                 fmt_local='("(",g0,",",g0,")",a)'
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) trim(re),trim(im),null
                 trimit=.false.
              else
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
              endif
   end select
   if(iostat /= 0)then
      line='<ERROR>'//trim(iomsg)
   else
      ilen=index(line,null,back=.true.)
      if(ilen == 0)ilen=len(line)
      line=line(:ilen-1)
   endif

   if(index(line,'.') /= 0 .and. trimit) call trimzeros_(line)

end function fmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    find_field(3f) - [M_strings:TOKENS] parse a string into tokens
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine find_field (string, field, position, delims, delim, found)
!!
!!     character*(*),intent(in)           :: string
!!     character*(*),intent(out)          :: field
!!     integer,optional,intent(inout)     :: position
!!     character*(*),optional,intent(in)  :: delims
!!     character*(*),optional,intent(out) :: delim
!!     logical,optional,intent(out)       :: found
!!
!!##DESCRIPTION
!!
!!    Find a delimited field in a string.
!!
!!    Here's my equivalent, which I've used for nearly 2 decades, as you can
!!    see from the date. This doesn't try to mimic the C strtok (and doesn't
!!    have its limitations either). It is in a much more native Fortran style.
!!
!!    It is a little more complicated than some because it does some things
!!    that I regularly find useful. For example, it can tell the caller what
!!    trailing delimiter it found. This can be useful, for example, to
!!    distinguish between
!!
!!        somefield, someotherfield
!!
!!    versus
!!
!!        somefield=somevalue, someotherfield
!!
!!    Also, I have a bit of special handling for blanks. All the usage
!!    information is in the argument descriptions. Note that most of the
!!    arguments are optional.
!!
!!    from comp.lang.fortran @ Richard Maine
!!
!!##OPTIONS
!!    STRING     The string input.
!!
!!    FIELD      The returned field. Blank if no field found.
!!
!!    POSITION   On entry, the starting position for searching for the field.
!!               Default is 1 if the argument is not present.
!!               On exit, the starting position of the next field or
!!               len(string)+1 if there is no following field.
!!
!!    DELIMS     String containing the characters to be accepted as delimiters.
!!               If this includes a blank character, then leading blanks are
!!               removed from the returned field and the end delimiter may
!!               optionally be preceded by blanks. If this argument is
!!               not present, the default delimiter set is a blank.
!!
!!    DELIM      Returns the actual delimiter that terminated the field.
!!               Returns char(0) if the field was terminated by the end of
!!               the string or if no field was found.
!!               If blank is in delimiters and the field was terminated
!!               by one or more blanks, followed by a non-blank delimiter,
!!               the non-blank delimiter is returned.
!!
!!    FOUND      True if a field was found.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!        program demo_find_field
!!        use M_strings, only : find_field
!!        implicit none
!!        character(len=256)           :: string
!!        character(len=256)           :: field
!!        integer                      :: position
!!        character(len=:),allocatable :: delims
!!        character(len=1)             :: delim
!!        logical                      :: found
!!
!!        delims='[,]'
!!        position=1
!!        found=.true.
!!        string='[a,b,[ccc,ddd],and more]'
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,delims,delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">")')trim(field)
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        position=1
!!        found=.true.
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,'[], ',delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">",i0,1x,a)')trim(field),position,delim
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        end program demo_find_field
!!
!! Results:
!!
!!     > [a,b,[ccc,ddd],and more]
!!     > <>
!!     > <a>
!!     > <b>
!!     > <>
!!     > <ccc>
!!     > <ddd>
!!     > <>
!!     > <and more>
!!     > <>
!!     > ==================================================================
!!     > [a,b,[ccc,ddd],and more]
!!     > <>2 [
!!     > <a>4 ,
!!     > <b>6 ,
!!     > <>7 [
!!     > <ccc>11 ,
!!     > <ddd>15 ]
!!     > <>16 ,
!!     > <and>20
!!     > <more>257 ]
!!     > ==================================================================
!!
!!##AUTHOR
!!    Richard Maine
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright Nov 15 1990, Richard Maine
!!
!!    Minor editing to conform to inclusion in the string procedure module
subroutine find_field (string, field, position, delims, delim, found)

!-- Find a delimited field in a string.
!-- 15 Nov 90, Richard Maine.

!-------------------- interface.
character*(*),intent(in)           :: string
character*(*),intent(out)          :: field
integer,optional,intent(inout)     :: position
character*(*),optional,intent(in)  :: delims
character*(*),optional,intent(out) :: delim
logical,optional,intent(out)       :: found
!-------------------- local.
character  :: delimiter*1
integer    :: pos, field_start, field_end, i
logical    :: trim_blanks
!-------------------- executable code.
   field = ''
   delimiter = char(0)
   pos = 1
   if (present(found)) found = .false.
   if (present(position)) pos = position
   if (pos > len(string)) goto 9000
   !if (pos < 1) error stop 'Illegal position in find_field'
   if (pos < 1) stop 'Illegal position in find_field'

   !-- Skip leading blanks if blank is a delimiter.
   field_start = pos
   trim_blanks = .true.
   if (present(delims)) trim_blanks = index(delims,' ') /= 0
   if (trim_blanks) then
      i = verify(string(pos:),' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      field_start = pos + i - 1
   end if
   if (present(found)) found = .true.

   !-- Find the end of the field.
   if (present(delims)) then
      i = scan(string(field_start:), delims)
   else
      i = scan(string(field_start:), ' ')
   end if
   if (i == 0) then
      field_end = len(string)
      delimiter = char(0)
      pos = field_end + 1
   else
      field_end = field_start + i - 2
      delimiter = string(field_end+1:field_end+1)
      pos = field_end + 2
   end if

   !-- Return the field.
   field = string(field_start:field_end)

   !-- Skip trailing blanks if blank is a delimiter.
   if (trim_blanks) then
      i = verify(string(field_end+1:), ' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      pos = field_end + i

      !-- If the first non-blank character is a delimiter,
      !-- skip blanks after it.
      i = 0
      if (present(delims)) i = index(delims, string(pos:pos))
      if (i /= 0) then
         delimiter = string(pos:pos)
         pos = pos + 1
         i = verify(string(pos:), ' ')
         if (i == 0) then
            pos = len(string) + 1
         else
            pos = pos + i - 1
         end if
      end if
   end if
   !---------- Normal exit.
   9000 continue
   if (present(delim)) delim = delimiter
   if (present(position)) position = pos
end subroutine find_field
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split2020(3f) - [M_strings:TOKENS] parse a string into tokens using
!!    proposed f2023 method
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   TOKEN form
!!
!!    subroutine split2020 (string, set, tokens, separator)
!!    character(len=*),intent(in)                       :: string
!!    character(len=*),intent(in)                       :: set
!!    character(len=:),allocatable,intent(out)          :: tokens(:)
!!    character(len=1),allocatable,intent(out),optional :: separator(:)
!!
!!   BOUNDS ARRAY form
!!
!!    subroutine split2020 (string, set, first, last)
!!    character(len=*),intent(in)     :: string
!!    character(len=*),intent(in)     :: set
!!    integer,allocatable,intent(out) :: first(:)
!!    integer,allocatable,intent(out) :: last(:)
!!
!!   STEP THROUGH BY POSITION form
!!
!!    subroutine split2020 (string, set, pos [, back])
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,intent(inout)       :: pos
!!    logical,intent(in),optional :: back
!!
!!##DESCRIPTION
!!    Parse a string into tokens. STRING, SET, TOKENS and SEPARATOR must
!!    all be of the same CHARACTER kind type parameter.
!!
!!##OPTIONS
!!    STRING      string to break into tokens
!!
!!    SET         Each character in SET is a token delimiter. A
!!                sequence of zero or more characters in STRING delimited by
!!                any token delimiter, or the beginning or end of STRING,
!!                comprise a token. Thus, two consecutive token delimiters
!!                in STRING, or a token delimiter in the first or last
!!                character of STRING, indicate a token with zero length.
!!
!!                ??? how about if null defaults to all whitespace characters
!!
!!    TOKENS      It is allocated with the lower bound equal to
!!                one and the upper bound equal to the number of tokens in
!!                STRING, and with character length equal to the length of
!!                the longest token. The tokens in STRING are assigned by
!!                intrinsic assignment, in the order found, to the elements
!!                of TOKENS, in array element order.
!!
!!                ???If input is null it still must be of size 1?
!!
!!    SEPARATOR   Each element in SEPARATOR(i) is assigned the value of
!!                the ith token delimiter in STRING.
!!                It is allocated with the lower bound equal to
!!                one and the upper bound equal to one less than the number
!!                of tokens in STRING, and with character length equal to
!!                one.
!!
!!                ???one less than? '' ' '
!!
!!    FIRST     It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the starting
!!              position of each token in STRING, in the order found. If a
!!              token has zero length, the starting position is equal to one
!!              if the token is at the beginning of STRING, and one greater
!!              than the position of the preceding delimiter otherwise.
!!
!!    LAST      It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the ending
!!              position of each token in STRING, in the order found. If
!!              a token has zero length, the ending position is one less
!!              than the starting position.
!!
!!    POS       If BACK is present with the value .TRUE., the value
!!              of POS shall be in the range 0 < POS     LEN (STRING)+1;
!!              otherwise it shall be in the range 0     POS LEN (STRING).
!!
!!              If BACK is absent or is present with the value .FALSE., POS
!!              is assigned the position of the leftmost token delimiter in
!!              STRING whose position is greater than POS, or if there is
!!              no such character, it is assigned a value one greater than
!!              the length of STRING. This identifies a token with starting
!!              position one greater than the value of POS on invocation,
!!              and ending position one less than the value of POS on return.
!!
!!              If BACK is present with the value true, POS is assigned the
!!              position of the rightmost token delimiter in STRING whose
!!              position is less than POS, or if there is no such character,
!!              it is assigned the value zero. This identifies a token with
!!              ending position one less than the value of POS on invocation,
!!              and starting position one greater than the value of POS
!!              on return.
!!
!!              When SPLIT is invoked with a value for POS of
!!              1 <= POS <= LEN(STRING) and STRING(POS:POS) is not a
!!              token delimiter present in SET, the token identified by
!!              SPLIT does not comprise a complete token as described in the
!!              description of the SET argument, but rather a partial token.
!!
!!    BACK      shall be a logical scalar. It is an INTENT (IN) argument. If
!!              POS does not appear and BACK is present with the value true,
!!              STRING is scanned backwards for tokens starting from the
!!              end. If POS does not appear and BACK is absent or present
!!              with the value false, STRING is scanned forwards for tokens
!!              starting from the beginning.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!    program demo_sort2020
!!    use M_strings, only : split2020
!!    implicit none
!!    character(len=*),parameter :: gen='(*("[",g0,"]":,","))'
!!
!!     ! Execution of TOKEN form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=:), allocatable :: tokens(:)
!!       character (len=*),parameter :: set = " ,"
!!       string = 'first,second,third'
!!       call split2020(string, set, tokens )
!!       write(*,gen)tokens
!!
!!     ! assigns the value ['first ','second','third ' ]
!!     ! to TOKENS.
!!     endblock
!!
!!     ! Execution of BOUNDS form
!!
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer, allocatable        :: first(:), last(:)
!!       string =    'first,second,,forth'
!!       call split2020 (string, set, first, last)
!!       write(*,gen)first
!!       write(*,gen)last
!!
!!     ! will assign the value [ 1, 7, 14, 15 ] to FIRST,
!!     ! and the value [ 5, 12, 13, 19 ] to LAST.
!!     endblock
!!
!!     ! Execution of STEP form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer :: p, ibegin, iend
!!       string = " one,   last  example  "
!!       do while (p < len(string))
!!         ibegin = p + 1
!!         call split2020 (string, set, p)
!!         iend=p-1
!!         if(iend > ibegin)then
!!            print '(t3,a,1x,i0,1x,i0)', string (ibegin:iend),ibegin,iend
!!         endif
!!       enddo
!!     endblock
!!    end program demo_sort2020
!!
!!   Results:
!!
!!    [first ],[second],[third ]
!!    [1],[7],[14],[15]
!!    [5],[12],[13],[19]
!!      one 2 4
!!      last 9 12
!!      example 15 21
!!
!!      > ??? option to skip adjacent delimiters (not return null tokens)
!!      >     common with whitespace
!!      > ??? quoted strings, especially CSV both " and ', Fortran adjacent
!!      >     is insert versus other rules
!!      > ??? escape character like \\ .
!!      > ??? multi-character delimiters like \\n, \\t,
!!      > ??? regular expression separator
!!
!!##AUTHOR
!!    Milan Curcic, "milancurcic@hey.com"
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright 2020, Milan Curcic
  pure subroutine split_tokens(string, set, tokens, separator)
     ! Splits a string into tokens using characters in set as token delimiters.
     ! If present, separator contains the array of token delimiters.
    character(*), intent(in)                      :: string
    character(*), intent(in)                      :: set
    character(:), allocatable, intent(out)        :: tokens(:)
    character, allocatable, intent(out), optional :: separator(:)

    integer, allocatable                          :: first(:), last(:)
    integer                                       :: n

    call split2020(string, set, first, last)
    allocate(character(len=maxval(last - first) + 1) :: tokens(size(first)))

    do concurrent (n = 1:size(tokens))
      tokens(n) = string(first(n):last(n))
    enddo

    if (present(separator)) then
      allocate(separator(size(tokens) - 1))
      do concurrent (n = 1:size(tokens) - 1)
        separator(n) = string(first(n+1)-1:first(n+1)-1)
      enddo
    endif

  end subroutine split_tokens
!===================================================================================================================================
  pure subroutine split_first_last(string, set, first, last)
     ! Computes the first and last indices of tokens in input string, delimited
     ! by the characters in set, and stores them into first and last output
     ! arrays.
    character(*), intent(in)          :: string
    character(*), intent(in)          :: set
    integer, allocatable, intent(out) :: first(:)
    integer, allocatable, intent(out) :: last(:)

    character                         :: set_array(len(set))
    logical, dimension(len(string))   :: is_first, is_last, is_separator
    integer                           :: n, slen

    slen = len(string)

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    do concurrent (n = 1:slen)
      is_separator(n) = any(string(n:n) == set_array)
    enddo

    is_first = .false.
    is_last = .false.

    if (.not. is_separator(1)) is_first(1) = .true.

    do concurrent (n = 2:slen-1)
      if (.not. is_separator(n)) then
        if (is_separator(n - 1)) is_first(n) = .true.
        if (is_separator(n + 1)) is_last(n) = .true.
      else
        if (is_separator(n - 1)) then
          is_first(n) = .true.
          is_last(n-1) = .true.
        endif
      endif
    enddo

    if (.not. is_separator(slen)) is_last(slen) = .true.

    first = pack([(n, n = 1, slen)], is_first)
    last = pack([(n, n = 1, slen)], is_last)

  end subroutine split_first_last
!===================================================================================================================================
  pure subroutine split_pos(string, set, pos, back)
     ! If back is absent, computes the leftmost token delimiter in string whose
     ! position is > pos. If back is present and true, computes the rightmost
     ! token delimiter in string whose position is < pos. The result is stored
     ! in pos.
    character(*), intent(in)      :: string
    character(*), intent(in)      :: set
    integer, intent(in out)       :: pos
    logical, intent(in), optional :: back

    logical                       :: backward
    character                     :: set_array(len(set))
    integer                       :: n, result_pos

    !TODO use optval when implemented in stdlib
    !backward = optval(back, .false.)
    backward = .false.
    if (present(back)) backward = back

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    if (backward) then
      result_pos = 0
      do n = pos - 1, 1, -1
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    else
      result_pos = len(string) + 1
      do n = pos + 1, len(string)
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    endif

    pos = result_pos

  end subroutine split_pos
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
  pure function string_tokens(string, set) result(tokens)
     ! Splits a string into tokens using characters in set as token delimiters.
    character(*), intent(in)  :: string
    character(*), intent(in)  :: set
    character(:), allocatable :: tokens(:)
    call split_tokens(string, set, tokens)
  end function string_tokens
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! Duplicate the M_journal module in condensed form for now so can be stand-alone on GITHUB
!                                                                     ll
!                                                                      l
!    j                                                                 l
!                                                                      l
!    j                                                                 l
!    j        oooooo    u      u   r rrrrrr   n nnnnn      aaaa        l
!    j       o      o   u      u   rr         nn     n         a       l
!    j       o      o   u      u   r          n      n    aaaaaa       l
! j  j       o      o   u      u   r          n      n   a     a       l
!  jj         oooooo     uuuuuu u  r          n      n    aaaaa a      l
!
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! @(#) place-holder for journal module
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

!@(#) M_journal::where_write_message(3fp): basic message routine used for journal files

character(len=*),intent(in)       :: where
character(len=*),intent(in)       :: msg
logical,save                      :: trailopen=.false.
integer,save                      :: itrail
character,save                    :: comment='#'
integer                           :: i
integer                           :: iostat
integer                           :: times             ! number of times written to stdout
character(len=3)                  :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable      :: prefix            ! the prefix string to add to output
logical,save                      :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)               :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   prefix=''
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
          !elseif(times == 0)then
          !   write(stdout,'(a)',advance=adv)prefix//trim(msg)
          !   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=iostat)
            open(unit=last_int,file=clip(msg),iostat=iostat)
            if(iostat == 0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',iostat
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=iostat)
            stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
             ! write(stdout,'(2a)',advance=adv)prefix,trim(msg)
             ! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=iostat,iomsg=mssge)
         if(iostat /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=clip(msg),&
            & form='formatted',iostat=iostat,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=clip(msg),form='formatted',iostat=iostat)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=iostat)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()
call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

!$(#) M_journal::write_message_only(3fp): calls JOURNAL('sc',message)

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     matching_delimiter(3f) - [M_strings:QUOTES] find position of matching delimiter
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   impure elemental subroutine matching_delimiter(str,ipos,imatch)
!!
!!    character(len=*),intent(in)  :: str
!!    integer,intent(in)           :: ipos
!!    integer,intent(out)          :: imatch
!!
!!##DESCRIPTION
!!    Sets imatch to the position in string of the delimiter matching the
!!    delimiter in position ipos. Allowable delimiters are (), [], {}, <>.
!!
!!##OPTIONS
!!    str     input string to locate delimiter position in
!!    ipos    position of delimiter to find match for
!!    imatch  location of matching delimiter. If no match is found, zero (0)
!!            is returned.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_matching_delimiter
!!       use M_strings, only : matching_delimiter
!!       implicit none
!!       character(len=128)  :: str
!!       integer             :: imatch
!!
!!       str=' a [[[[b] and ] then ] finally ]'
!!       write(*,*)'string=',str
!!       call matching_delimiter(str,1,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,4,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,5,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,6,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,7,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,32,imatch)
!!       write(*,*)'location=',imatch
!!
!!    end program demo_matching_delimiter
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
impure elemental subroutine matching_delimiter(str,ipos,imatch)

! Sets imatch to the position in string of the delimiter matching the delimiter
! in position ipos. Allowable delimiters are (), [], {}, <>.

! pedigree?

character(len=*),intent(in) :: str
integer,intent(in)          :: ipos
integer,intent(out)         :: imatch

character                   :: delim1,delim2,ch
integer                     :: lenstr
integer                     :: idelim2
integer                     :: ibegin, iend
integer                     :: inc
integer                     :: isum
integer                     :: i

imatch=0
lenstr=len_trim(str)
delim1=str(ipos:ipos)
select case(delim1)
   case('(')
      idelim2=iachar(delim1)+1
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(')')
      idelim2=iachar(delim1)-1
      ibegin=ipos-1
      iend=1
      inc=-1
   case('[','{','<')
      idelim2=iachar(delim1)+2
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(']','}','>')
      idelim2=iachar(delim1)-2
      ibegin=ipos-1
      iend=1
      inc=-1
   case default
      write(stderr,*) '*matching_delimiter*',delim1,' is not a valid delimiter'
      return
end select
if(ibegin < 1 .or. ibegin > lenstr) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
delim2=achar(idelim2) ! matching delimiter

isum=1
do i=ibegin,iend,inc
   ch=str(i:i)
   if(ch /= delim1 .and. ch /= delim2) cycle
   if(ch == delim1) isum=isum+1
   if(ch == delim2) isum=isum-1
   if(isum == 0) exit
enddo
if(isum /= 0) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
imatch=i

end subroutine matching_delimiter
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_common_substring(3f) - [M_strings:COMPARE] function that
!!    returns the longest common substring of two strings.
!!##SYNOPSIS
!!
!!    function longest_common_substring(a,b) result(match)
!!
!!     character(len=*),intent(in)  :: a, b
!!     character(len=:),allocatable :: match
!!##DESCRIPTION
!!    function that returns the longest common substring of two strings.
!!
!!    Note that substrings are consecutive characters within a string.
!!    This distinguishes them from subsequences, which is any sequence of
!!    characters within a string, even if there are extraneous characters in
!!    between them.
!!
!!    Hence, the longest common subsequence between "thisisatest" and
!!    "testing123testing" is "tsitest", whereas the longest common substring
!!    is just "test".
!!##OPTIONS
!!    a,b  strings to search for the longest common substring.
!!##RETURNS
!!    longest_common_substring  the longest common substring found
!!##EXAMPLES
!!
!!  Sample program
!!
!!    program demo_longest_common_substring
!!    use M_strings, only : longest_common_substring
!!    implicit none
!!      call compare('testing123testingthing','thisis',             'thi')
!!      call compare('testing',             'sting',              'sting')
!!      call compare('thisisatest_stinger','testing123testingthing','sting')
!!      call compare('thisisatest_stinger', 'thisis',            'thisis')
!!      call compare('thisisatest',         'testing123testing',   'test')
!!      call compare('thisisatest',      'thisisatest',     'thisisatest')
!!    contains
!!
!!    subroutine compare(a,b,answer)
!!    character(len=*),intent(in) :: a, b, answer
!!    character(len=:),allocatable :: match
!!    character(len=*),parameter :: g='(*(g0))'
!!       match=longest_common_substring(a,b)
!!       write(*,g) 'comparing "',a,'" and "',b,'"'
!!       write(*,g) merge('(PASSED) "','(FAILED) "',answer == match), &
!!       & match,'"; expected "',answer,'"'
!!    end subroutine compare
!!
!!    end program demo_longest_common_substring
!!
!!   expected output
!!
!!    comparing "testing123testingthing" and "thisis"
!!    (PASSED) "thi"; expected "thi"
!!    comparing "testing" and "sting"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "testing123testingthing"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "thisis"
!!    (PASSED) "thisis"; expected "thisis"
!!    comparing "thisisatest" and "testing123testing"
!!    (PASSED) "test"; expected "test"
!!    comparing "thisisatest" and "thisisatest"
!!    (PASSED) "thisisatest"; expected "thisisatest"
function longest_common_substring(a,b) result(match)
character(len=*),intent(in)  :: a, b
character(len=:),allocatable :: match
character(len=:),allocatable :: a2, b2
integer                      :: left, foundat, len_a, i
   if(len(a) < len(b))then ! to reduce required comparisions look for shortest string in longest string
      a2=a
      b2=b
   else
      a2=b
      b2=a
   endif

   match=''

   do i=1,len(a2)-1
      len_a=len(a2)
      do left=1,len_a
         foundat=index(b2,a2(left:))
         if(foundat /= 0.and.len(match) < len_a-left+1)then
            if(len(a2(left:)) > len(match))then
               match=a2(left:)
               exit
            endif
         endif
      enddo

      if(len(a2) < len(match))exit
      a2=a2(:len(a2)-1)

   enddo

end function longest_common_substring
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

pure elemental function atoi (string) result(val)    ! Convert STRING to an integer value
integer(kind=int32) :: val
character(len=*), intent(in) :: string
character(len=1)            :: c
integer                     :: i
integer                     :: j
integer                     :: ilen
logical                     :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atoi

pure elemental function atol (string) result(val)    ! Convert STRING to an integer value
integer(kind=int64) :: val
character(len=*), intent(in) :: string
character(len=1)            :: c
integer                     :: i
integer                     :: j
integer                     :: ilen
logical                     :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atol
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    aton(3f) - [M_strings:TYPE] function returns argument as a numeric
!!    value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function aton(str,val[,msg])
!!
!!     character(len=*),intent(in)              :: str
!!     type(TYPE(kind=KIND)),intent(out)        :: val
!!     character(len=:),allocatable,intent(out) :: msg
!!
!!##DESCRIPTION
!!    This function converts a string to a numeric value.
!!
!!##OPTIONS
!!
!!     str      holds string assumed to represent a numeric value
!!     val      returned value. May be REAL or INTEGER.
!!     msg      message describing error when ATON returns .false.
!!
!!##RETURNS
!!     aton     .true. if the conversion was successful, .false. otherwise
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_aton
!!
!!       use M_strings, only: aton
!!       implicit none
!!       character(len=14),allocatable :: strings(:)
!!       doubleprecision               :: dv
!!       integer                       :: iv
!!       real                          :: rv
!!       integer                       :: i
!!
!!       ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!       strings=[&
!!       &' 10.345       ',&
!!       &'+10           ',&
!!       &'    -3        ',&
!!       &'    -4.94e-2  ',&
!!       &'0.1           ',&
!!       &'12345.678910d0',&
!!       &'              ',& ! Note: will return zero without an error message
!!       &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!       &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!       do i=1,size(strings)
!!          write(*,'(a)',advance='no')'STRING:',strings(i)
!!          if(aton(strings(i),iv)) write(*,'(g0)',advance='no')':INTEGER ',iv
!!          if(aton(strings(i),rv)) write(*,'(g0)',advance='no')':INTEGER ',rv
!!          if(aton(strings(i),dv)) write(*,'(g0)',advance='no')':INTEGER ',dv
!!       enddo
!!
!!       end program demo_aton
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
logical function ator_real32(str,val,msg)
use iso_fortran_env, only: wp => real32, ip => int64, int8
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=int8)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=int8)            :: a, part
integer                       :: i, ipos, iostat, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real32 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real32 = .true.
   else
      read(str,fmt=*,iostat=iostat) val ! use internal read for INF, NAN for now
      if(iostat == 0)then
         ator_real32 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real32 = .false.
      endif
   endif
end function ator_real32
logical function ator_real64(str,val,msg)
use iso_fortran_env, only: wp => real64, ip => int64, int8
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=int8),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=int8),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=int8)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=int8)            :: a, part
integer                       :: i, ipos, iostat, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real64 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real64 = .true.
   else
      read(str,fmt=*,iostat=iostat) val ! use internal read for INF, NAN for now
      if(iostat == 0)then
         ator_real64 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real64 = .false.
      endif
   endif
end function ator_real64
logical function atoi_int8(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int8)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=int8)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int8 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int8 = .false.
   endif
end function atoi_int8
logical function atoi_int16(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int16)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=int8)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int16 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int16 = .false.
   endif
end function atoi_int16
logical function atoi_int32(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int32)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=int8)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int32 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int32 = .false.
   endif
end function atoi_int32
logical function atoi_int64(str,val,msg)
use iso_fortran_env, only: ip => int64, int8
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int64)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=int8),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=int8),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=int8)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=int8)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int64 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int64 = .false.
   endif
end function atoi_int64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_strings


!>>>>> build/dependencies/M_list/src/M_list.f90

!>
!!##NAME
!!    M_list(3f) - [M_list::INTRO] maintain simple lists
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    use M_list, only : insert, replace, remove, locate
!!    use M_list, only : dictionary
!!
!!##DESCRIPTION
!!
!!    The M_list(3fm) module allows for maintaining an allocatable array of
!!    intrinsic type (REAL, INTEGER, CHARACTER) as a sorted list. An example
!!    is given that creates a keyword-value dictionary using the lists.
!!
!!    The lists are maintained as simple allocatable arrays. Each time an
!!    entry is added or deleted the array is re-allocated. Because of the
!!    expense of reallocating the data these routines are best suited for
!!    maintaining small lists that do not change size frequently.
!!
!!    The advantage of this simplistic approach is that the dictionary
!!    components are simple arrays of intrinsic types which can be easily
!!    accessed with standard routines. It is easy to understand, as it
!!    works with simple arrays. For more demanding applications this would
!!    be implemented as a linked list, which there are a number of freely
!!    available examples of; several are listed on the Fortran Wiki.
!!
!!    BASIC LIST
!!
!!    subroutine locate(list,value,place,ier,errmsg)  finds the index where a
!!                                                    value is found or should
!!                                                    be in a sorted array and
!!                                                    flag if the value exists
!!                                                    already
!!    subroutine insert(list,value,place)     insert entry into an allocatable
!!                                            array at specified position
!!    subroutine replace(list,value,place)    replace entry in an allocatable
!!                                            array at specified position
!!    subroutine remove(list,place)           remove entry from an allocatable
!!                                            array at specified position
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_M_list
!!    use M_list, only : insert, locate, replace, remove
!!    ! create a dictionary with character keywords, values, and value lengths
!!    ! using the routines for maintaining a list
!!
!!     use M_list, only : locate, insert, replace
!!     implicit none
!!     character(len=:),allocatable   :: keywords(:)
!!     character(len=:),allocatable   :: values(:)
!!     integer,allocatable            :: counts(:)
!!     integer                        :: i
!!     ! insert and replace entries
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>","[",a,"]",/))')&
!!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! remove some entries
!!     call update('a')
!!     call update('c')
!!     write(*,'(*(a,"==>","[",a,"]",/))')&
!!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! get some values
!!     write(*,*)'get b=>',get('b')
!!     write(*,*)'get d=>',get('d')
!!     write(*,*)'get notthere=>',get('notthere')
!!     !
!!     contains
!!     subroutine update(key,valin)
!!     character(len=*),intent(in)           :: key
!!     character(len=*),intent(in),optional  :: valin
!!     integer                               :: place
!!     integer                               :: ilen
!!     character(len=:),allocatable          :: val
!!     if(present(valin))then
!!        val=valin
!!        ilen=len_trim(val)
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        ! if string was not found insert it
!!        if(place.lt.1)then
!!           call insert(keywords,key,iabs(place))
!!           call insert(values,val,iabs(place))
!!           call insert(counts,ilen,iabs(place))
!!        else
!!           call replace(values,val,place)
!!           call replace(counts,ilen,place)
!!        endif
!!     else
!!        call locate(keywords,key,place)
!!        if(place.gt.0)then
!!           call remove(keywords,place)
!!           call remove(values,place)
!!           call remove(counts,place)
!!        endif
!!     endif
!!     end subroutine update
!!     function get(key) result(valout)
!!     character(len=*),intent(in)   :: key
!!     character(len=:),allocatable  :: valout
!!     integer                       :: place
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        if(place.lt.1)then
!!           valout=''
!!        else
!!           valout=values(place)(:counts(place))
!!        endif
!!     end function get
!!     end program demo_M_list
!!
!!   Results
!!
!!       >  d==>[value of d]
!!       >  c==>[value of c again]
!!       >  b==>[value of b]
!!       >  a==>[value of a again]
!!       >
!!       > d==>[value of d]
!!       > b==>[value of b]
!!       >
!!       >  get b=>value of b
!!       >  get d=>value of d
!!       >  get notthere=>
!!
!!
!!    BASIC DICTIONARY
!!
!!    A basic dictionary that uses the basic M_list functions.
!!
!!    Consider using generic linked-list based dictionaries when heavy
!!    usage is required, now that that is available in more recent versions
!!    of Fortran.
!!
!!    Note: this does not work with gfortran(1) up to at least 7.4.0 but
!!    works from at least 10.3.0 and onward.
!!
!!    Dictionary type definition:
!!
!!       type dictionary
!!          character(len=:),allocatable :: key(:)
!!          character(len=:),allocatable :: value(:)
!!          integer,allocatable          :: count(:)
!!          contains
!!             procedure,public :: get => dict_get
!!             procedure,public :: set => dict_add
!!             procedure,public :: del => dict_delete
!!             procedure,public :: clr => dict_clear
!!       end type dictionary
!!
!!       %get      get value from type(dictionary) given an existing key
!!       %set      set or replace value for type(dictionary) given a key
!!       %del      delete an existing key from type(dictionary)
!!       %clr      empty a type(dictionary)
!!       %ifdef    test if name is defined
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!       program test_dictionary
!!       use M_list, only : dictionary
!!       implicit none
!!       type(dictionary)             :: table
!!         !
!!         ! create a character string dictionary
!!         !
!!         call table%set('A','aye')
!!         call table%set('B','bee')
!!         call table%set('C','see')
!!         call table%set('D','dee')
!!         !
!!         write(*,*)'A=',table%get('A')
!!         write(*,*)'C=',table%get('C')
!!         write(*,*)'notthere=',table%get('notthere')
!!         !
!!         call print_dict()
!!         !
!!         ! delete dictionary entries
!!         !
!!         call  table%del('A')
!!         call  table%del('C')
!!         call  table%del('z') ! a noop as there is no key of 'z'
!!         !
!!         call print_dict()
!!         !
!!         ! clear dictionary
!!         !
!!         call  table%clr()
!!         !
!!         call print_dict()
!!       !
!!       contains
!!       !
!!       subroutine print_dict()
!!       integer :: i
!!          ! the dictionary is just three arrays
!!          write(*,'("DICTIONARY:")')
!!          write(*,'(*(a,"==>","[",a,"]",/))') &
!!          & (trim(table%key(i)),               &
!!          & table%value(i)(:table%count(i)),    &
!!          & i=1,size(table%key))
!!          !
!!       end subroutine print_dict
!!       !
!!       end program test_dictionary
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module M_list
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdout=>OUTPUT_UNIT    ! access computing environment
implicit none
private

public locate        ! [M_list] find PLACE in sorted character array where value can be found or should be placed
   private locate_c
   private locate_d
   private locate_r
   private locate_i
public insert        ! [M_list] insert entry into a sorted allocatable array at specified position
   private insert_c
   private insert_d
   private insert_r
   private insert_i
   private insert_l
public replace       ! [M_list] replace entry by index from a sorted allocatable array if it is present
   private replace_c
   private replace_d
   private replace_r
   private replace_i
   private replace_l
public remove        ! [M_list] delete entry by index from a sorted allocatable array if it is present
   private remove_c
   private remove_d
   private remove_r
   private remove_i
   private remove_l

! ident_1="@(#) M_list locate(3f) Generic subroutine locates where element is or should be in sorted allocatable array"
interface locate
   module procedure locate_c, locate_d, locate_r, locate_i
end interface

! ident_2="@(#) M_list insert(3f) Generic subroutine inserts element into allocatable array at specified position"
interface insert
   module procedure insert_c, insert_d, insert_r, insert_i, insert_l
end interface

! ident_3="@(#) M_list replace(3f) Generic subroutine replaces element from allocatable array at specified position"
interface replace
   module procedure replace_c, replace_d, replace_r, replace_i, replace_l
end interface

! ident_4="@(#) M_list remove(3f) Generic subroutine deletes element from allocatable array at specified position"
interface remove
   module procedure remove_c, remove_d, remove_r, remove_i, remove_l
end interface

!-----------------------------------------------------------------------------------------------------------------------------------
public dictionary

type dictionary
   character(len=:),allocatable :: key(:)
   character(len=:),allocatable :: value(:)
   integer,allocatable          :: count(:)
   contains
      procedure,public :: get   => dict_get    ! get value associated with a key in a dictionary or return blank
      procedure,public :: set   => dict_add    ! insert or replace entry by name into a dictionary
      procedure,public :: del   => dict_delete ! delete entry by name from a dictionary if entry is present
      procedure,public :: clr   => dict_clear  ! clear dictionary
      procedure,public :: ifdef => dict_ifdef  ! return if defined or not
end type dictionary

logical,save :: debug=.false.
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    locate(3f) - [M_list] finds the index where a string is found or
!!                 should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!   Find if a string is in a sorted array, and insert the string into
!!   the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end.eq.0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus.eq.1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus.eq.end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update
!!     end program demo_locate
!!
!!   Results
!!
!!       >  for "b" index is            2           5
!!       >  for "[" index is           -4           5
!!       > SIZE=5 xxx,b,aaa,[,ZZZ,
!!       >  for "c" index is           -2           6
!!       > SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!       >  for "ZZ" index is           -7           7
!!       > SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!       >  for "ZZZZ" index is           -6           8
!!       > SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!       >  for "z" index is           -1           9
!!       > SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

! ident_5="@(#) M_list locate_c(3f) find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_c* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',trim(value)//' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_c* END PLACE=',place,' ARRAYSIZE=',size(list),' LENGTH=',len(list)
end subroutine locate_c
subroutine locate_d(list,value,place,ier,errmsg)

! ident_6="@(#) M_list locate_d(3f) find PLACE in sorted doubleprecision array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

doubleprecision,allocatable            :: list(:)
doubleprecision,intent(in)             :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   message=''
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_d* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_d* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_d
subroutine locate_r(list,value,place,ier,errmsg)

! ident_7="@(#) M_list locate_r(3f) find PLACE in sorted real array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

real,allocatable                       :: list(:)
real,intent(in)                        :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[real :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_r* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_r* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_r
subroutine locate_i(list,value,place,ier,errmsg)

! ident_8="@(#) M_list locate_i(3f) find PLACE in sorted integer array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

integer,allocatable                    :: list(:)
integer,intent(in)                     :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_i* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_i* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove(3f) - [M_list] remove entry from an allocatable array at
!!                 specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate, remove
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '','ZZZ','Z','aaa','b','b','ab','bb','xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results
!!
!!       > SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!       > SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!       > SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

! ident_9="@(#) M_list remove_c(3fp) remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(debug) write(stderr,*)'*remove_c* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_c* END PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine remove_c
subroutine remove_d(list,place)

! ident_10="@(#) M_list remove_d(3fp) remove doubleprecision value from allocatable array at specified position"

doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*remove_d* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_d* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_d
subroutine remove_r(list,place)

! ident_11="@(#) M_list remove_r(3fp) remove value from allocatable array at specified position"

real,allocatable    :: list(:)
integer,intent(in)  :: place
integer             :: end
   if(debug) write(stderr,*)'*remove_r* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_r* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_r
subroutine remove_l(list,place)

! ident_12="@(#) M_list remove_l(3fp) remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_l* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_l* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_l
subroutine remove_i(list,place)

! ident_13="@(#) M_list remove_i(3fp) remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_i* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_i* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_list] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out)          :: PLACE
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless
!!    the array needs the string length to increase this is merely an assign
!!    of a value to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!    It is assumed to be sorted in descending order without duplicate
!!    values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!   Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_list, only  : insert, locate, replace
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')&
!!            &(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate(keywords,'a',place)
!!     if(place.gt.0)then
!!        write(*,*)'The value of "a" is ',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate(keywords,key,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(keywords,key,abs(place))
!!        call insert(values,val,abs(place))
!!     else ! replace
!!        call replace(values,val,place)
!!     endif
!!
!!     end subroutine update
!!    end program demo_replace
!!
!!   Results
!!
!!    > d==>value of d
!!    > c==>value of c again
!!    > b==>value of b
!!    > a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

! ident_14="@(#) M_list replace_c(3fp) replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(debug) write(stderr,*)'*replace_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place.lt.0.or.place.gt.end)then
           write(stderr,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value).le.len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
   if(debug)write(stderr,*)'*replace_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine replace_c
subroutine replace_d(list,value,place)

! ident_15="@(#) M_list replace_d(3fp) place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)   :: value
doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*replace_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_d* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_d
subroutine replace_r(list,value,place)

! ident_16="@(#) M_list replace_r(3fp) place value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(debug) write(stderr,*)'*replace_r* START REPLACE_R VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_r* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_r* END REPLACE_R VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_r
subroutine replace_l(list,value,place)

! ident_17="@(#) M_list replace_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_l* START REPLACE_L VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_l* END REPLACE_L VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_l
subroutine replace_i(list,value,place)

! ident_18="@(#) M_list replace_i(3fp) place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert(3f) - [M_list] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!   Find if a string is in a sorted array, and insert the string into
!!   the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate, insert
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update
!!     end program demo_insert
!!
!!   Results
!!
!!        > array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!        > array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!        > array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!        > array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!        > array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!        > array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

! ident_19="@(#) M_list insert_c(3fp) place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end
   if(debug) write(stderr,*)'*insert_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)
   !call slower()
   call faster(ii)
   if(debug)write(stderr,*)'*insert_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list)
contains

subroutine slower()
character(len=:),allocatable :: kludge(:)
   if(end.eq.0)then                                          ! empty array
      list=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place.gt.end)then                                  ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif
end subroutine slower

subroutine faster(ilen)
integer,intent(in) :: ilen
character(len=:),allocatable :: temp(:)
   allocate(character(len=ilen) :: temp(size(list)+1))
   if(end.eq.0)then                                          ! empty array
      temp(:)=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      temp(1)=value
      temp(2:)=list
   elseif(place.gt.end)then                                  ! put at end of array
      temp(1:end)=list
      temp(end+1)=value
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      temp(:place-1)=list(:place-1)
      temp(place)=value
      temp(place+1:)=list(place:)
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif
   call move_alloc (from=temp, to=list)
end subroutine faster

end subroutine insert_c
subroutine insert_r(list,value,place)

! ident_20="@(#) M_list insert_r(3fp) place real value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end

   if(debug) write(stderr,*)'*insert_r* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif

   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_r* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_r* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_r
subroutine insert_d(list,value,place)

! ident_21="@(#) M_list insert_d(3fp) place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)       :: value
doubleprecision,allocatable      :: list(:)
integer,intent(in)               :: place
integer                          :: end
   if(debug) write(stderr,*)'*insert_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_d* error: index out of range. end=',end,' index=',place,' value=',value
   endif
   if(debug)write(stderr,*)'*insert_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_d
subroutine insert_l(list,value,place)

! ident_22="@(#) M_list insert_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_l* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_l* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_l
subroutine insert_i(list,value,place)

! ident_23="@(#) M_list insert_i(3fp) place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    del(3f) - [M_list::dictionary::OOPS] delete entry by key name from
!!              a basic dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!
!!    dict%del(key)
!!
!!##DESCRIPTION
!!
!!    Delete an entry from a basic dictionary if it is present.
!!
!!##OPTIONS
!!
!!    DICT   the dictionary.
!!    KEY    the key name to find and delete from the dictionary.
!!
!!##EXAMPLES
!!
!!   Delete an entry from a dictionary by key name.
!!
!!     program demo_del
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: caps
!!     integer                       :: i
!!        ! create a character string dictionary
!!        call caps%set('A','aye')
!!        call caps%set('B','bee')
!!        call caps%set('C','see')
!!        call caps%set('D','dee')
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!        ! delete dictionary entries
!!        call  caps%del('A')
!!        call  caps%del('C')
!!        call  caps%del('z') ! a noop as there is no key of 'z'
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!
!!     101 format (1x,*(a,"='",a,"'",:,","))
!!     end program demo_del
!!
!!   Results
!!
!!        > D='dee',C='see',B='bee',A='aye'
!!        > D='dee',B='bee'
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_delete(self,key)

! ident_24="@(#) M_list dict_delete(3f) remove string from sorted allocatable string array if present"

class(dictionary),intent(in) :: self
character(len=*),intent(in)  :: key
integer                      :: place

   call locate(self%key,key,place)
   if(place.ge.1)then
      call remove(self%key,place)
      call remove(self%value,place)
      call remove(self%count,place)
   endif

end subroutine dict_delete
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    get(3f) - [M_list::dictionary::OOPS] get value of key-value pair in
!!              a dictionary given key
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!    value=dict%get(key)
!!
!!
!!##DESCRIPTION
!!
!!    get a value given a key from a key-value dictionary
!!
!!    If key is not found in dictionary , return a blank
!!
!!##OPTIONS
!!
!!    DICT     is the dictionary.
!!    KEY      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_get
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary)             :: table
!!     character(len=:),allocatable :: val
!!     integer                      :: i
!!
!!        call table%set('A','value for A')
!!        call table%set('B','value for B')
!!        call table%set('C','value for C')
!!        call table%set('D','value for D')
!!        call table%set('E','value for E')
!!        call table%set('F','value for F')
!!        call table%set('G','value for G')
!!
!!        write(*,*)'A=',table%get('A')
!!        write(*,*)'B=',table%get('B')
!!        write(*,*)'C=',table%get('C')
!!        write(*,*)'D=',table%get('D')
!!        write(*,*)'E=',table%get('E')
!!        write(*,*)'F=',table%get('F')
!!        write(*,*)'G=',table%get('G')
!!        write(*,*)'H=',table%get('H')
!!
!!      end program demo_get
!!
!!   Results
!!
!!       >  A=value for A
!!       >  B=value for B
!!       >  C=value for C
!!       >  D=value for D
!!       >  E=value for E
!!       >  F=value for F
!!       >  G=value for G
!!       >  H=
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function dict_get(self,key) result(value)

! ident_25="@(#) M_list dict_get(3f) get value of key-value pair in dictionary given key"

class(dictionary),intent(in)    :: self
character(len=*),intent(in)     :: key
character(len=:),allocatable    :: value
integer                         :: place
   call locate(self%key,key,place)
   if(place.lt.1)then
      value=''
   else
      value=self%value(place)(:self%count(place))
   endif
end function dict_get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    set(3f) - [M_list::dictionary::OOPS] add or replace a key-value pair
!!              in a dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!    call dict%rep(key,value)
!!
!!##DESCRIPTION
!!    Add or replace a key-value pair in a dictionary.
!!
!!##OPTIONS
!!    DICT     is the dictionary.
!!    key      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!   Add or replace a key and value pair in a dictionary
!!
!!     program demo_set
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: dict
!!     integer          :: i
!!
!!         call dict%set('A','b')
!!         call dict%set('B','^')
!!         call dict%set('C',' ')
!!         call dict%set('D','c')
!!         call dict%set('E','ZZ')
!!         call dict%set('F','ZZZZ')
!!         call dict%set('G','z')
!!         call dict%set('A','new value for A')
!!
!!         write(*,'(*(a,"==>","[",a,"]",/))') &
!!          & (trim(dict%key(i)),              &
!!          & dict%value(i)(:dict%count(i)),   &
!!          & i=1,size(dict%key))
!!
!!      end program demo_set
!!
!!   Results
!!
!!       > G==>[z]
!!       > F==>[ZZZZ]
!!       > E==>[ZZ]
!!       > D==>[c]
!!       > C==>[]
!!       > B==>[^]
!!       > A==>[new value for A]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_add(self,key,value)

! ident_26="@(#) M_list dict_add(3f) place key-value pair into dictionary adding the key if required"

class(dictionary),intent(inout) :: self
character(len=*),intent(in)     :: key
character(len=*),intent(in)     :: value
integer                         :: place
integer                         :: place2
   call locate(self%key,key,place)
   if(place.le.0)then
      place2=iabs(place)
      call insert( self%key,   key,             place2 )
      call insert( self%value, value,           place2 )
      call insert( self%count, len_trim(value), place2 )
   elseif(place.gt.0)then  ! replace instead of insert
      call replace( self%value, value,           place )
      call replace( self%count, len_trim(value), place )
   endif
end subroutine dict_add
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    clr(3f) - [M_list::dictionary::OOPS] clear basic dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    call dict%clr()
!!
!!##DESCRIPTION
!!
!!    clear a basic dictionary.
!!
!!##OPTIONS
!!
!!    DICT   the dictionary.
!!
!!##EXAMPLES
!!
!!   create and clear a basic dictionary
!!
!!     program demo_clr
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: caps
!!     integer                       :: i
!!        ! create a character string dictionary
!!        call caps%set('A','aye')
!!        call caps%set('B','bee')
!!        call caps%set('C','see')
!!        call caps%set('D','dee')
!!        ! show current dictionary
!!        write(*,'("DICTIONARY BEFORE CLEARED")')
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!        call  caps%clr()
!!        write(*,'("DICTIONARY AFTER CLEARED")')
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!
!!     101 format (1x,*(a,"='",a,"'",:,","))
!!     end program demo_clr
!!
!!   Results
!!
!!       > DICTIONARY BEFORE CLEARED
!!       >  D='dee',C='see',B='bee',A='aye'
!!       > DICTIONARY AFTER CLEARED
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_clear(self)

! ident_27="@(#) M_list dict_clear(3f) clear basic dictionary"

class(dictionary),intent(inout) :: self
integer                         :: i

   do i=size(self%key),1,-1
      call self%del(self%key(i))
   enddo

end subroutine dict_clear
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    ifdef(3f) - [M_list::dictionary::OOPS] return whether name is present
!!                in dictionary or not
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    logical :: value
!!
!!    value=dict%ifdef(key)
!!
!!
!!##DESCRIPTION
!!
!!    determine if name is already defined in dictionary or not
!!
!!##OPTIONS
!!
!!    DICT     is the dictionary.
!!    KEY      key name
!!
!!##RETURNS
!!    VALUE    .FALSE. if name not defined, .TRUE if name is defined.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_ifdef
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary)             :: table
!!     character(len=:),allocatable :: val
!!     integer                      :: i
!!
!!        call table%set('A','value for A')
!!        call table%set('B','value for B')
!!        call table%set('C','value for C')
!!        call table%set('D','value for D')
!!        call table%set('E','value for E')
!!        call table%set('F','value for F')
!!        call table%set('G','value for G')
!!        call table%del('F')
!!        call table%del('D')
!!
!!        write(*,*)'A=',table%ifdef('A')
!!        write(*,*)'B=',table%ifdef('B')
!!        write(*,*)'C=',table%ifdef('C')
!!        write(*,*)'D=',table%ifdef('D')
!!        write(*,*)'E=',table%ifdef('E')
!!        write(*,*)'F=',table%ifdef('F')
!!        write(*,*)'G=',table%ifdef('G')
!!        write(*,*)'H=',table%ifdef('H')
!!
!!      end program demo_ifdef
!!
!!   Results:
!!
!!     > A= T
!!     > B= T
!!     > C= T
!!     > D= F
!!     > E= T
!!     > F= F
!!     > G= T
!!     > H= F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function dict_ifdef(self,key) result(value)

! ident_28="@(#) M_list dict_ifdef(3f) return whether name is defined or not"

class(dictionary),intent(in)    :: self
character(len=*),intent(in)     :: key
logical                         :: value
integer                         :: place
   call locate(self%key,key,place)
   if(place.lt.1)then
      value=.false.
   else
      value=.true.
   endif
end function dict_ifdef
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_list
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================


!>>>>> build/dependencies/M_framework/src/M_framework__journal.f90

!>
!!##NAME
!!     M_framework__journal(3fm) - [M_framework__journal::INTRO] write
!!     program messages to stdout and/or
!!     a log file
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!     use, M_framework__journal , only : journal
!!##DESCRIPTION
!!
!!    For large interactive programs in particular it is useful if all
!!    messages go thru a JOURNAL(3f) call. This makes it easy to
!!    write messages to a log file as well as standard output; to toggle
!!    time prefixes on and off; to turn on and off debug-mode messages;
!!    control output paging and create replayable input journals.
!!
!!    The primary use of JOURNAL(3f) is to create journal files for
!!    interactive programs that
!!
!!        + provide various levels of verbosity on demand, often for
!!          debugging purposes.
!!        + can be replayed even when interactive input was provided
!!        + and/or be used to verify program executions
!!
!!    Typically, you would echo what the user typed to the trail file as-is,
!!    and write output you write to stdout as comments to the trail file so
!!    that the trail file can easily be read back in (by ignoring comments).
!!
!!    Even though there is essentially one procedure (journal(3f) calls
!!    that are more than just a single message have an action specified as
!!    the first parameter. This action might specify to open a log file, to
!!    change the "level" required by messages for them to appear, whether
!!    output it written as a comment or not, and on what files the output
!!    shoud appear. So the interface can be used in a very simple manner
!!    but has more options than is evident at first glance, as detailed in
!!    the man-page for journal(3f).
!!
!!    to stdout is written with WHERE='SC' in the JOURNAL(3f) call.
!!
!!     >      :
!!     >      :
!!     > call journal('O','my_trail_file')  ! open trail file
!!     > ! write output to stdout as-is and as comment to trail file
!!     > call journal(output)
!!     > ! echo message to trail/log file only
!!     > call journal('T',userline)
!!     > ! write to stdout as-is and trail as a comment.
!!     > ! up to twenty scalar values of any intrinsic type are allowed
!!     > call journal('SC','i1=',i1,'i2=',i2,'i3=',i3)
!!     > ! for more complex messages you can build them with non-advancing
!!     > ! I/O journal calls, or build the message with internal writes
!!     > ! into a string and print that.
!!
!!       I=10
!!       R=20.3
!!       ! write to stdout and trail file without advancing I/O
!!       call journal('+SC','I=',i)
!!       ! write to stdout and trail file without advancing I/O
!!       call journal('SC','AND R=',r)
!!
!!    writes to the trail file(s) are ignored unless a trail file was opened,
!!    but output continues to stdout by default.
!!
!!    That is, destinations 'T' and 'C' are ignored unless a trail file
!!    has been requested, allowing journal to be used with programs that
!!    do not generate trails or journals.
!!
!!    Note that with no parameters, the trail file is flushed.
!!
!!##EXAMPLES
!!
!!
!!    The man-page for journal(3f) describes all the options for the
!!    action field WHERE.  In addition to being used to generate a journal,
!!    the routine can be used for producing optional debug messages and
!!    timing information.
!!
!!    Sample program for debug messages:
!!
!!      program demo_journal
!!      !! showing creating debug messages
!!      use M_framework__journal, only : journal
!!      implicit none
!!      !! produces no output because trail is not on
!!      call journal('D','*demo* DEBUG MESSAGE 001 IGNORED')
!!      !! turn on debug messages
!!      call journal('>','debug on')
!!      !! produces output on stdout because debug mode
!!      !! is on but no named trail file
!!      call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT')
!!      !! open trail file
!!      call journal('O','mytrail.txt')
!!      !! debug messages now go to the trail file only
!!      call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL')
!!      !! or always to stdout and trail file only if on
!!      call journal('DS','*demo* DEBUG MESSAGE 003 TO TRAIL')
!!      !! close trail file so messages go only to stdout again
!!      call journal('O','')
!!      !! debug on stdout now
!!      call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT')
!!      !! turn off debug messages
!!      call journal('<','debug off')
!!      !! back to no output from the next message
!!      call journal('D','*demo* DEBUG MESSAGE 005 IGNORED')
!!      end program demo_journal
!!
!!
!!   Sample program for trail messages with optional timing information:
!!
!!      program testit
!!      use M_framework__journal,only : journal
!!      implicit none
!!      call journal('a single string A -should be on S')
!!
!!      ! add time prefix to output
!!      call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b')
!!      !
!!      call journal('a single string B -should be on S with prefix')
!!      ! change to CPU time and number of calls prefix
!!      call journal('%','CPU_TIME: %c:CALLS: %C: %b')
!!      !
!!      call journal('a single string B-1 -should be on S with prefix')
!!      call journal('a single string B-2 -should be on S with prefix')
!!      call journal('a single string B-3 -should be on S with prefix')
!!      !  Other useful time formats:
!!      !     %E -- Unix Epoch time
!!      !     %e -- integer value of Unix Epoch time
!!      !     %C -- number of times this format is used
!!      !     %c -- CPU_time(3f) output
!!      !     %S -- seconds since last use of this format
!!      !     %k -- CPU time in seconds from system_clock
!!      call journal('%','') ! turn off time prefix
!!      !
!!      call journal('a single string C -should be on S')
!!      !
!!      call journal('O','aaa.out') ! turn on trail file
!!      call journal('a single string D -should be on SC')
!!      call journal('a single string E -should be on SC')
!!      call journal('a single string F -should be on SC')
!!      call journal('O','') ! turn off trail file
!!      !
!!      call journal('a single string G -should be on S')
!!      call journal('a single string H -should be on S')
!!      call journal('a single string I -should be on S')
!!
!!      ! build one line of output with intrinsic scalar values added
!!      call journal('+sc','APPEND:')
!!      call journal('+sc',' integer',         1234)
!!      call journal('+sc',' and real',        1234.5678)
!!      call journal('+sc',' and double',1234567890.123456d0)
!!      call journal('+sc',' and logical',    .true.)
!!      call journal('sc','')
!!      !
!!      end program testit
!!
!!##AUTHOR
!!     John S. Urban
!!##LICENSE
!!     Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_framework__journal
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT     ! access computing environment
use :: M_framework__msg,                      only : str
implicit none
private

!>
!!##NAME
!!      journal(3f) - [M_framework__journal] provides public message routine, no paging or graphic mode change
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!    subroutine journal([where,],[VALUE(s)])
!!
!!     character(len=*),intent(in) :: where
!!     class(*),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!
!!   WRITE MESSAGES
!!    basic messages
!!
!!       call journal(where,[VALUE(S)])
!!       call journal(message) # a shortcut for "call journal('sc',message)":
!!   OPEN OR CLOSE TRAIL FILE
!!    trail file
!!
!!       call journal('O',trailfile_name) # open trail file
!!       call journal('O','')             # close trail file
!!   SET OUTPUT TIME PREFIX
!!    set the function display format for timestamps. See the NOW(3f)
!!    procedure for allowable timestamp macros
!!
!!       call journal('%',time_stamp_prefix_specification)
!!
!!   MODES
!!
!!    Turn on/off writing DEBUG messages to trail file
!!
!!       call journal('>','debug on') # turn on debug mode
!!       call journal('<','debug off') # turn off debug mode
!!
!!   ASSIGN STDOUT TO AN ALTERNATE FILE
!!    change stdout to iunit and open filename; or close unit and go back to stdout if filename=''
!!
!!       call journal(iunit,filename)
!!
!!    change stdout to iunit to use a file already open
!!
!!       call journal(iunit)
!!
!!##DESCRIPTION
!!
!!    If a user procedure is used for outputting messages instead of calling
!!    WRITE(3f) it is easy to provide control of when messages are printed
!!    (ie. a "verbose" mode, or "quite" mode), creating files to replay
!!    program execution, duplicating output, ...
!!
!!##OPTIONS
!!   WHERE  indicates where messages are written. A combination of the
!!          following characters can be used...
!!
!!      Usually one of these to write to the standard output files ...
!!
!!      S   write to stdout or iounit set with journal(unit) or
!!          journal(unit,filename).
!!      E   write to stderr
!!
!!      And one of these to write to trail file (ignore if no trail file
!!      defined) ...
!!
!!      C   write to trail file as a comment (if file is open)
!!          Writing output "as a comment" means it is preceded by a pound(#)
!!          character.
!!      T   write to trail file (if file is open)
!!
!!      Usually used by itself
!!
!!      D   write to trail file as a comment with "DEBUG:" prefix in front
!!          of message (if file is open) if debug mode is on. Write to stdout
!!          if no trail file and debug mode is on.
!!
!!      Modifier for S|E|C|T|D specifiers
!!
!!      +   subsequent files are written to with advance='no'. Position is
!!          important. '+sc' does an advance='no' on both files, 's+c'
!!          only does the advance='no' for the trail file.
!!
!!      Mode changing options used by themselves:
!!
!!      >   turn off debug messages
!!      <   turn on debug messages
!!      O   open trail file using value of "message" parameter or close
!!          trail file if no filename or a blank filename.
!!      A   Auxiliary programs that also want to write to the current log file
!!          (a2b, z2a, ...) call this routine to see if there is a trail file
!!          being generated and then add to it so that a program like ush(1f)
!!          can call the auxiliary programs and still just generate one log file,
!!          but if the auxiliary program is used as a stand-alone program no trail
!!          is generated.
!!
!!   VALUES(S)   message to write to stdout, stderr, and the trail file.
!!               a numeric or character value to optionally be appended
!!               to the message. Up to twenty values are allowed. The WHERE
!!               field is required if there is anything other than a single
!!               character string or not values at all.
!!   FILENAME    when WHERE="O" to turn the trail file on or off, the "message"
!!               field becomes the trail filename to open. If blank, writing
!!               to the trail file is turned off.
!!   TIMEFORMAT  when WHERE="%" the message is treated as a time format
!!               specification as described under now(3f).
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_journal
!!    use M_framework__journal, only : journal
!!    !! BASIC USAGE
!!    call journal(&
!!    & 'write to standard output as-is, and trail file as a comment if open')
!!    ! since trail file is not yet open, only stdout will display output
!!    call journal('c','ignored, as trail file is not open')
!!    ! now open trail file "trail"
!!    call journal('o','trail')
!!    call journal('sc','same thing except now trail file is open')
!!    ! only write to trail file if open
!!    call journal('c',&
!!    & 'not ignored, as trail file is open. Written with # suffix')
!!    call journal('t',&
!!    & 'not ignored, as trail file is open. Written as-is')
!!    ! turn off trail file
!!    call journal('o','')
!!    end program demo_journal
!!
!!   Adding intrinsic scalar values to the message:
!!
!!    program test_journal
!!    use M_framework__journal, only: journal
!!    implicit none
!!       call journal('S','This is a test with no optional value')
!!       call journal('S','This is a test with a logical value',.true.)
!!       call journal('S', &
!!         & 'This is a test with a double value',1234567890.123456789d0)
!!       call journal('S', &
!!         & 'This is a test with a real value',1234567890.123456789)
!!       call journal('S','This is a test with an integer value',1234567890)
!!       call journal('STDC','This is a test using STDC',1234567890)
!!       call journal('stdc','This is a test using stdc',1234567890)
!!       call journal('o','journal.txt')  ! open trail file
!!       call journal('S', &
!!         & 1,12.34,56789.111111111d0,.false.,'a bunch of values')
!!       ! the combinations that make sense
!!       call journal('st','stdout and trail')
!!       call journal('s' ,'stdout only')
!!       call journal('t' ,'trail only')
!!       call journal('sc','stdout and trail_comment')
!!       call journal('c' ,'trail_comment only ')
!!       call journal('d' ,'debug only')
!!       call journal('e' ,'stderr only')
!!       call journal('o' ,' ') ! closing trail file
!!    end program test_journal
!!
!!    program testit
!!    ! this is a utility program that calls the module routines. It is
!!    ! typically built using ccall(1).
!!    use M_framework__journal, only : journal
!!    character(len=:),allocatable :: time_stamp_prefix
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES')
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() but did not generate a log file')
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES WITH LOG FILE')
!!     call journal('o','journal.txt')     ! open trail file
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() and generated log file journal.txt')
!!     call journal('','journal.txt')      ! close trail file
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES WITH TIMING INFORMATION')
!!     ! change time prefix
!!     time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b'
!!     call journal('%',time_stamp_prefix) ! set a message time prefix
!!     call journal('o','timed.txt')       ! open trail file
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() and generate log file timed.txt')
!!     call journal('','timed.txt')        ! close trail file
!!     call journal('%','')                ! turn off time prefix
!!     call journal('o','timed.txt')       ! open trail file
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!
!!    contains
!!
!!       subroutine two()
!!          call journal('Entered subroutine two')
!!          call journal('Exited subroutine two')
!!       end subroutine two
!!
!!       subroutine one()
!!          call journal('Entered subroutine one')
!!          sum=-HUGE(1.0)
!!          do i=1,10000000
!!            sum=sum+sqrt(real(i))
!!          enddo
!!          write(*,*)'SUM=',sum
!!          call journal('Exited subroutine one')
!!       end subroutine one
!!
!!    end program testit
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
public journal

interface journal
   module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

! ident_1="@(#) M_framework__journal journal(3fg) provides public message routine no paging or graphic mode change"

! global variables

!integer,parameter,private  :: stdin=INPUT_UNIT
integer,save,private       :: my_stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0

integer,parameter,private :: dp=kind(0.0d0)
real(kind=dp)             :: secday=86400.0d0              ! 24:00:00 hours as seconds

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

! ident_2="@(#) M_framework__journal where_write_message(3fp) basic message routine used for journal files"

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
!
!  writes error messages and general information text to stdout and the trace file
!     where=*C* write to trail file as a comment (if file is open)
!     where=*D* write to trail file as a comment with DEBUG: prefix in front of message (if file is open and debug mode on)
!     where=*E* write to stderr
!     where=*S* write to stdout or iounit set with journal(unit) or journal(unit,filename)
!     where=*T* write to trail file (if file is open)
!     where=*+* subsequent writes for this call are written with advance='no'

!     where=> turn on debug messages (change mode), which are ones with WHERE='D'
!     where=< turn off debug messages  (change mode), which are ones with WHERE='D'

!     where=O open trail file "msg" or close trail file if blank filename is given
!     where=% set prefix to run thru now(3f) to generate time prefix strings, blank turns off time prefix
!     where=N open new file and assign stdout to the file unless file name is blank; then revert to my_stdout being original stdout.
!
!  the trail file messages are preceded by a pound character (#) by default so they can easily be interpreted as comments
!  if the trace file is subsequently used as input data for a program
!
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save  :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable       :: prefix            ! the prefix string to add to output
logical,save                       :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)                :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   if(prefix_it)then
      prefix=now_ex(prefix_template)
   else
      prefix=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
         !!elseif(times == 0)then
         !!   write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         !!   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)prefix,trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()

! ident_3="@(#) M_framework__journal flush_trail(3fp) flush trail file"

call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_stdout_lun(iounit)

! ident_4="@(#) M_framework__journal set_stdout_lun(3fp) change I/O logical unit value for standard writes"

integer,intent(in)                   :: iounit
   my_stdout=iounit
end subroutine set_stdout_lun
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    where_write_message_all(3f) - [M_framework__journal] converts any
!!    standard scalar type to a string and calls journal(3f)
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine where_write_message_all(where,g0,g1,g2,..,gj,sep)
!!
!!     character(len=*),intent(in)   :: where
!!     class(*),intent(in)           :: g0
!!     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     character,intent(in),optional :: sep
!!
!!##DESCRIPTION
!!    where_write_message_all(3f) builds and writes a space-separated string
!!    from up to twenty scalar values.
!!
!!##OPTIONS
!!
!!    where       string designating where to write message, as with journal(3f)
!!    g0          value to print. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!                or CHARACTER.
!!    g[1-9a-j]   optional additional values to print the value of after g0.
!!    sep         separator to add between values. Default is a space. Should
!!                always be called with a keyword, as in "sep=VALUE".
!!##RETURNS
!!    where_write_message_all  description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wm_all
!!    use M_framework__journal, only : where_write_message_all
!!    implicit none
!!    end program program demo_wm_all
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine where_write_message_all(where,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep)
implicit none

! ident_5="@(#) M_framework__journal where_write_message_all(3f) writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
class(*),intent(in),optional  :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character,intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep=sep))
end subroutine where_write_message_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

! ident_6="@(#) M_framework__journal write_message_only(3fp) calls JOURNAL('sc' message)"

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2j(dat,julian,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
! * Author:    John S. Urban
! * Version:   1.0 2015-12-21
! * Reference: From Wikipedia, the free encyclopedia 2015-12-19
! * There is no year zero
! * Julian Day must be non-negative
! * Julian Day starts at noon; while Civil Calendar date starts at midnight
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_7="@(#) d2j(3f) Converts proleptic Gregorian date array to Julian Day"
integer,intent(in)         :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
real(kind=dp),intent(out)  :: julian   ! Julian Day (non-negative, but may be non-integer)
integer,intent(out)        :: ierr     ! Error return, 0 for successful execution,-1=invalid year,-2=invalid month,-3=invalid day,
                                       ! -4=invalid date (29th Feb, non leap-year)
   integer                 :: year, month, day, utc, hour, minute
   real(kind=dp)           :: second
   integer                 :: A, Y, M, JDN
!-----------------------------------------------------------------------------------------------------------------------------------
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0d0    ! Second   ! correction for time zone and milliseconds
!-----------------------------------------------------------------------------------------------------------------------------------
   julian = -HUGE(99999)                  ! this is the date if an error occurs and IERR is < 0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(year==0 .or. year .lt. -4713) then
      ierr=-1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or Febuary, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for Febuary
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian date given the JDN (Julian day number) and time of day
   julian=JDN + dble(hour-12)/24.0d0 + dble(minute)/1440.0d0 + second/86400.0d0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(julian.lt.0.d0) then                  ! Julian Day must be non-negative
      ierr=1
   else
      ierr=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine d2j
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2u(dat,unixtime,ierr)
! ident_8="@(#) d2u(3f) Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970)"
integer,intent(in)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
real(kind=dp),intent(out)  :: unixtime                ! Unix time (seconds)
integer,intent(out)        :: ierr                    ! return 0 on successful, otherwise 1
   real(kind=dp)           :: julian
   real(kind=dp),save      :: julian_at_epoch
   logical,save            :: first=.true.
!-----------------------------------------------------------------------------------------------------------------------------------
if(first) then                                        ! Compute zero of Unix Time in Julian days and save
   call d2j([1970,1,1,0,0,0,0,0],julian_at_epoch,ierr)
   if(ierr.ne.0) return                               ! Error
   first=.false.
endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call d2j(dat,julian,ierr)
   if(ierr.ne.0) return                               ! Error
   unixtime=(julian-julian_at_epoch)*secday
end subroutine d2u
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION d2o(dat) RESULT (ordinal)
! ident_9="@(#) d2o(3f) Converts date-time array to Ordinal day"
INTEGER,INTENT(IN)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
INTEGER                    :: ordinal                 ! the returned number of days
   REAL(KIND=dp)           :: unixtime                ! Unix time (seconds)
   REAL(KIND=dp)           :: unix_first_day
   INTEGER                 :: ierr                    ! return 0 on successful, otherwise 1 from d2u(3f)
   CALL d2u(dat,unixtime,ierr)                        ! convert date to Unix Epoch Time
   IF(ierr.NE.0)THEN
      write(*,*)'*d2o* bad date array'
      ordinal=-1                                      ! initialize to bad value
   ELSE
      CALL d2u([dat(1),1,1,dat(4),0,0,0,0],unix_first_day,ierr)
      ordinal=int((unixtime-unix_first_day)/secday)+1
   ENDIF
END FUNCTION d2o
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION v2mo(imonth) RESULT(month_name)
! ident_10="@(#) v2mo(3f) returns the month name of a Common month"
CHARACTER(LEN=:),ALLOCATABLE :: month_name                                        ! string containing month name or abbreviation.
INTEGER,INTENT(IN)           :: imonth                                            ! the number of the month(1-12)
CHARACTER(LEN=*),PARAMETER   :: names(12)=[ character(len=9) ::  &
&'January  ', 'February ', 'March    ', 'April    ', 'May      ', 'June     ', &
&'July     ', 'August   ', 'September', 'October  ', 'November ', 'December ']
   SELECT CASE(imonth)
   CASE (1:12);  month_name=TRIM(names(imonth))
   CASE DEFAULT; month_name='UNKNOWN'
   END SELECT
END FUNCTION v2mo
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION now(format)
! ident_11="@(#) JSU 2015-10-24"
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: format
CHARACTER(LEN=:),ALLOCATABLE         :: now
   INTEGER                           :: values(8)
!-----------------------------------------------------------------------------------------------------------------------------------
   CALL DATE_AND_TIME(VALUES=values)
   IF(PRESENT(format))THEN
      IF(format.NE.' ')THEN
         now=fmtdate(values,format)
      ELSE
         now=fmtdate(values,'%Y-%M-%D %h:%m:%s %z')
      ENDIF
   ELSE
      NOW=fmtdate(values,'%Y-%M-%D %h:%m:%s %z Julian date is %J Epoch time is %E ')
   ENDIF
END FUNCTION now
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION fmtdate(values,format) RESULT (timestring)
! Read the FORMAT string and replace the "%" strings per the following rules:
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_12="@(#) fmtdate(3f) given date array return date as string using format"
CHARACTER(LEN=*),INTENT(IN)     :: format    ! input format string
INTEGER,DIMENSION(8),INTENT(IN) :: values    ! numeric time values as DATE_AND_TIME(3f) intrinsic returns
CHARACTER(LEN=:),ALLOCATABLE    :: timestring
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   INTEGER              :: i10
   LOGICAL              :: keyword   ! flag that previous character was a % character
   CHARACTER(LEN=9)     :: day       ! day of week
   CHARACTER(LEN=1)     :: chara     ! character being looked at in format string
   CHARACTER(LEN=4096)  :: text      ! character array
   INTEGER              :: iout
   INTEGER              :: weekday
   INTEGER              :: ierr
   INTEGER,SAVE         :: called=0
   LOGICAL,SAVE         :: since=.FALSE.
   REAL(KIND=dp)        :: julian
   REAL(KIND=dp)        :: cputime
   INTEGER              :: ii
   REAL(KIND=dp)        :: unixtime
   REAL(KIND=dp),save   :: unixtime_last
   INTEGER              :: systemclock, countrate
   INTEGER              :: iso_year, iso_week, iso_weekday
   CHARACTER(LEN=10)    :: iso_name
   CHARACTER(LEN=2)     :: dayend

   text=' '
!  write string, when encounter a percent character do a substitution
   keyword=.FALSE.
   iout=1
   DO i10=1,LEN(format)
      chara=format(i10:i10)
      IF(chara.eq.'%'.and..not.keyword)THEN
            keyword=.TRUE.
            CYCLE
      ENDIF
      IF(keyword)THEN
         keyword=.FALSE.
         SELECT CASE(chara)
         !=====================================================================================
         CASE('%'); WRITE(text(iout:),'(A1)')chara                        ! literal percent character
         !=====================================================================================
         CASE('b'); WRITE(text(iout:),'(A1)')' '                          ! space character
         !=====================================================================================
         CASE('c'); CALL cpu_time(cputime)                                ! CPU_TIME()
                    WRITE(text(iout:),'(G0)')cputime
         !=====================================================================================
         CASE('C'); called = called + 1                                   ! number of times this routine called
                    WRITE(text(iout:),'(I0)')called
         !=====================================================================================
         CASE('d');                                                       ! the day of the month 1st..31st
                    dayend='  '
                    select case(values(3))
                    case(1,21,31); dayend='st'
                    case(2,22); dayend='nd'
                    case(3,23); dayend='rd'
                    case(4:20,24:30); dayend='th'
                    case default
                    end select
                    WRITE(text(iout:),'(I2,a)')values(3),dayend
         !=====================================================================================
         CASE('D'); WRITE(text(iout:),'(I2.2)')values(3)                  ! the day of the month 1..31
         !=====================================================================================
         CASE('e'); CALL d2u(values,unixtime,ierr)                        ! integer Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')int(unixtime)
         !=====================================================================================
         CASE('E'); CALL d2u(values,unixtime,ierr)                        ! Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')unixtime
         !=====================================================================================
         CASE('h'); WRITE(text(iout:),'(I2.2)')values(5)                  ! the hour of the day, in the range of 0 to 23
         !=====================================================================================
         CASE('H'); ii=mod(values(5),12)                                  ! hour of day in range 1..12
                    if(ii.eq.0)then
                       ii=12
                    endif
                    WRITE(text(iout:),'(I2.2)')ii
         !=====================================================================================
         CASE('i'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! ISO week of year
                    WRITE(text(iout:),'(I0)')iso_week
         !=====================================================================================
         CASE('I'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! iso-8601 Week-numbering year date
                    WRITE(text(iout:),'(a)')iso_name
         !=====================================================================================
         CASE('j'); CALL d2j(values,julian,ierr)                          ! integer Julian date (truncated to integer)
                    WRITE(text(iout:),'(I0)')int(julian)
         !=====================================================================================
         CASE('J'); CALL d2j(values,julian,ierr)                          ! Julian date to milliseconds
                    WRITE(text(iout:),'(I0,".",i3.3)')int(julian),int((julian-int(julian))*1000.0)
         !=====================================================================================
         CASE('k'); call system_clock(count=systemclock,count_rate=countrate)  ! systemclock/countrate
                    WRITE(text(iout:),'(G0)')real(systemclock)/countrate
         !=====================================================================================
         CASE('l'); WRITE(text(iout:),'(A3)')v2mo(values(2))              ! three characters of the name of the month of the year
         !=====================================================================================
         CASE('L'); WRITE(text(iout:),'(A)')v2mo(values(2))               ! name of the month of the year
         !=====================================================================================
         CASE('m'); WRITE(text(iout:),'(I2.2)')values(6)                  ! the minutes of the hour, in the range 0 to 59
         !=====================================================================================
         CASE('M'); WRITE(text(iout:),'(I2.2)')values(2)                  ! month of year (1..12)
         !=====================================================================================
         CASE('N'); if( values(5).ge.12)then                              ! AM||PM
                       WRITE(text(iout:),'("PM")')
                    else
                       WRITE(text(iout:),'("AM")')
                    endif
         !=====================================================================================
         CASE('O'); WRITE(text(iout:),'(I3.3)')d2o(values)                ! Ordinal day of year
         !=====================================================================================
         CASE('s'); WRITE(text(iout:),'(I2.2)')values(7)                  ! the seconds of the minute, in the range 0 to 60
         !=====================================================================================
         CASE('S'); IF(.NOT.since)THEN                                    ! seconds since last called
                       since=.TRUE.
                       CALL d2u(values,unixtime_last,ierr)
                    ENDIF
                    CALL d2u(values,unixtime,ierr)
                    WRITE(text(iout:),'(G0)')unixtime-unixtime_last
                    unixtime_last=unixtime
         !=====================================================================================
         CASE('t'); WRITE(text(iout:),'(A1)')CHAR(9)                      ! tab character
         !=====================================================================================
         CASE('U'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Sunday=1
                    WRITE(text(iout:),'(I1)')weekday
         !=====================================================================================
         CASE('u'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Monday=1
                    WRITE(text(iout:),'(I1)')mod(weekday+5,7)+1
         !=====================================================================================
         CASE('W'); CALL dow(values,weekday,day,ierr)                     ! Return the name of the day of the week
                    WRITE(text(iout:),'(a)')day
         !=====================================================================================
         CASE('w'); CALL dow(values,weekday,day,ierr)                     ! Return the first three characters of the day of the week
                    WRITE(text(iout:),'(A3)')day(1:3)
         !=====================================================================================
         CASE('x'); WRITE(text(iout:),'(I3.3)')values(8)                  ! the milliseconds of the second, in the range 0 to 999
         !=====================================================================================
         CASE('Y'); WRITE(text(iout:),'(I4.4)')values(1)                  ! the year, including the century (for example, 1990)
         !=====================================================================================
         CASE('Z'); WRITE(text(iout:),'(SP,I5.4)')values(4)               ! time difference with respect to UTC in minutes
         !=====================================================================================
         CASE('z'); WRITE(text(iout:),'(I3.2,":",I2.2)')int(values(4)/60),abs(mod(values(4),60)) ! time from UTC as +-hh:mm
         !=====================================================================================
         CASE DEFAULT
            WRITE(text(iout:),'(A1)')chara
         !=====================================================================================
         END SELECT
         !=====================================================================================
         iout=len_trim(text)+1
      ELSE
         WRITE(text(iout:),'(A1)')chara;iout=iout+1
      ENDIF
   ENDDO
   timestring=trim(text)
END FUNCTION fmtdate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine dow(values, weekday, day, ierr)
! ident_13="@(#) dow(3f) Return the day of the week"
real(kind=dp)                      :: julian    ! the julian day for which the weekday is required,
integer,intent(in)                 :: values(8) ! date and time array used to get time zone
integer,intent(out),optional       :: weekday   ! The day of the week, 1 = Sunday
character*(*),intent(out),optional :: day       ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9
integer,intent(out)                :: ierr      ! Error return,0=correct,-1=invalid Julian day,-2=neither day nor weekday specified
   integer                         :: iweekday

   call d2j(values,julian,ierr)                 ! need julian date to calculate day of week for first day of month
   ierr = 0

   if(julian < 0) then
      ierr = -1
      return
   endif

   if(.not.present(day).and. .not.present(weekday)) then
      ierr=-2
      return
   endif

   ! julian day starts at noon so add 1/2 day
   ! add time zone
   iweekday = mod(int((julian+dble(values(4)/60.0d0/24.0d0)+0.5d0)+1.0d0), 7)
   iweekday = iweekday +1

   if(present(day)) then
      select case(iweekday)
      case(1)     ;day = 'Sunday'
      case(2)     ;day = 'Monday'
      case(3)     ;day = 'Tuesday'
      case(4)     ;day = 'Wednesday'
      case(5)     ;day = 'Thursday'
      case(6)     ;day = 'Friday'
      case(7)     ;day = 'Saturday'
      case default;day = 'E-R-R-O-R'
      end select
   endif

   if(present(weekday))then
      weekday=iweekday
   endif

end subroutine dow
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine woy(dat,iso_year,iso_week,iso_weekday,iso_name)
!-----------------------------------------------------------------------------------------------------------------------------------
!  The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO).
!  It is used (mainly) in government and business for fiscal years, as well as in timekeeping.
!  The system specifies a week year atop the Gregorian calendar by defining a notation for ordinal weeks of the year.
!
!  An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks.
!  That is 364 or 371 days instead of the usual 365 or 366 days.
!  The extra week is referred to here as a leap week, although ISO 8601 does not use this term.
!  Weeks start with Monday.
!  The first week of a year is the week that contains the first Thursday of the year (and, hence, always contains 4 January).
!  ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January.
!-----------------------------------------------------------------------------------------------------------------------------------
!CALCULATION:
!  The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year)
!  and its day of the week.

!METHOD:
!   Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday),
!   subtract the weekday from the ordinal date, then add 10. Divide the result
!   by 7. Ignore the remainder; the quotient equals the week number. If
!   the week number thus obtained equals 0, it means that the given date
!   belongs to the preceding (week-based) year. If a week number of 53 is
!   obtained, one must check that the date is not actually in week 1 of the
!   following year.
! These two statements are assumed true when correcting the dates around January 1st ...
!   o  The number of weeks in a given year is equal to the corresponding week number of 28 December.
!   o  January 4th is always in the first week.
!
!ISO_NAME:
!  Week date representations are in the format YYYYWww-D.
!  o [YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year.
!  o [Www] is the week number prefixed by the letter W, from W01 through W53.
!  o [D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.
!
!  For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written
!     2006-W52-7 (extended form)
!  or 2006W527 (compact form).
!
!REFERENCE:
!  From Wikipedia, the free encyclopedia 2015-12-19
!AUTHOR:
!  John S. Urban, 2015-12-19
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_14="@(#) woy(3f) Calculate iso-8601 Week-numbering year date yyyy-Www-d"
integer,parameter               :: dp=kind(0.0d0)
integer,intent(in)              :: dat(8)     ! input date array
integer,intent(out)             :: iso_year, iso_week, iso_weekday
character(len=10),intent(out)   :: iso_name
integer                         :: shared_weekday
integer                         :: last_week_this_year
integer                         :: dec28_lastyear(8)   ! December 28th is always in last week
integer                         :: dec28_thisyear(8)   ! December 28th is always in last week
character(len=9)                :: day
integer                         :: ierr
   iso_year=dat(1)                                               ! initially assume the iso_year is the same as the data array year
   iso_week=uncorrected_week_of_year(dat)                        ! this is the week number unless around January 1st
   iso_weekday=shared_weekday                                    ! this is the number of the day of the week assuming Monday=1
   dec28_thisyear=[dat(1),12,28,dat(4),0,0,0,0]                  ! Dec 28th is always in last week; use this to get number of weeks
   last_week_this_year=uncorrected_week_of_year(dec28_thisyear)  ! get the number of the last week of the year (52 or 53)
   ! correct dates around January 1st
   if(iso_week  < 1)then                                         ! if week < 1 then week = lastWeek(year -1)
      dec28_lastyear=[dat(1)-1,12,28,dat(4),0,0,0,0]             ! Dec 28th is always in last week, we want its week number
      iso_week=uncorrected_week_of_year(dec28_lastyear)          ! got the week number for the last week of last year (52 or 53)
      iso_year=dat(1)-1                                          ! our date belongs to last year
   elseif(iso_week >last_week_this_year)then                     ! if week > lastweek(year) then week = 1
      iso_week=iso_week-last_week_this_year                      ! our date belongs to next year
      iso_year=dat(1)+1
   endif

   write(iso_name,'(i4.4,"-W",i2.2,"-",i1)')iso_year,iso_week,iso_weekday ! create ISO string designation for our date

contains
   function uncorrected_week_of_year(datin)
   implicit none
   integer            :: uncorrected_week_of_year
   integer,intent(in) :: datin(8)
      integer         :: ordinal
      call dow(datin,shared_weekday,day,ierr)                 ! formula needs day of week 1..7 where Monday=1
      shared_weekday=mod(shared_weekday+5,7)+1                ! change from Sunday=1 to Monday=1
      ordinal=d2o(datin)                                      ! formula needs ordinal day of year where Jan 1st=1
      uncorrected_week_of_year=(ordinal-shared_weekday+10)/7
   end function uncorrected_week_of_year

end subroutine woy
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function now_ex(format)

! ident_15="@(#) M_time now_ex(3f) use of now(3f) outside of a module"

character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: now_ex
   now_ex=now(format)
end function now_ex
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_framework__journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================


!>>>>> build/dependencies/M_framework/src/M_framework__verify.F90

!>
!!##NAME
!!    M_framework__verify(3f) - [M_framework__verify::INTRO] unit test framework
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!  Module procedures
!!
!!    use M_framework, only : unit_test, unit_test_start,    &
!!                            unit_test_end, unit_test_stop, &
!!                            unit_test_msg, unit_test_mode, &
!!                            unit_test_system,              &
!!                            unit_test_expected
!!  Module values
!!
!!    use M_framework, only : unit_test_level, unit_test_flags
!!
!!##QUOTE
!!    Do not let your victories go to your head, nor let your failures go
!!    to your heart.
!!
!!##DESCRIPTION
!!    The M_framework(3f) module is a collection of Fortran routines for
!!    supporting code development by providing logging, error processing,
!!    debugging, comparison and unit testing procedures.
!!
!!    The M_framework__verify(3f) module specifically brings together a
!!    few procedures for creating unit testing. It ...
!!
!!     o allows for a user-defined command to be called to collect results or
!!       produce mail alerts, or other custom bookkeeping operations.
!!
!!     o supports easily composing a message from up to twenty scalar
!!       intrinsic values and different strings
!!
!!     o allows stopping on failure or continuing
!!
!!     o provides for a non-zero exit code if any tests fail
!!
!!     o is designed for with integration with the fpm
!!      (Fortran Package Manager) "test" subcommand.
!!
!!    If default modes need changed it can be done via the unit_test_mode(3f)
!!    procedure or as command line options.
!!
!!    messages by default are writting to stderr, but may be written to any
!!    list of LUNs of preassigned or open files.
!!
!!    SET MODES
!!
!!    Some of the most common options are
!!
!!       call unit_test_mode(command,keep_going,level,luns=[K,L,M,N,...])
!!
!!        keep_going  logical variable that can be used to turn on or off
!!                    program termination on errors.
!!        luns        array of Fortran LUNs to write messages to
!!        level       An integer that can be used to specify
!!                    different debug levels
!!        command     name of optional command to execute for a start,
!!                    check, or finish.
!!
!!  PROCEDURES
!!
!!  The unit test procedures are
!!
!!       unit_test_start()     start tests of a procedure
!!       unit_test()           report if expression is false or true
!!                              and if .false. stop program when keep_going=.false.
!!       unit_test_end()       ends test of a procedure
!!       unit_test_msg()       write message
!!       unit_test_stop()      stop program with exit value of 0 if no failures
!!                              else with an exit value of 1
!!       unit_test_system()    execute system command, recursively if requested.
!!
!!  The unit test short-cut procedures are
!!
!!       unit_test_expected()  report if two values are equal
!!
!!    For custom unit testing reports, a command can be given that will be
!!    passed information on the command line in NAMELIST format.
!!
!!    This command is generally a script that makes entries for each unit,
!!    perhaps in an SQLite data file for example.
!!
!!    It might also send an email if a test fails in batch environments.
!!
!!    It could also convert the information to CSV for use in spreadsheets,
!!    or generate an HTML report, for example.
!!
!!    A sample command written in the bash(1) shell and using the sqlite3(1)
!!    command should be included in this distribution as an example.
!!
!!    The flexibility introduced by calling an external script or program
!!    is that the command can be changed as desired without changing the
!!    test programs.
!!
!!    RELATED FUNCTIONS
!!
!!    The routines in M_framework__verify(3f) are often combined with other
!!    small modules such as Comparisons of real values can be done with a
!!    tolerance with M_Compare_Float_Numbers(3f) and M_framework__approx(3f).
!!    M_hashkeys(3f) routines and various math and statistical routines can
!!    be helpful to quickly create unit tests.
!!
!!    The intrinsics ANY(3f) and ALL(3f) are particularly useful in calls
!!    to unit_test(3f).
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     !! program demo_M_framework__verify
!!     module M_framework__verify_demo
!!     private
!!     public one ! some regular routine
!!     public two ! some regular routine
!!     contains
!!
!!     subroutine one(array)
!!     integer,intent(out),allocatable :: array(:)
!!        array=[21,51,14,45]
!!     end subroutine one
!!
!!     subroutine two(array)
!!     integer,intent(inout),allocatable :: array(:)
!!        array=2*array
!!     end subroutine two
!!
!!     end module M_framework__verify_demo
!!
!!     program demo_M_framework__verify
!!     use M_framework, only: unit_test_start, unit_test,   &
!!         & unit_test_end, unit_test_msg, unit_test_stop, &
!!         & unit_test_system, unit_test_mode
!!     use M_framework__verify_demo,   only: one, two
!!     ! set-up
!!     call unit_test_mode(command='',flags=[0],keep_going=.true.)
!!     ! call a test procedure for each routine to test
!!        call test_one()
!!        call test_two()
!!     ! tear-down
!!     call unit_test_stop()
!!     contains
!!
!!     subroutine test_one()
!!     integer,allocatable :: results(:)
!!     integer,parameter   :: expected(*)=[21,51,14,45]
!!     call unit_test_start('one')
!!     call one(results)
!!     call unit_test('one',all(expected>0), &
!!        & 'testing if everyone greater than zero')
!!     call unit_test('one',all(expected==results), &
!!        & 'testing if all values are expected')
!!     call unit_test_end('one','checks on "one" ended')
!!     end subroutine test_one
!!
!!     subroutine test_two
!!     integer,allocatable :: results(:)
!!     integer,parameter   :: expected(*)=[2,20,200]
!!     results=[1,10,100]
!!     call two(results)
!!     call unit_test_start('two','check procedure "two" ')
!!     call unit_test('two', all(expected == results) .and. &
!!        & all(expected > 0) .and. maxval(expected) <201,msg='long expression')
!!     call unit_test_end('two','checks on "two" ended')
!!     end subroutine test_two
!!
!!     end program demo_M_framework__verify
!!
!!   Expected output:
!!
!!    check_start: one   START   :
!!    check:       one   SUCCESS : testing if everyone greater than zero
!!    check:       one   SUCCESS : testing if all values are expected
!!    check_end:   one   PASSED  : GOOD:  2 BAD:  0 DURATION:00000001
!!    check_start: two   START   :
!!    check:       two   SUCCESS : long expression
!!    check_end:   two   PASSED  : GOOD:   1 BAD:  0 DURATION:00000000
!!    check_stop:  TALLY PASSED  : GOOD:    3 BAD:  0 DURATION:00000001
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_framework__verify
use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64, real32, real64, real128
use,intrinsic :: iso_fortran_env,  only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
use           :: M_framework__msg, only : str, wrt
implicit none
private

type called
   logical :: preset_globals=.true.
   logical :: cmdline=.true.
   logical :: unit_test_mode=.true.
end type called

type(called),save             :: G_virgin

integer,save,allocatable      :: G_luns(:)              ! output units
logical,save                  :: G_debug=.false.
logical,save                  :: G_verbose=.false.
logical,save                  :: G_silent =.false.
logical,save                  :: G_brief=.false.    ! flag on whether to display SUCCESS: messages
character(len=:),allocatable  :: G_match

integer,save,public             :: unit_test_level=0      ! a value that can be used to select different debug levels
integer,save,public,allocatable :: unit_test_flags(:)     ! an array of flags that can be used to select different options
logical,save                    :: G_keep_going=.false.    ! can be used to turn on program termination on errors.
logical,save                    :: G_interactive=.false.
character(len=:),allocatable    :: G_command                         ! name of command to execute. Defaults to the name
logical,save                    :: G_cmdline=.true.                  ! flag whether to parse command line for arguments or not

integer,parameter,public   :: realtime=kind(0.0d0)      ! type for julian days
integer,parameter,public   :: EXIT_SUCCESS=0
integer,parameter,public   :: EXIT_FAILURE=1
real(kind=realtime),save   :: duration=0.0d0
real(kind=realtime),save   :: duration_all=0.0d0
integer(kind=int64),save   :: clicks=0_int64
integer(kind=int64),save   :: clicks_all=0_int64

integer,save :: IPASSED_G=0              ! counter of successes initialized by unit_test_start(3f)
integer,save :: IFAILED_G=0              ! counter of failures  initialized by unit_test_start(3f)
integer,save :: IPASSED_ALL_G=0          ! counter of successes initialized at program start
integer,save :: IFAILED_ALL_G=0          ! counter of failures  initialized at program start
integer,save :: G_LONGEST=20

public unit_test_mode      ! optionally set some non-default modes

public unit_test_start     ! start testing a procedure
public unit_test           ! report results of a test
public unit_test_end       ! end  testing a procedure

public unit_test_stop      ! produce tally of all procedures tested and end program

public unit_test_msg       ! maybe write some message
public unit_test_system    ! usually used for recursive calls when testing program termination status

public unit_test_expected  ! shortcut for common call to unit_test with expression and expected result

private atleast_
private cmdline_
private getarg0_
private getall_
private glob_

type :: force_keywd_hack  ! force keywords, using @awvwgk method
end type force_keywd_hack
! so then any argument that comes afer "force_keywd" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_keywd_hack), optional, intent(in) :: force_keywd

!===================================================
! for backward compatibility 2023-04-30. Otherwise, ignore these
public unit_test_good  ! report results of a test
public unit_test_bad   ! report results of a test

interface  unit_test_done;    module  procedure  unit_test_end;    end  interface  unit_test_done;    public  unit_test_done
interface  unit_check_start;  module  procedure  unit_test_start;  end  interface  unit_check_start;  public  unit_check_start
interface  unit_check;        module  procedure  unit_test;        end  interface  unit_check;        public  unit_check
interface  unit_check_done;   module  procedure  unit_test_end;    end  interface  unit_check_done;   public  unit_check_done
interface  unit_check_mode;   module  procedure  unit_test_mode;   end  interface  unit_check_mode;   public  unit_check_mode
interface  unit_check_stop;   module  procedure  unit_test_stop;   end  interface  unit_check_stop;   public  unit_check_stop
interface  unit_check_msg;    module  procedure  unit_test_msg;    end  interface  unit_check_msg;    public  unit_check_msg
interface  unit_check_good;   module  procedure  unit_test_good;   end  interface  unit_check_good;   public  unit_check_good
interface  unit_check_bad;    module  procedure  unit_test_bad;    end  interface  unit_check_bad;    public  unit_check_bad

interface unit_test_expected
   module procedure unit_test_expected_int32
   module procedure unit_test_expected_int64
   module procedure unit_test_expected_char
   module procedure unit_test_expected_boolean
   module procedure unit_test_expected_onoff
   module procedure unit_test_expected_real32
   module procedure unit_test_expected_real64
   module procedure unit_test_expected_cmplx32
   module procedure unit_test_expected_cmplx64
end interface

public unit_check_level
integer :: unit_check_level
equivalence (unit_test_level, unit_check_level)

! labels for PREFIX COLUMN OF MESSAGES

type prefix
   character(len=:),allocatable :: CHECK_MSG    !  'check_msg:    '
   character(len=:),allocatable :: CHECK        !  'check:        '
   character(len=:),allocatable :: CHECK_START  !  'check_start:  '
   character(len=:),allocatable :: CHECK_STOP   !  'check_stop:   '
   character(len=:),allocatable :: CHECK_END    !  'check_end:    '
end type prefix

!type(prefix),save :: CHECK_PREFIX=prefix( &
!   CHECK_MSG    =  'check_msg:   ', &
!   CHECK        =  'check:       ', &
!   CHECK_START  =  'check_start: ', &
!   CHECK_STOP   =  'check_stop:  ', &
!   CHECK_END    =  'check_end:   '  &
!&)

type(prefix),save :: CHECK_PREFIX=prefix( null(),null(),null(),null(),null())

public :: CHECK_PREFIX

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_msg(3f) - [M_framework__verify] converts up to twenty
!!    standard scalar values to a message for unit testing
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function unit_test_msg(name, msg, &
!!    & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,if)
!!
!!     character(len=*),intent(in)  :: name
!!     class(*),intent(in),optional :: msg, &
!!     & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!##DESCRIPTION
!!    unit_test_msg(3f) builds a string from up to twenty scalar values and
!!    prints it to the error log.
!!
!!##OPTIONS
!!    name        name of unit being tested
!!    msg,g[1-j]  optional values to print the value of. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!    if          expression must be true or message is not output.
!!                Must be specified by keyword as "if=expression".
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_msg
!!    use M_framework, only : unit_test_start,unit_test_msg, &
!!            & unit_test_end
!!    implicit none
!!
!!    call unit_test_start('myroutine')
!!    call unit_test_msg('myroutine','HUGE(3f) integers', &
!!            & huge(0),'and real',huge(0.0),'and double',huge(0.0d0))
!!    call unit_test_msg('myroutine','real            :', &
!!            & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!    call unit_test_msg('myroutine','doubleprecision :', &
!!            & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!    call unit_test_msg('myroutine','complex         :', &
!!            & cmplx(huge(0.0),tiny(0.0)) )
!!    call unit_test_end('myroutine')
!!
!!    end program demo_unit_test_msg
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_msg(name,msg, g1, g2, g3, g4, g5, g6, g7, g8, g9 ,ga, gb, gc, gd, ge, gf, gg, gh, gi, gj,force_keywd,if)
implicit none

! ident_1="@(#) M_framework__verify unit_test_msg(3f) writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: name
class(*),intent(in),optional  :: msg, g1 ,g2 ,g3 ,g4 ,g5, g6 ,g7 ,g8 ,g9, ga ,gb ,gc ,gd ,ge, gf ,gg ,gh ,gi, gj
type(force_keywd_hack), optional, intent(in) :: force_keywd
logical,intent(in),optional   :: if
character(len=:),allocatable  :: msg_all
logical                       :: if_local

G_LONGEST=max(G_LONGEST,len_trim(name))

if(present(if))then
   if_local=if
else
   if_local=.true.
endif
   if(G_virgin%cmdline) call cmdline_()

   if(if_local)then
      msg_all=str(msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)

      if(.not.G_brief)then
         ! write message to standard error
         call wrt(G_luns,CHECK_PREFIX%check_msg//atleast_(name,G_LONGEST)//' INFO    : '// msg_all)
      endif
      if(G_command /= '') call run(G_command//' type="message"  name="'//trim(name)//'" msg="'//ndq(msg_all)//'"')
   endif

end subroutine unit_test_msg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test(3f) - [M_framework__verify] report if logical expression is
!!    true or false, optionally call command and/or stop program.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail)
!!
!!     character(len=*),intent(in) :: name
!!     logical,intent(in) :: expression
!!     class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!     & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     logical,intent(in),optional :: only_on_fail
!!
!!##DESCRIPTION
!!    unit_test(3f) tests the expression and displays a message composed
!!    of the generic intrinsic values msg, and g1 thorough gj. Additionally,
!!    if the expression is false
!!
!!    o if unit_test_mode(command) is not blank calls the
!!    specified shell command
!!
!!       $COMMAND name="NAME" type="check" passed="passed|failed" ...
!!       msg="all messages"
!!
!!    o if keep_going = .false. stop the program on a failed test
!!
!!##OPTIONS
!!     NAME          the unit test name
!!     EXPRESSION    the logical expression to evaluate
!!     msg,g1...gj   optional message to display when performing test,
!!                   composed of any scalar intrinsics of type INTEGER,
!!                   REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or
!!                   CHARACTER. A space is placed between each value.
!!     wordy         If .false. The message MSG is only displayed if the expression
!!                   is .false. . Must be used as a keyword. Default is .true. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_unit_test
!!       use M_framework, only: &
!!          & unit_test_mode,     &
!!          & unit_test_start,    &
!!          & unit_test,          &
!!          & unit_test_end,      &
!!          & unit_test_stop
!!       use M_framework, only: almost
!!
!!       implicit none
!!       integer :: i
!!       integer :: x
!!       integer,allocatable :: arr(:)
!!       real,allocatable :: arr1(:)
!!       real,allocatable :: arr2(:)
!!
!!          call unit_test_mode(keep_going=.true.,debug=.false.,command='')
!!
!!          x=10
!!          arr1=[1.0,10.0,100.0]
!!          arr2=[1.0001,10.001,100.01]
!!          call unit_test_start('myroutine')
!!
!!          call unit_test('myroutine', x > 3 ,' if big enough')
!!          call unit_test('myroutine', x < 100 ,' if small enough')
!!
!!          do i=1,size(arr1)
!!             call unit_test('myroutine', &
!!             & almost(arr1(i),arr2(i),3.9,verbose=.true.) )
!!          enddo
!!
!!          arr=[10,20,30]
!!          call unit_test('myroutine', .not.any(arr < 0) , &
!!          & 'fail if any negative values in array ARR')
!!          call unit_test('myroutine', all(arr < 100) , &
!!          & 'fail unless all values are less than 100 in array ARR')
!!
!!          call unit_test_end('myroutine', &
!!          & msg='checks on "myroutine" all passed')
!!
!!          call unit_test_stop()
!!
!!       end program demo_unit_test
!!
!! Results:
!!
!!  Sample output (varies with what optional command or modes is used):
!!
!!      >check_start: myroutine            START   :
!!      >check:       myroutine            SUCCESS :  if big enough
!!      >check:       myroutine            SUCCESS :  if small enough
!!      >*almost* for values 1.00000000 1.00010002 agreement of 3.99997139 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >*almost* for values 10.0000000 10.0010004 agreement of 3.99986792 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >*almost* for values 100.000000 100.010002 agreement of 3.99995065 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >check:       myroutine            SUCCESS : fail if any negative ...
!!      >values in array ARR
!!      >check:       myroutine            SUCCESS : fail unless all values ...
!!      >are less than 100 in array ARR
!!      >check_end:   myroutine            PASSED  : GOOD:7         BAD: ...
!!      >0 DURATION:00000000294709: checks on "myroutine" all passed
!!      >check_stop:  TALLY                PASSED  : GOOD:7         BAD: ...
!!      >0 DURATION:00000000267059
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test(name,logical_expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,force_keywd,wordy)

! ident_2="@(#) M_framework__verify unit_test(3f) assert if expression is .true. or .false. and optionally call command or stop on .false."

character(len=*),intent(in)          :: name
logical,intent(in)                   :: logical_expression
class(*),intent(in),optional         :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
type(force_keywd_hack),optional,intent(in) :: force_keywd
logical,intent(in),optional          :: wordy
character(len=:),allocatable         :: msg_all
logical                              :: wordy_local

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(present(wordy))then
      wordy_local=wordy
   else
      wordy_local=.true.
   endif

   if(G_virgin%cmdline) call cmdline_()

   msg_all=str(msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)

   if(.not.logical_expression)then
      call wrt(G_luns,CHECK_PREFIX%check//atleast_(name,G_LONGEST)//' FAILURE : '//msg_all)
      if(G_command /= '') call run(G_command//' type="check" name="'//trim(name)//'" passed="failed" msg="'//ndq(msg_all)//'"')
      if(.not.G_keep_going) then
         call wrt(G_luns,CHECK_PREFIX%check//'STOPPING PROGRAM ON FAILED TEST OF '//trim(name))
         stop 1
      endif
      IFAILED_G=IFAILED_G+1
      IFAILED_ALL_G=IFAILED_ALL_G+1
   else
      if(.not.G_brief)then
         if(wordy_local)call wrt(G_luns,CHECK_PREFIX%check//atleast_(name,G_LONGEST)//' SUCCESS : '//msg_all)
      endif
      if(G_command /= '') call run(G_command//' type="check" name="'//trim(name)//'" passed="passed" msg="'//ndq(msg_all)//'"')
      IPASSED_G=IPASSED_G+1
      IPASSED_ALL_G=IPASSED_ALL_G+1
   endif

end subroutine unit_test
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_start(3f) - [M_framework__verify] reset counters
!!    and start a new test block
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_start(name,msg,opts,matched)
!!
!!     character(len=*),intent(in)          :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!     logical,intent(out),optional         :: matched
!!
!!##DESCRIPTION
!!    unit_test_start(3f) is an initialization procedure for starting a
!!    new procedure test.
!!
!!##OPTIONS
!!    NAME   name of the procedure to test
!!    MSG    message to print
!!    OPTS   pass additional options to the optional shell command that
!!           can be assigned on the command line or by unit_test_mode(3f).
!!    MATCHED  if the match string has been set with unit_test_mode(3f)
!!             or on the command line this will return true if the name
!!             and msg concatenated with a space match the entire match
!!             string, where "*" matches any string and "?" matches any
!!             single character. This allows you to skip a test set if
!!             you wish by exiting.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_start
!!     use M_framework, only: unit_test_start, unit_test, &
!!      & unit_test_end, unit_test_mode, unit_test_stop
!!     implicit none
!!     integer :: ival
!!     logical :: matched
!!     call unit_test_mode()
!!     call test_mysub1()
!!     call test_mysub2()
!!     call unit_test_stop()
!!     contains
!!     subroutine test_mysub1() ! first test
!!     call unit_test_start('mysub1')
!!     ! the example goodbad(1) command called here takes many options
!!     ! used to build an SQLite3 entry
!!     ival=10
!!     call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
!!     call unit_test('mysub1', ival < 100 , msg=' if small enough')
!!     call unit_test_end('mysub1',msg='completed checks of "mysub1"')
!!     end subroutine test_mysub1
!!
!!     subroutine test_mysub2() ! second test
!!     call unit_test_start('mysub1','',matched=matched)
!!     ival=200
!!        if(.not.matched)return ! makes it skippable
!!        call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
!!        call unit_test('mysub1', ival < 100 , msg=' if small enough')
!!        call unit_test_end('mysub1',msg='completed checks of "mysub2"')
!!     end subroutine test_mysub2
!!
!!     end program demo_unit_test_start
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_start(name,msg,opts,force_keywd,matched)

! ident_3="@(#) M_framework__verify unit_test_start(3f) start testing procedure "name""

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: msg
character(len=*),intent(in),optional :: opts
type(force_keywd_hack), optional, intent(in) :: force_keywd
logical,intent(out),optional         :: matched
character(len=:),allocatable         :: msg_local
logical,save                         :: called=.false.

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(present(msg))then
      msg_local=trim(msg)
   else
      msg_local=''
   endif

   if(G_virgin%cmdline) call cmdline_()

   ! check optional matched string and return if string is not blank and not matched.
   ! It is assumed program will skip the subsequent test
   if(present(matched))then
      if(G_match.ne.'')then
         matched=glob_(name//' '//msg_local,G_match)
         if(.not.matched)return
      endif
      matched=.true.
   endif

   if(present(opts))then
      if(G_command /= '') call run(G_command//' type="start" name="'//trim(name)//'" msg="'//ndq(msg_local)//'" '//opts)
   else
      if(G_command /= '') call run(G_command//' type="start" name="'//trim(name)//'" msg="'//ndq(msg_local)//'"')
   endif

   call system_clock(clicks)
   duration=julian()
   if(.not.called)then
      call system_clock(clicks_all)
      duration_all=julian()
      called=.true.
   endif

   if(.not.G_brief)then
      call wrt(G_luns,CHECK_PREFIX%check_start//atleast_(name,G_LONGEST)//' START   : '//msg_local)
   endif

   IPASSED_G=0
   IFAILED_G=0

end subroutine unit_test_start
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_stop(3f) - [M_framework__verify] report tally of all checks
!!    and stop program
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_stop(msg,opts)
!!
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    give a tally of all calls to unit_test(3f) and stop program.
!!
!!    Tally up the test result totals and stop the program.
!!    If a command is set via unit_test_mode(3f) or the command line
!!    call it appending OPTS to the end of the command.
!!
!!##OPTIONS
!!     MSG  additional message to display
!!     OPTS add string to filter command line if any is specified.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_stop
!!     use M_framework, only: unit_test_start, unit_test_end, &
!!     & unit_test, unit_test_stop, unit_test_mode
!!     use,intrinsic :: iso_fortran_env, stdout=>OUTPUT_UNIT
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_mode(luns=[stdout])
!!     ! do a test
!!     call unit_test_start('proc1')
!!     call unit_test('proc1', x > 3 , 'if big enough')
!!     call unit_test('proc1', x < 100 , 'if small enough')
!!     call unit_test_end  ('proc1',msg='checks all done' )
!!     ! do another test
!!     call unit_test_start('proc2')
!!     call unit_test('proc2', x > 3 , 'if big enough')
!!     call unit_test('proc2', x < 100 , 'if small enough')
!!     call unit_test_end  ('proc2',msg='checks all done' )
!!
!!     ! tally up test results and stop program
!!     call unit_test_stop()
!!
!!     end program demo_unit_test_stop
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_stop(msg)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64

! ident_4="@(#) M_framework__verify unit_test_stop(3f) stop program with report on calls to unit_test(3f)"

character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=4096)                  :: out
character(len=:),allocatable         :: PF
integer(kind=int64)                  :: milliseconds
integer(kind=int64)                  :: clicks_now

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif
   call system_clock(clicks_now)
   milliseconds=(julian()-duration_all)*1000
   milliseconds=clicks_now-clicks_all
   PF=merge('PASSED  :','FAILED  :',ifailed_all_G == 0)
   if(PF == 'PASSED  :'.and.ipassed_all_G == 0)then
      PF='UNTESTED:'
   endif
      write(out,'("'//CHECK_PREFIX%check_stop//'",a,1x,a," GOOD: ",a," BAD: ",a," DURATION: ",i14.14)') &
       & atleast_("TALLY",G_LONGEST),     &
       & PF,                              &
       & atleast_(str(IPASSED_ALL_G),9),  &
       & atleast_(str(IFAILED_ALL_G),9),  &
       & milliseconds
   if(present(msg))then
           if(.not.G_brief.or.(IFAILED_ALL_G+IPASSED_ALL_G.eq.0).or.IFAILED_ALL_G.ne.0) &
                   & call wrt(G_luns,trim(out)//': '//trim(msg))
   else
           if(.not.G_brief.or.(IFAILED_ALL_G+IPASSED_ALL_G.eq.0).or.IFAILED_ALL_G.ne.0) &
                   & call wrt(G_luns,out)
   endif

   if(PF=='UNTESTED')then
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="untested" clicks=0 msg="',ndq(msg_local),'"',sep='') )
      stop ! EXIT_SUCCESS
   elseif(IFAILED_ALL_G == 0)then
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="passed" clicks=',milliseconds,' msg="',ndq(msg_local),'"',sep='') )
      stop ! EXIT_SUCCESS
   else
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="failed" clicks=',milliseconds,' msg="',ndq(msg_local),'"',sep='') )
      stop EXIT_FAILURE
   endif
end subroutine unit_test_stop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!! unit_test_end(3f) - [M_framework__verify] end test of procedure started
!! by unit_test_start(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_end(name,msg,opts)
!!
!!     character(len=*),intent(in) :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    A message is shown including the duration of the tests
!!    If there have been no failures the optional shell command
!!
!!        $COMMAND name="name" type="end" passed="passed|failed|untested" ...
!!        clicks=NNNN msg="message" opts
!!
!!    is executed
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_end
!!     use M_framework, only: unit_test_start
!!     use M_framework, only: unit_test
!!     use M_framework, only: unit_test_end
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     ! program execution stopped
!!     call unit_test_end ('myroutine',msg='checks on "myroutine"' )
!!
!!     end program demo_unit_test_end
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_end(name,msg,opts)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64

! ident_5="@(#) M_framework__verify unit_test_end(3f) end checking procedure "name""

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: msg
character(len=*),intent(in),optional :: opts
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local
character(len=4096)                  :: out
character(len=9)                     :: pf
integer(kind=int64)                  :: milliseconds
integer(kind=int64)                  :: clicks_now

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   PF=merge('PASSED  :','FAILED  :',ifailed_G == 0)
   if(PF == 'PASSED  :'.and.ipassed_G == 0)then
      PF='UNTESTED:'
   endif
   if(duration /= 0.0d0)then
      call system_clock(clicks_now)
      milliseconds=(julian()-duration)*1000
      milliseconds=clicks_now-clicks
      write(out,'("'//CHECK_PREFIX%check_end//'",a,  &
       & 1x,a,                            &
       & " GOOD: ",a,                     &
       & " BAD: " ,a,                     &
       & " DURATION: ",i14.14             &
       & )')                              &
       & atleast_(name,G_LONGEST),        &
       & PF,                              &
       & atleast_(str(IPASSED_G),9),      &
       & atleast_(str(IFAILED_G),9),      &
       & milliseconds
   else
      milliseconds=0
      write(out,'("'//CHECK_PREFIX%check_end//'",a,1x,a," GOOD: ",a,1x," BAD: ",a)') &
       & atleast_(name,G_LONGEST),PF,atleast_(str(IPASSED_G),9),atleast_(str(IFAILED_G),9)
   endif
   if(present(msg))then
      if(.not.G_brief.or.(IFAILED_G+IPASSED_G.eq.0).or.IFAILED_G.ne.0) then
         call wrt(G_luns,trim(out)//': '//trim(msg))
         call wrt(G_luns,'')
      endif
   else
      if(.not.G_brief.or.(IFAILED_G+IPASSED_G.eq.0).or.IFAILED_G.ne.0) then
         call wrt(G_luns,out)
         call wrt(G_luns,'')
      endif
   endif

   if(G_command /= '')then                           ! if system command name is not blank call system command
      if(ipassed_G+ifailed_G == 0)then
         call run(str(G_command,' type="end" name="',name,'" passed="untested" clicks=0',' msg="',ndq(msg),'" ',sep='') )

      elseif(ifailed_G == 0)then
         call run(str(G_command,' type="end" name="',name,'" passed="passed" clicks=',milliseconds,' msg="',ndq(msg),'" ',sep='') )
      else
         call run(str(G_command,' type="end" name="',name,'" passed="failed" clicks=',milliseconds,' msg="',ndq(msg),'" ',sep='') )
      endif
   endif

   if(ifailed_G == 0)then
      if(.not.G_keep_going) stop 1             ! stop program depending on mode
   endif

   IPASSED_G=0
   IFAILED_G=0
   duration=0.0d0

   if(paws())continue

end subroutine unit_test_end
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_bad(3f) - [M_framework__verify] call command "goodbad NAME
!!    bad" and stop program
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_bad(name,msg,opts)
!!
!!     character(len=*),intent(in) :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    unit_test_bad(3f) calls the shell command
!!
!!         goodbad NAME bad [opts]
!!
!!    and stops the program. It is just a shortcut for calling
!!         call unit_test(name,.false.)
!!         call unit_test_end(name,msg,opts)
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_bad
!!     use M_framework, only: unit_test_start, unit_test
!!     use M_framework, only: unit_test_end, unit_test_stop
!!     use M_framework, only: unit_test_bad
!!
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     if(x /= 0)then
!!       call unit_test_bad ('myroutine',msg='checks on "myroutine" failed')
!!       ! program execution stopped
!!     endif
!!     call unit_test_end ('myroutine')
!!     call unit_test_stop ('myroutine')
!!
!!     end program demo_unit_test_bad
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine unit_test_bad(name,opts,msg)

! ident_6="@(#) M_framework__verify unit_test_bad(3f) call 'goodbad NAME bad'"

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: opts
character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   call unit_test(name,.false.)
   call unit_test_end(name,opts_local,msg_local)

end subroutine unit_test_bad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_good(3f) - [M_framework__verify] call command "goodbad
!!    NAME good"
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_good(name,msg,opts)
!!
!!     character(len=*),intent(in)          :: name
!!     character(len=*),intent(in),optional :: opts
!!     character(len=*),intent(in),optional :: msg
!!
!!##DESCRIPTION
!!    A shortcut for
!!
!!       call unit_test(name,.true.)
!!       call unit_test_end(name,opts,msg)
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_good
!!     use M_framework, only: unit_test_start, unit_test_end
!!     use M_framework, only: unit_test, unit_test_good
!!
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     call unit_test_good('myroutine',msg='checks on "myroutine" ')
!!
!!     end program demo_unit_test_good
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_good(name,msg,opts)

! ident_7="@(#) M_framework__verify unit_test_good(3f) call 'goodbad NAME good'"

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: opts
character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   call unit_test(name,.true.,msg=msg_local)
   call unit_test_end(name,opts_local)

end subroutine unit_test_good
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function atleast_(line,length) result(strout)

! ident_8="@(#) M_framework__verify atleast_(3f) return string padded to at least specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=max(length,len(trim(line)))) ::  strout
   strout=line
end function atleast_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function julian()
! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19

! ident_9="@(#) M_framework__verify julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date"

real(kind=realtime)              :: julian   ! Julian Date (non-negative, but may be non-integer)
integer                          :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
integer                          :: year, month, day, utc, hour, minute
real(kind=realtime)              :: second
integer                          :: A, Y, M, JDN

   call date_and_time(values=dat)
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0d0    ! Second   ! correction for time zone and milliseconds

!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or February, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for February
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian Calendar date given the JDN (Julian day number) and time of day
   julian=JDN + dble(hour-12)/24.0d0 + dble(minute)/1440.0d0 + second/86400.0d0
end function julian
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine preset_globals()
integer :: iostat
character(len=:),allocatable :: arg0
   G_virgin%preset_globals=.false.
   G_cmdline=.true.
   G_debug=.false.
   G_keep_going=.true.
   unit_test_level=0
   unit_test_flags=[integer :: ]
   !x!G_luns=[stderr]
   G_luns=[stdout]
   G_interactive=.false.
   G_match=repeat(' ',4096)
   G_command=repeat(' ',4096)
   open(unit=999,status='scratch',iostat=iostat)
   !  values used in prefix column for various messages
   !CHECK_PREFIX=prefix( null(),null(),null(),null(),null())
   !x!CHECK_PREFIX=prefix(                  &
   !x! check_MSG    =  'check_msg:   ', &
   !x! check        =  'check:       ', &
   !x! check_START  =  'check_start: ', &
   !x! check_STOP   =  'check_stop:  ', &
   !x! check_END    =  'check_end:   '  &
   !x!)
   !x!CHECK_PREFIX=prefix(             &
   !x! check_MSG    =  ':       ', &
   !x! check        =  ':       ', &
   !x! check_START  =  ':start: ', &
   !x! check_STOP   =  ':stop:  ', &
   !x! check_END    =  ':end:   '  &
   !x!)
   arg0=getarg0_()//': '
   CHECK_PREFIX=prefix(   &
    check_MSG    =  arg0, &
    check        =  arg0, &
    check_START  =  arg0, &
    check_STOP   =  arg0, &
    check_END    =  arg0  &
   )
end subroutine preset_globals
!===================================================================================================================================
subroutine cmdline_()
use, intrinsic :: iso_fortran_env, only: compiler_version, compiler_options
! define arguments and their default values
! use naming convention of global variables to make parsing easier
logical             :: G_help = .false.
integer,allocatable :: G_flags(:)
integer             :: G_level
integer,allocatable :: G_luns_hold(:)

! NOTE: assume all names in namelist start with G_ or unit_test
namelist /args/ G_match
namelist /args/ G_level
namelist /args/ G_debug                   ! debug mode
namelist /args/ G_flags                   ! values that can be used to select different tests or any conditional integer test
namelist /args/ G_keep_going              ! logical variable that can be used to turn off program termination on errors.
namelist /args/ G_command                 ! name of command to execute. Defaults to " ".
namelist /args/ G_brief
namelist /args/ G_luns
namelist /args/ G_interactive
namelist /args/ G_help
namelist /args/ G_verbose
namelist /args/ G_silent

!    Report the beginning and end of execution of each test case or suite
!    Only run cases or collections whose description contains the given string
!    Don't colorize the output

character(len=4096), save :: input(3) = [character(len=4096) :: '&args', '', ' /'], arg
character(len=256) :: message1, message2
integer :: i, j, k, iostat, equal_pos, iend

   if (G_virgin%preset_globals) then
      call preset_globals()
   endif

   if (G_virgin%cmdline) then
      G_virgin%cmdline = .false.
      ! read arguments from command line
      G_level=-1
      G_luns_hold=G_luns
      G_luns = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
      G_flags = [(-1, i=1, 1000)]
      do i = 1, command_argument_count()
         call get_command_argument(i, arg)
         do j = 1, len_trim(arg) ! blank out leading - or / so "--name=value" or "/name=value" works
            if (index('/- ', arg(j:j))  ==  0) exit
            arg(j:j) = ' '
         enddo
         ! if variable name does not start with "unit_test" add "G_" prefix so can use a nice name
         ! on command line, on unit_test_mode, and public variables
         arg= adjustl(arg)
         if (index(arg, 'unit_test_')  ==  1) then
            arg = ' '//adjustl(arg)
         else
            arg = ' G_'//adjustl(arg)
         endif
         ! if no equal sign add =T
         if (index(arg, '=')  ==  0) then
            arg = trim(arg)//'=T'
         endif

         iend=len_trim(arg)
         input(2)=arg
         if(arg(iend:iend).ne.',')input(2)=trim(input(2))//','
         read (input, nml=args, iostat=iostat, iomsg=message1)
         ! assume first failure might be because of missing quotes
         if (iostat  /=  0) then
            equal_pos = index(arg, '=')        ! find position of '='
            if(any(G_luns < -1) ) then
               G_luns=[integer ::]
            else
               G_luns = pack(G_luns, G_luns  /=  -1)     ! if G_luns is all negative at this point set it to [stderr]
               if (size(G_luns)  ==  0) G_luns = G_luns_hold
            endif
            if (equal_pos  /=  0) then
               ! requote and try again
               arg = arg (:equal_pos)//'"'//arg (equal_pos + 1:len_trim(arg))//'"'
               iend=len_trim(arg)
               input(2)=arg
               if(arg(iend:iend).ne.',')input(2)=trim(input(2))//' ,'
               read (input, nml=args, iostat=iostat, iomsg=message2)
               if (iostat  /=  0) then
                  call wrt(G_luns, 'ERROR UNQUOTED:'//trim(message1)//': when reading '//trim(input(2)))
                  call wrt(G_luns, 'ERROR QUOTED  :'//trim(message2)//': when reading '//trim(input(2)))
                  G_command=trim(G_command)
                  G_match=trim(G_match)
                  if(G_level == -1) G_level=unit_test_level
                  do k = 1, size(G_luns)
                     write (G_luns(k), nml=args, delim='quote')
                  enddo
                  stop 2
               endif
            else
               call wrt(G_luns, 'ERROR:'//trim(message1)//': when reading '//trim(input(2)))
               G_command=trim(G_command)
               G_match=trim(G_match)
               if(G_level == -1) G_level=unit_test_level
               do k = 1, size(G_luns)
                  write (G_luns(k), nml=args, delim='quote')
               enddo
               stop 4
            endif
         endif
      enddo

      if(any(G_luns < -1) ) then
         G_luns=[integer ::]
      else
         G_luns = pack(G_luns, G_luns  /=  -1)     ! if G_luns is all negative at this point set it to [stderr]
         if (size(G_luns)  ==  0) G_luns = G_luns_hold
      endif
      G_command = trim(G_command)
      G_match=trim(G_match)
      G_flags = pack(G_flags, G_flags  >=  0)
      if(G_verbose) G_flags=[G_flags,9997,9998,9999] ! turn on these flags if verbose mode
      if(G_silent) G_luns=[999] ! turn on these flags if verbose mode
      if (size(G_flags)  /=  0) unit_test_flags = G_flags
      if(G_level /= -1) unit_test_level = G_level

      ! some pre-defined level numbers
      if (any(unit_test_flags  ==  9997)) then
         call wrt(G_luns, 'This file was compiled by ', compiler_version())
      endif

      if (any(unit_test_flags  ==  9998)) then
         call wrt(G_luns, ' using the options ', compiler_options())
      endif

      if (any(unit_test_flags  ==  9999)) then
         do i = 1, size(G_luns)
            write (G_luns(i), nml=args, delim='quote')
         enddo
      endif
   endif

   if (G_help) then
      write (*, '(g0)') [character(len=80) :: &
      'NAME                                                                            ', &
      '    unit_tests(1f) -- unit test command line options                            ', &
      'SYNOPSIS                                                                        ', &
      ' CMD --level=0 --keep_going --flags=''10000*-1'' --command="" --match=""          ', &
      ' luns=stderr,-1,-1,-1,-1 --verbose=F --brief=F --silent=F interactive=F         ', &
      '                                                                                ', &
      'DESCRIPTION                                                                     ', &
      '   When using the M_framework unit test routines options are read from the      ', &
      '   command line of any program built with the interface by default. To prevent  ', &
      '   the command line from being parsed in case the program already parses the    ', &
      '   command line add "call unit_test_mode(cmdline=.false.)" to the calling       ', &
      '   program.                                                                     ', &
      'OPTIONS                                                                         ', &
      '--command="system_command"  program to call after each test                     ', &
      '--luns=L,M,N,...    list of unit numbers to write to, assumed opened by program ', &
      '                            * 6   typically stdout                              ', &
      '                            * 0   typically stderr                              ', &
      '                            * 999 scratch file deleted when program ends        ', &
      '--match="glob expression"   string to be tested by "matched" argument on        ', &
      '                            unit_test_start(3f)                                 ', &
      '--level=N                   user-requested debug level. Sets "unit_test_level". ', &
      '--keep_going=F              turn on program termination on test failure         ', &
      '--flags=L,M,N,...           set value for user to set different test flags      ', &
      '                               values >= 9990 are reserved                      ', &
      '                                  * 9997 compiler version                       ', &
      '                                  * 9998 compiler options                       ', &
      '                                  * 9999 command line options NAMELIST group    ', &
      '--help                      display this text and exit                          ', &
      '--verbose                   verbose mode                                        ', &
      '--brief                     only display messages of failed tests               ', &
      '--silent                    no messages from unit_test procedures is produced   ', &
      '--interactive                                                                   ', &
      '--debug                                                                         ', &
      '                                                                                ', &
      'Note flags => unit_test_flags(:) and level => unit_test_level, which are        ', &
      'public members of M_framework.                                                  ', &
      'EXAMPLES                                                                        ', &
      ' sample commands:                                                               ', &
      '  fpm test                                                                      ', &
      '  fpm test -- luns=6 # write to stdout instead of stderr                        ', &
      '  fpm test ''*regression*''  # run tests containing specified start string      ', &
      '                                                                                ', &
      '  # run a test called "crash" with gdb(1)                                       ', &
      '  fpm test --target crash --runner "gdb -ex run --quiet"                        ', &
      '                                                                                ', &
      '  # run all the tests in the gdb(1) debugger (you can enter                     ', &
      '  # "q" after each test has run; or enter gdb commands at the prompt):          ', &
      '  fpm test --target ''*'' --verbose \                                           ', &
      '     --runner ''gdb -ex "list, 0" -ex run --quiet --args'' \                    ', &
      '     -- flags=9997,9998,9999 luns=6 level=3                                     ', &
      ' ']
      G_help=.false.
      stop
   endif

end subroutine cmdline_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_mode(3f) - [M_framework__verify] set testing modes
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!      subroutine unit_test_mode( keep_going, flags, luns, command, &
!!      brief, interactive, CMDLINE, debug, match)
!!
!!      logical,intent(in) :: keep_going, brief, interactive,debug
!!      integer,intent(in),allocatable :: luns(:), flags(:)
!!      character(len=*),intent(in) :: command
!!##DESCRIPTION
!!    unit_test_mode(3f) changes testing mode defaults
!!
!!##OPTIONS
!!    keep_going   keep running if a test fails. Default to TRUE
!!    flags        a list of integer values that can be accessed from
!!                 M_framework as unit_test_flags(:) for use in
!!                 selecting various tests conditionally
!!    luns         list of Fortran units to unit test messages to. Defaults
!!                 to the the value of ERROR_UNIT from the intrinsic module
!!                 ISO_FORTRAN_ENV (ie. defaults to "stderr"). It is
!!                 Assumed the units have been opened by the program.
!!    match        the string that is tested against the name and msg
!!                 specified on unit_test_start() to set the "matched"
!!                 argument.
!!    command      filter command, typically to generate reports. It is
!!                 passed data on the command line. See the example filter
!!                 "bookkeeper" for examples.
!!    brief        If present only "FAIL" messages are produced.
!!
!!    brief        Only display FAIL messages and related information
!!    verbose      verbose mode displays compiler version and options and
!!                 all standard messages.
!!    silent       no output from unit_test_*(3f) procedures
!!    interactive  prompt as each test case starts as to continue.
!!    cmdline      If set to .false. do not parse command line for options.
!!    debug        Debug mode for the M_framework package
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_mode
!!    use M_framework
!!    implicit none
!!
!!    call unit_test_mode(keep_going=.false.,luns=[6], &
!!            & brief=.true.)
!!
!!    end program demo_unit_test_mode
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_mode(debug, keep_going, level, flags, command, brief,verbose,silent,cmdline,interactive,luns,match)
logical,optional, intent(in)           :: debug
logical,optional, intent(in)           :: keep_going     ! logical variable that can be used to turn off program termination on errors.
logical,optional, intent(in)           :: cmdline        ! flag whether to parse command line for arguments or not
logical,optional, intent(in)           :: interactive
logical,optional, intent(in)           :: brief          ! flag on whether to display SUCCESS: messages
logical,optional, intent(in)           :: verbose        ! flag on whether to display all messages including addtional information
logical,optional, intent(in)           :: silent         ! do not output any messages from unit_test_*(3f) procedures
character(len=*),optional, intent(in)  :: command        ! name of command to execute. Defaults to the name
integer,optional, intent(in)           :: flags(:)       ! an  array that can be used to select different options
integer,optional, intent(in)           :: level          ! an  integer that can be used to select different debug levels
integer,optional, intent(in)           :: luns(:)        ! logical unit number to write output to
character(len=*), optional, intent(in) :: match

   if (G_virgin%preset_globals) then
      call preset_globals()
   endif

   if (present(match))                G_match=match
   if (present(luns))                 G_luns=luns
   if (present(command))              G_command=command
   if (present(debug))                G_debug=debug
   if (present(cmdline))              G_cmdline=cmdline
   if (present(interactive))          G_interactive=interactive
   if (present(keep_going))           G_keep_going=keep_going
   if (present(flags))                unit_test_flags=flags
   if (present(level))                unit_test_level=level
   if (present(brief))                G_brief=brief
   if (present(verbose))              G_verbose=verbose
   if (present(silent))               G_silent=silent

!integer,parameter,public   :: realtime=kind(0.0d0)    ! type for julian days
!integer,parameter,public   :: EXIT_SUCCESS=0
!integer,parameter,public   :: EXIT_FAILURE=1

end subroutine unit_test_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_system(3f) - [M_framework__verify] return status from
!!    system command
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function unit_test_system(cmd,verbose)
!!
!!     character(len=*),intent(in)  :: cmd
!!     logical,intent(in),optional  :: verbose
!!##DESCRIPTION
!!    unit_test_system(3f) executes a system command and returns the
!!    exit status of the command.
!!
!!##OPTIONS
!!    command    system command to execute. If it starts with "* " the
!!               asterisk is replaced by the name of the current command.
!!               If it starts with "** " the asterisks are replaced by
!!               the current command including arguments.
!!
!!    verbose    if .true. the executed command is echoed to output. The
!!               default is .false.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_system
!!    use M_framework, only: &
!!       unit_test_start,  &
!!       unit_test,        &
!!       unit_test_system, &
!!       unit_test_end
!!    implicit none
!!    if (command_argument_count()  ==  0) then
!!       call unit_test_start('myroutine')
!!       call unit_test('false', unit_test_system('false') == 0, 'check false')
!!       call unit_test('true', unit_test_system('true') == 0, 'check true')
!!       call unit_test('notthere', unit_test_system('notthere') == 0, &
!!       & 'check notthere')
!!       call unit_test('*',&
!!       & unit_test_system('* and options', verbose=.true.) == 0, 'check "*"')
!!       call unit_test_end('myroutine')
!!    else
!!       write (*, *) 'called with an option'
!!    endif
!!    end program demo_unit_test_system
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function unit_test_system(command,verbose) result(istat)
!  EXITSTAT contains the integer exit code of the command, as returned by SYSTEM.
!  CMDSTAT is set to zero if the command line was executed (whatever its exit status was).
!          If an error condition occurs and CMDSTAT is not present, error termination of execution of the image is initiated.
!     It is assigned
!      + the value -1 if the processor does not support command line execution,
!      + a processor-dependent positive value if an error condition occurs
!      + the value -2 if no error condition occurs but WAIT is present
!        with the value false and the processor does not support asynchronous
!        execution.
!      + Otherwise it is assigned the value 0.
!  CMDMSG is assigned an error message if an error has occurred. (exitstat or cmdstat or both?)
!         If an error condition occurs, it is assigned a processor- dependent explanatory message. Otherwise, it is unchanged.
character(len=*),intent(in)  :: command
logical,intent(in),optional  :: verbose
logical                      :: verbose_
integer                      :: istat
logical,parameter            :: wait=.true.
integer                      :: exitstat
integer                      :: cmdstat
character(len=256)           :: cmdmsg
character(len=:),allocatable :: command_
   if(present(verbose))then
      verbose_=verbose
   else
      verbose_=.false.
   endif
   command_=adjustl(command)//'   '
   if(index(command_,'* ') == 1)then
      command_=getarg0_()//command_(2:)
   elseif(index(command_,'** ') == 1)then
      command_=getall_()//command_(2:)
   endif
   if(verbose_)call wrt(G_luns,"command: ",command_)
   cmdmsg=' '
   call execute_command_line(command_,wait,exitstat,cmdstat,cmdmsg)
   flush(unit=6)
   if(cmdstat /= 0)then
      call wrt(G_luns,"cmdstat: ",cmdmsg,'for command :',command_)
   elseif(cmdmsg /= '')then
      call wrt(G_luns,"exitstat: ",cmdmsg,'for command :',command_)
   endif
   istat=merge(-cmdstat,exitstat,exitstat == 0.and.cmdstat /= 0)
end function unit_test_system
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getarg0_(3f) - [M_framework__verify:QUERY] get basename of the current executable
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getarg0_() result(name)
!!
!!     character(len=:),allocatable         :: getarg0_
!!
!!##DESCRIPTION
!!    getarg0_(3f) returns the name of the current executable using
!!    get_command_argument(3f) and inquire(3f). It returns only
!!    the leaf name past the last backslash or slash and trims
!!    the suffix ".exe" as well.
!!
!!##EXAMPLE
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getarg0_
!!      use M_framework__verify, only : getarg0_
!!      implicit none
!!         write(*,'(*(a))')'Running ',getarg0_()
!!      end program demo_getarg0_
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getarg0_()
! get the pathname of getarg0_
implicit none
integer                      :: getarg0__length
integer                      :: ios
integer                      :: iend
character(len=4096)          :: long_name
character(len=:),allocatable :: getarg0_
   getarg0__length=0
   getarg0_=''
   long_name=''
   call get_command_argument(0,length=getarg0__length,status=ios)
   if(ios == 0)then
      if(allocated(getarg0_))deallocate(getarg0_)
      allocate(character(len=getarg0__length) :: getarg0_)
      call get_command_argument(0,getarg0_,status=ios)
      if(ios == 0)then
         inquire(file=getarg0_,iostat=ios,name=long_name)
         if(ios == 0)then
            getarg0_=trim(long_name)
         else
            getarg0_=getarg0_
         endif
      else
         getarg0_=''
      endif
   else
      getarg0_=''
   endif
   iend=index(getarg0_,'\',back=.true.)
   if(iend.ne.0) then
      getarg0_=getarg0_(iend+1:)
   else
      iend=index(getarg0_,'/',back=.true.)
      if(iend.ne.0)getarg0_=getarg0_(iend+1:)
   endif
   iend=len_trim(getarg0_)
   if(iend.gt.4)then
      if(getarg0_(iend-3:iend)=='.exe')getarg0_=getarg0_(:iend-4)
   endif
end function getarg0_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getall_(3f) - [M_framework__verify:QUERY] get name of the current executable and options
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getall_() result(name)
!!
!!     character(len=:),allocatable         :: getall_
!!
!!##DESCRIPTION
!!    getall_(3f) returns the name of the current executable
!!    and all the arguments surrounded with double-quotes
!!
!!##EXAMPLE
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getall_
!!      use M_framework__verify, only : getall_
!!      implicit none
!!         write(*,'(*(a))')'Running ',getall_()
!!      end program demo_getall_
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getall_() result(command)
! get the pathname of arg
implicit none
character(len=:),allocatable :: arg
integer                      :: length
integer                      :: ios
integer                      :: i
character(len=:),allocatable :: command
   length=0
   command=''
   do i=1,command_argument_count()
      call get_command_argument(i,length=length,status=ios)
      if(ios == 0)then
         if(allocated(arg))deallocate(arg)
         allocate(character(len=length) :: arg)
         call get_command_argument(0,arg,status=ios)
         if(ios == 0)then
                 command=command//' "'//arg//'"'
         endif
      endif
   enddo
   command=getarg0_()//command
end function getall_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine run(command) ! convenience routine so command does not cause program to stop
character(len=*)             :: command
logical,parameter            :: wait=.true.
integer                      :: exitstat
integer                      :: cmdstat
character(len=256)           :: cmdmsg
   if(G_verbose)call wrt(G_luns,"+ ",command)
   cmdmsg=' '
   call execute_command_line(command,wait,exitstat,cmdstat,cmdmsg)
   if(cmdstat /= 0)then
      call wrt(G_luns,"cmdstat: ",cmdmsg,'for command :',command)
   elseif(cmdmsg /= '')then
      call wrt(G_luns,"exitstat: ",cmdmsg,'for command :',command)
   endif
end subroutine run
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! because of shell expansion just remove doublequote character from messages for now
function ndq(string) result(out)
character(len=*),intent(in)  :: string
character(len=len(string))   :: out
integer                      :: i
   do i=1,len(string)
      select case(string(i:i))
      case('"');    out(i:i)=' '
      case default; out(i:i)=string(i:i)
      end select
   enddo
end function ndq
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob_(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob_(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob_(3f) compares given (entire) STRING for a match to PATTERN which may
!!    contain basic wildcard "globbing" characters.
!!
!!    To get a match the entire string must be described
!!    by PATTERN. Trailing whitespace is significant, so trim the input
!!    string to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the
!!    algorithm finds an early match. To skip over the early matches insert
!!    an extra character at the end of the string and pattern that does
!!    not occur in the pattern. Typically a NULL is used (char(0)).
!!
!!##OPTIONS
!!    string   the input string to test to see if it contains the pattern.
!!    pattern  the following simple globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or pretrimmed
!!             o There is no escape character, so matching strings with
!!               literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    use M_framework, only : unit_test_glob
!!    implicit none
!!    write(*,*)glob_('abcdabcd','*cd*')
!!    write(*,*)glob_('abcdabcd','*no*')
!!    end program demo_glob
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCE
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob_(tame,wild)

! ident_10="@(#) M_strings glob_(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                    :: glob_
character(len=*)           :: tame       ! A string without wildcards
character(len=*)           :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1) :: tametext
character(len=len(wild)+1) :: wildtext
character(len=1),parameter :: NULL=char(0)
integer                    :: wlen
integer                    :: ti, wi
integer                    :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi) == '*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi) == NULL) then        ! "x" matches "*"
            glob_=.true.
            return
         endif
         if(wildtext(wi:wi)  /=  '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti)  /=  wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti) == NULL)then
                  glob_=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark /= NULL) then
            if(wildtext(wi:) /=  wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti)  /=  wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti) /= NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob_=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti > len(tametext)) then
         glob_=.false.
         return
      elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi) /= NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi) == NULL)exit
            enddo
         endif
         if (wildtext(wi:wi) == NULL)then
            glob_=.true.
            return                               ! "x" matches "x"
         endif
         glob_=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function paws()
! prompt for a letter and return try if "y" or "Y"
! maybe choice if default is T or F; maybe raw read (not portable though)
! originally was interactive with NAMELIST group for "expected" and "answer" that could be viewed
! option to pause on each unit_test(3f) as well or not; allow system commands; ...
character(len=1) :: value
integer :: iostat
logical :: paws
   paws=.false.
   if(G_interactive)then
      write(*,'(*(g0))',advance='no')'enter RETURN to continue:'
      read(*,'(a)',iostat=iostat)value
      if(iostat.eq.0)then
         select case(value)
         case('y','Y')
            paws=.true.
         case default
            paws=.false.
         end select
      endif
   endif
end function paws
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_expected(3f) - [M_framework__verify] report if two scalar values
!!    of like type and kind are equal.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental subroutine unit_test_example(name,result,expected)
!!
!!     character(len=*),intent(in)  :: name
!!     class(*),intent(in)          :: result
!!     class(*),intent(in),optional :: expected
!!
!!##DESCRIPTION
!!    A shortcut for a common call to unit_test(3f) tests the two values
!!    of like type and kind. It is equivalent to
!!
!!        call unit_test(name,result,expected,'result=',result,'expected=',.true.)
!!
!!##OPTIONS
!!     RESULT    A generated value or expression of integer, real, character,
!!               or complex type.
!!     EXPECTED  The expected value for RESULT, of the same type and kind
!!               as RESULT. If not present, it is equivalent to .TRUE.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_unit_test_expected
!!       use, intrinsic :: iso_fortran_env, only: &
!!       & stdin => input_unit, stdout => output_unit, stderr => error_unit
!!       use M_framework, only:                &
!!       &  unit_test_mode,                    &
!!       &  start     =>  unit_test_start,     &
!!       &  expected  =>  unit_test_expected,  &
!!       &  stop      =>  unit_test_stop,      &
!!       & unit_test_level, unit_test_flags
!!       implicit none
!!       logical, parameter :: T=.true., F=.false.
!!       ! optional call to change default modes
!!          call unit_test_mode(  &
!!              keep_going=T,     &
!!              flags=[0],        &
!!              luns=[stderr],    &
!!              command='',       &
!!              brief=F,          &
!!              match='',         &
!!              interactive=F,    &
!!              CMDLINE=T,        &
!!              debug=F)
!!
!!          unit_test_level=0
!!          ! unit tests for ABS(3f) intrinsic
!!          call start('abs')
!!          ! integer
!!          call expected('abs',abs(-10),10)
!!          call expected('abs',abs( 10),10)
!!          ! real and elemental
!!          call expected('abs',abs( [-10.0, 10.0]),10.0)
!!          ! complex
!!          call expected('abs',abs(( 3.0,-4.0)),5.0)
!!          call expected('abs',abs((-3.0, 4.0)),5.0)
!!          call expected('abs',abs((-3.0,-4.0)),5.0)
!!          call expected('abs',abs(( 3.0, 4.0)),5.0)
!!          call stop('abs')
!!       end program demo_unit_test_expected
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
impure elemental subroutine unit_test_expected_int32(name,result,expected)
character(len=*),intent(in) :: name
integer(kind=int32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_int32

impure elemental subroutine unit_test_expected_int64(name,result,expected)
character(len=*),intent(in) :: name
integer(kind=int64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_int64

impure elemental subroutine unit_test_expected_real32(name,result,expected)
character(len=*),intent(in) :: name
real(kind=real32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_real32

impure elemental subroutine unit_test_expected_real64(name,result,expected)
character(len=*),intent(in) :: name
real(kind=real64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_real64

impure elemental subroutine unit_test_expected_cmplx32(name,result,expected)
character(len=*),intent(in) :: name
complex(kind=real32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_cmplx32

impure elemental subroutine unit_test_expected_cmplx64(name,result,expected)
character(len=*),intent(in) :: name
complex(kind=real64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_cmplx64

impure elemental subroutine unit_test_expected_char(name,result,expected)
character(len=*),intent(in) :: name
character(len=*),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_char

impure elemental subroutine unit_test_expected_boolean(name,result,expected)
character(len=*),intent(in) :: name
logical,intent(in) :: result,expected
   call unit_test(name,result .eqv. expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_boolean

impure elemental subroutine unit_test_expected_onoff(name,result)
character(len=*),intent(in) :: name
logical,intent(in) :: result
   call unit_test(name,result,'result=',result,'expected=',.true.)
end subroutine unit_test_expected_onoff
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__verify
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================


!>>>>> build/dependencies/M_framework/src/M_framework__approx.F90

module M_framework__approx
use, intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64 !  1           2           4           8
use, intrinsic :: iso_fortran_env,  only : real32, real64, real128   !  4           8          10
use, intrinsic :: iso_fortran_env,  only : ERROR_UNIT,OUTPUT_UNIT    ! access computing environment
implicit none
private
! COMPARING AND ROUNDING FLOATING POINT VALUES
public  :: almost          ! function compares two numbers only up to a specified number of digits
public  :: accdig          ! compare two real numbers only up to a specified number of digits
public  :: in_margin       ! check if two reals are approximately equal using a relative margin
public  :: round_to_power  ! round val to specified number of digits after the decimal point
public  :: round           ! round val to specified number of significant digits
public  :: significant     ! round val to specified number of significant digits
public  :: compare_float
public  :: operator (.equalto.)
public  :: operator (.greaterthan.)
public  :: operator (.lessthan.)
!===========================
! deprecated
public  :: sp_accdig       ! compare two real numbers only up to a specified number of digits
public  :: dp_accdig       ! compare two double numbers or other kinds only up to a specified number of digits
interface dp_accdig        ! for backward compatibility, accdig(3f) preferred
   module procedure accdig
end interface dp_accdig
!===========================

interface significant
   module procedure significant_real32
   module procedure significant_real64
end interface significant

private :: anyscalar_to_realbig_
private :: anyscalar_to_double_

interface compare_float
   module procedure compare_float_real32
   module procedure compare_float_real64

   module procedure compare_float_real128

end interface compare_float

interface operator (.equalto.)
   module procedure is_equal_to_real32
   module procedure is_equal_to_real64

   module procedure is_equal_to_real128

end interface operator (.equalto.)

interface operator (.greaterthan.)
   module procedure is_greater_than_real32
   module procedure is_greater_than_real64

   module procedure is_greater_than_real128

end interface operator (.greaterthan.)

interface operator (.lessthan.)
   module procedure is_less_than_real32
   module procedure is_less_than_real64

   module procedure is_less_than_real128

end interface operator (.lessthan.)
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    almost(3f) - [M_framework__approx] return true or false if two numbers
!!    agree up to specified number of digits
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    elemental impure function almost(x,y,digits,verbose)
!!
!!     class(*),intent(in)         :: x,y
!!     class(*),intent(in)         :: rdigits
!!     logical,intent(in),optional :: verbose
!!     logical                     :: almost
!!
!!##DESCRIPTION
!!    Returns true or false depending on whether the two numbers given agree
!!    to within the specified number of digits as calculated by ACCDIG(3f).
!!##OPTIONS
!!    x,y      expected and calculated values to be compared. May be of
!!             type REAL, INTEGER, or DOUBLEPRECISION.
!!    rdigits  number of digits of precision to compare. May be INTEGER or
!!             REAL.
!!    verbose  optional value that specifies to print the results of the
!!             comparison when set to .TRUE..
!!##RETURNS
!!    almost   TRUE if the input values compare up to the specified number
!!             of values
!!##EXAMPLE
!!
!!   sample:
!!
!!    program demo_almost
!!    use M_framework__approx, only : almost
!!    implicit none
!!    real    :: x, y
!!    logical :: z
!!    integer :: i
!!    x=1.2345678
!!    y=1.2300000
!!    do i=1,8
!!       z=almost(x,y,i,verbose=.true.)
!!       write(*,*)i,z
!!    enddo
!!    end program demo_almost
!!
!!   Results:
!!
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 1.00000000
!!     >            1 T
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 2.00000000
!!     >            2 T
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 3.00000000
!!     >            3 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 4.00000000
!!     >            4 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 5.00000000
!!     >            5 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 6.00000000
!!     >            6 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 7.00000000
!!     >            7 F
!!     > *sp_accdig* significant digit request too high= 8.00000000
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 8.00000000
!!     >            8 F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental impure function almost(x,y,digits,verbose)
use M_framework__journal,  only : journal

! ident_1="@(#) M_framework__approx almost(3f) function compares two real numbers up to specified number of digits by calling ACCDIG(3f)"

class(*),intent(in)         :: x,y
class(*),intent(in)         :: digits
logical,intent(in),optional :: verbose
logical                     :: almost

logical                     :: verbose_local
real                        :: acurcy
real                        :: digits_local
integer                     :: ind

   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif

   digits_local=anyscalar_to_realbig_(digits)
   acurcy=0.0
   select type(x)
   type is(real)
      select type(y)
      type is(real)
         call accdig(x,y,digits_local,acurcy,ind)
         if(verbose_local)then
            call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
         endif
      class default
         call accdig(x,y,digits_local,acurcy,ind)
         if(verbose_local)then
            call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
         endif
      end select
   class default
      call accdig(x,y,digits,acurcy,ind)
      if(verbose_local)then
         call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
      endif
   end select

   if(ind == 0)then
      almost=.true.
   else
      almost=.false.
   endif

end function almost
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    sp_accdig(3f) - [M_framework__approx] compare two real numbers of
!!    default kind only up to a specified number of digits
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine sp_accdig(x,y,digio,acurcy,ind)
!!
!!        real,intent(in)     :: X
!!        real,intent(in)     :: Y
!!        real,intent(in)     :: DIGI0
!!        real,intent(out)    :: acurcy
!!        integer,intent(out) :: ind
!!
!!##DESCRIPTION
!!    This procedure is used to check how closely two numbers agree.
!!
!!       call sp_accdig(X,Y,DIGI0,ACURCY,IND)
!!
!!    The values X and Y are the numbers to compare, and DIGI0 is the
!!    threshold number of digits to consider significant in returning IND.
!!
!!    If X and Y are considered equal within DIGI0 relative tolerance,
!!
!!        IND    = 0, if tolerance is     satisfied.
!!               = 1, if tolerance is not satisfied.
!!
!!    The result ACURCY gives a measure of the number of leading digits in X
!!    which are the same as the number of leading digits in Y.
!!
!!            ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0
!!            ACURCY=-log10(X-Y)       if X != Y and Y = 0
!!            ACURCY=8                 if X=Y
!!
!!            ACURCY is never less than -8 or greater than 8
!!
!!    TOLERANCE ...
!!         X and Y are considered equal within DIGI0 relative tolerance,
!!         if ACURCY is greater than DIGI0.
!!
!!    For example, Take some numbers and compare them to 1.2345678 ...
!!
!!        > ================================================
!!        > A number     |    ACURCY       |   ACURCY
!!        >              |    1.2345678=Y  |   1.2345678=X
!!        > ================================================
!!        >  1.234680    |    3.7900571    |   3.7901275
!!        >  1.2345378   |    4.6144510    |   4.6144404
!!        >  2.2234568   |    0.096367393  |   0.35188114
!!        >  1.2345678   |    8.0000000    |   8.0000000
!!        >  1.2345679   |    7.0732967    |   7.0731968
!!        > -1.2345678   |   -0.30103000   |  -0.30103000
!!        > 76.234567    |   -1.7835463    |   0.0070906729
!!        >  2.4691356   |    0.0          |   0.3010300
!!        >  0.0         |    0.0          |  -0.91514942.
!!
!!    Due to the typical limits of the log function, the number of
!!    significant digits in the result is best considered to be three.
!!
!!    Notice that 1.2345678=Y produces different values than 1.2345678=X
!!
!!    A negative result indicates the two values being compared either do
!!    not agree in the first digit or they differ with respect to sign. An
!!    example of two numbers which do not agree in their leading digit (and
!!    actually differ in order of magnitude) is given above by X=76.234567
!!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of
!!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678;
!!    here the accuracy reported is -0.30103000.
!!
!!##EXAMPLE
!!
!!
!!   Example program:
!!
!!    program demo_sp_accdig ! fortran 90 example
!!    use M_framework__approx, only : sp_accdig
!!    implicit none
!!    integer :: digi
!!    integer :: i10, i20, i30
!!    integer :: ind, ind1, ind2
!!    real    :: acurcy, acurcy1, acurcy2
!!    real    :: a, b
!!    real    :: vals(9)
!!    data vals/ &
!!      &1.234680,   1.2345378,  2.2234568, 1.2345678, &
!!      &1.2345679, -1.2345678, 76.234567,  2.4691356, &
!!      &0.0/
!!       write(*,*)'========================='
!!       do i10=0,16
!!          a=1.0
!!          b=a+1.0/(10.0**i10)
!!          call sp_accdig(a,b,8.0,acurcy,ind)
!!          write(*,*)i10,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       digi=16
!!       do i20=0,digi
!!          a=1.0
!!          b=a+1.0/(10.0**i20)
!!          call sp_accdig(a,b,real(digi),acurcy,ind)
!!          write(*,*)i20,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       do i30=1,9
!!          call sp_accdig(1.2345678,vals(i30),8.0,acurcy1,ind1)
!!          call sp_accdig(vals(i30),1.2345678,8.0,acurcy2,ind2)
!!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2
!!       enddo
!!    end program demo_sp_accdig
!!
!!##REFERENCES
!!
!!   based on ...
!!
!!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. accdig V 7.00  2/14/90. **
!!       David Hogben,
!!       Statistical Engineering Division,
!!       Center for Computing and Applied Mathematics,
!!       A337 Administration Building,
!!       National Institute of Standards and Technology,
!!       Gaithersburg, MD 20899
!!                      TELEPHONE 301-975-2845
!!           ORIGINAL VERSION -  October, 1969.
!!            CURRENT VERSION - February, 1990.
!!            JSU     VERSION - February, 1991.
!!
!!##DEPENDENCIES
!!    o M_framework__journal(),log10(), abs(1)
!!
!!##AUTHOR
!!    David Hogben, John S. Urban
!!
!!##LICENSE
!!    Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE sp_accdig(X,Y,digi0,ACURCY,IND)
use M_framework__journal, only : journal
implicit none

! ident_2="@(#) M_framework__approx sp_accdig(3f) compare two real numbers only up to a specified number of digits"

!     INPUT ...
real,intent(in) :: x           ! First  of two real numbers to be compared.
real,intent(in) :: y           ! Second of two real numbers to be compared.
real,intent(in) :: digi0       ! Number of digits to be satisfied in relative tolerance.
!     OUTPUT ...
real,intent(out)    :: acurcy  ! = -LOG10(ABS((X-Y)/Y)))
integer,intent(out) :: ind     ! = 0, If tolerance is     satisfied.
! = 1, If tolerance is not satisfied.

real     :: diff
real     :: digi
integer,parameter  :: ireal_significant_digits = int(log10(2.**digits(0.0))) ! maximum number of significant digits in a real number.

   digi=digi0
   if(digi <= 0)then
      call journal('sc','*sp_accdig* bad number of significant digits=',digi)
      digi=ireal_significant_digits
   elseif(digi  >  ireal_significant_digits)then
      call journal('sc','*sp_accdig* significant digit request too high=',digi)
      digi=min(digi,real(ireal_significant_digits))
   endif

   diff = x - y
   if(diff  ==  0.0) then
      acurcy = ireal_significant_digits
   elseif(y  ==  0.0) then
      acurcy = -log10(abs(x))
   else
      acurcy = -log10(abs(diff)) + log10(abs(y))
   endif

   if(acurcy  <  digi ) then
      ind = 1
   else
      ind = 0
   endif

END SUBROUTINE sp_accdig
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!      accdig(3f) - [M_framework__approx] compare two numbers only up to
!!      a specified number of digits
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       elemental impure subroutine accdig(x,y,digio,acurcy,ind)
!!
!!        class(*),intent(in)  :: X
!!        class(*),intent(in)  :: Y
!!        class(*),intent(in)  :: DIGI0
!!        real,intent(out)     :: acurcy
!!        integer,intent(out)  :: ind
!!
!!##DESCRIPTION
!!
!!    This procedure is used to check how closely two numbers agree.
!!
!!       call accdig(X,Y,DIGI0,ACURCY,IND)
!!
!!    The values X and Y are the numbers to compare, and DIGI0 is the
!!    threshold number of digits to consider significant in returning IND.
!!
!!    If X and Y are considered equal within DIGI0 relative tolerance,
!!
!!        IND    = 0, if tolerance is     satisfied.
!!               = 1, if tolerance is not satisfied.
!!
!!    The result ACURCY gives a measure of the number of leading digits in X
!!    which are the same as the number of leading digits in Y.
!!
!!         ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0
!!         ACURCY=-log10(X-Y)       if X != Y and Y = 0
!!         ACURCY=8                 if X=Y
!!
!!         ACURCY is never less than -8 or greater than 8 for 32-bit REAL values
!!
!!    TOLERANCE ...
!!         X and Y are considered equal within DIGI0 relative tolerance,
!!         if ACURCY is greater than DIGI0.
!!
!!    For example, Take some numbers and compare them  to 1.2345678 ...
!!
!!       >  ================================================
!!       >  A number     |    ACURCY       |   ACURCY
!!       >               |    1.2345678=Y  |   1.2345678=X
!!       >  ================================================
!!       >   1.234680    |    3.7900571    |   3.7901275
!!       >   1.2345378   |    4.6144510    |   4.6144404
!!       >   2.2234568   |    0.096367393  |   0.35188114
!!       >   1.2345678   |    8.0000000    |   8.0000000
!!       >   1.2345679   |    7.0732967    |   7.0731968
!!       >  -1.2345678   |   -0.30103000   |  -0.30103000
!!       >  76.234567    |   -1.7835463    |   0.0070906729
!!       >   2.4691356   |    0.0          |   0.3010300
!!       >   0.0         |    0.0          |  -0.91514942.
!!
!!    Due to the typical limits of the log function, the number of
!!    significant digits in the result is best considered to be three.
!!
!!    Notice that 1.2345678=Y produces different values than 1.2345678=X
!!
!!    A negative result indicates the two values being compared either do
!!    not agree in the first digit or they differ with respect to sign. An
!!    example of two numbers which do not agree in their leading digit (and
!!    actually differ in order of magnitude) is given above by X=76.234567
!!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of
!!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678;
!!    here the accuracy reported is -0.30103000.
!!
!!##EXAMPLE
!!
!!
!!   Example program:
!!
!!    program demo_accdig ! fortran 90 example
!!    use M_framework__approx, only : accdig
!!    implicit none
!!    integer         :: digi
!!    doubleprecision :: a, b
!!    integer         :: i10, i20, i30
!!    integer         :: ind, ind1, ind2
!!    real            :: acurcy, acurcy1, acurcy2
!!    doubleprecision :: vals(9)
!!    data vals/ &
!!      &1.234680d0,   1.2345378d0,  2.2234568d0, 1.2345678d0, &
!!      &1.2345679d0, -1.2345678d0, 76.234567d0,  2.4691356d0, &
!!      &0.0d0/
!!       write(*,*)'========================='
!!       do i10=0,16
!!          a=1.0d0
!!          b=a+1.0d0/(10.0d0**i10)
!!          call accdig(a,b,8.0,acurcy,ind)
!!          write(*,*)i10,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       digi=16
!!       do i20=0,digi
!!          a=1.0d0
!!          b=a+1.0d0/(10.0d0**i20)
!!          call accdig(a,b,dble(digi),acurcy,ind)
!!          write(*,*)i20,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       do i30=1,9
!!          call accdig(1.2345678d0,vals(i30),8.0,acurcy1,ind1)
!!          call accdig(vals(i30),1.2345678d0,8.0,acurcy2,ind2)
!!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2
!!       enddo
!!    end program demo_accdig
!!
!!##NOTES
!!##REFERENCES
!!
!!   based on ...
!!
!!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. **
!!       David Hogben,
!!       Statistical Engineering Division,
!!       Center for Computing and Applied Mathematics,
!!       A337 Administration Building,
!!       National Institute of Standards and Technology,
!!       Gaithersburg, MD 20899
!!                      TELEPHONE 301-975-2845
!!           ORIGINAL VERSION -  October, 1969.
!!            CURRENT VERSION - February, 1990.
!!            JSU     VERSION - February, 1991.
!!
!!##DEPENDENCIES
!!         o M_framework__journal(), log10(), abs(1)
!!
!!##AUTHORS
!!      David Hogben, John S. Urban
!!
!!##LICENSE
!!      Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
elemental impure SUBROUTINE accdig(x,y,digi0,ACURCY,IND)

use,intrinsic :: iso_fortran_env, only : wp=>real128

use M_framework__journal,  only : journal
implicit none

! ident_3="@(#) M_framework__approx accdig(3f) compare two values only up to a specified number of digits"

!  INPUT ...
class(*),intent(in)  :: x           ! FIRST  OF TWO NUMBERS TO BE COMPARED.
class(*),intent(in)  :: y           ! SECOND OF TWO NUMBERS TO BE COMPARED.
class(*),intent(in)  :: digi0       ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE.
real(kind=wp)        :: x_local
real(kind=wp)        :: y_local
!  OUTPUT ...
real,intent(out)     :: acurcy      ! = -LOG10(ABS((x_local-y_local)/y_local)))
integer,intent(out)  :: ind         ! = 0, IF TOLERANCE IS     SATISFIED.
                                    ! = 1, IF TOLERANCE IS NOT SATISFIED.
real(kind=wp)        :: diff
real(kind=wp)        :: digi
                        ! Maximum number of significant digits in a number of biggest real kind.
integer,parameter    :: idble_significant_digits = int(log10(2.0_wp**digits(0.0_wp)))

   x_local=anyscalar_to_realbig_(x)
   y_local=anyscalar_to_realbig_(y)
   digi=anyscalar_to_realbig_(digi0)

   if(digi <= 0)then
      call journal('sc','*accdig* bad number of significant digits=',real(digi,kind=wp))
      digi=idble_significant_digits
   elseif(digi  >  idble_significant_digits)then
      call journal('sc','*accdig* significant digit request too high=',real(digi,kind=wp))
      digi=min(digi,real(idble_significant_digits,kind=wp))
   endif
   diff = x_local - y_local
   if(diff  ==  0.0_wp) then
      acurcy = idble_significant_digits
   elseif(y_local  ==  0.0_wp) then
      acurcy = -log10(abs(x_local))
   else
      acurcy = -log10(abs(diff)) + log10(abs(y_local))
   endif
   if(acurcy  <  digi ) then
      ind = 1
   else
      ind = 0
   endif
end subroutine accdig
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!   in_margin(3f) - [M_framework__approx] check if two reals are
!!   approximately equal using a relative margin
!!
!!##SYNOPSIS
!!
!!     elemental pure function in_margin( expected_value, measured_value,
!!     allowed_margin )
!!
!!      real, intent(in)    :: expected_value
!!      real, intent(in)    :: measured_value
!!      real, intent(in)    :: allowed_margin
!!      class(*),intent(in) :: invalue
!!
!!##DESCRIPTION
!!   Compare two values to see if they are relatively equal using the
!!   specified allowed margin. That is, see if VALUE_MEASURED is in
!!   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error
!!   varies with the magnitude of the values, such that the allowed error
!!   is margin * average magnitude of measured and expected).
!!
!!   So the allowed error is smaller when the magnitudes are smaller.
!!
!!##OPTIONS
!!   expected_value   First value
!!   measured_value   Second value
!!   allowed_margin   Allowed relative margin
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_in_margin
!!    use :: M_framework__approx, only : in_margin
!!    implicit none
!!    write(*,*) in_margin(4.00000,3.99999,0.000000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.00000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.0000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.000001)
!!
!!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
!!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.000001)
!!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
!!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.00001)
!!
!!    write(*,*) in_margin(4.00000,3.99999,0.00001)
!!    write(*,*) in_margin(4.00000,3.99999,0.0001)
!!    write(*,*) in_margin(4.00000,3.99999,0.001)
!!    write(*,*) in_margin(4.00000,3.99999,0.01)
!!
!!    end program demo_in_margin
!!
!!   Results:
!!
!!        > F
!!        > F
!!        > F
!!        > F
!!        > F F F F F
!!        > F F F F T
!!        > T
!!        > T
!!        > T
!!        > T
!===================================================================================================================================
elemental impure function in_margin(expected_value, measured_value, allowed_margin)
implicit none

! ident_4="@(#) M_framework__approx in_margin(3f) check if two reals are approximately equal using a relative margin"

class(*),intent(in) :: expected_value, measured_value, allowed_margin
logical             :: in_margin

   doubleprecision     :: expected, measured, margin

   expected=anyscalar_to_double_(expected_value)
   measured=anyscalar_to_double_(measured_value)
   margin=anyscalar_to_double_(allowed_margin)

   if ( abs(expected-measured) > 0.50d0 * margin * (abs(expected)+abs(measured)) ) then
      in_margin=.false.  ! values not comparable
   else
      in_margin=.true.   ! values comparable
   endif

end function in_margin
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function round_to_power(val,n)

! ident_5="@(#) M_framework__approx round_to_power(3f) round val to specified given decimal (power) position"

real,intent(in) :: val
integer,intent(in) :: n
real :: round_to_power
   round_to_power = anint(val*10.0**n)/10.0**n
end function round_to_power
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function round(val,idigits0)
implicit none

! ident_6="@(#) M_framework__approx round(3f) round val to specified number of significant digits"

integer,parameter          :: dp=kind(0.0d0)
real(kind=dp),intent(in)   :: val
integer,intent(in)         :: idigits0
   integer                 :: idigits,ipow
   real(kind=dp)           :: aval,rnormal
   real(kind=dp)           :: round
!  this does not work very well because of round-off errors.
!  Make a better one, probably have to use machine-dependent bit shifting
   ! make sure a reasonable number of digits has been requested
   idigits=max(1,idigits0)
   aval=abs(val)
!  select a power that will normalize the number
!  (put it in the range 1 > abs(val) <= 0)
   if(aval >= 1)then
      ipow=int(log10(aval)+1)
   else
      ipow=int(log10(aval))
   endif
   rnormal=val/(10.0d0**ipow)
   if(rnormal == 1)then
      ipow=ipow+1
   endif
   !normalize, multiply by 10*idigits to an integer, and so on
   round=real(anint(val*10.d0**(idigits-ipow)))*10.d0**(ipow-idigits)
end function round
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   significant(3f) - [M_framework__approx] round val to specified number
!!   of significant digits
!!
!!##SYNOPSIS
!!
!!     pure elemental function significant(val,digits,round)
!!
!!      real,intent(in)                      :: val
!!      integer,intent(in)                   :: digits
!!      character(len=*),intent(in),optional :: round
!!      real                                 :: significant
!!
!!##DESCRIPTION
!!
!! Round real value to specified number of significant digits
!!
!!##OPTIONS
!!
!! val     value to round
!! digits  number of significant digits to produce
!! round   Use the round edit descriptor
!!
!!           RU  UP : the value resulting from conversion shall be the
!!                    smallest representable value that is greater than or
!!                    equal to the original value
!!           RD  DOWN : the value resulting from conversion shall be the
!!                    largest representable value that is less than or
!!                    equal to the original value
!!           RZ  ZERO : the value resulting from conversion shall be the value
!!                    closest to the original value and no greater in
!!                    magnitude than the original value.
!!           RN  NEAREST : modeis NEAREST,thevalueresulting from conversion
!!                        shall be the closer of the two nearest
!!                        representable values if one is closer than the
!!                        other. If the two nearest representable values
!!                        are equidistant from the original value, it is
!!                        processor dependent which one of them is chosen.
!!           RC  COMPATIBLE : the value resulting from conversion shall be
!!                          the closer of the two nearest representable
!!                          values or the value away from zero if halfway
!!                          between them.
!!           RP  PROCESSOR_DEFINED : rounding during conversion shall be
!!                                   a processor-dependent default mode,
!!                                   which may correspond to one of the
!!                                   other modes.
!!
!!##EXAMPLE
!!
!!  Sample program
!!
!!    program demo_significant
!!    use M_framework__approx, only : significant
!!    implicit none
!!    integer :: i
!!    real :: r, v
!!    character(len=*),parameter :: g='(*(g0.7,1x))'
!!
!!       write(*,g)significant([8765.43210,0.1234567890],5)
!!
!!       write(*,*)'default:',1.23456789012345
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9])
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RU'),'RU'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RD'),'RD'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RZ'),'RZ'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RN'),'RN'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RC'),'RC'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RP'),'RP'
!!    end program demo_significant
!!
!!   Results:
!!
!!       > 8765.400 .1234600
!!       >  default:   1.234568
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568
!!       > 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RU
!!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
!!       > 1.234567 1.234568 1.234568 RD
!!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
!!       > 1.234567 1.234568 1.234568 RZ
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RN
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RC
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RP
pure elemental function significant_real32(val,digits,round) result(significant)

! ident_7="@(#) M_framework__approx significant_real32(3f) round val to specified number of significant digits"

integer,parameter :: wp=real32
real(kind=wp),intent(in)             :: val
integer,intent(in)                   :: digits
character(len=*),intent(in),optional :: round
real(kind=wp)                        :: significant
character(len=80)                    :: line,fmt
   if(present(round))then
      write(fmt,'("(",a,",e0.",i0,")")')trim(round),digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   else
      write(fmt,'("(e0.",i0,")")')digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   endif
   write(line,fmt)val                  ! write with specified number of significant diguts
   read(line,'(e80.30)')significant    ! read back into a value
end function significant_real32
!-----------------------------------------------------------------------------------------------------------------------------------
pure elemental function significant_real64(val,digits,round) result(significant)

! ident_8="@(#) M_framework__approx significant_real64(3f) round val to specified number of significant digits"

integer,parameter :: wp=real64
real(kind=wp),intent(in)             :: val
integer,intent(in)                   :: digits
character(len=*),intent(in),optional :: round
real(kind=wp)                        :: significant
character(len=80)                    :: line,fmt
   if(present(round))then
      write(fmt,'("(",a,",d0.",i0,")")')trim(round),digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   else
      write(fmt,'("(d0.",i0,")")')digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   endif
   write(line,fmt)val                  ! write with specified number of significant diguts
   read(line,'(d80.30)')significant    ! read back into a value
end function significant_real64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function anyscalar_to_realbig_(valuein) result(d_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit

use,intrinsic :: iso_fortran_env, only : wp=>real128

implicit none

! ident_9="@(#) M_framework__approx anyscalar_to_realbig_(3f) convert integer or real parameter of any kind to real128 or biggest available"

class(*),intent(in)          :: valuein
real(kind=wp)           :: d_out
character(len=3)             :: readable
   select type(valuein)
   type is (integer(kind=int8));   d_out=real(valuein,kind=wp)
   type is (integer(kind=int16));  d_out=real(valuein,kind=wp)
   type is (integer(kind=int32));  d_out=real(valuein,kind=wp)
   type is (integer(kind=int64));  d_out=real(valuein,kind=wp)
   type is (real(kind=real32));    d_out=real(valuein,kind=wp)
   type is (real(kind=real64));    d_out=real(valuein,kind=wp)

   Type is (real(kind=real128));   d_out=valuein

   type is (logical);              d_out=merge(0.0_wp,1.0_wp,valuein)
   type is (character(len=*));     read(valuein,*) d_out
   class default
    !!d_out=huge(0.0_wp)
    readable='NaN'
    read(readable,*)d_out
    !!stop '*M_framework__approx::anyscalar_to_realbig_: unknown type'
   end select
end function anyscalar_to_realbig_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function anyscalar_to_double_(valuein) result(d_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
implicit none

! ident_10="@(#) M_framework__approx anyscalar_to_double_(3f) convert integer or real parameter of any kind to doubleprecision"

class(*),intent(in)       :: valuein
doubleprecision           :: d_out
doubleprecision,parameter :: big=huge(0.0d0)
   select type(valuein)
   type is (integer(kind=int8));   d_out=dble(valuein)
   type is (integer(kind=int16));  d_out=dble(valuein)
   type is (integer(kind=int32));  d_out=dble(valuein)
   type is (integer(kind=int64));  d_out=dble(valuein)
   type is (real(kind=real32));    d_out=dble(valuein)
   type is (real(kind=real64));    d_out=dble(valuein)

   Type is (real(kind=real128))

      !!if(valuein > big)then
      !!   write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein
      !!endif
      d_out=dble(valuein)
   type is (logical);              d_out=merge(0.0d0,1.0d0,valuein)
   type is (character(len=*));      read(valuein,*) d_out
   !type is (real(kind=real128))
   !   if(valuein > big)then
   !      write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein
   !   endif
   !   d_out=dble(valuein)
   class default
     d_out=0.0d0
     !!stop '*M_framework__approx::anyscalar_to_double_: unknown type'
   end select
end function anyscalar_to_double_

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!##NAME
!!    compare_float(3f) - [M_framework__approx] compare floating point
!!    values with adjustable tolerance.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     result = compare_float( x, y,ulp = SCALING_VALUE)
!!
!!      elemental function (x,y,ulp)
!!      real(kind=KIND),intent(in) :: x,y
!!      real|integer,intent(in),optional :: ulp
!!
!!     Additional convenience operators:
!!
!!        X.equalto.Y
!!        X.lessthan.Y
!!        X.greaterthan.Y
!!
!!##DESCRIPTION
!!    compare_float(3f) is a function for comparing floating point numbers
!!    within an automatically adjusted tolerance.
!!
!!    The test performed is
!!
!!        abs( x - y ) < ( ulp * spacing( max(abs(x),abs(y)) ) )
!!
!!    If the result is .TRUE., the numbers are considered equal.
!!    Both single and double precision scalar and array numbers can
!!    be compared, as the function is elemental.
!!
!!    As a convenience relational operators .EqualTo., .GreaterThan.,
!!    and .LessThan. are provided. These are based on the
!!    compare_float(3f) function using the commonly used default
!!    scaling of ULP=1.
!!
!!##DETAILS
!!
!!    It is generally acknowledged that real numbers should not be
!!    compared directly but within some tolerance. However, the magnitude
!!    of an appropriate tolerance value will vary depending on the
!!    magnitudes of the numbers being compared and the precision of the
!!    computing environment.
!!
!!    The Fortran standard does not specify functions or operators
!!    specifically for comparing float values, but leaves some latitude in
!!    how the compilers address floating point comparisions. It does
!!    specify functions that return platform-specific values useful in
!!    applying different methods to the problem such as
!!
!!     + digits(3f)        - Significant digits in the numeric model
!!     + epsilon(3f)       - Epsilon function
!!     + exponent(3f)      - Exponent of floating-point number
!!     + fraction(3f)      - Fractional part of the model representation
!!     + huge(3f)          - Largest number of a type and kind
!!     + maxexponent(3f)   - Maximum exponent of a real kind
!!     + minexponent(3f)   - Minimum exponent of a real kind
!!     + nearest(3f)       - Nearest representable number
!!     + precision(3f)     - Decimal precision of a real kind
!!     + radix(3f)         - Base of a numeric model
!!     + range(3f)         - Decimal exponent range of a numeric kind
!!     + rrspacing(3f)     - Reciprocal of the relative spacing of a numeric type
!!     + scale(3f)         - Scale a real value by a whole power of the radix
!!     + set_exponent(3f)  - real value with specified exponent
!!     + spacing(3f)       - Smallest distance between two numbers of a given type
!!     + tiny(3f)          - Smallest positive number of a real kind
!!
!!    Books have been written on the behavior of floating point math.
!!
!!    As is used here, a commonly used simple general floating point
!!    comparison algorithm is
!!
!!        if(abs(x < y) < (ulp * spacing(max(abs(x),abs(y))))) then
!!          :
!!        endif
!!
!!    where the intrinsic function SPACING(3f) determines the distance
!!    between the argument X and the nearest adjacent representable number
!!    of the same type and ULP is an optional user-supplied scaling factor.
!!
!!##OPTIONS
!!
!!    x,y   Two congruent floating point values to compare.
!!
!!    ulp   The ULP ("unit in the last place") scaling value allows for
!!          users to control the scaling of the value returned by SPACING(3f)
!!          in order to relax or tighten what is considered "equal". That
!!          is, the ULP value can be used to scale the comparison based
!!          on knowledge of the "numerical quality" of the values being used
!!          in the comparision.
!!
!!          The value should be positive. The absolute value of the value is
!!          taken if it is negative.
!!
!!          The default ULP scaling value is 1.0.
!!
!!          The value may be of type integer or real.
!!
!!          A 0.5 ULP maximum error is the best you could hope for, since
!!          this corresponds to always rounding to the nearest representable
!!          floating point number.
!!##RESULT
!!
!!    The return value is a logical value indicating whether the inputs
!!    are equal to within the requested precision.
!!
!!##OPERATORS
!!
!! Additional operators based on compare_float(3f) are included:
!!
!! X.equalto.Y  If the result is .TRUE., the numbers are considered equal.
!!              The test performed is
!!
!!                abs( x - y ) < spacing( max(abs(x),abs(y)) )
!!
!! X.greaterthan.Y  If the result is .TRUE., x is considered greater than y.
!!                  The result is a logical value indicating whether the
!!                  operand x is greater than y by more than the spacing
!!                  between representable floating point numbers.
!!
!!                  The test performed is
!!
!!                   ( x - y ) >= SPACING( MAX(ABS(x),ABS(y)) )
!! X.lessthan.Y  Test if one operand is less than another.
!!               The result is a logical value indicating whether
!!               the operand x is less than y by more than the
!!               spacing between representable floating point
!!               numbers.
!!
!!               The test performed is
!!
!!                  ( y - x ) >= SPACING( MAX(ABS(x),ABS(y)) )
!!
!!               If the result is .TRUE., x is considered less than y.
!!
!!##EXAMPLES
!!
!!
!!   use m_compare_float_numbers
!!   real :: x, y
!!   if ( compare_float( x, y, ulp=5.0 ) ) ) then
!!     ! what to do when x effectively equals y
!!   endif
!!
!!   For no ULP scaling (ULP=1.0), the relational operators can be used
!!   instead
!!
!!   use m_compare_float_numbers
!!   real :: x, y
!!   if ( x .equalto. y ) then
!!     ! -- x effectively equals y, so perform some operation
!!     ....
!!   endif
elemental function compare_float_real32( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real32
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = 1.0_wp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real32
elemental function is_less_than_real32( x, y ) result ( less_than )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real32
elemental function is_greater_than_real32( x, y ) result ( greater_than )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real32
elemental function is_equal_to_real32( x, y ) result( equal_to )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real32

elemental function compare_float_real64( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real64
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = 1.0_wp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real64
elemental function is_less_than_real64( x, y ) result ( less_than )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real64
elemental function is_greater_than_real64( x, y ) result ( greater_than )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real64
elemental function is_equal_to_real64( x, y ) result( equal_to )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real64

elemental function compare_float_real128( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real128
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = 1.0_wp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real128
elemental function is_less_than_real128( x, y ) result ( less_than )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real128
elemental function is_greater_than_real128( x, y ) result ( greater_than )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real128
elemental function is_equal_to_real128( x, y ) result( equal_to )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real128

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__approx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================


!>>>>> build/dependencies/M_args/src/M_args.f90

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    M_args(3fm) - [ARGUMENTS::M_args::INTRO] - define a NAMELIST in a module template to provide command line argument parsing
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!  Usage:
!!
!!      use M_args, only : get_namelist, print_dictionary, unnamed
!!      use M_args, only : get_command_arguments_as_raw_namelist
!!      use M_args, only : get_command_arguments_stack
!!      use M_args, only : get_command_arguments_string
!!      use M_args, only : longest_command_argument
!!      use M_args, only : debug
!!      use M_args, only : oneline
!!
!!##DESCRIPTION
!!    Use the M_arguments(3fp) module template in the following example
!!    program to allow for command line parsing much like standard
!!    Unix command line parsing. Just change the variables defined in
!!    the NAMELIST. There are further details in the documentation for
!!    get_namelist(3f) and print_dictionary(3f), but for basic use starting
!!    with the example program should be sufficient.
!!
!!    Then, your program can be called with forms like:
!!
!!     cmd -x 1.0 -y -20 --points 1,2,3 -title 'This is my title'
!!     cmd --help *.data
!!
!!    A variable of the form LETTER_ becomes the uppercase keyword -LETTER,
!!    and negative values do not need quoted as values. Single-letter keywords
!!    are assumed to be used on the command line as short options with a single
!!    dash prefix, while multi-letter keywords are assumed to be long options.
!!    variable names may be equivalenced to allow for short and long versions of
!!    a keyword.
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    !program demo_M_args
!!    module M_arguments
!!    use M_args,    only : get_namelist, print_dictionary, unnamed, oneline
!!
!!    ! >>> CHANGE THIS
!!    ! declare and initialize a namelist. Letter_ denotes an uppercase short command keyword
!!    real              :: x=111.1, y=222.2, z=333.3
!!    real              :: point(3)=[10.0,20.0,30.0]
!!    character(len=80) :: title=" "
!!    logical           :: l=.false., l_=.false.
!!    logical           :: help=.false., version=.false., v=.false., h=.false.
!!    equivalence       (help,h),(version,v)
!!    namelist /args/ x,y,z,point,title,help,h,version,v,l,l_
!!    ! << END OF CHANGES
!!
!!    contains
!!       subroutine get_args()
!!       integer :: ios
!!       character(len=255) :: message ! use for I/O error messages
!!       character(len=:),allocatable :: readme  ! stores updated namelist
!!       character(len=10000) :: hold_namelist(60)
!!          hold_namelist=''
!!          write(hold_namelist,nml=args,iostat=ios,iomsg=message)
!!          if(ios.eq.0)then
!!             readme=get_namelist(oneline(hold_namelist))
!!             read(readme,nml=args,iostat=ios,iomsg=message)
!!          endif
!!          if(ios.ne.0)then
!!             write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!             call print_dictionary()
!!             stop 1
!!          endif
!!       end subroutine get_args
!!    end module M_arguments
!!
!!    program short
!!    use M_arguments, only : get_args, unnamed
!!    use M_arguments  ! make user variables available
!!    implicit none
!!    integer :: i
!!       call get_args()  ! crack command line options
!!       ! >> USER YOUR VARIABLES HERE. FOR EXAMPLE:
!!       write(*,*)'VALUES ARE NOW ', new_line('A'),&
!!       &'x        ',x,              new_line('A'),&
!!       &'y        ',y,              new_line('A'),&
!!       &'z        ',z,              new_line('A'),&
!!       &'point    ',point,          new_line('A'),&
!!       &'title    ',title,          new_line('A'),&
!!       &'help     ',help,'h ',h,    new_line('A'),&
!!       &'version  ',version,'v ',v, new_line('A'),&
!!       &'l        ',l,              new_line('A'),&
!!       &'l_       ',l_
!!       if(size(unnamed).gt.0)then
!!          write(*,'(a)')'UNNAMED:'
!!          write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!       endif
!!       !<< END OF EXAMPLE USAGE OF VARIABLES
!!    end program short
!!    !end program demo_M_args
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
module M_args
use M_framework__journal, only : journal
use M_list,    only : insert, locate, replace, remove
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdin=>INPUT_UNIT    ! access computing environment
use M_strings, only : isupper, lower, quote, upper
private
!===================================================================================================================================
public  :: get_command_arguments_stack
public  :: get_command_arguments_string
public  :: longest_command_argument
public  :: get_namelist
public  :: print_dictionary
public  :: oneline
public debug
public unnamed

public :: get_command_arguments_as_raw_namelist

private :: namelist_to_dictionary
private :: prototype_and_cmd_args_to_nlist
private :: prototype_to_dictionary
private :: update
private :: get
private :: wipe_dictionary

type option
   character(:),allocatable :: shortname
   character(:),allocatable :: longname
   character(:),allocatable :: value
   integer                  :: length
   logical                  :: present_in
end type option
!===================================================================================================================================
character(len=:),allocatable   :: keywords(:)
character(len=:),allocatable   :: values(:)
integer,allocatable            :: counts(:)
logical,allocatable            :: present_in(:)

logical                        :: keyword_single=.true.
character(len=:),allocatable   :: passed_in
character(len=:),allocatable   :: namelist_name

character(len=:),allocatable   :: unnamed(:)
logical                        :: debug=.false.
logical                        :: return_all

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_command_arguments_stack(3f) - [ARGUMENTS:M_args] return a character array containing all the command line arguments
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function get_command_arguments(stack) result (args)
!!
!!     character(len=:),allocatable :: args(:)
!!
!!##DESCRIPTION
!!    Return a character array containing all the command arguments.
!!    For cases where it is difficult to process the command arguments
!!    one at a time, this function returns an array of the command line
!!    arguments
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_command_arguments_stack
!!    use M_args,    only : get_command_arguments_stack
!!    implicit none
!!    character(len=:),allocatable :: myargs(:)
!!    integer                      :: i
!!    myargs=get_command_arguments_stack()
!!    write(*,'(i0,t10,a)')(i,myargs(i),i=1,size(myargs))
!!    write(*,*)'longest argument is ',len(myargs)
!!    write(*,*)'number of arguments is ',size(myargs)
!!    end program demo_get_command_arguments_stack
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
function get_command_arguments_stack() result(args)
character(len=:),allocatable :: args(:)
integer :: ilength, ilongest, iargs, istatus, i
ilength=0
ilongest=1 ! get an error if try to get string of zero length in gfortran 7.0.4 so set to 1 instead of 0
iargs=command_argument_count()
   GET_LONGEST: do i=1,iargs                                                ! look at all arguments
      call get_command_argument(number=i,length=ilength,status=istatus)     ! get next argument
      if(istatus /= 0) then                                                 ! stop program on error
         call journal('sc','*get_command_arguments_stack* error obtaining argument ',i)
         exit GET_LONGEST
      elseif(ilength.gt.0)then
         ilongest=max(ilongest,ilength)
      endif
   enddo GET_LONGEST
   allocate(character(len=ilongest) :: args(iargs))
   args(:)=''
   GET_ARGS: do i=1,command_argument_count()                                             ! copy array of arguments
      call get_command_argument(number=i,value=args(i),length=ilength,status=istatus)    ! get next argument
      if(istatus /= 0) then                                                              ! stop program on error
         call journal('sc','*get_command_arguments_stack* error obtaining argument ',i)
         exit GET_ARGS
      endif
   enddo GET_ARGS
end function get_command_arguments_stack
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_command_arguments_string(3f) - [ARGUMENTS:M_args] return all command arguments as an allocated string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine get_command_arguments_string(string,istatus)
!!
!!    character(len=:),allocatable,intent(out) :: string
!!    integer,intent(out)                      :: istatus
!!##DESCRIPTION
!!    Returns the entire command line sans the command verb
!!
!!##RETURNS
!!    STRING  composed of all command arguments concatenated into a string
!!    ISTATUS status (non-zero means error)
!!
!!##EXAMPLE
!!
!!   Sample usage
!!
!!    program demo_get_command_arguments_string
!!    use M_framework__journal, only : journal
!!    use M_args, only : get_command_arguments_string
!!    implicit none
!!    integer :: ier
!!    character(len=:),allocatable :: cmd
!!    call get_command_arguments_string(cmd,ier)
!!    write(*,*)'CMD=',trim(cmd)
!!    write(*,*)'LEN(CMD)=',len(cmd)
!!    write(*,*)'IER=',ier
!!    end program demo_get_command_arguments_string
!!##SEE ALSO
!!    M_kracken, kracken
!!
!!    dget,dgets,iget,igets,lget,lgets,rget,rgets,sget,sgets,retrev
!!
!!    parse,dissect,store,setprompts,show
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine get_command_arguments_string(string,istatus)

! ident_1="@(#) M_args get_command_arguments_string(3f) return all command arguments as an allocated string"

!  try to guess original quoting and reintroduce quotes
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=:),allocatable,intent(out) :: string            ! string of all arguments to create
integer,intent(out)                      :: istatus           ! status (non-zero means error)
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                      :: max_string_len             ! allowed length of output string
   integer                      :: i                          ! loop count
   character(len=:),allocatable :: value                      ! store individual arguments one at a time
   integer                      :: ilength                    ! length of individual arguments
   character(len=1024)          :: deallocate_error_message
   integer                      :: deallocate_status
!-----------------------------------------------------------------------------------------------------------------------------------
   call get_command(LENGTH=max_string_len, STATUS=istatus)
   if(istatus > 0)then
     STOP "*get_command_arguments_string* error: could not retrieve command line"
   elseif (max_string_len == 0) then
     STOP "*get_command_arguments_string* error: could not determine command length"
   endif
   max_string_len=max_string_len+2*command_argument_count()   ! leave room for adding double quotes to each argument
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(character(len=max_string_len) :: value)           ! no single argument should be longer than entire command length
   istatus=0                                                  ! initialize returned error code
   string=""                                                  ! initialize returned output string
!-----------------------------------------------------------------------------------------------------------------------------------
   APPEND_ARGS: do i=1,command_argument_count()               ! append any arguments together
      call get_command_argument(i,value,ilength,istatus)      ! get next argument
      if(istatus /= 0) then                                   ! stop program on error
         call journal('sc','*get_command_arguments_string* error obtaining argument ',i)
         exit APPEND_ARGS
      elseif(ilength.gt.0)then
         !---------------------
         ! BEGIN GUESS AT RE-QUOTING STRING
         ! if argument contains a space and does not contain a double-quote and is short enough to have double quotes added
         ! assume this argument was quoted but that the shell stripped the quotes and add double quotes. This is an optional
         ! behavior and assumes an operating system that strips the quotes from quoted strings on the command line. If the
         ! operating system is smarter than that remove this section
         if(index(value(:ilength),' ').ne.0.and.index(value(:ilength),'"').eq.0)then
            if((ilength+2).le.len(value))then
               string=string//' "'//value(:ilength)//'"'
            endif
         ! END GUESS AT RE-QUOTING STRING
         !---------------------
         else
            string=string//' '//value(:ilength) ! append strings together
         endif
      endif
   enddo APPEND_ARGS
!-----------------------------------------------------------------------------------------------------------------------------------
   deallocate(value,stat=deallocate_status,errmsg=deallocate_error_message) ! should be automatically removed in newer compilers
   if(deallocate_status.ne.0)then
      call journal('*get_command_arguments_string *'//trim(deallocate_error_message))
   endif
end subroutine get_command_arguments_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_namelist(3f) - [ARGUMENTS:M_args] NAMELIST-based command line argument parsing
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function get_namelist(definition,all) result(string)
!!
!!    character(len=*),intent(in),optional  :: definition
!!    logical,intent(in),optional  :: all
!!    character(len=:),allocatable :: string
!!
!!##DESCRIPTION
!!    This routine leverages NAMELIST groups to do the conversion from strings
!!    to numeric values required by other command line parsers.
!!
!!    Several of the following example programs simply need an initialized
!!    variable added to the NAMELIST and it automatically is available as
!!    a command line argument. Hard to imagine it getting much simpler.
!!
!!    To use the routine define a NAMELIST group called ARGS.
!!
!!    The routine provides three modes
!!
!!    o keyword=value(s) pairs on the command line.
!!
!!      Typical program usage:
!!
!!       cmd x=1 point=-1,-2,-3 help=T
!!
!!      This requires nothing but a call to the get_namelist(3f) procedure
!!      with no arguments and is very suitable if you just need to pass in
!!      a few numeric values. the syntax used on the command line is the
!!      syntax required for a NAMELIST input string which is very good for
!!      numeric values but does not follow the common syntax rules found
!!      in routines like getopts(3c) or IEEE Std 1003.1-2001, for example.
!!
!!    o Unix-like command usage when provided a NAMELIST group string.
!!
!!      Typical program usage:
!!
!!       cmd -x 1 --point -1,-2,-3 --title 'my string' --help file1 file2
!!
!!      You can use an internal write to generate the input string (which
!!      means to add a new parameter you need to do nothing but initialize
!!      the variable and add the name to the ARGS NAMELIST group and it
!!      automatically becomes a new command line argument).
!!
!!    o Unix-like command usage when provided a Unix-like prototype.
!!
!!      Typical program usage:
!!
!!       cmd -x 1 --point -1,-2,-3 --title 'my string' --help file1 file2
!!
!!      If you are not familiar with NAMELIST input and output you can
!!      declare all the members of the namelist and their default values
!!      much like you were calling the program with a command prototype
!!      string.
!!
!!    For all three modes there is no need to convert from strings to numeric
!!    values in the source code. Even arrays and user-defined types can be
!!    used, complex values can be input ... just define the variable and
!!    add it to the NAMELIST definition.
!!
!!    Note that since all the arguments are defined in a NAMELIST group
!!    that config files can easily be used for the same options.
!!    Just create a NAMELIST input file and read it.
!!
!!    NAMELIST syntax can vary between different programming environments.
!!    Currently, this routine has only been tested using gfortran 7.0.4;
!!    and requires at least Fortran 2003.
!!
!!    NO DEFINITION
!!
!!    If the routine is called with no definition string arguments are passed
!!    in on the command line using NAMELIST syntax (ie. KEYWORD=VALUE). This
!!    is particularly suited for passing a few numeric values.
!!
!!    For example:
!!
!!     program nooptions
!!     use M_args, only : get_namelist
!!     implicit none
!!     character(len=255)           :: message ! use for I/O error messages
!!     character(len=:),allocatable :: readme  ! stores command line
!!     integer                      :: ios     ! I/O error number
!!
!!     ! declare and initialize a namelist that defines all
!!     ! the command keywords
!!     integer    :: i=1, j=2, k=3
!!     real       :: s=111.1, t=222.2, r=333.3
!!     real       :: point(3)=[10.0,20.0,30.0]
!!     logical    :: help=.false.,version=.false.
!!
!!     ! just add a variable here and it is a new parameter
!!     namelist /args/ i,j,k,s,t,r,point,help,version
!!
!!        ! return command line arguments as NAMELIST input
!!        readme=get_namelist()
!!        ! internal read of namelist
!!        read(readme,nml=args,iostat=ios,iomsg=message)
!!        if(ios.ne.0)then
!!           write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!           write(*,*)'OPTIONS:'
!!           write(*,nml=args)
!!           stop 1
!!        endif
!!        ! all done cracking the command line
!!
!!        ! use the values in your program.
!!        write(*,nml=args)
!!     end program nooptions
!!
!!    You can call the example program with syntax like:
!!
!!       cmd  r=200e3 i=200
!!       cmd  K=33333,J=22222,I=11111
!!       cmd  point = 1, 2, 3 s= -3.0e4 t = 405.5
!!
!!    If you do pass in strings nested quotes or escaped double-quote
!!    characters are typically required. How to do that can vary with what
!!    shell and OS you are running in. Typically the following will work ...
!!
!!       # just quote the entire argument list with single quotes ...
!!       cmd 'c="my character string" S=10,T=20.30,R=3e-2'
!!
!!       # or nest the quotes ...
!!       cmd c='"string"' S=20.30
!!
!!       # or escape the quotes ...
!!       cmd c=\"string\"
!!
!!    PASS IN A NAMELIST STRING
!!
!!    If you want to pass in options using syntax similar to that provided
!!    by the C getopts(3c) procedure pass in a NAMELIST string. Typically,
!!    you would generate the input string by writing the NAMELIST group to
!!    an internal file.
!!
!!    The following program can be called using commands like
!!
!!      cmd -A 'string Value' -l -V --help -p 3.4,5.6 -- *
!!
!!    Typical program skeleton:
!!
!!     program demo_get_namelist
!!     use M_args,  only : unnamed
!!     implicit none
!!     integer :: i
!!
!!     ! declare and initialize a namelist
!!     ! letter_ denotes an uppercase short command keyword
!!     ! all values should be allocated before calling get_args(3f)
!!     real              :: x=111.1, y=222.2, z=333.3
!!     real              :: point(3)=[10.0,20.0,30.0]
!!     character(len=80) :: title=" "
!!     logical           :: help=.false., version=.false.
!!     logical           :: l=.false., l_=.false., v=.false., h=.false.
!!     ! you can equivalence short and long options
!!     equivalence       (help,h),(version,v)
!!     ! just add a variable here and it is a new parameter !!
!!     namelist /args/ x,y,z,point,title,help,h,version,v,l,l_
!!     !
!!        call get_args()  ! crack command line options
!!        ! do stuff with your variables
!!        write(*,*)'VALUES ARE NOW'
!!        write(*,nml=args)
!!        if(size(unnamed).gt.0)then
!!           write(*,'(a)')'UNNAMED:'
!!           write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!        endif
!!     contains
!!     subroutine get_args()
!!     ! The NAMELIST cannot be passed as an option to a routine so this
!!     ! routine must be in a contained routine or directly in the body of
!!     ! the routine that declares the NAMELIST. get_args(3f) should not
!!     ! need changed except for possibly the length of HOLD_NAMELIST
!!     use M_args,    only : get_namelist, print_dictionary, oneline
!!     !
!!     integer :: ios
!!     character(len=255) :: message ! use for I/O error messages
!!     character(len=:),allocatable :: readme  ! stores updated namelist
!!     ! make big enough for all of namelist
!!     character(len=10000) :: hold_namelist(60)
!!     ! the routine needs a copy of the options to determine what values
!!     ! are character and logical versus numeric
!!        write(hold_namelist,nml=args,iostat=ios,iomsg=message)
!!        if(ios.eq.0)then
!!           ! pass in the namelist and get an updated copy that includes
!!           ! values specified on the command line
!!           readme=get_namelist(oneline(hold_namelist))
!!           ! read the updated namelist to update the values
!!           ! in the namelist group
!!           read(readme,nml=args,iostat=ios,iomsg=message)
!!        endif
!!        if(ios.ne.0)then
!!           write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!           call print_dictionary()
!!           stop 1
!!        endif
!!        ! all done cracking the command line
!!     end subroutine get_args
!!     end program demo_get_namelist
!!
!!    Instead of writing the NAMELIST group into a string you can compose
!!    the string yourself. only defined names will be able to be specified
!!    on the command line. For example:
!!
!!     call get_namelist('&ARGS A_="A value",B_=" ",C_=11 22 33, help=F/')
!!
!!   Sample with manual definition of NAMELIST string
!!
!!     program show_get_namelist_manual
!!     use M_args,  only : unnamed, get_namelist, print_dictionary
!!     implicit none
!!     integer            :: i, ios
!!     character(len=255) :: message
!!     ! define namelist
!!     real               :: x, y, z
!!     logical            :: help, h, version, v
!!     namelist /args/ x,y,z,help,h,version,v
!!     ! equivalence short and long version and help options
!!     equivalence           (help,h),(version,v)
!!     ! define NAMELIST string that defines all NAMELIST
!!     ! group variables
!!     character(len=:),allocatable :: cmd
!!        cmd='&ARGS X=1 Y=2 Z=3 HELP=F H=F VERSION=F V=F/'
!!        ! initialize all values in NAMELIST by reading string
!!        read(cmd,nml=args,iostat=ios,iomsg=message)
!!        if(ios.eq.0)then
!!           ! reduce NAMELIST string to just values on command line
!!           cmd=get_namelist(cmd)
!!           ! update NAMELIST group with values from command line
!!           read(cmd,nml=args,iostat=ios,iomsg=message)
!!        endif
!!        if(ios.ne.0)then
!!           call print_dictionary('ERROR: '//message)
!!           stop 1
!!        endif
!!        ! all done. use values in program
!!        write(*,nml=args)
!!        if(size(unnamed).gt.0)then
!!           write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!        endif
!!     end program show_get_namelist_manual
!!
!!    UNIX PROTOTYPE
!!
!!    Instead of passing in a NAMELIST string a Unix-like command prototype
!!    string can be used. Something like:
!!
!!       call get_namelist('-A " " -l -x -30.34e2 --help -version ')
!!
!!    typical usage:
!!
!!       program show_get_namelist_unix_prototype
!!          use M_args,  only : unnamed, get_namelist, print_dictionary
!!          implicit none
!!          integer                      :: i
!!          character(len=255) :: message ! use for I/O error messages
!!          character(len=:),allocatable :: readme ! stores updated namelist
!!          integer                      :: ios
!!
!!       ! declare a namelist
!!          real               :: x, y, z, point(3)
!!          character(len=80)  :: title
!!          logical            :: help, version, l, l_, v, h
!!          equivalence       (help,h),(version,v)
!!          namelist /args/ x,y,z,point,title,help,h,version,v,l,l_
!!
!!       ! Define the prototype
!!       !  o All parameters must be listed with a default value
!!       !  o string values  must be double-quoted
!!       !  o numeric lists must be comma-delimited. No spaces are allowed
!!          character(len=*),parameter  :: cmd='&
!!          & -x 1 -y 2 -z 3     &
!!          & --point -1,-2,-3   &
!!          & --title "my title" &
!!          & -h --help          &
!!          & -v --version       &
!!          & -l -L'
!!          ! reading in a NAMELIST definition defining the entire NAMELIST
!!          readme=get_namelist(cmd,all=.true.)
!!          read(readme,nml=args,iostat=ios,iomsg=message)
!!          if(ios.ne.0)then
!!             write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!             call print_dictionary('OPTIONS:')
!!             stop 1
!!          endif
!!          ! all done cracking the command line
!!
!!          ! use the values in your program.
!!          write(*,nml=args)
!!          ! the optional unnamed values on the command line are
!!          ! accumulated in the character array "UNNAMED"
!!          if(size(unnamed).gt.0)then
!!             write(*,'(a)')'files:'
!!             write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!          endif
!!       end program show_get_namelist_unix_prototype
!!
!!##OPTIONS
!!    DESCRIPTION   null or composed of all command arguments concatenated
!!                  into a string prepared for reading as a NAMELIST group
!!                  or a Unix-line command prototype string.
!!
!!                  When creating a Unix-like prototype
!!
!!                  o all values except logicals get a value.
!!                  o long names (--keyword) should be all lowercase
!!                  o short names (-letter) that are uppercase map to a
!!                    NAMELIST variable called "letter_", but lowercase
!!                    short names map to NAMELIST name "letter".
!!                  o strings MUST be delimited with double-quotes and
!!                    must be at least one space and internal
!!                    double-quotes are represented with two double-quotes
!!                  o lists of numbers should be comma-delimited.
!!                     No spaces are allowed in lists of numbers.
!!                  o the values follow the rules for NAMELIST values, so
!!                    "-p 2*0" for example would define two values.
!!
!!    ALL           By default the output NAMELIST string only contains
!!                  keywords and values for names that were specified on
!!                  the command line. If ALL is .TRUE. a full NAMELIST
!!                  string is returned containing all the variables from
!!                  the input string.
!!##RETURNS
!!    STRING   The output is a NAMELIST string than can be read to update
!!             the NAMELIST "ARGS" with the keywords that were supplied on
!!             the command line.
!!
!!    When using one of the Unix-like command line forms note that
!!    (subject to change) the following variations from other common
!!    command-line parsers:
!!
!!       o duplicate keywords are replaced by the rightmost entry
!!
!!       o numeric keywords are not allowed; but this allows
!!         negative numbers to be used as values.
!!
!!       o specifying both names of an equivalenced keyword will have
!!         undefined results (currently, their alphabetical order
!!         will define what the Fortran variable values become).
!!
!!       o there is currently no mapping of short names to long
!!         names except via an EQUIVALENCE.
!!
!!       o short keywords cannot be combined. -a -b -c is required,
!!         not -abc even for Boolean keys.
!!
!!       o shuffling is not supported. Values must follow their
!!         keywords.
!!
!!       o if a parameter value of just "-" is supplied it is
!!         converted to the string "stdin".
!!
!!       o if the keyword "--" is encountered the rest of the
!!         command arguments go into the character array "UNUSED".
!!
!!       o values not matching a keyword go into the character
!!         array "UNUSED".
!!
!!       o long names do not take the --KEY=VALUE form, just
!!         --KEY VALUE; and long names should be all lowercase and
!!         always more than one character.
!!
!!       o short-name parameters of the form -LETTER VALUE
!!         map to a NAMELIST name of LETTER_ if uppercase
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!
!!##LICENSE
!!    Public Domain
function get_namelist(definition,all) result (readme)

! ident_2="@(#) M_args get_namelist(3f) return all command arguments as a NAMELIST(3f) string to read"

character(len=*),intent(in),optional :: definition
logical,intent(in),optional          :: all
character(len=:),allocatable         :: hold               ! stores command line argument
character(len=:),allocatable         :: readme             ! stores command line argument
integer                              :: ibig

   if(allocated(unnamed))then
       deallocate(unnamed)
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   allocate(character(len=ibig) :: unnamed(0))
   if(present(all))then
      return_all=all
   else
      return_all=.false.
   endif
   if(present(definition))then
      if(definition.eq.'')then
         readme=get_command_arguments_as_raw_namelist()
      else
         call wipe_dictionary()
         hold=adjustl(definition)
         if(hold(1:1).eq.'&')then                          ! definition is assumed to be a NAMELIST string
            call namelist_to_dictionary(hold)
            present_in=.false.
            call prototype_and_cmd_args_to_nlist(' ',readme)
         else                                              ! definition is assumed to be a prototype of the command
            call prototype_and_cmd_args_to_nlist(hold,readme)
         endif
      endif
   else                                                    ! assume should read command line as a raw string in NAMELIST format
      readme=get_command_arguments_as_raw_namelist()
   endif

   if(.not.allocated(unnamed))then
       allocate(character(len=0) :: unnamed(0))
   endif

end function get_namelist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_command_arguments_as_raw_namelist(3f) - [ARGUMENTS:M_args] NAMELIST-based command line argument parsing
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine get_command_arguments_as_raw_namelist(string)
!!
!!    character(len=:),allocatable,intent(out) :: string
!!##DESCRIPTION
!!
!!    NAMELIST can be used to pass keyword-value pairs via the command
!!    line. the following example program simply needs an initialized
!!    variable added to the NAMELIST and it automatically is available as
!!    a command line argument. Hard to imagine it getting much simpler.
!!
!!    You can call the example program with syntax like:
!!
!!       testit r=200e3 i=200
!!       testit K=33333,J=22222,I=11111
!!
!!    Note that if you pass in strings you probably will have to use nested
!!    quotes or escape your quote characters. How you do that can vary with
!!    what shell and OS you are running in.
!!
!!       # just quote the entire argument list with single quotes ...
!!       testit 'c="my character string" S=10,T=20.30,R=3e-2'
!!
!!       or nest the quotes ...
!!       testit c='"string"' S=20.30
!!
!!       or escape the quotes ...
!!       testit c=\"string\"
!!
!!    As you will see, there is no need to convert from strings to numeric
!!    values in the source code. Even arrays and user-defined types can be
!!    used, complex values can be input ... just define the variable and
!!    add it to the NAMELIST definition.
!!
!!    And if you want to use a config file instead of command line arguments
!!    since your arguments are defined in a NAMELIST group just create a
!!    NAMELIST input file and read it.
!!
!!##RETURNS
!!    STRING  composed of all command arguments concatenated into a string
!!            prepared for reading as a NAMELIST.
!!
!!##EXAMPLE
!!
!!   Sample usage
!!
!!    program demo_get_command_arguments_as_raw_namelist
!!    implicit none
!!    character(len=255)           :: message ! use for I/O error messages
!!    character(len=:),allocatable :: string  ! stores command line argument
!!    integer                      :: ios
!!
!!    ! declare and initialize a namelist
!!    integer    :: i=1, j=2, k=3
!!    real       :: s=111.1, t=222.2, r=333.3
!!    real       :: arr(3)=[10.0,20.0,30.0]
!!    character(len=255) :: c=' '
!!    ! just add a variable here and it is a new parameter !!
!!    namelist /args/ i,j,k,s,t,r,c,arr
!!
!!       ! return command line arguments as NAMELIST input
!!       string=get_command_arguments_as_raw_namelist()
!!       ! internal read of namelist
!!       read(string,nml=args,iostat=ios,iomsg=message)
!!       if(ios.ne.0)then
!!          write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!          write(*,*)'OPTIONS:'
!!          write(*,nml=args)
!!          stop 1
!!       endif
!!       ! all done cracking the command line
!!
!!       ! use the values in your program. For example ...
!!       sum=i+j+k
!!       write(*,*)'sum=',sum
!!    end program demo_get_command_arguments_as_raw_namelist
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
function get_command_arguments_as_raw_namelist() result (string)

! ident_3="@(#) M_args get_command_arguments_as_raw_namelist(3f) return all command arguments as a NAMELIST(3f) string"

character(len=:),allocatable :: string                     ! stores command line argument
character(len=:),allocatable :: string_bug                 ! bug in gfortran 7.4.0 where string in LHS and RHS causes problems
integer :: command_line_length
   call get_command(length=command_line_length)            ! get length needed to hold command
   allocate(character(len=command_line_length) :: string)
   call get_command(string)
   ! trim off command name and get command line arguments
   string_bug=adjustl(string)//' '                         ! assuming command verb does not have spaces in it
   string=string_bug(index(string_bug,' '):)
   string="&ARGS "//string//" /"                            ! add namelist prefix and terminator
   end function get_command_arguments_as_raw_namelist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_to_dictionary(3f) - [ARGUMENTS:M_args] parse user command and store tokens into dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine prototype_to_dictionary(string)
!!
!!    character(len=*),intent(in)     ::  string
!!
!!##DESCRIPTION
!!    given a string of form
!!
!!      -var value -var value
!!
!!    define dictionary of form
!!
!!      keyword(i), value(i)
!!
!!    o  string values
!!
!!        o must be delimited with double quotes.
!!        o adjacent double quotes put one double quote into value
!!        o must not be null. A blank is specified as " ", not "".
!!
!!    o  logical values
!!
!!        o logical values must not have a value
!!
!!    o  leading and trailing blanks are removed from unquoted values
!!
!!
!!##OPTIONS
!!
!!    STRING   string is character input string to define command
!!
!!##RETURNS
!!
!!##EXAMPLE
!!
!!   sample program:
!!
!!    program demo_prototype_to_dictionary
!!       ! look at some of the values as strings or numbers
!!    end program demo_prototype_to_dictionary
!!
!!   Results:
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine prototype_to_dictionary(string)
implicit none

! ident_4="@(#) M_args prototype_to_dictionary(3f) parse user command and store tokens into dictionary"

character(len=*),intent(in)       :: string ! string is character input string of options and values

character(len=:),allocatable      :: dummy   ! working copy of string
character(len=:),allocatable      :: value
character(len=:),allocatable      :: keyword
character(len=3)                  :: delmt   ! flag if in a delimited string or not
character(len=1)                  :: currnt  ! current character being processed
character(len=1)                  :: prev    ! character to left of CURRNT
character(len=1)                  :: forwrd  ! character to right of CURRNT
integer,dimension(2)              :: ipnt
integer                           :: islen   ! number of characters in input string
integer                           :: ipoint
integer                           :: itype
integer                           :: ifwd
integer                           :: ibegin
integer                           :: iend

   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   dummy=string//'  '

   keyword=""          ! initial variable name
   value=""            ! initial value of a string
   ipoint=0            ! ipoint is the current character pointer for (dummy)
   ipnt(2)=2           ! pointer to position in parameter name
   ipnt(1)=1           ! pointer to position in parameter value
   itype=1             ! itype=1 for value, itype=2 for variable

   delmt="off"
   prev=" "

   keyword_single=.true.
   do
      ipoint=ipoint+1               ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)   ! store current character into currnt
      ifwd=min(ipoint+1,islen)
      forwrd=dummy(ifwd:ifwd)       ! next character (or duplicate if last)

      if((currnt=="-".and.prev==" ".and.delmt == "off".and.index("0123456789.",forwrd) == 0).or.ipoint > islen)then
         ! beginning of a parameter name
         if(forwrd.eq.'-')then                      ! change --var to -var so "long" syntax is supported
            dummy(ifwd:ifwd)='_'
            ipoint=ipoint+1                         ! ignore second - instead
            keyword_single=.false.
         else
            keyword_single=.true.
         endif
         if(ipnt(1)-1 >= 1)then
            ibegin=1
            iend=len_trim(value(:ipnt(1)-1))
            do
               if(iend  ==  0)then                  ! len_trim returned 0, parameter value is blank
                  iend=ibegin
                  exit
               elseif(value(ibegin:ibegin) == " ")then
                  ibegin=ibegin+1
               else
                  exit
               endif
            enddo
            if(keyword.ne.' ')then
               call update(keyword,value)         ! store name and its value
            else
               write(stderr,*)'*prototype_to_dictionary* warning: ignoring blank keyword ',trim(value)
            endif
         else
            if(keyword.ne.' ')then
               call update(keyword,'F')           ! store name and null value
            else
               if(debug)then
                  write(stderr,*)'*prototype_to_dictionary* warning: blank keyword, and ignoring blank value',trim(value)
               endif
            endif
         endif
         itype=2                               ! change to filling a variable name
         value=""                              ! clear value for this variable
         keyword=""                            ! clear variable name
         ipnt(1)=1                             ! restart variable value
         ipnt(2)=1                             ! restart variable name

      else       ! currnt is not one of the special characters
         ! the space after a keyword before the value
         if(currnt == " ".and.itype  ==  2)then
            ! switch from building a keyword string to building a value string
            itype=1
            ! beginning of a delimited parameter value
         elseif(currnt  ==  """".and.itype  ==  1)then
            ! second of a double quote, put quote in
            if(prev  ==  """")then
               if(itype.eq.1)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
               delmt="on"
            elseif(delmt  ==  "on")then     ! first quote of a delimited string
               delmt="off"
            else
               delmt="on"
            endif
            if(prev /= """")then  ! leave quotes where found them
               if(itype.eq.1)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
            endif
         else     ! add character to current parameter name or parameter value
            if(itype.eq.1)then
               value=value//currnt
            else
               keyword=keyword//currnt
            endif
            ipnt(itype)=ipnt(itype)+1
         endif

      endif

      prev=currnt
      if(ipoint <= islen)then
         cycle
      endif
      exit
   enddo

end subroutine prototype_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    update(3f) - [ARGUMENTS:M_args] update internal dictionary given keyword and value
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine update(key,val)
!!
!!    character(len=*),intent(in)           :: key
!!    character(len=*),intent(in),optional  :: val
!!##DESCRIPTION
!!    Update internal dictionary in M_args(3fm) module.
!!##OPTIONS
!!    key  name of keyword to add, replace, or delete from dictionary
!!    val  if present add or replace value associated with keyword. If not
!!         present remove keyword entry from dictionary.
!!##RETURNS
!!##EXAMPLE
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine update(key,val)
character(len=*),intent(in)           :: key
character(len=*),intent(in),optional  :: val
integer                               :: place
integer                               :: ilen
character(len=:),allocatable          :: val_local
   if(debug)then
      if(present(val))then
         write(stderr,*)'*update* DEBUG: KEY=',key,' VAL=',val
      else
         write(stderr,*)'*update* DEBUG: KEY=',key
      endif
   endif
   if(present(val))then
      val_local=val
      ilen=len_trim(val_local)
      call locate(keywords,key,place)                   ! find where string is or should be
      if(place.lt.1)then                                ! if string was not found insert it
         call insert(keywords,key,iabs(place))
         call insert(values,val_local,iabs(place))
         call insert(counts,ilen,iabs(place))
         call insert(present_in,.true.,iabs(place))
      else
         call replace(values,val_local,place)
         call replace(counts,ilen,place)
         call replace(present_in,.true.,place)
      endif
   else                                                 ! if no value is present remove the keyword and related values
      call locate(keywords,key,place)
      if(place.gt.0)then
         call remove(keywords,place)
         call remove(values,place)
         call remove(counts,place)
         call remove(present_in,place)
      endif
   endif
   if(debug)then
      if(present(val))then
         write(stderr,*)'*update* DEBUG: KEY=',key,'PLACE=',place,' VAL=',val, &
                &size(keywords),size(values),size(counts),size(present_in)
      else
         write(stderr,*)'*update* DEBUG: KEY=',key,'PLACE=',place,size(keywords),size(values),size(counts),size(present_in)
      endif
      write(stderr,*)present_in
   endif
end subroutine update
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wipe_dictionary(3fp) - [ARGUMENTS:M_args] reset private M_args(3fm) dictionary to empty
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine wipe_dictionary()
!!##DESCRIPTION
!!    reset private M_args(3fm) dictionary to empty
!!##EXAMPLE
!!
!!    program demo_wipe_dictionary
!!    use M_args, only : dictionary
!!       call wipe_dictionary()
!!    end program demo_wipe_dictionary
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine wipe_dictionary()
   if(allocated(keywords))deallocate(keywords)
   allocate(character(len=0) :: keywords(0))
   if(allocated(values))deallocate(values)
   allocate(character(len=0) :: values(0))
   if(allocated(counts))deallocate(counts)
   allocate(counts(0))
   if(allocated(present_in))deallocate(present_in)
   allocate(present_in(0))
end subroutine wipe_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##SYNOPSIS
!!
!!    get(3f) - [ARGUMENTS:M_args] get dictionary value associated with key name in private M_args(3fm) dictionary
!!##DESCRIPTION
!!    Get dictionary value associated with key name in private M_args(3fm) dictionary.
!!##OPTIONS
!!##RETURNS
!!##EXAMPLE
!!
function get(key) result(valout)
character(len=*),intent(in)   :: key
character(len=:),allocatable  :: valout
integer                       :: place
   ! find where string is or should be
   call locate(keywords,key,place)
   if(place.lt.1)then
      valout=''
   else
      valout=values(place)(:counts(place))
   endif
end function get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_and_cmd_args_to_nlist(3f) - [ARGUMENTS:M_args] convert Unix-like command arguments to namelist
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine prototype_and_cmd_args_to_nlist(prototype,nml)
!!
!!    character(len=*)             :: prototype
!!    character(len=:),allocatable :: nml
!!##DESCRIPTION
!!    create dictionary with character keywords, values, and value lengths using the routines for maintaining a list from
!!    command line arguments.
!!##OPTIONS
!!    prototype
!!##RETURNS
!!    nml
!!##EXAMPLE
!!
!!   Sample program
!!    program demo_prototype_and_cmd_args_to_nlist
!!    use M_args,  only : prototype_and_cmd_args_to_nlist, unnamed, debug
!!    implicit none
!!    character(len=:),allocatable :: readme
!!    character(len=256)           :: message
!!    integer                      :: ios
!!    integer                      :: i
!!    doubleprecision              :: something
!!
!!    ! define namelist
!!    ! lowercase keywords
!!    logical            :: l,h,v
!!    real               :: p(2)
!!    complex            :: c
!!    doubleprecision    :: x,y,z
!!
!!    ! uppercase keywords get an underscore
!!    logical            :: l_,h_,v_
!!    character(len=256) :: a_,b_                  ! character variables must be long enough to hold returned value
!!    integer            :: c_(3)
!!    namelist /args/ l,h,v,p,c,x,y,z,a_,b_,c_,l_,h_,v_
!!
!!       debug=.true.
!!       ! give command template with default values
!!       ! all values except logicals get a value.
!!       ! strings must be delimited with double quotes
!!       ! A string has to have at least one character as for -A
!!       ! lists of numbers should be comma-delimited. No spaces are allowed in lists of numbers
!!       ! the values follow the rules for NAMELIST input, so  -p 2*0 would define two values.
!!       call prototype_and_cmd_args_to_nlist('-l -v -h -LVH -x 0 -y 0.0 -z 0.0d0 -p 0,0 -A " " -B "Value B" -C 10,20,30 -c (-123,-456)',readme)
!!       read(readme,nml=args,iostat=ios,iomsg=message)
!!       if(ios.ne.0)then
!!          write(*,*)'ERROR:',trim(message)
!!          write(*,'("INPUT WAS ",a)')readme
!!          write(*,args)
!!          stop 3
!!       else
!!          something=sqrt(x**2+y**2+z**2)
!!          write(*,*)something,x,y,z
!!          if(size(unnamed).gt.0)then
!!             write(*,'(a)')'files:'
!!             write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!          endif
!!       endif
!!    end program demo_prototype_and_cmd_args_to_nlist
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine prototype_and_cmd_args_to_nlist(prototype,nml)
implicit none

! ident_5="@(#) M_args prototype_and_cmd_args_to_nlist create dictionary from prototype (if not null) and update from command line arguments"

character(len=*)             :: prototype
character(len=:),allocatable :: nml
integer                      :: ibig
   if(debug)then
      write(stderr,*)'*prototype_and_cmd_args_to_nlist* DEBUG: prototype=',trim(prototype)
   endif

   passed_in=prototype ! make global copy for printing

   if(allocated(unnamed))deallocate(unnamed)
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   allocate(character(len=ibig) ::unnamed(0))

   if(prototype.ne.'')then
      call prototype_to_dictionary(prototype)  ! build dictionary from prototype
      namelist_name='&ARGS'
      present_in=.false.  ! reset all values to false
   endif

   if(debug)then                            ! look at some of the values as strings or numbers
      call print_dictionary('DICTIONARY FROM PROTOTYPE')
   endif

   call cmd_args_to_dictionary(check=.true.)

   call dictionary_to_namelist(nml)

   ! show array
   if(debug)then
      call print_dictionary('DICTIONARY FROM COMMAND LINE:')
   endif

end subroutine prototype_and_cmd_args_to_nlist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine cmd_args_to_dictionary(check)
! convert command line arguments to dictionary entries
! reading the namelist output will trap unknown option names so do not really need to trap them here
logical,intent(in),optional  :: check
logical                      :: check_local
integer                      :: pointer
character(len=:),allocatable :: lastkeyword
integer                      :: i
integer                      :: ilength, istatus, imax
character(len=:),allocatable :: current_argument
character(len=:),allocatable :: current_argument_padded
character(len=:),allocatable :: dummy
character(len=:),allocatable :: oldvalue
logical                      :: nomore
   if(present(check))then
      check_local=check
   else
      check_local=.false.
   endif
   nomore=.false.
   pointer=0
   lastkeyword=' '
   keyword_single=.true.
   GET_ARGS: do i=1, command_argument_count()                                                        ! insert and replace entries
      call get_command_argument(number=i,length=ilength,status=istatus)                              ! get next argument
      if(istatus /= 0) then                                                                          ! stop program on error
         write(stderr,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
            &'status=',istatus,&
            &'length=',ilength
         exit GET_ARGS
      else
         if(allocated(current_argument))deallocate(current_argument)
         ilength=max(ilength,1)
         allocate(character(len=ilength) :: current_argument)
         call get_command_argument(number=i,value=current_argument,length=ilength,status=istatus)    ! get next argument
         if(istatus /= 0) then                                                                       ! stop program on error
            write(stderr,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
               &'status=',istatus,&
               &'length=',ilength,&
               &'target length=',len(current_argument)
            exit GET_ARGS
          endif
      endif

      if(current_argument.eq.'-')then  ! sort of
         current_argument='"stdin"'
      endif
      if(current_argument.eq.'--')then ! everything after this goes into the unnamed array
         nomore=.true.
         pointer=0
         cycle
      endif
      dummy=current_argument//'   '
      current_argument_padded=current_argument//'   '
      if(.not.nomore.and.current_argument_padded(1:2).eq.'--'.and.index("0123456789.",dummy(3:3)).eq.0)then ! beginning of long word
         keyword_single=.false.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate(keywords,current_argument_padded(3:),pointer)
         if(pointer.le.0.and.check_local)then
            call print_dictionary('UNKNOWN LONG KEYWORD: '//current_argument)
            stop 1
         endif
         lastkeyword=trim(current_argument_padded(3:))
      elseif(.not.nomore.and.current_argument_padded(1:1).eq.'-'.and.index("0123456789.",dummy(2:2)).eq.0)then  ! short word
         keyword_single=.true.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate(keywords,current_argument_padded(2:),pointer)
         if(pointer.le.0.and.check_local)then
            call print_dictionary('UNKNOWN SHORT KEYWORD: '//current_argument)
            stop 2
         endif
         lastkeyword=trim(current_argument_padded(2:))
      elseif(pointer.eq.0)then                                                                           ! unnamed arguments
         imax=max(len(unnamed),len(current_argument))
         unnamed=[character(len=imax) :: unnamed,current_argument]
      else
         if(debug)then
            write(stderr,*)'POINTER=',pointer,' KEYWORD=',keywords(pointer),' VALUE=',current_argument,' LENGTH=',ilength
         endif
         oldvalue=get(keywords(pointer))//' '
         if(oldvalue(1:1).eq.'"')then
            current_argument=quote(current_argument(:ilength))
         endif
         if(upper(oldvalue).eq.'F'.or.upper(oldvalue).eq.'T')then  ! assume boolean parameter
            if(current_argument.ne.' ')then
               imax=max(len(unnamed),len(current_argument))
               unnamed=[character(len=imax) :: unnamed,current_argument]
            endif
            current_argument='T'
         endif
         call update(keywords(pointer),current_argument)
         pointer=0
         lastkeyword=''
      endif
   enddo GET_ARGS
   if(lastkeyword.ne.'')then
      call ifnull()
   endif

contains
subroutine ifnull()
   oldvalue=get(lastkeyword)//' '
   if(upper(oldvalue).eq.'F'.or.upper(oldvalue).eq.'T')then
      call update(lastkeyword,'T')
   elseif(oldvalue(1:1).eq.'"')then
      call update(lastkeyword,'" "')
   else
      call update(lastkeyword,' ')
   endif
end subroutine ifnull

end subroutine cmd_args_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine dictionary_to_namelist(nml)
character(len=:),allocatable,intent(out) :: nml
integer :: i
character(len=:),allocatable :: newkeyword
   ! build namelist string
   nml=namelist_name//' '
   if(return_all)then  ! if returning all first do keywords not present on command line so equivalences work
      do i=1,size(keywords)
         if(isupper(keywords(i)(1:1)))then
            newkeyword=trim(lower(keywords(i)))//'_'
         else
            newkeyword=trim(keywords(i))
         endif
         if(.not.present_in(i))then
            nml=nml//newkeyword//'='//trim(values(i))//' '
         endif
      enddo
   endif

   do i=1,size(keywords)  ! now only do keywords present on command line
      if(isupper(keywords(i)(1:1)))then
         newkeyword=trim(lower(keywords(i)))//'_'
      else
         newkeyword=trim(keywords(i))
      endif
      if(present_in(i))then
         nml=nml//newkeyword//'='//trim(values(i))//' '
      endif
   enddo

   nml=nml//' /'
   if(debug)then
      write(stderr,'(a)')'NAMELIST:'
      write(stderr,'(a)')nml
      if(size(unnamed).gt.0)then
         write(stderr,'(a)')'UNNAMED'
         write(stderr,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
      endif
   endif
end subroutine dictionary_to_namelist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   print_dictionary(3f) - [ARGUMENTS:M_args] print internal dictionary created by calls to get_namelist(3f)
!!   (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine print_dictionary(header)
!!
!!    character(len=*),intent(in),optional :: header
!!##DESCRIPTION
!!   Print the internal dictionary created by calls to get_namelist(3f).
!!   This routine is intended to print the state of the argument list
!!   if an error occurs in using the get_namelist(3f) procedure..
!!##OPTIONS
!!   HEADER  label to print before printing the state of the command
!!           argument list.
!!##EXAMPLE
!!
!!    Typical usage:
!!
!!     program demo_print_dictionary
!!     use M_args,  only : unnamed, get_namelist, print_dictionary
!!     implicit none
!!     integer                      :: i
!!     character(len=255)           :: message ! use for I/O error messages
!!     character(len=:),allocatable :: readme  ! stores updated namelist
!!     integer                      :: ios
!!     real               :: x, y, z
!!     logical            :: help, h
!!     equivalence       (help,h)
!!     namelist /args/ x,y,z,help,h
!!     character(len=*),parameter :: cmd='&ARGS X=1 Y=2 Z=3 HELP=F H=F /'
!!     ! initialize namelist from string and then update from command line
!!     readme=cmd
!!     read(readme,nml=args,iostat=ios,iomsg=message)
!!     if(ios.eq.0)then
!!        ! update cmd with options from command line
!!        readme=get_namelist(cmd)
!!        read(readme,nml=args,iostat=ios,iomsg=message)
!!     endif
!!     if(ios.ne.0)then
!!        write(*,'("ERROR:",i0,1x,a)')ios, trim(message)
!!        call print_dictionary('OPTIONS:')
!!        stop 1
!!     endif
!!     ! all done cracking the command line
!!     ! use the values in your program.
!!     write(*,nml=args)
!!     ! the optional unnamed values on the command line are
!!     ! accumulated in the character array "UNNAMED"
!!     if(size(unnamed).gt.0)then
!!        write(*,'(a)')'files:'
!!        write(*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!     endif
!!     end program demo_print_dictionary
!!
!!    Sample output
!!
!!    Calling the sample program with an unknown
!!    parameter produces the following:
!!
!!       $ ./print_dictionary -A
!!       UNKNOWN SHORT KEYWORD: -A
!!       KEYWORD             PRESENT  VALUE
!!       z                   F        [3]
!!       y                   F        [2]
!!       x                   F        [1]
!!       help                F        [F]
!!       h                   F        [F]
!!
!!       STOP 2
!!
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine print_dictionary(header)
character(len=*),intent(in),optional :: header
integer          :: i
   if(present(header))then
      if(header.ne.'')then
         write(stderr,'(a)')header
      endif
   endif
   if(allocated(keywords))then
      if(size(keywords).gt.0)then
         write(stderr,'(*(a,t21,a,t30,a))')'KEYWORD','PRESENT','VALUE'
         write(stderr,'(*(a,t21,l1,t30,"[",a,"]",/))')(trim(keywords(i)),present_in(i),values(i)(:counts(i)),i=1,size(keywords))
      endif
   endif
   if(allocated(unnamed))then
      if(size(unnamed).gt.0)then
         write(stderr,'(a)')'UNNAMED'
         write(stderr,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
      endif
   endif
end subroutine print_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_command_argument(3f) - [ARGUMENTS:M_args] length of longest argument on command line
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function longest_command_argument() result(ilongest)
!!
!!     integer :: ilongest
!!
!!##DESCRIPTION
!!    length of longest argument on command line. Useful when allocating storage for holding arguments.
!!##RESULT
!!    longest_command_argument  length of longest command argument
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_longest_command_argument
!!    use M_args, only : longest_command_argument
!!       write(*,*)'longest argument is ',longest_command_argument()
!!    end program demo_longest_command_argument
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
function longest_command_argument() result(ilongest)
integer :: i
integer :: ilength
integer :: istatus
integer :: ilongest
   ilength=0
   ilongest=0
   GET_LONGEST: do i=1,command_argument_count()                             ! loop throughout command line arguments to find longest
      call get_command_argument(number=i,length=ilength,status=istatus)     ! get next argument
      if(istatus /= 0) then                                                 ! stop program on error
         write(stderr,*)'*prototype_and_cmd_args_to_nlist* error obtaining length for argument ',i
         exit GET_LONGEST
      elseif(ilength.gt.0)then
         ilongest=max(ilongest,ilength)
      endif
   enddo GET_LONGEST
end function longest_command_argument
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    namelist_to_dictionary(3f) - [ARGUMENTS:M_args] parse namelist string and store tokens into dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine namelist_to_dictionary(string)
!!
!!    character(len=*),intent(in)     ::  string
!!
!!##DESCRIPTION
!!   must start with a keyword, any keyword that appears must have a value. A character array can have more than one delimited string
!!   unallocated and null values are not allowed
!!   set parameter name to blank
!!   find undelimited =
!!   find previous , or beginning of string. in-between is a keyword= to , that starts a keyword is a value
!!   one keyword and value are known store them
!!
!!##OPTIONS
!!    STRING   string is character input string to define command
!!
!!##EXAMPLE
!!
!!   Typical string:
!!
!!    >&ARGS
!!    > L = F,
!!    > A_="xxxxxxxxxxxxxxxxxxxxxxxxxx                                                      ",
!!    > B_="Value B                                                                         ",
!!    > P= 2*0.00000000      ,
!!    > C_=         10,         20,         30, XYZ_=(-123.000000,-456.000000),
!!    > X=  0.0000000000000000     ,
!!    > Y=  0.0000000000000000     ,
!!    > Z=  0.0000000000000000     ,
!!    > /
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
subroutine namelist_to_dictionary(string)
implicit none

! ident_6="@(#) M_args namelist_to_dictionary(3f) parse user command and store tokens into dictionary"

character(len=*),intent(in)       :: string ! string is character input string of options and values

character(len=:),allocatable      :: dummy       ! working copy of string
character(len=:),allocatable      :: dummy_bug   ! bug in gfortran 7.4.0 where if dummy is on LHS and used in RHS get wrong result
character(len=:),allocatable      :: keyword_value
character(len=:),allocatable      :: value
character(len=:),allocatable      :: keyword
logical                           :: delmt   ! flag if in a delimited string or not
character(len=1)                  :: currnt  ! current character being processed
character(len=1)                  :: prev    ! current character being processed
integer                           :: islen   ! number of characters in input string
integer                           :: ipoint
integer                           :: istart
integer                           :: iend
integer                           :: ileft
integer                           :: icut
integer                           :: i
integer                           :: iback1,iback2
   if(debug)then
      write(stderr,*)'*namelist_to_dictionary* INPUT=',trim(string)
   endif
   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   islen=islen-1                                        ! by definition last character in NAMELIST output is /
   dummy=trim(adjustl(string(:islen)))
   ! strip off namelist group name
   ileft=index(dummy,'&')
   dummy_bug=adjustl(dummy(ileft+1:))
   ileft=index(dummy_bug,' ')
   if(ileft.eq.0)then
      ileft=len(dummy_bug)
   endif
   namelist_name=upper('&'//dummy_bug(:ileft-1))
   dummy=adjustl(dummy_bug(ileft:))

   islen=len(dummy)
   dummy=dummy//'    '
   if(debug)then
      write(stderr,*)'*namelist_to_dictionary* NAMELIST_NAME=['//namelist_name//']'
      write(stderr,*)'*namelist_to_dictionary* DUMMY=['//dummy//']'
   endif

   keyword=""          ! initial variable name
   value=""            ! initial value of a string
   delmt=.false.       ! whether in a character string or not
   prev=" "
   istart=1
   do ipoint=1,islen
      currnt=dummy(ipoint:ipoint)             ! store current character into currnt
      if(currnt=="=".and..not.delmt)then ! end of a parameter name
         keyword_value=''
         iend=0
         do i=ipoint-1,1,-1
            if(dummy(i:i).eq.' ')cycle
            ! found non-space
            iback1=index(dummy(:i),' ',back=.true.)
            iback2=index(dummy(:i),',',back=.true.)
            iend=max(iback1,iback2)
            exit
         enddo
         if(iend.ne.0)then
            call splitit()
         endif
         istart=iend+1
      elseif(currnt  ==  """")then
         if(prev  ==  """")then               ! second of a double quote, put quote in
            delmt=.not.delmt
         elseif(delmt)then
            delmt=.false.
         else
            delmt=.true.
         endif
      endif
      prev=currnt
      if(ipoint.ge.islen)then
         iend=ipoint
         call splitit()
      endif
   enddo
   if(debug)then
      call print_dictionary('NAMELIST TO DICTIONARY')
   endif
contains

subroutine splitit()
integer :: ilast
keyword_value=dummy(istart:iend)
! split keyword_value on first = and convert values to lowercase except for LETTER_ convert to uppercase LETTER and
! remove trailing , as NAMELIST output being read should not contain null values as everything in a namelist needs
! to be allocated (at least in this version of Fortran?).
   icut=index(keyword_value,'=')
   if(icut.eq.0)then
      write(stderr,*)'*splitit* INTERNAL ERROR: KEYWORD_VALUE=['//keyword_value//']'
   else
      if(debug)then
         write(stderr,*)'*splitit* KEYWORD_VALUE=['//keyword_value//']',icut
      endif
      keyword=adjustl(trim(lower(keyword_value(:icut-1))))
      if(len(keyword).eq.2)then
         if(keyword(2:2).eq.'_')then
            keyword=upper(keyword(1:1))
         endif
      endif
      if(icut.eq.len(keyword_value))then
         value=''
      else
         value=trim(adjustl(keyword_value(icut+1:)))
         ilast=len(value)
         if(ilast.eq.0)then
            value=''
         else
            if(value(ilast:ilast).eq.',')then
               value=trim(value(:ilast-1))
            endif
         endif
      endif
      call update(keyword,value)
   endif
end subroutine splitit

end subroutine namelist_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function oneline(str) result (string)

! ident_7="@(#) M_strings oneline(3f) append an array of character variables with space separator into a single CHARACTER variable"

character(len=*),intent(in)          :: str(:)
character(len=:),allocatable         :: string
integer                              :: i
character(len=1),parameter           :: sep=' '

   string=''
   do i = 1,size(str)
      string=string//trim(str(i))//sep
   enddo
end function oneline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================


!>>>>> build/dependencies/M_kracken/src/M_kracken.f90

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_kracken
use M_framework__journal, only: journal
use M_strings, only: upper, string_to_value, split, s2v, atleast
use M_list,    only: locate, insert, replace
use M_args,    only: get_command_arguments_string, longest_command_argument
implicit none

! ident_1="@(#) M_kracken(3fm) parse command line options of Fortran programs using Unix-like syntax"

!===================================================================================================================================
   private
   logical,save :: debug=.false.
!-----------------------------------------------------------------------------------------------------------------------------------
   public :: kracken                ! define command and default parameter values from command arguments
!-----------------------------------------------------------------------------------------------------------------------------------
   public :: rget                   ! fetch real    value of name VERB_NAME from the Language Dictionary
   public :: dget                   ! fetch double  value of name VERB_NAME from the Language Dictionary
   public :: iget                   ! fetch integer value of name VERB_NAME from the Language Dictionary
   public :: lget                   ! fetch logical value of name VERB_NAME from the Language Dictionary
   public :: sget                   ! fetch string  value of name VERB_NAME from the Language Dictionary.
!-----------------------------------------------------------------------------------------------------------------------------------
   public :: rgets                  ! fetch real    values of name VERB_NAME from the Language Dictionary
   public :: dgets                  ! fetch double  values of name VERB_NAME from the Language Dictionary
   public :: igets                  ! fetch integer values of name VERB_NAME from the Language Dictionary
   public :: lgets                  ! fetch logical values of name VERB_NAME from the Language Dictionary
   public :: sgets                  ! fetch string  values of name VERB_NAME from the Language Dictionary.
!-----------------------------------------------------------------------------------------------------------------------------------
   public :: retrev                 ! retrieve token value as string from Language Dictionary when given NAME
!-----------------------------------------------------------------------------------------------------------------------------------
!  SPECIAL-PURPOSE PUBLIC ROUTINES:
   public :: setprompts             ! define prompts for commands in interactive mode
!  Only needs to be public for building languages, not cracking command line arguments
   public :: dissect                ! for user-defined commands: define defaults, then process user input
   public :: parse                  ! parse user command and store tokens into Language Dictionary
   public :: store                  ! replace dictionary name's value (if allow=add add name if necessary)
   public :: show                   ! display dictionary contents for information
!-----------------------------------------------------------------------------------------------------------------------------------
   private :: subscript_            ! return the subscript value of a string when given its name
   private :: menu                  ! generate an interactive menu when -? option is used
!-----------------------------------------------------------------------------------------------------------------------------------
! length of verbs and entries in Language dictionary
! NOTE:   many parameters may be  reduced in size so as to just accommodate being used as a command line parser.
!         In particular, some might want to change:
   logical,public            :: stop_command=.false.               ! indication to return stop_command as false in interactive mode
   integer,parameter,public  :: IPvalue=4096*16                    ! length of keyword value
   integer,parameter,public  :: IPverb=20                          ! length of verb
!-----------------------------------------------------------------------------------------------------------------------------------
   integer, parameter        :: dp = kind(0.d0)
   integer, parameter        :: k_int = SELECTED_INT_KIND(9)       ! integer*4
   integer, parameter        :: k_dbl = SELECTED_REAL_KIND(15,300) ! real*8
!-----------------------------------------------------------------------------------------------------------------------------------
   ! dictionary for Language routines
   character(len=:),allocatable               :: dict_vals(:)      ! contains the values of string variables
   character(len=:),allocatable               :: dict_verbs(:)     ! string variable names
   integer(kind=k_int),allocatable            :: dict_lens(:)      ! significant lengths of string variable values
   integer(kind=k_int),allocatable            :: dict_calls(:)     ! number of times this keyword stored on a call to parse
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=1),save,public               :: kracken_comment='#'
   character(len=:),public,allocatable,save   :: leftover          ! remaining command(s) on line
   integer,public,save                        :: current_command_length=0 ! length of options for current command
!-----------------------------------------------------------------------------------------------------------------------------------
   public :: cmd_args_to_dictionary
   public :: print_kracken_dictionary
   public unnamed
   public kracken_method
   character(len=:),allocatable,save :: unnamed(:)
   character(len=10),save            :: kracken_method='kracken'
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    RETREV(3f) - [ARGUMENTS:M_kracken] get keyword value as a string from a command's argument list processed by kracken(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   SUBROUTINE retrev(name, string, len, ier)
!!
!!    CHARACTER(len=*),intent(in)  :: name
!!    CHARACTER(len=*),intent(out) :: string
!!    INTEGER,intent(out)          :: len
!!    INTEGER,intent(out)          :: ier
!!
!!##DESCRIPTION
!!    When a command has had its command argument list parsed using the
!!    kracken(3f) routine the value associated with any keyword can be retrieved
!!    as a string.
!!
!!##OPTIONS
!!
!!     NAME    parameter name of form VERB_KEYWORD
!!     STRING  returned parameter value
!!     LEN     length of returned STRING
!!     IER     error flag. Any non-zero value means an error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_retrev
!!     use M_kracken, only : kracken, retrev
!!     use M_kracken, only : IPvalue ! length of keyword value
!!     implicit none
!!     character(len=IPvalue) :: val
!!     integer                :: len, ier
!!
!!     call kracken('demo', ' -value my default string')
!!     call retrev('demo_value',val,len,ier)
!!     write(*,'(a)')'VALUE IS '//trim(val)
!!
!!     end program demo_retrev
!!
!!   Example execution and output:
!!
!!     $ ./demo_retrev
!!     VALUE IS my default string
!!
!!     $ ./demo_retrev -value use this value instead
!!     VALUE IS use this value instead
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine retrev(name,val,len,ier)

! ident_2="@(#) M_kracken retrev(3f) retrieve token value from Language Dictionary when given NAME"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)     :: name        ! name of variable to retrieve value for in form VERB_NAME
character(len=*),intent(out)    :: val         ! value for requested variable
   integer,intent(out)          :: len         ! position of last non-blank character in requested variable
   integer,intent(out)          :: ier         ! error flag 0=found requested variable; -1=entry not found
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                      :: isub        ! subscript in dictionary where requested entry and corresponding value are found
!-----------------------------------------------------------------------------------------------------------------------------------
   isub=subscript_(name)                       ! get index entry is stored at
!-----------------------------------------------------------------------------------------------------------------------------------
   if(isub > 0)then                            ! entry was in dictionary
      val=dict_vals(isub)                      ! retrieve corresponding value for requested entry
      len=dict_lens(isub)                      ! get significant length of value
      ier=0                                    ! indicate requested entry name was successfully found
   else                                        ! entry was not in dictionary
      val=" "                                  ! set value to blank
      len=0                                    ! set length to zero
      ier=-1                                   ! set error flag to indicate requested entry was not found
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine retrev
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dget(3f) - [ARGUMENTS:M_kracken] given keyword fetch doubleprecision value from command argument
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dget(keyword) result(value)
!!
!!     character(len=*),intent(in)  :: keyword
!!     doubleprecision              :: value
!!
!!##DESCRIPTION
!!     The dget(3f) function returns a scalar doubleprecision value from a command line
!!     argument using the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     KEYWORD    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the KRACKEN(3f)
!!                call. The KEYWORD is a keyword from the KRACKEN(3f) call that
!!                should be interpreted as a doubleprecision value.
!!
!!##RETURNS
!!     VALUE      doubleprecision value returned by function
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_dget
!!    use M_kracken, only: kracken, dget
!!    implicit none
!!    doubleprecision :: val
!!      ! define command arguments and parse user command
!!      call kracken('demo','-val 3.1416' )
!!      val=dget('demo_val') ! get any values specified on -val option
!!      write(*,*)val         ! print the value
!!    end program demo_dget
!!
!!   Example program runs:
!!
!!    $ demo_dget
!!       3.14159989
!!
!!    $ demo_dget -val 10
!!       10.0000000
!!
!!    $ demo_dget -val 3.000
!!       3.00000000
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dget(keyword)

! ident_3="@(#) M_kracken dget(3f) given keyword fetch dble value from Language Dictionary (zero on err)"

real(kind=dp)                :: dget              ! function type
character(len=*),intent(in)  :: keyword           ! keyword to retrieve value for from dictionary
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                      :: ier            ! error flag on call to retrieve value
!-----------------------------------------------------------------------------------------------------------------------------------
   call string_to_value(sget(keyword), dget, ier) ! convert the string to a numeric value
!-----------------------------------------------------------------------------------------------------------------------------------
end function dget
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    rget(3f) - [ARGUMENTS:M_kracken] given keyword fetch real value from command argument
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function rget(keyword) result(value)
!!
!!     character(len=*),intent(in)  :: keyword
!!     real                         :: value
!!
!!##DESCRIPTION
!!     The rget(3f) function returns a scalar real value from a command line
!!     argument using the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     KEYWORD    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the KRACKEN(3f)
!!                call. The KEYWORD is a keyword from the KRACKEN(3f) call that
!!                should be interpreted as a REAL value.
!!
!!##RETURNS
!!     VALUE      real value returned by function
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_rget
!!    use M_kracken, only: kracken, rget
!!    implicit none
!!    real :: val
!!      ! define command arguments and parse user command
!!      call kracken('demo','-val 3.1416' )
!!      val=rget('demo_val') ! get any values specified on -val option
!!      write(*,*)val        ! print the value
!!    end program demo_rget
!!
!!   Example program runs:
!!
!!    $ demo_rget
!!       3.14159989
!!
!!    $ demo_rget -val 10
!!       10.0000000
!!
!!    $ demo_rget -val 3.000
!!       3.00000000
!!
!!##SEE ALSO
!!    M_kracken(3fm), kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse,dissect,store,setprompts,show
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rget(keyword)

! ident_4="@(#) M_kracken rget(3f) given keyword fetch real value from language dictionary (zero on err)"

!-----------------------------------------------------------------------------------------------------------------------------------
   real                        :: rget             ! function type
   character(len=*),intent(in) :: keyword          ! keyword to retrieve value for from dictionary
!-----------------------------------------------------------------------------------------------------------------------------------
   rget=real(dget(keyword))                        ! just call DGET(3f) but change returned value to type REAL
!-----------------------------------------------------------------------------------------------------------------------------------
end function rget
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    iget(3f) - [ARGUMENTS:M_kracken] given keyword fetch integer value from command argument
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function iget(keyword) result(value)
!!
!!     character(len=*),intent(in)  :: keyword
!!     integer              :: value
!!
!!##DESCRIPTION
!!     The iget(3f) function returns a scalar integer value from a command line
!!     argument using the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     KEYWORD    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the KRACKEN(3f)
!!                call. The KEYWORD is a keyword from the KRACKEN(3f) call that
!!                should be interpreted as a integer value.
!!
!!##RETURNS
!!     VALUE      integer value returned by function
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_iget
!!    use M_kracken, only: kracken, iget
!!    implicit none
!!    integer :: val
!!      ! define command arguments and parse user command
!!      call kracken('demo','-val 31416' )
!!      val=iget('demo_val') ! get any values specified on -val option
!!      write(*,*)val        ! print the value
!!    end program demo_iget
!!
!!   Example program runs:
!!
!!    $ demo_iget
!!       31416
!!
!!    $ demo_iget -val 10
!!       10
!!
!!    $ demo_iget -val 3.000
!!       3
!!
!!##SEE ALSO
!!    M_kracken(3fm), kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function iget(keyword)

! ident_5="@(#) M_kracken iget(3f) given keyword fetch integer value from Language Dictionary (0 on err)"

!-----------------------------------------------------------------------------------------------------------------------------------
   integer                      :: iget            ! function type
   character(len=*),intent(in)  :: keyword         ! keyword to retrieve value for from dictionary
!-----------------------------------------------------------------------------------------------------------------------------------
   !iget = int(dget(keyword)+0.5_dp)               ! just call DGET(3f) but change returned value to type INTEGER
   iget = int(dget(keyword))                       ! just call DGET(3f) but change returned value to type INTEGER
!-----------------------------------------------------------------------------------------------------------------------------------
end function iget
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lget(3f) - [ARGUMENTS:M_kracken] given keyword fetch logical value from command arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lget(keyword) result(lval)
!!
!!     character(len=*),intent(in)  :: keyword
!!     logical                      :: lval
!!##DESCRIPTION
!!
!!     The lget(3f) function returns a scalar logical value from a command line
!!     argument using the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     keyword    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the
!!                KRACKEN(3f) call. The KEYWORD is a keyword from the second
!!                argument to the KRACKEN(3f) call.
!!
!!##RETURNS
!!     lval       logical value returned by function. The input value should be
!!                from the case-insensitive list of the words "true, false,
!!                t, f, yes, no, y, n, .false., .true., .f., .t.,''". .TRUE. is returned
!!                if the corresponding string in the dictionary for KEYWORD is blank.
!!                .FALSE. is returned if a string not in the list is found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_lget
!!    use M_kracken, only: kracken, lget
!!    implicit none
!!    logical  :: val
!!      ! define command arguments and parse user command
!!      call kracken('demo','-truth .F.' )
!!      ! get any values specified on command line for -truth
!!      val=lget('demo_truth')
!!      write(*,'("The truth is ",l1)')val
!!    end program demo_lget
!!
!!   Example program runs:
!!
!!      $ demo_lget             # uses the default
!!      The truth is F
!!      $ demo_lget -truth      # A BLANK VALUE IS TRUE
!!      The truth is T
!!      $ demo_lget -truth yes  # Y, yes, T, true, .T., .true. are all true
!!      The truth is T
!!      $ demo_lget -truth F    # N, no, F, false, .F., .FALSE. are all false
!!      The truth is F
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lget(keyword)

! ident_6="@(#) M_kracken lget(3f) given keyword fetch logical value from lang. dictionary (.f. on err)"

!-----------------------------------------------------------------------------------------------------------------------------------
logical                      :: lget                  ! procedure type
character(len=*),intent(in)  :: keyword               ! the dictionary keyword (in form VERB_KEYWORD) to retrieve
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=:),allocatable :: value              ! value corresponding to the requested keyword
!-----------------------------------------------------------------------------------------------------------------------------------
!  ignore a leading dot character. Then, any word starting in "T" or "Y" is true, any word starting in "F" or "N" is false.
   if(len(sget(keyword)).ne.0)then
      value=trim(adjustl(upper(sget(keyword))))//' '  ! get value as uppercase, spaces trimmed, then add trailing space
      lget=.false.                                    ! initialize return value to .false.
      if(value.ne."#N#".and.value.ne.'"#N#"')then
         select case(value(1:1))                      ! check first letter
         case('T','Y',' ') ; lget=.true.              ! anything starting with "T" or "Y" or a blank is TRUE (true,t,yes,y,...)
         case('F','N')     ; lget=.false.             ! assume this is false or no
         case('.')                                    ! looking for fortran logical syntax .STRING.
            select case(value(2:2))
            case('T')      ; lget=.true.              ! assume this is .t. or .true.
            case('F')      ; lget=.false.             ! assume this is .f. or .false.
            case default
               call journal("*lget* bad logical expression for "//trim(keyword)//'='//value)
            end select
         case default
               call journal("*lget* bad logical expression for "//trim(keyword)//'='//value)
         end select
      else                                            ! special value "#N#" is assumed FALSE
         lget=.false.
      endif
   else
      lget=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function lget
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sget(3f) - [ARGUMENTS:M_kracken] given keyword fetch string value and length from command arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function sget(name,ilen) result(string)
!!
!!    character(len=*),intent(in)   :: name        ! name to look up in dictionary
!!    integer,intent(out),optional  :: ilen        ! length of returned output string
!!    character(len=:),allocatable  :: string      ! returned value
!!
!!##DESCRIPTION
!!     The sget(3f) function returns a scalar character value from a command line
!!     argument using the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     name    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!             The VERB name comes from the first argument of the
!!             KRACKEN(3f) call. The KEYWORD is a keyword from the second
!!             argument to the KRACKEN(3f) call.
!!             This routine trusts that the desired name exists.
!!
!!##RETURNS
!!     string  returned string. If LEN(STRING).EQ.0 an error occurred, such
!!             as NAME not being in the dictionary.
!!     ilen    optional length of returned output string
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_sget
!!    use M_kracken, only: kracken, sget
!!    implicit none
!!    character(len=:),allocatable :: string, a, b
!!      ! define command arguments and parse user command
!!      call kracken('demo','-string This is the default -a A default -b B default' )
!!      ! get any values specified on command line for -truth
!!      string=sget('demo_string')
!!      a=sget('demo_a')
!!      b=sget('demo_b')
!!      write(*,'("string is ",a)')trim(string)
!!      write(*,'("a is ",a)')trim(a)
!!      write(*,'("b is ",a)')trim(b)
!!    end program demo_sget
!!
!!   Example program runs:
!!
!!    $demo_sget
!!    string is This is the default
!!    a is A default
!!    b is B default
!!
!!    $ demo_sget -a A value for A -string new value for string -b BBBBBBB
!!    string is new value for string
!!    a is A value for A
!!    b is BBBBBBB
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sget(name,ilen) result(string)

! ident_7="@(#) M_kracken sget(3f) Fetch string value and length of specified NAME from lang. dictionary"

!  This routine trusts that the desired name exists. A blank is returned if the name is not in the dictionary
character(len=:),allocatable  :: string      ! returned value
character(len=*),intent(in)   :: name        ! name to look up in dictionary
integer,intent(out),optional  :: ilen        ! length of returned output string
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                    :: isub        ! index where verb_oo is stored or -1 if this is an unknown name
!-----------------------------------------------------------------------------------------------------------------------------------
   isub=subscript_(name)                     ! given name return index name is stored at
!-----------------------------------------------------------------------------------------------------------------------------------
   if(isub > 0)then                          ! if index is valid return string
      string=trim(dict_vals(isub))
      if(len(string).eq.0)string=" "
   else                                      ! if index is not valid return blank string
      string=""
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(ilen))then                     ! if ILEN is present on call, return the value
      ilen=dict_lens(isub)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sget
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dgets(3f) - [ARGUMENTS:M_kracken] given keyword fetch doubleprecision array from command arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dgets(keyword,ier) result(darray)
!!
!!     character(len=*),intent(in)   :: keyword
!!     doubleprecision,allocatable   :: DARRAY
!!     integer,optional,intent(iout) :: ier
!!
!!##DESCRIPTION
!!     The dgets(3f) function returns a dynamically allocated array of
!!     doubleprecision values from a string that is the value for a command
!!     line option. It is part of the M_kracken(3fm) module.
!!
!!     Values that cannot be read as a numeric value are returned as a NaN.
!!
!!##OPTIONS
!!     keyword  dictionary name to retrieve, of form VERB_NAME where VERB
!!              is taken from the first parameter of the call to KRACKEN(3f)
!!              or DISSECT(3f).
!!
!!##RETURNS
!!     darray   double precision numeric array returned by function. The array
!!              will have zero size if the parsed dictionary entry is blank.
!!     IER      If present and non-zero an error occurred in converting strings to a value
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_dgets
!!    use M_kracken, only: kracken, dgets
!!    implicit none
!!    doubleprecision,allocatable  :: vals(:)
!!    integer :: i
!!    ! define command arguments and parse user command
!!    call kracken('demo','-nums 1 2 3 1000 100,000 11.11111 77.77777 -77.7777' )
!!    vals=dgets('demo_nums') ! get any values specified for -nums
!!    write(*,'(*(g0:,","))')( vals(i),i=1,size(vals)) ! print the values
!!    end program demo_dgets
!!
!!   Example program runs:
!!
!!    $ demo_dgets
!!     1.0000000000000000,2.0000000000000000,3.0000000000000000,
!!     1000.0000000000000,100000.00000000000,11.111110000000000,
!!     77.777770000000004,-77.777699999999996
!!
!!    $ demo_dgets -nums 89,123,456.789 10.9999999
!!     89123456.789000005,10.999999900000001
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dgets(keyword,ier) result(darray)

! ident_8="@(#) M_kracken dgets(3f) given keyword fetch dble value from Language Dictionary (0 on err)"

character(len=*),intent(in) :: keyword                      ! keyword to retrieve value for from dictionary
real(kind=dp),allocatable   :: darray(:)                    ! function type

   character(len=:),allocatable  :: carray(:)          ! convert value to an array using split(3f)
   integer                       :: i
   integer,optional              :: ier
   integer                       :: ier_local
!-----------------------------------------------------------------------------------------------------------------------------------
   if(sget(keyword).ne.' ')then
      call split(sget(keyword),carray)                      ! find value associated with keyword and split it into an array
   else
      allocate(character(len=0) :: carray(0))
   endif
   allocate(darray(size(carray)))                           ! create the output array
   ier_local=0
   if(present(ier))then
         ier=0
   endif
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier_local)       ! convert the string to a numeric value
      if(present(ier).and.ier_local.ne.0)then
         ier=ier_local
      endif
      !if(ier_local.ne.0)then
      !   !darray(i)=0.0d0
      !   deallocate(darray)
      !   allocate(darray(i-1))                              ! create the output array
      !   exit
      !endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function dgets
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    igets(3f) - [ARGUMENTS:M_kracken] given keyword fetch integer array from command arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function igets(keyword,ier) result(iarray)
!!
!!     character(len=*),intent(in)   :: keyword
!!     integer,allocatable           :: iarray(:)
!!     integer,optional,intent(iout) :: ier
!!
!!##DESCRIPTION
!!     The igets(3f) function returns a dynamically allocated array of integers
!!     from a string that is the value for a command line option. It is part of
!!     the M_kracken(3fm) module.
!!
!!     Values that cannot be read as an integer value are returned as a NaN.
!!
!!##OPTIONS
!!     KEYWORD    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the KRACKEN(3f)
!!                call. The KEYWORD is a keyword from the KRACKEN(3f) call that
!!                should be interpreted as a list of INTEGER values. Decimal values
!!                are allowed but truncated. Note that comma characters are ignored.
!!
!!##RETURNS
!!     IARRAY     INTEGER array returned by function
!!                The array will have zero size if the parsed dictionary
!!     IER        If present and non-zero an error occurred in converting strings to a value
!!
!!##EXAMPLE
!!
!!   Sample program
!!
!!    program demo_igets
!!    use M_kracken, only: kracken, igets
!!    implicit none
!!    doubleprecision,allocatable  :: vals(:)
!!    integer :: i
!!    ! define command arguments and parse user command
!!    call kracken('demo','-nums 1 2 3 100 1000 10000 100,000 11.11111 77.77777 -77.7777' )
!!    vals=igets('demo_nums') ! get any values specified for -nums
!!    write(*,'(*(g0:,","))')( vals(i),i=1,size(vals)) ! print the values
!!    end program demo_igets
!!
!!   Example program runs:
!!
!!    $ demo_igets
!!    1,2,3,100,1000,10000,100000,11,77,-77
!!    $ demo_igets -val 89,123,456 10.9999999
!!    89123456,10
!!
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function igets(keyword,ier) result(iarray)

! ident_9="@(#) M_kracken igets(3f) given keyword fetch integer array from string in dictionary(0 on err)"

character(len=*),intent(in) :: keyword             ! keyword to retrieve value for from dictionary
integer,allocatable         :: iarray(:)           ! convert value to an array
doubleprecision,allocatable :: darray(:)           ! convert value to an array
integer,optional            :: ier
   if(present(ier))then
      darray=dgets(keyword,ier)
      if(ier.eq.0)then
         iarray=int(darray)                           ! just call DGETS(3f) but change returned value to type INTEGER
      else
         iarray=[integer ::]
      endif
   else
      iarray=int(dgets(keyword))                   ! just call DGETS(3f) but change returned value to type INTEGER
   endif
end function igets
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    rgets(3f) - [ARGUMENTS:M_kracken] given keyword fetch real array from command arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function rgets(keyword,ier) result(rarray)
!!
!!     character(len=*),intent(in)   :: keyword
!!     real,allocatable              :: rarray(:)
!!     integer,optional,intent(iout) :: ier
!!
!!##DESCRIPTION
!!     The rgets(3f) function returns a dynamically allocated array of real values
!!     from a string that is the value for a command line option. It is part of
!!     the M_kracken(3fm) module.
!!
!!     Values that cannot be read as a numeric value are returned as a NaN.
!!
!!##OPTIONS
!!     KEYWORD    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the KRACKEN(3f)
!!                call. The KEYWORD is a keyword from the KRACKEN(3f) call that
!!                should be interpreted as a list of REAL values.
!!
!!##RETURNS
!!     RARRAY     real array returned by function.
!!                The array will have zero size if the parsed dictionary
!!                entry is blank.
!!     IER        If present and non-zero an error occurred in converting strings to a value
!!
!!##EXAMPLE
!!
!!   Sample program converts between Celcius and Fahrenheit
!!
!!    program demo_rgets
!!    use M_kracken, only: kracken, rgets
!!    implicit none
!!    real,allocatable  :: val(:)
!!    integer :: i
!!      ! define command arguments and parse user command
!!      call kracken('fc','-F -C' )
!!
!!      ! get any values specified on -C option
!!      val=rgets('fc_C')
!!      ! test if have something to print in C ==> F table
!!      if(size(val).gt.0)then
!!         ! print the requested values
!!         write(*,'(a,t14,a)')'celsius','fahrenheit'
!!         write(*,'(f5.1,t14,f5.1)')( val(i),(val(i)+40.0)*9.0/5.0 - 40.0,i=1,size(val))
!!      endif
!!
!!      val=rgets('fc_F')
!!      ! check for values on -F
!!      if(size(val).gt.0)then
!!         write(*,'(a,t14,a)') 'fahrenheit', 'celsius'
!!         write(*,'(f5.1,t14,f5.1)')(val(i),(val(i)+40.0)*5.0/9.0 - 40.0,i=1,size(val))
!!      endif
!!    end program demo_rgets
!!
!!   Example program runs:
!!
!!    % demo_rgets -C -273.15 0 100 -40 37
!!    celsius      fahrenheit
!!     -273.15      -459.67
!!        0.0         32.0
!!      100.0        212.0
!!      -40.0        -40.0
!!       37.0         98.6
!!
!!    % demo_rgets -F -459.67 32 212 -40 98.6
!!    fahrenheit   celsius
!!     -459.67      -273.15
!!       32.00         0.00
!!      212.00       100.00
!!      -40.00       -40.00
!!       98.60        37.00
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rgets(keyword,ier) result(rarray)

! ident_10="@(#) M_kracken rgets(3f) given keyword fetch real array from string in dictionary (0 on err)"

character(len=*),intent(in) :: keyword             ! keyword to retrieve value for from dictionary
real,allocatable            :: rarray(:)           ! convert value to an array
doubleprecision,allocatable :: darray(:)           ! convert value to an array
integer,optional            :: ier
   if(present(ier))then
      darray=dgets(keyword,ier)
      if(ier.eq.0)then
         rarray=real(darray)              ! just call DGETS(3f) but change returned value to type REAL
      else
         rarray=[real ::]
      endif
   else
      rarray=real(dgets(keyword))                  ! just call DGETS(3f) but change returned value to type REAL
   endif
end function rgets
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lget(3f) - [ARGUMENTS:M_kracken] given keyword fetch logical array from command argument
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lgets(keyword) result(lvals)
!!
!!     character(len=*),intent(in)  :: keyword
!!     logical,allocatable          :: lvals(:)
!!
!!##DESCRIPTION
!!     The lgets(3f) function returns a dynamically allocated array of logical values
!!     from a string that is the value for a command line option. It is part of
!!     the M_kracken(3fm) module.
!!
!!     Values that cannot be read as a logical value are returned as a ".FALSE.".
!!
!!##OPTIONS
!!     keyword    the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!                The VERB name comes from the first argument of the
!!                KRACKEN(3f) call. The KEYWORD is a keyword from the second
!!                argument to the KRACKEN(3f) call.
!!
!!##RETURNS
!!     lvals      logical array returned by function. The input value should be
!!                from the case-insensitive list of the words "true, false,
!!                t, f, yes, no, y, n, .false., .true., .f., .t".
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_lgets
!!    use M_kracken, only: kracken, lgets
!!    implicit none
!!    logical,allocatable  :: vals(:)
!!      ! define command arguments and parse user command
!!      call kracken('demo','-truths .F. .T. .F. .F. .T. .T.' )
!!      ! get any values specified on command line for -truth
!!      vals=lgets('demo_truths')
!!      write(*,*)vals
!!    end program demo_lgets
!!
!!   Example program runs:
!!
!!    $ demo_lgets
!!     F T F F T T
!!
!!    $ demo_lgets -truths false F .f. no true .true. t T Yes No
!!     F F F F T T T T T T F
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lgets(keyword) result(larray)

! ident_11="@(#) M_kracken lgets(3f) given keyword fetch logical array from string in dictionary(F on err)"

character(len=*),intent(in)  :: keyword                    ! the dictionary keyword (in form VERB_KEYWORD) to retrieve
logical,allocatable          :: larray(:)                  ! convert value to an array
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=:),allocatable       :: carray(:)         ! convert value to an array
   integer                            :: i
   integer                            :: ichar             ! point to first character of word unless first character is "."
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len(sget(keyword)).ne.0)then
   call split(adjustl(upper(sget(keyword))),carray)        ! convert value to uppercase, left spaces trimmed; then parse into array
   if(size(carray).gt.0)then                                  ! if not a null string
      allocate(larray(size(carray)))                          ! allocate output array
      do i=1,size(carray)
         larray(i)=.false.                                    ! initialize return value to .false.
         if(carray(i).ne."#N#".and.carray(i).ne.'"#N#"')then
            if(carray(i)(1:1).eq.'.')then                     ! looking for fortran logical syntax .STRING.
               ichar=2
            else
               ichar=1
            endif
            select case(carray(i)(ichar:ichar))               ! check word to see if true or false
            case('T','Y',' '); larray(i)=.true.               ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
            case('F','N');     larray(i)=.false.              ! assume this is false or no
            case default
                  call journal("*lgets* bad logical expression for "//trim(keyword)//'='//carray(i))
            end select
         else                                                 ! special value "#N#" is assumed FALSE
            larray(i)=.false.
         endif
      enddo
   else                                                       ! for a blank string return one T
      allocate(larray(1))                                     ! allocate output array
      larray(1)=.true.
   endif
   else
      allocate(larray(1))                                     ! allocate output array
      larray(1)=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function lgets
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sgets(3f) - [ARGUMENTS:M_kracken] given keyword fetch string value parsed on whitespace into an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function sgets(name,delim) result(strings)
!!
!!    character(len=*),intent(in) :: name
!!    character(len=*),intent(in),optional :: delim
!!    character(len=:),allocatable :: strings(:)
!!
!!##DESCRIPTION
!!     The sgets(3f) function returns a dynamically allocated array of character values
!!     from a string that is the value for a command line option. It is part of
!!     the M_kracken(3fm) module.
!!
!!##OPTIONS
!!     name     the dictionary keyword (in form VERB_KEYWORD) to retrieve.
!!              The VERB name comes from the first argument of the
!!              KRACKEN(3f) or DISSECT(3f) call. The KEYWORD is a keyword from the second
!!              argument to the KRACKEN(3f) or DISSECT(3f) call.
!!              This routine trusts that the desired name exists.
!!              If the name does not exist the array [char(0)] is returned.
!!              An array of zero size is returned if the string is blank.
!!     delim    characters to split the string at into elements
!!
!!##RETURNS
!!     strings  returned string array
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_sgets
!!    use M_kracken, only : kracken, sgets
!!    implicit none
!!    character(len=:),allocatable :: strings(:)
!!    integer :: i
!!       call kracken('cmd',' -string    This   is  a sentence ')
!!       strings= sgets("cmd_string")            ! get -strings words
!!       print *, "string=",('['//trim(strings(i))//']',i=1,size(strings))
!!       print *, "len= ",len(strings)
!!       print *, "size=",size(strings)
!!    end program demo_sgets
!!
!!   Example program execution:
!!
!!    $ demo_sgets
!!     string=[This][is][a][sentence]
!!     len=            8
!!     size=           4
!!
!!    $ demo_sgets -string a b c d e f g
!!     string=[a][b][c][d][e][f][g]
!!     len=            1
!!     size=           7
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sgets(name,delim) result(strings)

! ident_12="@(#) M_kracken sgets(3f) Fetch strings value for specified NAME from the lang. dictionary"

! This routine trusts that the desired name exists. A blank is returned if the name is not in the dictionary
character(len=:),allocatable         :: strings(:)
character(len=*),intent(in)          :: name                       ! name to look up in dictionary
character(len=*),intent(in),optional :: delim

integer                              :: isub                      ! index where verb_oo is stored or -1 if this is an unknown name
!-----------------------------------------------------------------------------------------------------------------------------------
   isub=subscript_(name)                                          ! given name return index name is stored at
!-----------------------------------------------------------------------------------------------------------------------------------
   if(isub > 0)then                                               ! if index is valid return strings
      if(present(delim))then
         call split(dict_vals(isub),strings,delim)
      else
         call split(dict_vals(isub),strings)
      endif
   else                                                           ! if index is not valid return NULL string
      allocate(character(len=1) :: strings(1))
      strings(1)=char(0)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sgets
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    kracken(3f) - [ARGUMENTS:M_kracken] crack command line options on Fortran programs, using "-KEYWORD VALUE" syntax
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine kracken(verb, string[,ierror][style])
!!
!!        character(len=*), intent(in) ::  verb
!!        character(len=*), intent(in) :: string
!!        integer, intent(out), optional :: ierror
!!        character(len=*), intent(in),optional :: style
!!
!!##DESCRIPTION
!!     This is the main public procedure in the M_kracken(3f) module.
!!     It is used to define the command line options, their default
!!     values, and to crack the command line options using a syntax
!!     that looks very much like an execution of the program.
!!
!!##OPTIONS
!!     VERB     arbitrary command name, usually 'cmd' or the name of the
!!              program calling the routine. This defines the
!!              variable prefix name used by the other functions to
!!              retrieve command option values.
!!
!!     STRING   prototype command to define keywords and defaults.
!!              This string is simply a list of all keywords and their
!!              default values exactly as you would type them on the
!!              command line, with default values explicitly set.
!!
!!     IERROR   If an error occurs such as an unknown keyword the
!!              calling program will be stopped unless the optional
!!              parameter IERROR is present. If present, it is up
!!              to the calling program to decide what to do if
!!              a non-zero value is returned.
!!     STYLE    parsing style. Either 'kracken' or 'args'. The default
!!              is 'kracken'.
!!
!!##EXAMPLE
!!
!!
!!   Sample program:
!!
!!       program demo_kracken
!!
!!       use M_kracken
!!       implicit none
!!       ! define command arguments, default values and crack command line
!!       call kracken('cmd',              &
!!          &   '-int 20                  &
!!          &   -real 10e3                &
!!          &   -file input               &
!!          &   -dble 4.11223344556677d0  &
!!          &   -help    .false.          &
!!          &   -version .false.         '&
!!          &   )
!!       ! that's it. You defined your command arguments and their default
!!       ! values and parsed the user-supplied command line arguments.
!!
!!       ! Now you can just retrieve the values as strings using
!!       ! names of the form VERB_SWITCHNAME anywhere in your program.
!!       ! Note that the special name "VERB_oo"  is for the string
!!       ! before any switch.
!!          if(lget('cmd_help'))then ! was -help specified?
!!             write(*,*)'The help text'
!!             stop
!!          endif
!!          if(lget('cmd_version'))then ! was -version specified?
!!             write(*,*)'version 1.0 20161030'
!!             stop
!!          endif
!!          ! convert all the remaining options to scalar values
!!          ! and call a procedure with the values
!!          call mymain(                  &
!!          & sget('cmd_file'),           &
!!          & rget('cmd_real'),           &
!!          & dget('cmd_dble'),           &
!!          & iget('cmd_int')             &
!!          & )
!!       contains
!!       subroutine mymain(filename,value1,value2,ivalue3)
!!       ! this routine is using conventional values and does
!!       ! not use M_kracken(3fm) module at all
!!       implicit none
!!       character(len=*),intent(in) :: filename
!!       real,intent(in)             :: value1
!!       doubleprecision,intent(in)  :: value2
!!       integer,intent(in)          :: ivalue3
!!          ! just to show the command arguments have
!!          ! been processed echo the values
!!          print *, 'filename=',trim(filename)
!!          print *, 'values=',value1,value2,ivalue3
!!       end subroutine mymain
!!       end program demo_kracken
!!
!!   expected output from : "./cmd"
!!
!!          filename=input
!!          values= 10000.0000  4.1122334455667700  20
!!
!!   expected output from : "./cmd -file myfile -int 1234"
!!
!!          filename=myfile
!!          values= 10000.0000  4.1122334455667700  1234
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine kracken(verb,string,error_return,style)

! ident_13="@(#) M_kracken kracken(3f) define and parse command line options"

!  get the entire command line argument list and pass it and the prototype to dissect()
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)          :: string
character(len=*),intent(in)          :: verb
integer,intent(out),optional         :: error_return
character(len=*),intent(in),optional :: style
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=:),allocatable         :: command
integer                              :: ier
integer                              :: ibig
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(error_return))then
      error_return=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier=0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(style))then
      kracken_method=style
   else
      kracken_method='kracken'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ! no matter what method make sure this is allocated so user can query it
   ! and so methods can use unnamed array without having to test it
   if(allocated(unnamed))then
      deallocate(unnamed)
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   allocate(character(len=ibig) ::unnamed(0))
   unnamed=[character(len=ibig) ::]            ! kludge
!-----------------------------------------------------------------------------------------------------------------------------------
   select case(upper(kracken_method))
    case('ARGS')
      call parse(trim(verb),string,'add')                ! initialize command
      call cmd_args_to_dictionary(trim(verb))            ! process user command options
      if(lget(trim(verb)//'_?'))then                     ! if -? option was present prompt for values
         call menu(verb)
      endif
      ! if calling procedure is not testing error flag stop program on error
      if(.not.present(error_return).and.ier.ne.0)then
         call journal("*kracken* (V 20191018) STOPPING: error parsing arguments using ARGS method")
         stop
      endif
    case default
      call store(trim(verb)//'_?','.false.','add',ier)   ! all commands have the option -? to invoke prompt mode
      call get_command_arguments_string(command,ier)
      if(debug) call journal('sc','KRACKEN ',trim(command))
      if(ier.ne.0)then
         call journal("*kracken* could not get command line arguments")
         if(present(error_return))error_return=ier
      else
         call dissect(verb,string,command,ier)
         ! if calling procedure is not testing error flag stop program on error
         if(.not.present(error_return).and.ier.ne.0)then
            call journal("*kracken* (V 20191018) STOPPING: error parsing arguments using DEFAULT method")
            stop
         endif
      endif
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine kracken
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    setprompts(3f) - [ARGUMENTS:M_kracken] set explicit prompts for keywords in interactive mode
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine setprompts(verb,init)
!!
!!    character(len=*),intent(in):: verb
!!    character(len=*),intent(in):: init
!!
!!##DESCRIPTION
!!
!!    Optionally set prompts for interactive prompting mode.
!!    The syntax of the call is the same as for KRACKEN(3f)/DISSECT(3f) except that prompt
!!    strings are given instead of default values. It is called before a call to KRACKEN(3f)
!!    or DISSECT(3f).
!!
!!##OPTIONS
!!    verb    name to define prompts for
!!    string  to define prompts instead of values
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_setprompts
!!     use M_kracken, only : kracken,iget,rget,sget,setprompts
!!     implicit none
!!
!!     call setprompts('demo', ' -int My INTEGER value  -float My REAL value  -str My CHARACTER value')
!!     call kracken(   'demo', ' -int 100 -float 123.456 -str DEFAULT')
!!     write(*,'(a,i0)')'INTEGER IS ',iget('demo_int')
!!     write(*,'(a,g0)')'REAL IS ',rget('demo_float')
!!     write(*,'(a,a)')'STRING IS '//trim(sget('demo_str'))
!!
!!     end program demo_setprompts
!!
!!   Example execution and output:
!!
!!        $ demo_setprompts -?
!!        demo parameters are
!!        >   1)My CHARACTER value:[DEFAULT]
!!            3)My INTEGER value:[100]
!!            4)My REAL value:[123.456]
!!        Enter parameter number to change("RETURN" to finish):
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine setprompts(verb,init)

! ident_14="@(#) M_kracken setprompts(3f) set explicit prompts for keywords in interactive mode"

character(len=*),intent(in):: verb   ! verb name to define prompts for
character(len=*),intent(in):: init   ! string to define prompts instead of values
      call parse('?'//trim(verb),init,'add') ! initialize command, prefixing verb with question mark character to designate prompts
end subroutine setprompts
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dissect(3f) - [ARGUMENTS:M_kracken] convenient call to parse() -- define defaults, then process
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine dissect(verb,init,pars,error_return)
!!
!!    character(len=*),intent(in)  :: verb
!!    character(len=*),intent(in)  :: init
!!    character(len=*),intent(in)  :: pars
!!    integer,intent(out),optional :: error_return
!!##DESCRIPTION
!!
!!##OPTIONS
!!    VERB          the name of the command to be reset/defined
!!    INIT          used to define command options; usually hard-set in the program.
!!    PARS          defines the command options to be set, usually from user input
!!
!!##RETURNS
!!    ERROR_RETURN  error code. If zero no error occurred.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_dissect
!!     use M_kracken, only : kracken,iget,rget,sget,dissect
!!     implicit none
!!     integer :: ierr
!!
!!     call dissect('demo',' -int 1000 -float 1234.567 -str CHARACTER value','-int 456 -float 50.00 ',ierr)
!!     write(*,'(a,i0)')'INTEGER IS ',iget('demo_int')
!!     write(*,'(a,g0)')'REAL IS ',rget('demo_float')
!!     write(*,'(a,a)')'STRING IS '//trim(sget('demo_str'))
!!
!!     end program demo_dissect
!!
!!   Results:
!!
!!    INTEGER IS 456
!!    REAL IS 50.0000000
!!    STRING IS CHARACTER value
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine dissect(verb,init,pars,error_return)

! ident_15="@(#) M_kracken dissect(3f) convenient call to parse() will define defaults then process"

character(len=*),intent(in)  :: verb                     ! the name of the command to be reset/defined  and then set
character(len=*),intent(in)  :: init                     ! used to define or reset command options; usually hard-set in the program.
character(len=*),intent(in)  :: pars                     ! defines the command options to be set, usually from a user input file
integer,intent(out),optional :: error_return
!-----------------------------------------------------------------------------------------------------------------------------------
   integer                :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(debug) call journal('sc','START DISSECT ',trim(verb)//'::'//trim(init)//'::'//trim(pars))
!-----------------------------------------------------------------------------------------------------------------------------------
   call store(trim(verb)//'_?','.false.','add',ier)   ! all commands have the option -? to invoke prompt mode
   call parse(trim(verb),init,'add')                  ! initialize command
!-----------------------------------------------------------------------------------------------------------------------------------
   call parse(verb,pars,"no_add",ier)                 ! process user command options
   if(lget(trim(verb)//'_?'))then                     ! if -? option was present prompt for values
      call menu(verb)
   endif
   if(present(error_return))error_return=ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(debug) call journal('sc','END DISSECT ',trim(verb)//'::'//trim(init)//'::'//trim(pars))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine dissect
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    parse(3f) - [ARGUMENTS:M_kracken] parse user command and store tokens into Language Dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! recursive subroutine parse(verb,string,allow,error_return)
!!
!!    character(len=*),intent(in)     ::  verb
!!    character(len=*),intent(in)     ::  string
!!    character(len=*),intent(in)     ::  allow
!!    integer,optional,intent(out)    ::  error_return
!!
!!##DESCRIPTION
!!    given a string of form
!!
!!      value  -var value -var value
!!
!!    define variables of form
!!
!!      verb_var(i) = value
!!
!!    --var will become verb__var
!!
!!    o  values may be in double quotes if they contain alphameric characters
!!    o  a # signifies the rest of the line is a comment
!!    o  adjacent double quotes put one double quote into value
!!    o  processing ends when an unquoted semi-colon or end of string is encountered
!!    o  the variable name for the first value is verb_init (often verb_oo)
!!    o  leading and trailing blanks are removed from values
!!    o  call it once to give defaults
!!    o  call it again and vars without values are set to null strings
!!
!!##OPTIONS
!!
!!    VERB     command name to process
!!    STRING   string is character input string with first verb removed (options + other commands)
!!    ALLOW    flag to allow or disallow new VERB_KEYWORD name being added. Should be
!!              NEW VARIABLES ARE ALLOWED
!!               o 'define'  -  add or replace a new VERB_KEYWORD entry and value
!!               o 'add'     -  add or append to a new VERB_KEYWORD entry and value
!!              NO NEW VARIABLES ARE ALLOWED
!!               o 'append' or 'no_add' - append to an *EXISTING* entry value
!!               o 'replace' - replace an *EXISTING* entry
!!
!!             That is, ff 'add' or 'append' and the value is not blank
!!             it will be APPENDED to the current value. If 'define' or
!!             'replace' it will replace the value instead of appending
!!             to it.
!!##RETURNS
!!    ERROR_RETURN  error code. If zero, no error occurred
!!
!!##EXAMPLE
!!
!!   sample program:
!!
!!    program demo_parse
!!    use M_kracken, only : parse, sget, iget, rget
!!    use M_strings, only : chomp
!!    implicit none
!!    character(len=:),allocatable  :: verb
!!    character(len=*),parameter    :: delimiters=' ;,'
!!    integer     :: i
!!    integer     :: ierr
!!    character(len=132) :: line
!!    character(len=132), parameter :: commands(5)= [character(len=132) :: &
!!      'start -i 10 -message this is a message', &
!!      'end -i 20 -j 30 -k 55.55 ', &
!!      'list', &
!!      'help -oo', &
!!      'end -i 44.44 ']
!!      do i=1,size(commands)
!!         line=commands(i) ! need mutable line
!!         if(chomp(line,verb,delimiters).ge. 0)then
!!            call parse(verb,line,'add',ierr)
!!            write(*,*)'do whatever a '//verb//' command does'
!!            select case(verb)
!!            case('start')
!!               write(*,*)trim(sget('start_i'))
!!               write(*,*)trim(sget('start_message'))
!!            case('end')
!!               write(*,*)iget('end_i')
!!               write(*,*)iget('end_j')
!!               write(*,*)rget('end_k')
!!            case('list')
!!               write(*,*)'list things'
!!            case('help')
!!               write(*,*)'show help text'
!!            endselect
!!         endif
!!      enddo
!!      ! look at some of the values as strings or numbers
!!      write(*,*)trim(sget('start_i'))
!!      write(*,*)trim(sget('start_message'))
!!      write(*,*)iget('end_i')
!!      write(*,*)iget('end_j')
!!      write(*,*)rget('end_k')
!!    end program demo_parse
!!
!!   Results:
!!
!!     do whatever a start command does
!!     10
!!     this is a message
!!     do whatever a end command does
!!              20
!!              30
!!       55.5499992
!!     do whatever a list command does
!!     list things
!!     do whatever a help command does
!!     show help text
!!     do whatever a end command does
!!              44
!!              30
!!       55.5499992
!!     10
!!     this is a message
!!              44
!!              30
!!       55.5499992
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive subroutine parse(verb,string,allow,error_return)

! ident_16="@(#) M_kracken parse(3f) parse user command and store tokens into Language Dictionary"

!!!   set up odd for future expansion
!!!   need to handle a minus followed by a blank character
!-----------------------------------------------------------------------------------------------------------------------------------
!     SPECIAL FORM:
!        VERB="MODE"
!           then STRING is a special keyword used to identify a special mode to set
!           and ALLOW is a value used to set the mode
!-----------------------------------------------------------------------------------------------------------------------------------
!     for left-over command string for Language routines
!     optionally needed if you are going to allow multiple commands on a line
      ! number of characters left over,
      ! number of non-blank characters in actual parameter list
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)     ::  verb   ! command name to process
character(len=*),intent(in)     ::  string ! string is character input string with first verb removed (options + other commands)
character(len=*),intent(in)     ::  allow  ! keyword indicating whether commands may be added or only replaced
integer,optional,intent(out)    ::  error_return
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=:),allocatable         ::  dummy  ! working copy of string
character(len=IPvalue),dimension(2)  ::  var
character(len=3)                     ::  delmt
character(len=2)                     ::  init
character(len=1)                     ::  currnt  ! current character being processed
character(len=1)                     ::  prev    ! character to left of CURRNT
character(len=1)                     ::  forwrd  ! character to right of CURRNT
character(len=IPvalue)               ::  val
character(len=IPverb)                ::  name
integer,dimension(2)                 ::  ipnt
integer,save                         ::  ileave=1 ! if 0, leave " where you find them; else if 1 remove them. Normally removed
integer                              ::  ilist
integer                              ::  ier
integer                              ::  islen
integer                              ::  ipln
integer                              ::  ipoint
integer                              ::  itype
integer                              ::  ifwd
integer                              ::  ibegin
integer                              ::  iend
!-----------------------------------------------------------------------------------------------------------------------------------
   if(.not.allocated(dict_verbs)) call initd()
!-----------------------------------------------------------------------------------------------------------------------------------
   if(debug) call journal('sc','PARSE ',trim(verb)//'::'//trim(string)//'::'//trim(allow))
!-----------------------------------------------------------------------------------------------------------------------------------
   leftover=" "
   current_command_length=0
   ilist=1
   init="oo"
   ier=0
   if(present(error_return)) error_return=0
   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   dummy=string//'  '
   ipln=len_trim(verb)             ! find number of characters in verb prefix string
   if(size(dict_verbs).ne.0)then
      dict_calls=0                 ! clear number of times this keyword stored on a call to parse
                                   ! should more efficiently only do this for current VERB instead of entire array in dictionary
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   if(subscript_(trim(verb)//'_?') .le. 0 )then         ! assuming if adding this is initial call
      call store(trim(verb)//'_?','.false.','add',ier)  ! all commands have the option -? to invoke prompt mode
   elseif(allow.eq.'add')then
      call store(trim(verb)//'_?','.false.','add',ier)  ! all commands have the option -? to invoke prompt mode
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   if(subscript_(trim(verb)//'_>') .le. 0 )then         ! assuming if adding this is initial call
      call store(trim(verb)//'_>','#N#','add',ier)      ! all commands have the option -> to write journal(3f) output
   elseif(allow.eq.'add')then
      call store(trim(verb)//'_>','#N#','add',ier)      ! all commands have the option -> to write journal(3f) output
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
!  Process special mode-setting calls
   if(verb(:ipln)=="MODE")then
      if(string=="LEAVEQUOTES")then
         if(allow=="YES")then
            ileave=0
         elseif(allow=="NO")then
            ileave=1
         else
            call journal("*parse* LEAVEQUOTES value bad")
            ileave=1
         endif
      else
         call journal("*parse* UNKNOWN MODE")
      endif
      return
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   var(2)=init         ! initial variable name
   var(1)=" "          ! initial value of a string
   ipoint=0            ! ipoint is the current character pointer for (dummy)
   ipnt(2)=2           ! pointer to position in parameter name
   ipnt(1)=1           ! pointer to position in parameter value
   itype=1             ! itype=1 for value, itype=2 for variable
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   delmt="off"
   prev=" "
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   do
      ipoint=ipoint+1               ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)   ! store current character into currnt
      ifwd=min(ipoint+1,islen)
      forwrd=dummy(ifwd:ifwd)       ! next character (or duplicate if last)
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      if((currnt=="-".and.prev==" ".and.delmt == "off".and.index("0123456789.",forwrd) == 0).or.ipoint > islen)then
      ! beginning of a parameter name
         if(forwrd.eq.'-')then                      ! change --var to -var so "long" syntax is supported
            dummy(ifwd:ifwd)='_'
            ipoint=ipoint+1                         ! ignore second - instead
         endif
         if(ipnt(1)-1 >= 1)then
            ibegin=1
            iend=len_trim(var(1)(:ipnt(1)-1))
            do
               if(iend  ==  0)then                  ! len_trim returned 0, parameter value is blank
                  iend=ibegin
                  exit
               elseif(var(1)(ibegin:ibegin) == " ")then
                  ibegin=ibegin+1
               else
                  exit
               endif
            enddo
            name=verb(:ipln)//"_"//var(2)(:ipnt(2))
            ! #A# means append
            ! #R# means retain previous value if any
            val=var(1)(ibegin:iend)
            if(val.eq.'"#R#"')then               ! special value saying to retain previous value so commands can remember last value
               if(subscript_(name).le.0)then
                  call store(name,' ',allow,ier) ! store name and blank value
               endif
            else
               call store(name,val,allow,ier)    ! store name and its value
            endif
            if(present(error_return).and.ier.ne.0)error_return=ier
         else
            name=verb(:ipln)//"_"//var(2)(:ipnt(2))
            val=" "                                 ! store name and null value
            call store(name,val,allow,ier)
            if(present(error_return).and.ier.ne.0)error_return=ier
         endif
         ilist=ilist+ipln+1+ipnt(2)
         ilist=ilist+1
         itype=2                          ! change to filling a variable name
         var(1)=" "                       ! clear value for this variable
         var(2)=" "                       ! clear variable name
         ipnt(1)=1                        ! restart variable value
         ipnt(2)=1                        ! restart variable name
         if(currnt.ne.' ')current_command_length=ipoint
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      elseif(currnt == kracken_comment .and. delmt == "off")then   ! rest of line is comment
         islen=ipoint
         dummy(:)=" "
         prev=" "
         leftover=" "
         cycle
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      elseif(currnt.eq.';'.and.delmt.eq.'off')then ! rest of line is another command(s)
         if(islen-ipoint.gt.0)then
            leftover=dummy(ipoint+1:)
         else
            leftover=' '
         endif

         islen=ipoint
         dummy(:)=" "
         prev=" "
         cycle
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      else       ! currnt is not one of the special characters
         ! the space after a keyword before the value
         if(currnt == " ".and.itype  ==  2)then
            ! switch from building a keyword string to building a value string
            itype=1
         ! beginning of a delimited parameter value
         elseif(currnt  ==  """".and.itype  ==  1)then
            ! second of a double quote, put quote in
            if(prev  ==  """")then
                var(itype)(ipnt(itype):ipnt(itype))=currnt
                ipnt(itype)=ipnt(itype)+1
                current_command_length=ipoint
                delmt="on"
            elseif(delmt  ==  "on")then     ! first quote of a delimited string
                delmt="off"
            else
                delmt="on"
            endif
            if(ileave  ==  0.and.prev /= """")then  ! leave quotes where found them
               var(itype)(ipnt(itype):ipnt(itype))=currnt
               ipnt(itype)=ipnt(itype)+1
               current_command_length=ipoint
            endif
         else     ! add character to current parameter name or parameter value
            var(itype)(ipnt(itype):ipnt(itype))=currnt
            ipnt(itype)=ipnt(itype)+1
            if(currnt /= " ")then
               current_command_length=ipoint
            endif
         endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
      prev=currnt
      if(ipoint <= islen)then
         cycle
      endif
      exit
   enddo
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
   if(lget(trim(verb)//'_?'))then    ! if -? option was present prompt for values
      call menu(verb)
   endif
!=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
end subroutine parse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    store(3f) - [ARGUMENTS:M_kracken] add or replace value for specified name in dictionary(if allow='add' add name if needed)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine store(name1,value1,allow1,ier)
!!
!!    character(len=*),intent(in) :: name1
!!    class(*),intent(in)         :: value1
!!    character(len=*),intent(in) :: allow1
!!    integer,intent(out)         :: ier
!!
!!##DESCRIPTION
!!    Normally a command string and the associated values are placed in
!!    the dictionary by a call to KRACKEN(3f) when parsing a command
!!    line, or DISSECT(3f) and PARSE(3f) when creating input file
!!    interpreters. Rarely there may be a need to place
!!    <NAME,VALUE> pairs directly into the command dictionary, so this
!!    routine is public in the M_kracken(3fm) module. However,
!!    *this routine is primarily assumed to be an internal procedure*.
!!
!!##OPTIONS
!!    NAME1    name in dictionary of form VERB_KEYWORD
!!    VALUE1   value to be associated to NAME1. Value may be of type INTEGER,
!!             REAL, DOUBLEPRECISION, LOGICAL or CHARACTER.
!!    ALLOW1   flag to allow new VERB_KEYWORD name being added. Should be
!!              'define'  add or replace a new VERB_KEYWORD entry and value
!!              'add'     add or append to a new VERB_KEYWORD entry and value
!!              'no_add' or 'append'  append to an *EXISTING* entry value
!!              'replace'             replace an *EXISTING* entry
!!
!!             If 'add' or 'append' and the value is not blank it will
!!             be APPENDED to the current value. If 'define' or 'replace'
!!             it will replace the value instead of appending to it.
!!
!!##RETURNS
!!    IER      flag if error occurs in adding or setting value
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_store
!!    use M_kracken, only : store, show
!!    implicit none
!!    integer :: ier
!!    ! The following should be equivalent to
!!    ! call kracken('MY',' &
!!    ! & -STRING My string value &
!!    ! & -INTEGER 1234 &
!!    ! & -INTEGER 0987654321 &
!!    ! & -REAL 1234.5678 &
!!    ! & -DOUBLE 123.4567d8 &
!!    ! & -LOGICAL T &
!!    ! & '
!!    call store('MY_STRING','My string value','add',ier)
!!    if(ier.ne.0)write(*,*)'ERROR: could not store MY_STRING ier=',ier
!!    ! now the verb MY is defined with the option -STRING so the
!!    ! dictionary has MY_STRING='My string value' defined
!!
!!    ! this will be an error because MY does not have the -INTEGER
!!    ! keyword defined
!!    call store('MY_INTEGER',12345678,'no_add',ier)
!!
!!    ! now define MY_INTEGER
!!    call store('MY_INTEGER',1234,'add',ier)
!!    ! if 'no_add' it will APPEND to current string
!!    call store('MY_INTEGER',987654321,'add',ier)
!!
!!    call store('MY_REAL',1234.5678,'add',ier)
!!    call store('MY_DOUBLE',123.4567d8,'add',ier)
!!    call store('MY_LOGICAL',.true.,'add',ier)
!!
!!    call show('MY',.false.,0)
!!    write(*,*)repeat('=',76)
!!
!!    ! if 'replace' is used REPLACE instead of APPEND to current value
!!    call store('MY_INTEGER',987654321,'replace',ier)
!!    call show('MY',.false.,0)
!!    write(*,*)repeat('=',76)
!!
!!    ! 'replace' can only replace an existing entry, not add one
!!    call store('MY_UNKNOWN',987654321,'replace',ier)
!!    call show('MY',.false.,0)
!!    write(*,*)repeat('=',76)
!!
!!    end program demo_store
!!
!!   Results:
!!
!!    >########################################################
!!    >error: UNKNOWN OPTION -INTEGER
!!    >MY parameters are
!!    > -STRING My string value
!!    >########################################################
!!    > MY_STRING            = My string value
!!    > MY_REAL              = 1234.5677
!!    > MY_LOGICAL           = T
!!    > MY_INTEGER           = 1234 987654321
!!    > MY_DOUBLE            = 12345670000.000000
!!    > =======================================================================
!!    > MY_STRING            = My string value
!!    > MY_REAL              = 1234.5677
!!    > MY_LOGICAL           = T
!!    > MY_INTEGER           = 987654321
!!    > MY_DOUBLE            = 12345670000.000000
!!    > =======================================================================
!!    >########################################################
!!    >error: UNKNOWN OPTION -UNKNOWN
!!    >MY parameters are
!!    > -STRING My string value
!!    > -REAL 1234.5677
!!    > -LOGICAL T
!!    > -INTEGER 987654321
!!    > -DOUBLE 12345670000.000000
!!    >########################################################
!!    > MY_STRING            = My string value
!!    > MY_REAL              = 1234.5677
!!    > MY_LOGICAL           = T
!!    > MY_INTEGER           = 987654321
!!    > MY_DOUBLE            = 12345670000.000000
!!    > =======================================================================
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine store(name1,value1,allow1,ier)

! ident_17="@(#) M_kracken store(3f) replace or add dictionary entry name and value (if allow='add' add name if necessary)"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)        :: name1       ! name in dictionary of form VERB_KEYWORD
class(*),intent(in)                :: value1      ! value to be associated to NAME1
character(len=*),intent(in)        :: allow1      ! flag to allow new VERB_KEYWORD name being added
integer,intent(out)                :: ier         ! flag if error occurs in adding or setting value
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=:),allocatable       :: l_value1    ! value to be associated to NAME1
integer                            :: ilen
character(len=IPverb)              :: name
integer                            :: indx
character(len=10)                  :: allow
character(len=IPvalue)             :: value
character(len=IPvalue)             :: mssge       ! the  message/error/string  value
integer                            :: nlen
integer                            :: new
integer                            :: ii
integer                            :: i10
integer                            :: inew
!-----------------------------------------------------------------------------------------------------------------------------------
   select type(value1)                         ! convert non-character values to character string
   type is(integer)
      allocate(character(len=30):: l_value1)
      write(l_value1,'(i0)')value1
   type is(logical)
      l_value1=merge('T','F',value1)
   type is(real)
      allocate(character(len=30):: l_value1)
      write(l_value1,'(g0.8)')value1
   type is(doubleprecision)
      allocate(character(len=30):: l_value1)
      !does not work in ifort/ifx!write(l_value1,'(g0)')value1
      write(l_value1,'(es24.17)')value1
   type is(character(len=*))
      l_value1=value1
   class default
      error stop 'unknown type'
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   if(debug) write(*,*)'STORE ',trim(name1)//'::'//trim(l_value1)//'::'//trim(allow1)
!-----------------------------------------------------------------------------------------------------------------------------------
   value=" "
   name=" "                                          ! compiler bug. KLUDGE
   allow=" "
   name=name1                                        ! store into a standard size variable for this type

   ii=index(name,"_")                                ! -- is an alias for -oo
   ii=min(ii,IPverb-2)
   if(name(ii+1:).eq.' ')then
      name(ii+1:)='oo'
   endif

   value=l_value1                                    ! store into a standard size variable for this type
   allow=allow1                                      ! store into a standard size variable for this type
   nlen=len(name1)
!-----------------------------------------------------------------------------------------------------------------------------------
   if(.not.allocated(dict_verbs)) call initd()
   call locate(dict_verbs,name,indx,ier,mssge)       ! determine storage placement of the variable and whether it is new
   if(ier  ==  -1)then                               ! an error occurred in determining the storage location
      call journal('sc', "error occurred in *store* name=", name, "indx=", indx)
      call journal('sc', "ier=", ier, "message=", mssge)
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(indx > 0)then                                       ! found the variable name
      new=1
   elseif( allow  ==  'add'.or. allow == 'define' )then   ! check if the name needs added and allow to add
      inew=iabs(indx)                                     ! adding the new variable name in the variable name array
      call insert(dict_verbs,name,inew)                   ! pull down the dictionary arrays to make room for new value
      call insert(dict_vals," ",inew)
      call insert(dict_calls,0,inew)
      call insert(dict_lens,0,inew)

      if(ier  ==  -1)then
         call journal("*store* could not add "//name(:nlen))
         call journal(mssge)
         return
      endif
      new=0
!-----------------------------------------------------------------------------------------------------------------------------------
   else                                              ! did not find variable name but not allowed to add it
      ii=index(name,"_")
      call journal("########################################################")
      call journal("*store* error: UNKNOWN OPTION -"//name(ii+1:))
      if(ii > 0)then
         call journal(name(:ii-1)//" parameters are")
         do i10=1,size(dict_verbs)
            if(name(:ii)  ==  dict_verbs(i10)(:ii))then
               if(dict_verbs(i10)(ii:ii+1).eq.'__')then
                  call journal(" --"//dict_verbs(i10)(ii+2:len_trim(dict_verbs(i10)))//" "//dict_vals(i10)(:dict_lens(i10)))
               else
                  call journal(" -"//dict_verbs(i10)(ii+1:len_trim(dict_verbs(i10)))//" "//dict_vals(i10)(:dict_lens(i10)))
               endif
            endif
         enddo
      endif
      call journal("########################################################")
      ier=-10
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ! ignore special value that means leave alone, used by 'set up' calls to leave a value alone
   ! note that this will prevent the keyword from being defined.
   indx=iabs(indx)  ! entry existed or was added
   if(indx.eq.0)then
      write(*,*)'*store* error: INDEX=0'
   elseif(value(1:4)  ==  "@LV@")then
      ! a leave-alone flag (for use by a 'defining' call)
      if(new  ==  0) then
         value=value(5:)                                                  ! trim off the leading @LV@
         if(dict_calls(INDX).eq.0.or.dict_vals(INDX).eq.' ')then
            call replace(dict_vals,value,INDX)
         else
            if(allow.eq.'define')then
               call replace(dict_vals,value,INDX)                             ! set a defined variable's value
            else
               call replace(dict_vals,trim(dict_vals(INDX))//' '//value,INDX) ! append a defined variable's value
            endif
         endif
         dict_lens(INDX)= len_trim(dict_vals(INDX))                       ! store length of string
         dict_calls(INDX)=dict_calls(INDX)+1                              ! detect duplicate use of a keyword
      endif
   else
      if(dict_calls(INDX).eq.0.or.dict_vals(INDX).eq.' ')then             ! if first time given a value or value blank
         call replace(dict_vals,value,indx)                               ! store a defined variable's value
      elseif(allow.eq.'replace'.or.allow.eq.'define')then
         call replace(dict_vals,value,indx)                               ! set a defined variable's value
      else
         call replace(dict_vals,trim(dict_vals(INDX))//' '//value,indx)   ! set a defined variable's value
      endif
      dict_lens(INDX)= len_trim(dict_vals(INDX))                          ! store length of string
      dict_calls(INDX)=dict_calls(INDX)+1                                 ! detect duplicate use of a keyword
   endif
   !---------------------------------------------------!
   !()()()()()()()()()()-                              !
   !---------------------                              !
   ! assume suffix _> is used to open file for journal()   !
   ! special-purpose just for USH.                     !
   ilen=len_trim(name)                                 !
      if(ilen.ge.2)then                                !
         if(name(ilen-1:ilen).eq.'_>')then             !
         if(value.ne."#N#")then                        !
            call journal('N',value)                    !
         endif                                         !
      endif                                            !
   endif                                               !
   !---------------------                              !
   !()()()()()()()()()()-                              !
   !---------------------------------------------------!
!-----------------------------------------------------------------------------------------------------------------------------------
   if(debug) write(*,*)'STORE END ',trim(name1)//'::'//trim(l_value1)//'::'//trim(allow1)
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine store
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    subscript_(3fp) - [ARGUMENTS:M_kracken] return the subscript value of a string when given its name
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function subscript_(chars0)
!!
!!    character(len=*),intent(in) :: chars0
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!
!!##RETURNS
!!
!!##EXAMPLE
!!
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function subscript_(chars0)

! ident_18="@(#) M_kracken subscript_(3fp) return the subscript value of a string when given its name"

!  WARNING: only request value of names known to exist
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=*),intent(in)        :: chars0
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=IPverb)              :: chars
   character(len=IPvalue)             :: mssge
   integer                            :: ierr
   integer                            :: indx
   integer                            :: subscript_
!-----------------------------------------------------------------------------------------------------------------------------------
   chars=chars0
   indx=0
   ierr=0
   call locate(dict_verbs,chars,indx,ierr,mssge)                        ! look up position
!-----------------------------------------------------------------------------------------------------------------------------------
   if((ierr  ==  -1).or.(indx <= 0))then
      !call journal("*subscript_* variable "//trim(chars)//" undefined")
      subscript_=-1                                                       ! very unfriendly subscript value
   else
      subscript_=indx
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function subscript_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    menu(3fp) - [ARGUMENTS:M_kracken] prompt for values using a menu interface
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine menu(verb)
!!
!!    character(len=*),intent(in)  :: verb
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!
!!##RETURNS
!!
!!##EXAMPLE
!!
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine menu(verb)

! ident_19="@(#) M_kracken menu(3fp) prompt for values using a menu interface"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: verb
!-----------------------------------------------------------------------------------------------------------------------------------
   character(len=IPvalue)    :: reply
   character(len=IPvalue)    :: prompt
   integer                   :: ii
   integer                   :: icount
   integer                   :: ios
   integer                   :: i10
   integer                   :: i20
   integer                   :: istart
   integer                   :: iend
   integer                   :: iend_OK   ! last open actually printed
   integer                   :: ifound
   integer                   :: ireply
   integer                   :: ivalu
   integer                   :: ierr
   integer                   :: indx
   character(len=IPvalue)    :: mssge     ! the message/error/string  value returned by BOUNCE(3f)
   character(len=1)          :: prefix
   integer                   :: icurrent  ! current menu item
   integer                   :: icmd
   integer                   :: imenu
   character(len=80),allocatable :: help_text(:)
   integer                       :: i
   integer                       :: cstat
   character(len=256)            :: sstat
!-----------------------------------------------------------------------------------------------------------------------------------
   stop_command=.false.
   ii=len_trim(verb)
   call journal(verb(:ii)//" parameters are")
   istart=1
   icurrent=1
!-----------------------------------------------------------------------------------------------------------------------------------
   if(.not.allocated(dict_verbs)) call initd()
   INFINITE: do
      icount=0                                                ! how many entries in the dictionary belong to this command
      iend=size(dict_verbs)                                   ! last dictionary entry to search for current command
      iend_OK=istart
      MAKEMENU: do i10=istart,iend                            ! search dictionary for keywords for current command
         if(verb(:ii)//'_'  ==  dict_verbs(i10)(:ii+1))then   ! found part of the desired command
            if(istart.eq.0)then
               istart=i10                                     ! store index to the beginning of this command
               icurrent=i10
            endif
            icount=icount+1                                   ! count keywords that start with VERB_
            if(dict_verbs(i10).eq.verb(:ii)//'_?')then        ! do not show the keyword VERB_?
               cycle MAKEMENU
            endif
            call locate(dict_verbs,'?'//dict_verbs(i10),indx,ierr,mssge) ! if ?VERB is defined assume it is a prompt
            if(indx.gt.0)then
               prompt=dict_vals(indx)
            else
               prompt=' '
            endif
            if(i10.eq.icurrent)then
              prefix='>'
            else
              prefix=' '
            endif
            imenu=i10-istart+1
            if(prompt.eq.'')then
               write(*,'(a,i4,")",a,a)') prefix,imenu,dict_verbs(i10)(ii+2:),trim(dict_vals(i10)(:dict_lens(i10)))
               iend_OK=i10
            elseif(prompt.eq.'#N#'.or.prompt.eq.'"#N#"')then                 ! special prompt value which means to skip prompting
            else
               write(*,'(a,i4,")",a,":[",a,"]")') prefix,imenu,trim(prompt),trim(dict_vals(i10))
               iend_OK=i10
            endif
         endif
      enddo MAKEMENU
      iend=icount+istart-1                                 ! no need to go thru entire dictionary on subsequent passes
!-----------------------------------------------------------------------------------------------------------------------------------
      write(*,'(a)',advance='no')'Enter parameter number to change("RETURN" to finish):'
      read(*,'(a)',iostat=ios)reply
      if(ios.ne.0)then
         reply=' '
      else
         reply=adjustl(reply)
      endif
      ivalu=-1
!-----------------------------------------------------------------------------------------------------------------------------------
      select case(REPLY(1:1))
!-----------------------------------------------------------------------------------------------------------------------------------
      case('-')  ! if it starts with a - assume it is a new specification of the arguments
         call parse(verb,trim(reply)//' -? .false.',"no_add")
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('@')                                        ! debug option to dump dictionary
         do i20=1,size(dict_verbs)
            if(dict_verbs(i20).ne.' ')then
                 write(*,*)i20,trim(dict_verbs(i20)),trim(dict_vals(i20)(:dict_lens(i20)))
            endif
         enddo
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('#')                                                                  ! ignore
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case(' ','q','e','0')                                                      ! exit menu changes
         exit INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('x','.')                                                              ! return value to indicate command has been stopped
         stop_command=.true.
         exit INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('!')                                                                      ! call system
         call execute_command_line(trim(reply(2:)), exitstat=icmd,cmdstat=cstat,cmdmsg=sstat)   ! execute system command
         if(icmd.ne.0)then                                                           ! if system command failed exit program
            call journal('sc','*M_kracken:menu* ERROR - SYSTEM COMMAND FAILED:',icmd)
         endif
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('?','h','i')                                                              ! get help information
      help_text=[ CHARACTER(LEN=80) ::                                                       &
!        &'12345678901234567890123456789012345678901234567890123456789012345678901234567890',&
         &'#------------------------------------------------------------------------------#',&
         &'| How to change parameter options by number:                                   |',&
         &'|  o  NNN              the number of the menu option to change the value of    |',&
         &'#------------------------------------------------------------------------------#',&
         &'| How to change parameter options by respecifying them:                        |',&
         &'|  o  -key1 value1 -key2 value2 ...                                            |',&
         &'|                      to respecify values using original specification style  |',&
         &'#------------------------------------------------------------------------------#',&
         &'# Working on the current keyword(identified by a ">" prefix in the menu):      |',&
         &'|  o  c                change current option value with command-line editor    |',&
         &'|  o  n                change "current" to next menu option                    |',&
         &'|  o  p                change "current" to previous menu option                |',&
!        &'|  o  /name            change "current" option to keyword "name"               |',&
         &'#------------------------------------------------------------------------------#',&
         &'| Exit menu mode:                                                              |',&
         &'|  o   |q|e|0          a RETURN on a blank line or the indicated characters    |',&
         &'|                      exits the menu and processes the command                |',&
         &'|  o  .                indicate to program to ignore command (may be ignored ) |',&
         &'#------------------------------------------------------------------------------#',&
         &'| Special functions:                                                           |',&
         &'|  o  !command         execute system command                                  |',&
         &'|  o  ?|i|h            display this help                                       |',&
         &'#------------------------------------------------------------------------------#']
         WRITE(*,'(a)')(help_text(i),i=1,size(help_text))
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('1','2','3','4','5','6','7','8','9')
         ivalu=nint(s2v(reply))
         ivalu=ivalu+istart-1
!-----------------------------------------------------------------------------------------------------------------------------------
      case('c')                                            ! change current menu item
         ivalu=icurrent
!-----------------------------------------------------------------------------------------------------------------------------------
      case('d')                                            ! turn on debug mode
         debug=.true.
         call journal('*menu* DEBUG: debug mode on')
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('D')                                            ! turn off debug mode
         debug=.false.
         call journal('*menu* DEBUG: debug mode off')
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('p')                                            ! change previous menu item
         icurrent=icurrent-1
         icurrent=max(icurrent,istart)
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('v')                                            ! show version
        !call journal('Version 20140403')
        !call journal('Version 20151229')
        !call journal('Version 20160414')
         call journal('Version 20191018')
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case('n')                                            ! change next menu item
         icurrent=icurrent+1
         if(debug)then
             call journal('sc','*menu* DEBUG: ICURRENT=',icurrent)
             call journal('sc','*menu* DEBUG: ISTART=',istart)
             call journal('sc','*menu* DEBUG: IEND=',iend)
             call journal('sc','*menu* DEBUG: IEND_OK=',iend_ok)
         endif
         icurrent=min(icurrent,iend_OK)
         cycle INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
      case default
         call journal(' Unrecognized selection (? for help)')
         cycle INFINITE
      end select
!-----------------------------------------------------------------------------------------------------------------------------------
      ireply=ivalu
!-----------------------------------------------------------------------------------------------------------------------------------
      if((ivalu.lt.istart).or.(ivalu.gt.iend))then
         write(*,*)'illegal menu choice ',istart,'<=',ivalu,'<=',iend, ' (enter "?" for help)'
!-----------------------------------------------------------------------------------------------------------------------------------
      else
         ifound=ireply                                                    ! index into dictionary for requested keyword and value
         if(dict_verbs(ifound).eq.verb(:ii)//'_?')then                    ! replaced this with FINISHED so exit
            exit INFINITE
         endif
         call locate(dict_verbs,'?'//dict_verbs(ifound),indx,ierr,mssge) ! if ?VERB is defined assume it is a prompt
         if(indx.gt.0)then
            prompt=dict_vals(indx)
         else
            prompt=' '
         endif
         if(prompt.eq.'')then
            write(*,'("Enter value for ",a,":")',advance='no') trim(dict_verbs(ifound)(ii+2:))
         elseif(prompt.eq.'#N#'.or.prompt.eq.'"#N#"')then                 ! special prompt value
         else
            write(*,'(a,":")',advance='no') trim(prompt)
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
         read(*,'(a)',iostat=ios)reply
         call store(dict_verbs(ifound),reply,"no_add",ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
      endif
   enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   call store(trim(verb)//'_?','.false.','add',ierr)                      ! all commands have the option -? to invoke prompt mode
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine menu
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    show(3f) - [ARGUMENTS:M_kracken] dump dictionary entries
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine show(VERB_NAME0,VERBS_ONLY,IWIDE)
!!
!!    character(len=*),intent(in)   :: VERB_NAME0
!!    logical,intent(in)            :: VERBS_ONLY
!!    integer,intent(in)            :: iwide
!!
!!##DESCRIPTION
!!    Write information about a command from the command dictionary or list all the
!!    command verbs in the dictionary
!!
!!##OPTIONS
!!    VERB_NAME0   verb prefix to display. Default is all
!!    VERBS_ONLY   flag to show verbs only
!!    IWIDE        if .ge. zero, how many columns wide to show just verbs
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_show
!!     use M_kracken, only : kracken, show
!!     implicit none
!!
!!     call kracken('demo', ' default keyword -i 10 -j 20.20 -value my default string')
!!     call show('demo',.false.,0)
!!
!!     end program demo_show
!!   Results:
!!
!!     demo_value           = my default string
!!     demo_oo              = default keyword
!!     demo_j               = 20.20
!!     demo_i               = 10
!!     demo_?               = .false.
!!     demo_>               = #N#
!!
!!##SEE ALSO
!!    M_kracken(3f),  kracken(3f)
!!
!!    dget(3f), dgets(3f), iget(3f), igets(3f), lget(3f), lgets(3f),
!!    rget(3f), rgets(3f), sget(3f), sgets(3f), retrev(3f)
!!
!!    parse(3f), dissect(3f), store(3f), setprompts(3f), show(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine show(VERB_NAME0,VERBS_ONLY,IWIDE)

! ident_20="@(#) M_kracken show(3f) dump dictionary entries"

character(len=*),intent(in)   :: VERB_NAME0     ! verb prefix to display. Default is all
logical,intent(in)            :: VERBS_ONLY     ! flag to show verbs only
integer,intent(in)            :: iwide          ! if .ge. zero, how many columns wide to show just verbs
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=IPvalue)        :: VERB_NAME      ! verb prefix to display. Default is all
character(len=IPvalue)        :: message
integer                       :: i
integer                       :: j
integer                       :: ii
integer                       :: ich
integer                       :: istart
integer                       :: istep
integer                       :: iwide_local
integer                       :: verb_length
integer,parameter             :: bug=0  ! for gfortran-11 bug
!-----------------------------------------------------------------------------------------------------------------------------------
   if(.not.allocated(dict_verbs)) call initd()
!-----------------------------------------------------------------------------------------------------------------------------------
   iwide_local=iwide
   if(iwide_local.le.0)iwide_local=80
   VERB_NAME=VERB_NAME0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(VERBS_ONLY)then                                         ! show just verbs
      message=' '
      istart=1
      !!istep=len(DICT_VERBS)
      istep=1
      verb_length=1
      call journal('+c','')                                   ! start comment line
      do j=1,2                                                ! to make compact, make 1st pass to get length, 2nd pass to print
         do i=size(dict_verbs),1,-1                           ! loop thru entire dictionary
            if(DICT_VERBS(i)(1:1).eq.'?')cycle                ! remove prompts
            if(DICT_VERBS(i)(1:1).eq.'_')cycle                ! remove initial values
            verb_length=len_trim(DICT_VERBS(i))               ! find longest verb
            if(DICT_VERBS(i)(verb_length-2:).ne.'_oo') cycle  ! assume all commands have a VERB_oo value
            if(verb_length.lt.3)cycle                         ! looking for VERB_oo
            if(j.eq.1)then
               istep=max(istep,verb_length-3+1)
            elseif(istart+istep+1.gt.iwide_local)then
               call journal('ts','')                          ! end line
               call journal('+c','')                          ! start next comment line in trail so get pound character
               istart=1
               call journal('+st',adjustr(atleast(DICT_VERBS(i)(:verb_length-3),istep)))
               istart=istart+istep
            elseif(verb_length-3.gt.0.and.j.eq.2)then
               call journal('+st',adjustr(atleast(DICT_VERBS(i)(:verb_length-3),istep)))
               istart=istart+istep
            endif
         enddo
      enddo
      call journal('st','')
!-----------------------------------------------------------------------------------------------------------------------------------
   elseif(VERB_NAME.eq.' ')then                                   ! show all variables
      do i=1,size(dict_verbs)
         if(DICT_VERBS(i).ne.' ')then
            ii=max(1,dict_lens(i))                                 ! number of characters in corresponding dictionary VALUE
            call journal('sc',' ',atleast(DICT_VERBS(i),20)//'=',dict_vals(i))
         endif
      enddo
      call journal('sc',' dictionary size=',size(DICT_VERBS)+bug,&
              &'verb length=',len(DICT_VERBS)+bug,&
              &'value length=',len(DICT_VALS)+bug)
!-----------------------------------------------------------------------------------------------------------------------------------
   else                                                        ! show only verb_ variables
      ich=index(VERB_NAME,' ')                                 ! VERB_NAME assumed longer than any verb name, so at least one space
      VERB_NAME(ich:ich)='_'
      SCAN_DICTIONARY: do i=1,size(dict_verbs)
         if(DICT_VERBS(i).eq.' ')cycle SCAN_DICTIONARY
         if(VERB_NAME(:ich).eq.DICT_VERBS(i)(:ich))then
           ii=max(1,dict_lens(i))                          ! number of characters in corresponding dictionary VALUE
           call journal('+sc',' ',atleast(DICT_VERBS(i),20)//'=')
           call journal(dict_vals(i)(:ii))
         endif
      enddo SCAN_DICTIONARY
!-----------------------------------------------------------------------------------------------------------------------------------
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine show
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine initd()
   dict_verbs=[character(len=0) ::]  ! string variable names
   dict_vals=[character(len=0)  ::]  ! contains the values of string variables
   dict_calls=[integer ::]           ! number of times this keyword stored on a call to parse
   dict_lens=[integer ::]            ! significant lengths of string variable values
end subroutine initd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine cmd_args_to_dictionary(verb)

! ident_21="@(#) M_kracken cmd_args_to_dictionary(3f) convert command line arguments to dictionary entries using alternate style"

character(len=*),intent(in)  :: verb
integer                      :: pointer
character(len=:),allocatable :: lastkeyword
integer                      :: i
integer                      :: ilength, istatus, imax
integer                      :: ibig
character(len=:),allocatable :: current_argument
character(len=:),allocatable :: current_argument_padded
character(len=:),allocatable :: dummy
character(len=:),allocatable :: oldvalue
logical                      :: nomore
logical                      :: keyword_single
integer                      :: ierr
! revisit this. Assuming .false. and .true. can only occur as values for a logical switch is not valid but is a low risk.
! this could be particularly strange because .false. and .true. get converted to .true. to handle a duplicate logical switch
   if(allocated(unnamed))then
      deallocate(unnamed)
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   allocate(character(len=ibig) ::unnamed(0))
   unnamed=[character(len=ibig) ::]            ! kludge

   nomore=.false.
   pointer=0
   lastkeyword=' '
   keyword_single=.true.
   GET_ARGS: do i=1, command_argument_count()                                                        ! insert and replace entries
      call get_command_argument(number=i,length=ilength,status=istatus)                              ! get next argument
      if(istatus /= 0) then                                                                          ! stop program on error
         call journal('sc','*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
            &'status=',istatus,&
            &'length=',ilength)
         exit GET_ARGS
      else
         if(allocated(current_argument))deallocate(current_argument)
         ilength=max(ilength,1)
         allocate(character(len=ilength) :: current_argument)
         call get_command_argument(number=i,value=current_argument,length=ilength,status=istatus)    ! get next argument
         if(istatus /= 0) then                                                                       ! stop program on error
            call journal('sc','*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
               &'status=',istatus,&
               &'length=',ilength,&
               &'target length=',len(current_argument))
            exit GET_ARGS
          endif
      endif

      if(current_argument.eq.'--')then ! everything after this goes into the unnamed array
         nomore=.true.
         pointer=0
         cycle
      endif
      dummy=current_argument//'   '
      current_argument_padded=current_argument//'   '
      if(.not.nomore.and.current_argument_padded(1:2).eq.'--'.and.index('0123456789.',dummy(3:3)).eq.0)then ! beginning of long word
         keyword_single=.false.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate(dict_verbs,verb//'_'//current_argument_padded(3:),pointer)
         if(pointer.le.0)then
            call journal('sc','*cmd_args_to_dictionary* UNKNOWN LONG KEYWORD: ',current_argument)
            call print_kracken_dictionary('OPTIONS:')
            stop 1
         endif
         lastkeyword=verb//'_'//trim(current_argument_padded(3:))
      elseif(.not.nomore .and. current_argument_padded(1:1).eq.'-' .and. index('0123456789.',dummy(2:2)).eq.0 .and. &
         & current_argument_padded.ne.'-')then  ! short word
         keyword_single=.true.
         if(lastkeyword.ne.'')then
            call ifnull()
         endif
         call locate(dict_verbs,verb//'_'//current_argument_padded(2:),pointer)
         if(pointer.le.0)then
            call journal('sc','*cmd_args_to_dictionary* UNKNOWN SHORT KEYWORD: ',current_argument)
            call print_kracken_dictionary('OPTIONS:')
            stop 2
         endif
         lastkeyword=verb//'_'//trim(current_argument_padded(2:))
      elseif(pointer.eq.0)then                                                                           ! unnamed arguments
         imax=max(len(unnamed),len(current_argument))
         !!write(*,*)'GOT HERE 4 UNNAMED:',current_argument,size(unnamed)
         unnamed=[character(len=imax) :: unnamed,current_argument]
      else
         if(debug)then
            call journal('sc','POINTER=',pointer,' KEYWORD=',dict_verbs(pointer),' VALUE=',current_argument,' LENGTH=',ilength)
         endif
         oldvalue=sget(dict_verbs(pointer))//'  '
         if(upper(oldvalue).eq.'.F'.or.upper(oldvalue).eq.'.T')then  ! assume boolean parameter
            if(current_argument.ne.' ')then
               imax=max(len(unnamed),len(current_argument))
               !!write(*,*)'GOT HERE 5',current_argument,size(unnamed)
               unnamed=[character(len=imax) :: unnamed,current_argument]
            endif
            current_argument='.true.'
         endif
         !!call journal('sc','GOT HERE D KEY=',dict_verbs(pointer),'VALUE=',current_argument,&
         !!   &'OLDVALUE=',oldvalue,'LASTKEYWORD=',lastkeyword)
         if(upper(oldvalue).eq.'.FALSE.'.or.upper(oldvalue).eq.'.TRUE.')then
            imax=max(len(unnamed),len(current_argument))
            unnamed=[character(len=imax) :: unnamed,current_argument]
            call store(dict_verbs(pointer),'.true.','replace',ierr)
         else
            call store(dict_verbs(pointer),current_argument,'replace',ierr)
         endif
         pointer=0
         lastkeyword=''
      endif
   enddo GET_ARGS
   if(lastkeyword.ne.'')then
      call ifnull()
   endif

contains
subroutine ifnull()
   oldvalue=sget(lastkeyword)//'  '
   if(upper(oldvalue).eq.'.F'.or.upper(oldvalue).eq.'.T')then
      !!call journal('sc','GOT HERE E','KEY=',dict_verbs(pointer),'VALUE ',oldvalue,'TO T',' LASTKEYWORD=',lastkeyword)
      call store(lastkeyword,'.true.','replace',ierr)
   else
      !!call journal('sc','GOT HERE F','KEY=',dict_verbs(pointer),'VALUE ',oldvalue,'TO BLANK',' LASTKEYWORD=',lastkeyword)
      if(upper(oldvalue).eq.'.FALSE.'.or.upper(oldvalue).eq.'.TRUE')then
         call store(lastkeyword,'.true.','replace',ierr)
      else
         call store(lastkeyword,' ','replace',ierr)
      endif
   endif
end subroutine ifnull

end subroutine cmd_args_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_kracken_dictionary(header)
character(len=*),intent(in) :: header
integer                     :: i
   if(allocated(dict_verbs))then
      if(size(dict_verbs).gt.0)then
         write(*,'(a,t21,1x,a5,a5,1x,a)')'OPTION','COUNT','LEN','VALUE'
         do i=1,size(dict_verbs)
            write(*,'(a,t21,i5,1x,i5,1x,"[",a,"]")') dict_verbs(i), dict_calls(i), dict_lens(i),trim(dict_vals(i))
         enddo
      endif
   endif
   if(allocated(unnamed))then
      if(size(unnamed).gt.0)then
         write(*,*)'UNNAMED:'
         do i=1,size(unnamed)
            write(*,'(i5.5,"[",a,"]")')i,unnamed(i)
         enddo
      endif
   endif
end subroutine print_kracken_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_kracken
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! HISTORY:
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20191018
! added 'kracken_method' and the 'args' method for users that prefer a more unix-like feel requiring quoted arguments on input
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20160414
! multiple uses of a keyword appends values together with a space in between rather than taking right-most definition
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20151228
! merged command-parsing module back into kracken. Makes kracken a little dirty and makes it require M_verify and M_journal
! but code is too similar in function to keep separate
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20151212
! allow cmd_oo to have default value
! requote token from the command line if it starts with - and has a space in it to make is possible to pass "-[^0-9-] values
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20131224
! minor cleanup
! updated 20131214
! added preliminary setprompts and menu as routines to explore prompting modes.
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20131206
! added optional error flag to KRACKEN(3f). If the error flag is not present, an error will cause the program to stop instead of
! always returning to the calling procedure.
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20131201
! create name CMD__NAME if --NAME is specified; so --version and --help are more easily used
! add dget(3f) function for returning doubleprecision values
! rename parse_two(3f) to dissect(3f) and make it public so input from sources other than
! command line arguments can be parsed easily.
!-----------------------------------------------------------------------------------------------------------------------------------
! updated 20131029
! read environment variable DEFAULT_CMD
! REMOVED
!-----------------------------------------------------------------------------------------------------------------------------------


!>>>>> build/dependencies/M_framework/src/M_framework.f90

module M_framework
use M_framework__journal
use M_framework__msg
use M_framework__verify
use M_framework__approx
use M_framework__utility
!use M_framework__attr
implicit none(type,external)
!private
! public ...
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    M_framework(3f) - [M_framework::INTRO] unit test framework
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!! M_framework(3f) is an aggregate of Fortran modules brought together to
!! provide unit testing for Fortran; and is particularly well suited for
!! use with the Fortran Package Manager (fpm).
!!
!! The support modules are useful for creating terminal messages, comparing
!! expected values to results, writing logfiles and playback journals
!! independant of unit testing as well.
!!
!! Typically unit testing can be integrated seamlessly into the fpm(1) subcommand
!! "test" making unit testing from github/gitlab CD/CI utilities as simple as
!! "fpm teet" in many cases.
!!
!!
!!  BASIC TIMING IS INCLUDED
!! As well as the expected **pass/fail/skipped unit testing** report.
!! basic **timing information** can be produced by the unit testing module
!! M_framework__verify(3f).
!!
!!  HOOKS ARE PROVIDED TO EXTERNAL LOCAL APPLICATIONS
!!
!! M_framework(3f) comes with a unique hook that allows calling your own
!! programs to integrate with local logging tools, report generators,
!! spreadsheets or other local infrastructure. The example program
!! "bookkeeper" is included that uses the hook to write example report
!! data files:
!!
!!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv),
!!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html)
!!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml)
!!
!! The hook can call any local program with an interface similar to
!! "bookkeeper". This allows modifying the program for local needs such
!! as sending e-mail alerts and so on without having to change the tests.
!!
!!   MESSAGES CAN BE COMPOSED ALMOST LIKE LIST-DIRECTED I/O
!! Messages can be composed of up to twenty scalar intrinsic variables,
!! allowing freedom in writing messages akin to that of list-directed I/O;
!! but simultaneously to a list of output units. This easily lets messages
!! go to stdout or stderr and a file of the user's choosing as well. Output
!! can even be sent to a scratch file, essentially creating a quiet mode.
!!
!!    DESIGNED FOR INTEGRATION WITH FPM(1)
!! In conjunction with fpm(1) it is easy to run the tests with the --runner
!! option, allowing for integration with other utilities as well such as
!! the GNU debugger gdb(1), valgrind(1), and other tools.
!!
!!    PROGRAMS INCLUDED TO GENERATE SKELETON TEST PROGRAM
!! Example programs are provided to create unit test skeleton programs to
!! ease usage.
!!
!!    EASILY USED WITH GITHUB CD/CI
!! Example CD/CI scripts that can be used with github are in the .github/
!! directory that assume your tests can by run by using "fpm test".
!!
!!    MOTIVATION
!! Including **unit testing** is strongly encouraged for any software package,
!! but particularly when it is to be used in programming environments the
!! package was not developed in.
!!
!! This is the typical case for public fpm(1) packages on github.
!!
!! Additionally the proposed rules for registered fpm(1) package repositories
!! include requiring package candidates themselves only have external
!! dependencies that are also registered repository packages ( of course
!! wrappers of C libraries or other existing libraries cannot easily be
!! conformed to this).
!!
!! As a result -- this project concentrates on tools for a procedural unit
!! testing framework based on nothing but standard Fortran that specifically
!! can be used as a remote fpm(1) dependency in fpm(1) packages that may
!! reside in public github repositories.
!!
!! That is, it is designed to be integrated with the fpm(1) "test" subcommand
!! as an external dependency. It is intended to have little or no other
!! dependencies and ultimately become a registered fpm(1) package to aid in
!! the development of the fpm(1) repository.
!!
!! That being said, it can be used standalone as well.
!!
!!##DESCRIPTION
!!
!! Unit testing allows you to automatically confirm changes are acceptable
!! so you can quickly and confidently make and release changes. But many of
!! the operations required for testing are useful generically. So this
!! project is broken down into small general-purpose modules and
!! one unit-testing-specific one.
!!
!! M_framework(3f) is composed of the following individual modules:
!!
!!  + **M\_framework__msg** is a small module that in particular
!!    can convert a list of variables of any of the common default types
!!    to a string.
!!
!!    It performs low-level operations that are often used by other larger
!!    modules so it is its own module to prevent circular dependencies.
!!
!!  + **M\_framework__journal__** allows for creating log and journal files
!!
!!  + **M\_framework__approx** contains routines for rounding and comparing
!!    floating-point values.
!!
!!  + **M\_framework__help** provides for creating a standard simple
!!    interactive help facility
!!
!!  + **M\_framework__verify** is at the heart of the collection and
!!    handles virtually all the unit-test-specific operations.
!!
!! The procedures can be used in a variety of ways. After using them for
!! a long time my typical usage has changed completely several times.
!!
!! As part of private software there was little problem calling the
!! procedures directly from within the modules where they resided; and even
!! auto-detecting the routines (a naming convention of "test\_suite\_$NAME"
!! was used). The routines were pre-installed on virtually all platforms
!! so using them was no more a burden than say, calling an intrinsic.
!!
!! Put autodetecting tools (at least the ones employed) are not generally
!! portable; and with public packages there is a strong incentive to
!! minimize the amount of infrastructure and external dependencies. It is
!! generally imperative to make package use as simple and generic as possible.
!!
!! So the suggested scheme is to create a small test program for each
!! procedure or closely related procedures in the fpm test/ directory.
!!
!!  + make a subroutine for each component to be tested
!!  + in each test procedure start it with a call to UNIT\_CHECK\_START(3f)
!!  + end each test procedure it with a call to UNIT\_CHECK\_END(3f)
!!  + make multiple calls to UNIT\_CHECK(3f) in-between to generate
!!    test results
!!  + call each of those test routines from the main program
!!  + end the main program with a call to UNIT\_CHECK\_STOP(3f)
!!
!! Optionally, before starting set preferred non-default modes.
!!
!! Use the 'fpm test' command to run specific tests; all tests (the default);
!! a list of tests or test names using simple globbing.
!!
!! As desired, command line options can be used to control various test
!! behaviors.
!!
!! As an example, we can create a skeleton program to test a few
!! routines. Using
!!
!!      fpm test_suite sqrt cos sin > test/test_suite.f90
!!
!! to create the skeleton program and then adding a few actual
!! calls to unit\_test\_check(3f) results in
!!
!!   Sample program:
!!
!!    program M_test_suite_M_intrinsics
!!    use,intrinsic :: iso_fortran_env, only : &
!!    & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
!!    !
!!    use M_framework, only : unit_test_start,unit_test,unit_test_end, &
!!                     unit_test_mode, unit_test_level, unit_test_stop
!!    use M_framework, only : CHECK_PREFIX ! change column one of messages
!!    !
!!    !use M_mymodule ! load any modules you will be testing
!!    implicit none
!!    double precision,allocatable :: expected(:), answers(:), input(:)
!!    double precision,parameter :: PI=atan(1.0d0)*4
!!    !! setup
!!       !---------------------------------------------------
!!       !OPTIONAL:
!!       !  values used in prefix column for various messages
!!       !  the default is to set them all to the basename of
!!       !  the executable running tests, but they can be
!!       !  altered. For example:
!!       CHECK_PREFIX=prefix(                  &
!!        check_MSG    =  'check_msg:   ', &
!!        check        =  'check:       ', &
!!        check_START  =  'check_start: ', &
!!        check_STOP   =  'check_stop:  ', &
!!        check_END    =  'check_end:   '  &
!!       )
!!       !---------------------------------------------------
!!       !OPTIONAL:
!!       ! the options available at run-time on the command
!!       ! line can have their defaults selected. See the
!!       ! man-page for the procedure for details.
!!       call unit_check_mode(
!!         ( keep_going=.true. ,
!!         flags=[character(len=0) ::],
!!         luns=[stdout],
!!         command, &
!!         brief=.false. ,
!!         interactive=.false. ,
!!         CMDLINE='',
!!         debug=.false. ,
!!         match
!!         )
!!       !---------------------------------------------------
!!    !! test each subroutine
!!       call test_sqrt()
!!       call test_cos()
!!       call test_sin()
!!    !! teardown
!!       call unit_test_stop()
!!    contains
!!    subroutine test_sqrt()
!!    integer :: i
!!       call unit_test_start('sqrt',msg='calculate the square root')
!!       input   =[1.0d0,4.0d0,9.0d0]
!!       expected=[1.0d0,2.0d0,3.0d0]
!!       answers=[(sqrt(input(i)),i=1,size(input))]
!!       call unit_test('sqrt', all(expected.eq.answers),&
!!          & 'check table of values')
!!       call unit_test('sqrt', sqrt(25.0d0).eq.5.0d0,&
!!          & 'got',sqrt(25.0d0),'expected',5.0d0)
!!       call unit_test_end('sqrt',msg='')
!!    end subroutine test_sqrt
!!
!!    subroutine test_sin()
!!       call unit_test_start('sin',msg='calculate the sine of a value')
!!       call unit_test_end('sin',msg='')
!!    end subroutine test_sin
!!
!!    subroutine test_cos()
!!       call unit_test_start('cos',msg='calculate the cosine of a value')
!!       call unit_test_end('cos',msg='')
!!    end subroutine test_cos
!!
!!    end program M_test_suite_M_intrinsics
!!
!! The output now looks like this (note if no calls to unit\_test
!! routines are made between unit_test_start(3f) and unit_test_end(3f)
!! the procedure gets an "UNTESTED" entry to remind you to make
!! some tests ..).
!!
!!    > check:       sqrt   SUCCESS : check table of values
!!    > check:       sqrt   SUCCESS : got 5.0000000000000000 expected 5.0000000000000000
!!    > check_end:   sqrt   PASSED  : GOOD:        2 BAD:        0 DURATION:00000000012000:
!!    > check_end:   cos    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:
!!    > check_end:   sin    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:
!!    > check_stop:  TALLY  PASSED  : GOOD:        2 BAD:        0 DURATION:00000000000000
!!    > STOP 0
!!
!! this is a model that works particularly well for basic numeric procedures.
!!
!! Now it is just a matter of adding more calls to unit\_test(3f). This is
!! where procedures from the other modules become useful, as they provide
!! methods for comparing float values, for example. Since Fortran has
!! many powerful masking intrinsics usually just the unit\_test(3f) procedure
!! is required. In particular, be familiar with the ALL(3f), ANY(3f),
!! and PACK(3f) procedures.
!!
!! There are options to call a system command and use the initial string as
!! options, to interactively pause after each check, and to change options
!! like which output file to write on, what error level to use, and other
!! things I will hopefully solidify and document here.
!!
!!    RECOMMENDED BASIC USAGE
!!
!! So for an fpm(1) user a recommended process is to create and/or enter the
!! test/ directory and use the "unit\_test" program. It will make a test
!! program called "unit\_test\_$NAME.f90" for each name given on the command
!! line.
!!
!! There is a case made for closely related groups of procedures to share
!! a single test file that will be made a little bit later. For that, the
!! command "test\_suite" is used instead of "unit\_test".
!!
!! For now lets assume we have or plan to have the procedures
!! "a","b", and "c" in our package, and that we want to create a test for
!! each ( and that unit\_test(1) has been installed in your path):
!!
!!     cd $TOP_OF_FPM_PACKAGE
!!     cd test
!!     unit_test a b c
!!
!! If you then run "fpm test" the skeleton should run indicating the
!! procedures are not tested. Change the routines to actually call the
!! "unit\_test" procedure and you have the beginnings of a unit test for
!! your procedures.
!!
!! The "unit\_test(3f)" procedure in its simplest form takes a string that
!! is usually the procedure name and a logical expression, along with up
!! to twenty completely optional intrinsic scalar values which will be used
!! to create an optional message.
!!
!! The example programs also contain a placeholder call to unit\_test\_mode(3f).
!!
!!    PROCEDURAL AND COMMAND LINE MODE OPTIONS
!! The dummy skeleton routines all start with a call to unix\_check\_mode(3f).
!! Its documentation describes a few default modes you can change with the
!! routine. Essentially the same options are available on the command line
!! of the test program(s) as well.
!!
!!     # options may be specified in NAMELIST input format with no
!!     # extraneous spaces on the command line
!!     fpm test -- flags=100,200,300 keep_going=T
!!     # a little more Unix-like or MSWindows-like syntax is allowed, as
!!     # these are equivalent to the original command ...
!!     fpm test -- --flags=100,200,300 --keep_going
!!     fpm test -- /flags=100,200,300 /keep_going=T
!!
!! M_framework(3f) uses a built-in command line parser instead of
!! packages like M\_CLI or M\_CLI2 to minimize the number of dependencies
!! required.
!!
!!    SUGGEST ONE TEST PER PROGRAM
!!
!! There are advantages to each procedure being tested with a separate
!! program.
!!
!! A large number of individual test programs works well with fpm(1).
!! fpm defaults to running all the tests, but can execute subgroups
!! easily because it can execute a list of tests and the names can
!! use simple globbing.
!!
!! If you autogenerate a list of procedure names to test and call the
!! sample program "unit_test" with the names of the procedures it will
!! generate new names but skip existing files; allowing for a simple form
!! of auto-generation assuming you have a way of listing all the procedure
!! names to test.
!!
!! individual procedure tests can be deleted or added or moved easily when
!! each is in its own file.
!!
!! It is easier to test with debuggers and other tools like gdb and valgrind
!! on small units.
!!
!! This is true with other tools that you can use with --runner as well.
!! See "fpm help runner" or "fpm manual \>manual.txt" for more information.
!!
!!     TESTING MANY PROCEDURES IN A SINGLE FILE
!!
!! If it is preferred, one program can test multiple procedures. The
!! main disadvantage is that the complete test suite is always run unless
!! conditional coding is added. One of the uses of the unit\_test\_flags(:)
!! array is to allow integer values to be passed at execution time that
!! can be tested to provide such conditional testing. When many tests are
!! in one file the unit_test_start(3f) procedure includes a "matched" argument
!! which can detect if a simple globbing expression that can be given on the
!! command line matches the string composed of the test name and message.
!! This allows you to optionally select specific groups of tests from a set.
!!
!!##UNIQUE FEATURES
!!
!!    CALLING AN EXTERNAL PROGRAM
!!
!! A unique feature of the M\_framework(3f) test harness is a hook to call
!! a custom program. You can ignore it is there, but it is a very powerful
!! feature if you want to do bookkeeping on the test results or enter
!! the results into a tracking tool. This allows you a way to sent alerts
!! if something fails in automated tests, to create spreadsheets with the
!! test results, to retain results in a database or SQLite3 file, or make
!! a custom tool to convert the data to something else like TAP (Test Anywhere
!! Protocol) reports.
!!
!! An example program called "bookkeeper" is included that shows how to
!! parse the information passed to the program that generates several files:
!!
!!    + bookkeeper.csv
!!    + bookkeeper.html
!!    + bookkeeper.nml
!!    + bookkeeper\_clicks.csv
!!
!! To use the defaults you simply enter
!!
!!     fpm test -- command=bookkeeper
!!
!! The CSV files can typically be read directly into a spreadsheet program.
!!
!! They can also be read using the SQLite3 tool. This is very powerful,
!! letting you use SQL to select specific data, generate reports, and
!! convert the subsequent results to HTML, CSV, flat text and other formats.
!!
!! The NAMELIST output file is essentially a record of the harness calls
!! using the standardized NAMELIST format that is almost trivial to read
!! in with a custom Fortran program. This might be considered a metafile
!! format for a test run. You can replay the data and do whatever you want
!! with it including generating alternate output file types; plotting
!! timing data and so on.
!!
!! The HTML file is handy for importing into word processors or viewing
!! via browsers. Example output files from an fpm(1) package that uses
!! M_framemaker illustrate the different types of output that can be
!! generated.
!!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv).
!!    Generally. comma-separated files can be read directly into spreadsheet
!!    programs, sqlite3, and several common databases.
!!  + [CSV runtimes](https://urbanjost.github.io/M_framework/bookkeeper_clicks.csv)
!!    Another CSV file that is a record of the runtimes between a
!!    unit test start and end.
!!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html)
!!    An example of a formatted report that can be displayed in a browser.
!!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml).
!!    Essentially this is a metafile that records the unit test calls.
!!    It is very easy for a custom Fortran program to read back a NAMELIST
!!    file and generate custom outputs instead of modifying bookkeeper(1).
!!
!! The bookkeeper(1) program is an example program that is expected to
!! be customized. It provides for parsing the parameters passed to a
!! M_framemaker external program.
!!
!!     IMPORTING INTO SQLLITE3
!! Here is an example SQLite3 Tool input file that if placed in "test.sql"
!! can be run with
!!
!!      sqlite3 -batch -init test.sql bookkeeper.db .quit
!!
!! if you have sqlite3(1) installed.
!!
!!    .mode csv
!!    .import bookkeeper.csv unit_check
!!    .schema unit_check
!!    ---
!!    --- show all data to show it worked
!!    SELECT * FROM unit_check;
!!    ---
!!    --- example lists unique names
!!    SELECT name FROM unit_check GROUP BY name ORDER BY name ;
!!    ---
!!    --- tally up passed, failed, skipped in a text table
!!    .header on
!!    .mode column unit_check
!!    .width 64 9 9 9
!!    SELECT name,
!!    --- depending on SQL version a simpler IIF/IF, IFNULL, or TOTAL might be better but this works well
!!    --- and is relatively "standard" as much as something like a standard is actually adhered to in
!!    --- SQL-land.
!!    CASE  sum( passed == 'passed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'passed')  END  AS 'ok',
!!    CASE  sum( passed == 'failed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'failed')  END  AS 'not ok',
!!    CASE  sum( passed == 'skipped' ) WHEN NULL THEN 0 ELSE sum ( passed == 'skipped') END  AS 'skip'
!!    FROM unit_check
!!    --- WHERE condition
!!    GROUP BY name
!!    ORDER BY name ;
!!    ---
!!    --- If the table already exists, the sqlite3 tool uses all the rows,
!!    --- including the first row, in the CSV file as the actual data to import.
!!    --- Therefore, you should delete the first row of the CSV file with the
!!    --- header labels if adding to an existing table instead of creating
!!    DROP TABLE IF EXISTS unit_check;
!!    --- CREATE TABLE unit_check(
!!    ---   name   TEXT NOT NULL,
!!    ---   date   DATE NOT NULL,
!!    ---   passed TEXT NOT NULL,
!!    ---   msg    TEXT
!!    --- );
!!
!! The last select generates a little tally table showing for all the runs
!! in the input DataBaseFile the number of pass, fail, and skips of the test
!! names. you could tally over a particular date range, only show failures,
!! display the last test status, generating output in HTML or CSV or ...
!! See the SQLite3 Tool documentation for sqlite3(3f) for more information.
!!
!!    name                                          ok         not ok     skip
!!    --------------------------------------------  ---------  ---------  ---------
!!    accdig                                        3          0          0
!!    almost                                        24         0          0
!!    flush_trail                                   0          0          3
!!    in_margin                                     30         0          0
!!    round                                         0          0          3
!!    set_stdout_lun                                0          0          3
!!    significant                                   15         1          2
!!    unit_test                                     0          0          3
!!    unit_test_bad                                 0          0          3
!!    unit_test_end                                 0          0          3
!!    unit_test_good                                0          0          3
!!    unit_test_start                               0          0          6
!!    unit_test_stop                                0          0          3
!!    where_write_message_all                       0          0          3
!!    write_message_only                            4          2          4
!!
!!##UNIQUE FEATURES
!!
!! fpm(1), gdb(1), and M\_framework(3f) work together
!!
!! It is easy to debug an individual test in a debugger. For example to run
!! a test called "crash" with gdb(1) use
!!
!!      fpm test --target crash --runner "gdb -ex run --quiet"
!!
!! A more elaborate example passing arguments to M\_framework(3f) to change
!! default behavior to for example write output to stdout instead of stderr
!! and display compiler version and options and to run all the tests in
!! the gdb(1) debugger (you can enter "q" after each test has run; or enter
!! gdb commands at the prompt):
!!
!!     > fpm test --target '*' --verbose !!     > --runner 'gdb -ex "list, 0" -ex run --quiet --args' !!     > -- flags=9997,9998,9999 luns=6 level=3

!!
!! This is long enough that an alias or script would facilitate its use,
!! with one changing it to use one's favorite options.
!!
!!    EASILY CALLED BY STANDARDIZED CD/CI SCRIPTS
!!
!! If a CD/CI github automated test script creates a Fortran
!! environment including fpm and simply calls "fpm test" you can standardize
!! your testing and use the same CD/CI scripts for any package. The testing
!! framework is designed with just that scenario in mind.
!!
!! The .github subdirectory in M\_framework package contains examples of just
!! such files that you can copy as-is into your fpm project. Activate test
!! actions in your github repository after adding the .github directory and
!! your package will be automatically tested on several different platforms
!! by the scripts whenever a "push" to the repository occurs.
!!
!! ------------------------------------------------------------------------------------------
!!
!!##SUPPORTS FPM
!!
!! The impatient can try this, assuming git(1) and fpm(1) are installed.
!!
!! Download the github repository and build it with fpm(1)
!! and create a test fpm(1) project:
!!
!!    #!/bin/bash
!!    # first you need to install a few example programs
!!    cd /tmp
!!    git clone https://github.com/urbanjost/M_framework.git
!!    cd M_framework
!!    # install the "unit_test", "bookkeeper", and "test_suite"
!!    # example programs; assuming the default install puts
!!    # them in your path:
!!    fpm install
!!    # "fpm help install" describes how to customize where the
!!    # programs are installed.
!!    #
!!    # go to your fpm package test/ directory.
!!    # here, we will make one up
!!    fpm new /tmp/tryit  # create test project
!!    cd /tmp/tryit/test
!!    # so lets say you plan on adding procedures "a","b",and "c" to your src/tryit.f90
!!    # project code. Set up individual skeleton tests for each procedure.
!!    unit_test a b c                         # a file for each test
!!    test_suite a b c > test_suite_tryit.f90 # or a single file
!!    cd ..  # go to the top of the project
!!    # add M_framework to the developer dependencies
!!    cat >> fpm.toml <<\EOF
!!    [dev-dependencies]
!!    M_framework    = { git = "https://github.com/urbanjost/M_framework.git" }
!!    EOF
!!    #
!!    # test the package
!!    fpm test
!!    # if will say the procedures are untested. Put real calls
!!    # in to unit_test(3f) and see how the default report
!!    # changes
!!    #
!!    # so now to run the default tests is as simple as
!!    fpm test
!!    # run just one test
!!    fpm test unit_test_a
!!    # run tests using globbing; eg. all tests beginning with "unit\_"
!!    fpm test 'unit_*'
!!    # display help on the interactive command options
!!    fpm test -- --help
!!
!!    # you can pass parameters and/or change the unit_test_mode(3f)
!!    # calls to change some of the test behavior
!!
!! So once you want to use this on your own projects, you would normally
!! just add M\_framework(3f) as a developer dependency
!! in your fpm.toml project file and start making tests that call M\_framework(3f).
!!
!! The optional programs demonstrated ("unit\_test", "test\_suite") are just simple
!! stand-alone programs that make skeleton programs to run tests that you can
!! customize (and rename too to avoid confusion).
!!
!!    # some useful things to try. Check out the man-pages for all the unit_test_*(3f)
!!    # procedures.
!!    # Then look at
!!    unit_test --help
!!    fpm test -- help
!!    # run the demo bookkeeper script
!!    fpm test -- command=bookkeeper
!!    # and look at the bookkeeper*.* files in the top of the project
!!
!!##DOCUMENTATION
!!
!!   USER
!!
!!  - An [index](https://urbanjost.github.io/M_framework/man3.html) to HTML versions
!!    of the manpages
!!
!!  - single pages that uses javascript to combine all the HTML descriptions
!!    of the man-pages is at
!!     + [BOOK_M_framework__verify](https://urbanjost.github.io/M_framework/BOOK_M_framework__verify.html)
!!     + [BOOK_M_framework__approx](https://urbanjost.github.io/M_framework/BOOK_M_framework__approx.html)
!!     + [BOOK_M_framework__journal](https://urbanjost.github.io/M_framework/BOOK_M_framework__journal.html)
!!     + [BOOK_M_framework__msg](https://urbanjost.github.io/M_framework/BOOK_M_framework__msg.html)
!!
!!  - man-pages in
!!     + [manpages.zip](https://urbanjost.github.io/M_framework/manpages.zip)
!!     + [manpages.tgz](https://urbanjost.github.io/M_framework/manpages.tgz)
!!
!!    DEVELOPER
!!    + [ford-generated developers' document](https://urbanjost.github.io/M_framework/fpm-ford/index.html)
!!    + [github action status](docs/STATUS.md)
!!
!!##ADDITIONAL DIRECTORY DESCRIPTIONS
!!
!!    - src/ is where the source for the M_framework(3f) module code resides
!!    - docs/ contains HTML documentation and the manpage archives
!!    - test/ contains simple test programs
!!    - example/ has demos
!!
!!##REFERENCES
!!  + See the .github directory in [easy](https://github.com/urbanjost/easy)
!!  + for examples of CD/CI scripts that assume your package can be tested with an "fpm test" command.
!!  + examples that use M_framework in github fpm packages:
!!      * [M_strings](https://github.com/urbanjost/M_strings)
!!      * [M_process](https://github.com/urbanjost/M_process)
!!
!!    These packages used a different reincarnation of the testing harness and are in the process of
!!    being changed to use M_framework(3f) more appropriately, but still contain some useful examples.
!!
!!  + [Fortran Package Manager](https://github.com/fortran-lang/fpm)
!!  + [fpm(1) registry](https://github.com/fortran-lang/fpm-registry)
!!  + [Fortran Wiki: unit testing list](https://fortranwiki.org/fortran/show/Unit+testing+frameworks)
!!  + [ford(1)](https://politicalphysicist.github.io/ford-fortran-documentation.html) for generating documentation for your projects
!!
!!    NOTE
!! M_framework(3f) is subject to interface changes so the generally recommended
!! practice of using a specific commit when using it an an external
!! fpm(1) dependency is highly encouraged.
!!
!! Any feedback (features, performance, ease of use, ...) is appreciated,
!! particularly in the ongoing development phase.
!!
!!
!!##QUOTE
!!    Do not let your victories go to your head, nor let your failures go
!!    to your heart.
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework


!>>>>> app/compute.f90

program compute
use M_kracken,    only : kracken, sget, lget
use M_calculator, only : calculator,iclen_calc
use M_history,    only : redo
use M_io,         only : read_line
use M_framework,  only : journal
!use M_noown, only     : juown1, c
!!implicit real(kind=selected_real_kind(15,300)) (a-h, o-z)
implicit none
integer,parameter            :: dp=selected_real_kind(15,300)
character(len=iclen_calc)    :: line
character(len=iclen_calc)    :: outlin
character(len=iclen_calc)    :: event
character(len=:),allocatable :: readin
character(len=:),allocatable :: trailfile
character(len=256)           :: csys
character(len=256)           :: mssge
integer                      :: isys, esys
real(kind=dp)                :: rvalue
integer                      :: ierr=0
logical                      :: verbose
integer                      :: in=5
integer                      :: ios
   call calculator('ownmode(1)',outlin,event,rvalue,ierr)     ! specify user-supplied routine contains extra routines for calculator
   call kracken('compute',' -oo -help .f. -version .f. -verbose .f. -trail') ! define and crack command line arguments
   call help_usage(lget('compute_help'))                      ! process -help switch
   call help_version(lget('compute_version'))                 ! process -version switch

   verbose=lget('compute_verbose')                     ! test if -verbose switch is present on command line
   trailfile=sget('compute_trail')
   if(trailfile.ne.' ')then
      call journal('O',trailfile)
   endif
   line=sget('compute_oo')                             ! get any expressions from command line to evaluate

   if(line.ne.'')then                                  ! if expressions on command line evaluate them
      call processit()
   else
      READ: do
         INFINITE: do while (read_line(readin,in)==0)  ! no expressions on command line to read expressions from stdin
            readin=adjustl(readin)//'  '               ! make at least two characters long and left-adjusted to avoid overindexing
            if(readin.eq.'.')then                      ! exit command is "."
               if(in.eq.5)then
                  exit INFINITE                        ! quit if user enters command "." on stdin
               else
                  close(in,iostat=ios)
                  in=5
                  cycle INFINITE
               endif
            elseif(readin(1:1).eq.'<')then             ! read from alternate input file assuming have "<filename"
               open(newunit=in,iostat=ios,file=readin(2:),iomsg=mssge)
               if(ios.ne.0)then                        ! file open failed, revert back to stdin
                  close(in,iostat=ios)
                  in=5
                  call journal('sc','error:',mssge)
               endif
               cycle INFINITE
            endif
            line=readin
            call redo(line,r='!')                         ! command history
            call journal('t',line)
            if(line(1:1).eq.'!')then                      ! system command
               call execute_command_line(line(2:),exitstat=esys,cmdstat=isys,cmdmsg=csys)   ! try as system command
            elseif(adjustl(line(1:1)).eq.'#')then         ! comment
            else                                          ! expression
               call processit()
            endif
         enddo INFINITE
         if(in.eq.5)exit READ
         close(in,iostat=ios)
         call journal('sc','exiting altername input file')
         in=5
      enddo READ
   endif
contains
   subroutine processit
      call calculator(line,outlin,event,rvalue,ierr)
      select case(ierr)                                                             ! several different meanings to the error flag
       case(-1);     call journal('sc','error===>',event)                           ! an error has occurred
       case(0)
         if(verbose.or.(in.ne.5))then
            call journal('sc',line,"=>",outlin)                                     ! a numeric value was returned without error
         else
            call journal('sc',outlin)                                               ! a numeric value was returned without error
         endif
       case(1);      call journal('sc','message===>',event)                         ! request for a message (from DUMP or FUNC)
       case(2);      call journal('sc',event(:int(rvalue)))                         ! a string value was returned without error
       case default; call journal('sc','*compute* unexpected ierr value ',ierr)     ! this should not occur
      end select
   end subroutine processit
subroutine help_usage(l_help)
implicit none
character(len=*),parameter     :: ident="@(#)help_usage(3f): prints help information"
logical,intent(in)             :: l_help
character(len=:),allocatable :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_help)then
help_text=[ CHARACTER(LEN=128) :: &
'NAME                                                                            ',&
'   compute(1f) - [MATH] evaluate a calculator expression                        ',&
'   (LICENSE:PD)                                                                 ',&
'SYNOPSISprep                                                                    ',&
'   compute [[STRING] [--trail FILENAME] [ -verbose]]|[ -help|-version]          ',&
'DESCRIPTION                                                                     ',&
'   Given any expression call the CALCULATOR(3f) calculator function and         ',&
'   evaluate it. If no expression is present on the command line, read           ',&
'   expressions from stdin until a line composed of a period(".") or             ',&
'   end of data is encountered.                                                  ',&
'                                                                                ',&
'   Expressions are similar to Fortran77 syntax except powers are                ',&
'   processed from left to right, and string variable names start                ',&
'   with a dollar-sign, and all numeric values are assumed to be                 ',&
'   DOUBLEPRECISION.                                                             ',&
'OPTIONS                                                                         ',&
'   STRING            calculator expression to evaluate                          ',&
'   --trail FILENAME  record actions on a trail file.                            ',&
'   --verbose         echo the input as well as the computed values              ',&
'   --help            display this help and exit                                 ',&
'   --version         output version information and exit                        ',&
'EXAMPLES                                                                        ',&
'  Sample commands:                                                              ',&
'                                                                                ',&
'    $ compute ''(sin(30.33333)*2)**2+40.0/2.3-1.23e3''                          ',&
'    $ compute funcs|more                                                        ',&
'                                                                                ',&
'    $ compute --trail record.txt                                                ',&
'    a=10                                                                        ',&
'    # The redo(3f) command is used for command recall and history               ',&
'    # by entering an exclamation on a line by itself or by following            ',&
'    # the exclamation by a space and an optional initial command for            ',&
'    # redo(3f). Enter "?" at the redo(3f) prompt for help using the             ',&
'    # command line history editor.                                              ',&
'                                                                                ',&
'    # enter a long calculation                                                  ',&
'    b=sin(a)**2+3.4e2+100-11*2/55.6                                             ',&
'    # use redo(3f) to change "sin" to "cos". Enter return to execute            ',&
'    # the changed line                                                          ',&
'    ! c/sin/cos                                                                 ',&
'                                                                                ',&
'    # system commands can be called if prefixed by exclamation                  ',&
'    !ls                                                                         ',&
'                                                                                ',&
'    # exit using a period on a line by itself                                   ',&
'    .                                                                           ',&
'                                                                                ',&
'    # a simple non-nesting alternate input file can be read                     ',&
'    <myfile                                                                     ',&
'                                                                                ',&
'    funcs # list available functions                                            ',&
'    dump  # list current variables                                              ',&
'                                                                                ',&
'SEE  ALSO                                                                       ',&
'   See the man(1) page for M_calculator(3fm) for a more detailed                ',&
'   description of the CALCULATOR(3f) routine.                                   ',&
'AUTHOR                                                                          ',&
'   John S. Urban                                                                ',&
'LICENSE                                                                         ',&
'   Public License                                                               ',&
'']
   WRITE(*,'(a)')(trim(help_text(i)),i=1,size(help_text))
   stop ! if --help was specified, stop
endif
end subroutine help_usage
!>
!!##NAME
!!    compute(1f) - [MATH] evaluate a calculator expression
!!    (LICENSE:PD)
!! SYNOPSISprep
!!    compute [[STRING] [--trail FILENAME] [ -verbose]]|[ -help|-version]
!!##DESCRIPTION
!!    Given any expression call the CALCULATOR(3f) calculator function and
!!    evaluate it. If no expression is present on the command line, read
!!    expressions from stdin until a line composed of a period(".") or
!!    end of data is encountered.
!!
!!    Expressions are similar to Fortran77 syntax except powers are
!!    processed from left to right, and string variable names start
!!    with a dollar-sign, and all numeric values are assumed to be
!!    DOUBLEPRECISION.
!!##OPTIONS
!!    STRING            calculator expression to evaluate
!!    --trail FILENAME  record actions on a trail file.
!!    --verbose         echo the input as well as the computed values
!!    --help            display this help and exit
!!    --version         output version information and exit
!!##EXAMPLES
!!
!!   Sample commands:
!!
!!     $ compute '(sin(30.33333)*2)**2+40.0/2.3-1.23e3'
!!     $ compute funcs|more
!!
!!     $ compute --trail record.txt
!!     a=10
!!     # The redo(3f) command is used for command recall and history
!!     # by entering an exclamation on a line by itself or by following
!!     # the exclamation by a space and an optional initial command for
!!     # redo(3f). Enter "?" at the redo(3f) prompt for help using the
!!     # command line history editor.
!!
!!     # enter a long calculation
!!     b=sin(a)**2+3.4e2+100-11*2/55.6
!!     # use redo(3f) to change "sin" to "cos". Enter return to execute
!!     # the changed line
!!     ! c/sin/cos
!!
!!     # system commands can be called if prefixed by exclamation
!!     !ls
!!
!!     # exit using a period on a line by itself
!!     .
!!
!!     # a simple non-nesting alternate input file can be read
!!     <myfile
!!
!!     funcs # list available functions
!!     dump  # list current variables
!!
!!##SEE  ALSO
!!    See the man(1) page for M_calculator(3fm) for a more detailed
!!    description of the CALCULATOR(3f) routine.
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public License
subroutine help_version(l_version)
implicit none
character(len=*),parameter     :: ident="@(#)help_version(3f): prints version information"
logical,intent(in)             :: l_version
character(len=:),allocatable   :: help_text(:)
integer                        :: i
logical                        :: stopit=.false.
stopit=.false.
if(l_version)then
help_text=[ CHARACTER(LEN=128) :: &
'@(#)PRODUCT:        GPF (General Purpose Fortran) utilities and examples>',&
'@(#)PROGRAM:        compute(1f)>',&
'@(#)DESCRIPTION:    line mode calculator program (that calls CALCULATOR(3f))>',&
'@(#)VERSION:        23.1 20160618>',&
'@(#)AUTHOR:         John S. Urban>',&
'@(#)HOME PAGE:      http://www.urbanjost.altervista.org/index.html>',&
'@(#)COMPILED:       2024-12-27 14:24:34 UTC-300>',&
'']
   WRITE(*,'(a)')(trim(help_text(i)(5:len_trim(help_text(i))-1)),i=1,size(help_text))
   stop ! if --version was specified, stop
endif
end subroutine help_version
end program compute

