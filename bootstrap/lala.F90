!>>>>> build/dependencies/M_framework/src/M_framework__msg.F90
module M_framework__msg
use,intrinsic :: iso_fortran_env, only : ERROR_UNIT,OUTPUT_UNIT    ! access computing environment
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
private
!-----------------------------------------------------------------------------------------------------------------------------------
! USED SO FREQUENTLY IN OTHER MODULES PUT IN THIS ONE WITH NO DEPENDENCIES TO PREVENT CIRCULAR DEPENDENCY
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_1="@(#) M_framework__msg str(3f) {msg_scalar msg_one}"

public str
public stderr
public wrt
public fmt
public set
public pdec
public assert
!!public :: a,i,f,g

interface str
   module procedure msg_scalar, msg_one
end interface str

interface set
   module procedure set_scalar
   module procedure set_single
end interface set

type :: force_kwargs_hack ! force keywords, using @awvwgk method
end type force_kwargs_hack
! so then any argument that comes after "force_kwargs" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_kwargs_hack), optional, intent(in) :: force_kwargs

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    str(3f) - [M_framework__msg] converts up to twenty standard scalar
!!    type values to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!                      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,if)
!!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!      logical,intent(in),optional          :: if
!!      character(len=*),intent(in),optional :: sep
!!      character,len=(:),allocatable        :: str
!!
!!##DESCRIPTION
!!    str(3f) builds a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   Optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!                Optionally, all the generic values can be
!!                single-dimensioned arrays. Currently, mixing scalar
!!                arguments and array arguments is not supported.
!!
!!    sep         separator string used between values. Defaults to a space.
!!                Must be specified with a keyword.
!!    if          If false return a null string.
!!                Must be specified with a keyword.
!!
!!##RETURNS
!!    str     description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_str
!!    use M_framework__msg, only : str
!!    implicit none
!!    character(len=:),allocatable :: pr
!!    character(len=:),allocatable :: frmt
!!    integer                      :: biggest
!!
!!    pr=str('HUGE(3f) integers',huge(0),&
!!    &'and real',huge(0.0),'and double',huge(0.0d0))
!!    write(*,'(a)')pr
!!    pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!    write(*,'(a)')pr
!!    pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!    write(*,'(a)')pr
!!    pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!    write(*,'(a)')pr
!!
!!    ! create a format on the fly
!!    biggest=huge(0)
!!    ! +0 for gfortran-11 bug
!!    frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
!!    write(*,*)'format=',frmt
!!
!!    ! although it will often work, using str(3f)
!!    ! in an I/O statement is not recommended
!!    ! because if an error occurs str(3f) will try
!!    ! to write while part of an I/O statement
!!    ! which not all compilers can handle and is currently non-standard
!!    write(*,*)str('program will now stop')
!!
!!    end program demo_str
!!
!!  Output
!!
!!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 ...
!!    and double 1.7976931348623157E+308
!!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...
!!    12345.678900000001 2.2250738585072014E-308
!!    complex         : (3.40282347E+38,1.17549435E-38)
!!     format=(*(i9:,1x))
!!     program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                       & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                       & force_kwargs,sep,if)
implicit none

! ident_2="@(#) M_framework__msg msg_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=:),allocatable  :: msg_scalar
type(force_kwargs_hack), optional, intent(in) :: force_kwargs
character(len=*),intent(in),optional :: sep
logical,intent(in),optional   :: if
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=:),allocatable  :: sep_local

   if(present(if))then
      if(.not.if)then
         msg_scalar=''
         return
      endif
   endif

   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      increment=2
      sep_local=' '
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
#endif
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,&
                    & generica,genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj,&
                    & force_kwargs,sep,if)
implicit none

! ident_3="@(#) M_framework__msg msg_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
class(*),intent(in),optional  :: generica(:), genericb(:), genericc(:), genericd(:), generice(:)
class(*),intent(in),optional  :: genericf(:), genericg(:), generich(:), generici(:), genericj(:)
type(force_kwargs_hack), optional, intent(in) :: force_kwargs
character(len=*),intent(in),optional :: sep
logical,intent(in),optional          :: if
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment

   if(present(if))then
      if(.not.if)then
         msg_one=''
         return
      endif
   endif

   if(present(sep))then
      increment=1+len(sep)
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_one=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
#endif
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",:,1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         !error_stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment+1
   line=trim(line)//']'//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmt(3f) - [M_framework__msg] convert any intrinsic to a string using specified format
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function fmt(value,format) result(string)
!!
!!     class(*),intent(in),optional :: value
!!     character(len=*),intent(in),optional :: format
!!     character(len=:),allocatable :: string
!!##DESCRIPTION
!!    FMT(3f) converts any standard intrinsic value to a string using the specified
!!    format.
!!##OPTIONS
!!    value    value to print the value of. May be of type INTEGER, LOGICAL,
!!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    format   format to use to print value. It is up to the user to use an
!!             appropriate format. The format does not require being
!!             surrounded by parenthesis. If not present a default is selected
!!             similar to what would be produced with free format, with
!!             trailing zeros removed.
!!##RETURNS
!!    string   A string value
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_fmt
!!     use :: M_framework__msg, only : fmt
!!     implicit none
!!     character(len=:),allocatable :: output
!!
!!        output=fmt(10,"'[',i0,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(10.0/3.0,"'[',g0.5,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(.true.,"'The final answer is [',g0,']'")
!!        write(*,*)'result is ',output
!!
!!     end program demo_fmt
!!
!!   Results:
!!
!!     result is [10]
!!     result is [3.3333]
!!     result is The final answer is [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive function fmt(generic,format) result (line)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

! ident_4="@(#) M_framework__msg fmt(3f) convert any intrinsic to a string using specified format"

class(*),intent(in)                   :: generic
character(len=*),intent(in),optional  :: format
character(len=:),allocatable          :: line
character(len=:),allocatable          :: fmt_local
character(len=:),allocatable          :: re,im
integer                               :: iostat
character(len=255)                    :: iomsg
character(len=1),parameter            :: null=char(0)
integer                               :: ilen
logical                               :: trimit
   if(present(format))then
      fmt_local=format
      trimit=.false.
   else
      fmt_local=''
      trimit=.true.
   endif
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local == '')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     fmt_local='(1pg0,a)'
#endif
         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
      end select
   else
      if(format(1:1) == '(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   iostat=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int16));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int32));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int64));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real32));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real64));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
#endif
      type is (logical);                write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (character(len=*));       write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (complex);
              if(trimit)then
                 re=fmt(generic%re)
                 im=fmt(generic%im)
                 call trimzeros_(re)
                 call trimzeros_(im)
                 fmt_local='("(",g0,",",g0,")",a)'
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) trim(re),trim(im),null
                 trimit=.false.
              else
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
              endif
   end select
   if(iostat /= 0)then
      line='<ERROR>'//trim(iomsg)
   else
      ilen=index(line,null,back=.true.)
      if(ilen == 0)ilen=len(line)
      line=line(:ilen-1)
   endif

   if(index(line,'.') /= 0 .and. trimit) call trimzeros_(line)

end function fmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_framework__msg:TYPE] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       !use M_framework__msg, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          string= '123.450000000000'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.00e3'
!!          call trimzeros_(string)
!!          write(*,*)string
!!       end program demo_trimzeros_
!!
!!   Results:
!!
!!     > 123.45
!!     > 12345
!!     > 12345
!!     > 12345e3
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_5="@(#) M_framework__msg trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)               :: string
character(len=len(string) + 2) :: str
character(len=len(string))     :: exp        ! the exponent string if present
integer                        :: ipos       ! where exponent letter appears if present
integer                        :: i, ii
   str = string                              ! working copy of string
   ipos = scan(str, 'eEdD')                  ! find end of real number if string uses exponent notation
   if (ipos > 0) then                        ! letter was found
      exp = str(ipos:)                       ! keep exponent string so it can be added back as a suffix
      str = str(1:ipos - 1)                  ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if (index(str, '.') == 0) then            ! if no decimal character in original string add one to end of string
      ii = len_trim(str)
      str(ii + 1:ii + 1) = '.'               ! add decimal to end of string
   endif
   do i = len_trim(str), 1, -1               ! scanning from end find a non-zero character
      select case (str(i:i))
      case ('0')                             ! found a trailing zero so keep trimming
         cycle
      case ('.')                             ! found a decimal character at end of remaining string
         if (i <= 1) then
            str = '0'
         else
            str = str(1:i - 1)
         endif
         exit
      case default
         str = str(1:i)                      ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if (ipos > 0) then                        ! if originally had an exponent place it back on
      string = trim(str)//trim(exp)
   else
      string = str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stderr(3f) - [M_framework__msg] write message to stderr
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine stderr(msg,[generic(s)])
!!
!!     class(*),intent(in),optional :: msg
!!     class(*),intent(in),optional :: &
!!                     & generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: &
!!                     & generic5,generic6,generic7,generic8,generic9
!!     class(*),intent(in),optional :: &
!!                     & generica,genericb,genericc,genericd,generice
!!     class(*),intent(in),optional :: &
!!                     & genericf,genericg,generich,generici,genericj
!!##DESCRIPTION
!!    STDERR(3f) writes a message to standard error using a standard
!!    f2003 method.  Up to twenty generic options are available.
!!##OPTIONS
!!    msg           - description to print
!!    generic[0-j]  - optional value to print the value of after the
!!                    message. May be of type INTEGER, LOGICAL, REAL,
!!                    DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_stderr
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32
!!    use M_framework__msg, only: stderr
!!    implicit none
!!
!!    call stderr('A simple message')
!!    call stderr('error: RVALUE=',3.0/4.0)
!!    call stderr('error: IVALUE=',123456789)
!!    call stderr('error: LVALUE=',.true.)
!!
!!    SEVERAL: block
!!    integer :: least=10, most=999, ival=-10
!!    call stderr('error: value',ival, &
!!            & 'should be between',least,'and',most)
!!    endblock SEVERAL
!!
!!    call stderr('real32  :',huge(0.0_real32),0.0_real32, &
!!            & 12345.6789_real32,tiny(0.0_real32))
!!    call stderr('real64  :',huge(0.0_real64),0.0_real64, &
!!            & 12345.6789_real64,tiny(0.0_real64))
!!    !#ifdef __NVCOMPILER
!!    !#else
!!    call stderr('real128 :',huge(0.0_real128),0.0_real128, &
!!            & 12345.6789_real128,tiny(0.0_real128))
!!    !#endif
!!    call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real)))
!!
!!    call stderr('error: program will now stop')
!!    stop 1
!!
!!    end program demo_stderr
!!
!!   Results:
!!     A simple message
!!     error: RVALUE= 0.750000000
!!     error: IVALUE= 123456789
!!     error: LVALUE= T
!!     error: value -10 should be between 10 and 999
!!     real32  : 3.40282347E+38 ...
!!               0.00000000 ...
!!               12345.6787 ...
!!               1.17549435E-38
!!     real64  : 1.7976931348623157E+308 ...
!!               0.0000000000000000 ...
!!               12345.678900000001 ...
!!               2.2250738585072014E-308
!!     real128 : 1.18973149535723176508575932662800702E+4932 ...
!!               0.00000000000000000000000000000000000  ...
!!               12345.6789000000000000000000000000002 ...
!!               3.36210314311209350626267781732175260E-4932
!!     complex : (3.40282347E+38,1.17549435E-38)
!!     error: program will now stop
!!     STOP 1
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine stderr(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
implicit none

! ident_6="@(#) M_framework__msg stderr(3f) writes a message to standard error using a standard f2003 method"

class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer                      :: ios
   write(error_unit,'(a)',iostat=ios) str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
   flush(unit=output_unit,iostat=ios)
   flush(unit=error_unit,iostat=ios)
end subroutine stderr
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wrt(3f) - [M_framework__msg] write multiple scalar values to any
!!    number of files
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine wrt(luns,generic(s),iostat)
!!
!!     integer,intent(in)           :: luns(:)
!!     class(*),intent(in),optional :: &
!!                     & generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: &
!!                     & generic5,generic6,generic7,generic8,generic9
!!     class(*),intent(in),optional :: &
!!                     & generica,genericb,genericc,genericd,generice
!!     class(*),intent(in),optional :: &
!!                     & genericf,genericg,generich,generici,genericj
!!     integer,intent(out),optional :: iostat
!!     character(len=*),intent(in)  :: types(*)
!!##DESCRIPTION
!!    WRT(3f) writes a list of scalar values  to the list of unit numbers
!!    in LUNS(:).
!!##OPTIONS
!!    LUNS            Unit numbers to write to. If of size zero no output
!!                    is generated
!!    generic[1-20]   optional value to print the value of after the
!!                    message. May be of type INTEGER, LOGICAL, REAL,
!!                    DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    TYPES           one for each lun. '' for ASCII, 'CSV' for
!!                    comma-separated.
!!##RETURNS
!!    IOSTAT          The value of the last non-zero IOSTAT value. Returns
!!                    zero if no errors occurred.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wrt
!!    use, intrinsic :: iso_fortran_env, only : &
!!     & stdin=>input_unit, &
!!     & stdout=>output_unit, &
!!     & stderr=>error_unit
!!    use M_framework__msg, only: wrt, fmt
!!    implicit none
!!    integer,allocatable :: luns(:)
!!    integer :: iostat=0
!!    integer,parameter :: ints(3)=[1,2,3]
!!
!!    ! a null list allows for turning off verbose or debug mode output
!!    luns=[integer ::]
!!    call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! multiple files can be used to create a log file, for example
!!    luns=[stderr,stdout]
!!    call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! using fmt
!!    call wrt([stdout,stdout,stdout],'USING FMT :', &
!!     & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat)
!!
!!
!!    end program demo_wrt
!!
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!  IOSTAT=           0
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!  IOSTAT=           0
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine wrt(luns,g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, iostat)
implicit none

! ident_7="@(#) M_framework__msg write(3f) writes a message to any number of open files with any scalar values"

integer,intent(in)           :: luns(:)
class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer,intent(out),optional :: iostat
integer                      :: i
integer                      :: ios, ios2
character(len=256)           :: msg
   ios2=0
   do i=1,size(luns)
      write(luns(i),'(a)',iostat=ios,iomsg=msg)str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)
      if(ios /= 0)then
         ios2=ios
         call stderr('<ERROR>*write*:',msg)
         if(.not.present(iostat))stop 1
      endif
   enddo
   if(present(iostat))iostat=ios2

end subroutine wrt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set(3f) - [M_msg] set scalars from an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9, &
!!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk)
!!      class(*),intent(in)           :: g0
!!      class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga
!!      class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk
!!
!!##DESCRIPTION
!!    set(3f) sets up to twenty scalars to elements from an array.
!!
!!##OPTIONS
!!    g0(:)       array to read values from. Can be of type INTEGER or REAL
!!    g[1-9a-k]   optional values to set to an array element. Can
!!                be of type INTEGER or REAL
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_set
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use M_framework__msg, only : set
!!    implicit none
!!    real(kind=real32)    :: a; namelist /all/a
!!    real(kind=real64)    :: b; namelist /all/b
!!    real(kind=real128)   :: c; namelist /all/c
!!    integer(kind=int8)   :: i; namelist /all/i
!!    integer(kind=int16)  :: j; namelist /all/j
!!    integer(kind=int32)  :: k; namelist /all/k
!!    integer(kind=int64)  :: l; namelist /all/l
!!       call set([1,2,3,4,5,6,7],a,b,c,i,j,k,l)
!!       write(*,nml=all)
!!       call set(10,a)
!!       call set(100,l)
!!       write(*,nml=all)
!!    end program demo_set
!!
!!   Results:
!!
!!     &ALL
!!     A       =   1.000000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                     7
!!     /
!!     &ALL
!!     A       =   10.00000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                   100
!!     /
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine set_single(generic0, generic1)
implicit none
class(*),intent(in)            :: generic0
class(*),intent(out)           :: generic1
   call set_generic(generic1)
contains
subroutine set_generic(gen)
class(*),intent(out) :: gen
   select type(generic0)

   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
#ifdef __NVCOMPILER
#else
   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
#endif
   end select
end subroutine set_generic
end subroutine set_single
subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
          & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick)
implicit none

! ident_7="@(#)M_framework__msg::set_scalar(3fp): set scalars from array elements"

class(*),intent(in)            :: generic0(:)
class(*),intent(out),optional  ::           generic1, generic2, generic3, generic4
class(*),intent(out),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(out),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(out),optional  :: genericf, genericg, generich, generici, genericj
class(*),intent(out),optional  :: generick

   if(present(generic1))call set_generic(generic1,1)
   if(present(generic2))call set_generic(generic2,2)
   if(present(generic3))call set_generic(generic3,3)
   if(present(generic4))call set_generic(generic4,4)
   if(present(generic5))call set_generic(generic5,5)
   if(present(generic6))call set_generic(generic6,6)
   if(present(generic7))call set_generic(generic7,7)
   if(present(generic8))call set_generic(generic8,8)
   if(present(generic9))call set_generic(generic9,9)
   if(present(generica))call set_generic(generica,10)
   if(present(genericb))call set_generic(genericb,11)
   if(present(genericc))call set_generic(genericc,12)
   if(present(genericd))call set_generic(genericd,13)
   if(present(generice))call set_generic(generice,14)
   if(present(genericf))call set_generic(genericf,15)
   if(present(genericg))call set_generic(genericg,16)
   if(present(generich))call set_generic(generich,17)
   if(present(generici))call set_generic(generici,18)
   if(present(genericj))call set_generic(genericj,19)
   if(present(generick))call set_generic(generick,20)
contains
!===================================================================================================================================
subroutine set_generic(gen,i)
class(*),intent(out) :: gen
integer,intent(in)   :: i
   if(size(generic0) < i)then
      write(ERROR_UNIT,'()')'<ERROR> i=',i,' is out of bounds (<',size(generic0),')'
      stop 1
   endif
   select type(generic0)
   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
#ifdef __NVCOMPILER
#else
   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
#endif
   end select
end subroutine set_generic
!===================================================================================================================================
end subroutine set_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      pdec(3f) - [M_framework__msg] write out string with ASCII decimal
!!      equivalent vertically under it
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Usage:
!!
!!     subroutine pdec(string)
!!     character(len=*),intent(in) :: string
!!
!!##DESCRIPTION
!!
!!    Given a string to print, PDEC() writes out the ASCII Decimal equivalent
!!    of the string directly underneath it. This can help you to locate
!!    unprintable characters or non-standard white-space such as a backspace
!!    character or tab character in input strings that your program could
!!    not interpret. On output, non-printable characters are replaced with
!!    a space, and trailing spaces are ignored.
!!
!!    You read the numbers vertically.
!!
!!    1. ignore trailing spaces
!!    2. print the character if it has an ADE of 32 on up
!!    3. print a space if it has an ADE of less than 32
!!    4. underneath each character print the ADE value vertically
!!
!!##EXAMPLES
!!
!!
!!    Sample program:
!!
!!       program demo_pdec
!!       use M_framework__msg, only : pdec
!!       call pdec(' ABCDEFG abcdefg    ')
!!       end program demo_pdec
!!
!!    would produce (notice trailing space is trimmed):
!!
!!      > ABCDEFG abcdefg
!!      >0000000000001111
!!      >3666667739990000
!!      >2567890127890123
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine pdec(string)

! ident_8="@(#) M_framework__msg pdec(3f) write ASCII Decimal Equivalent (ADE) numbers vertically beneath string"

character(len=*),intent(in) :: string   ! the string to print
integer                     :: ilen     ! number of characters in string to print
integer                     :: i        ! counter used to step thru string

   ilen=len_trim(string(:len(string)))  ! get trimmed length of input string

   write(*,101)(char(max(32,ichar(string(i:i)))),i=1,ilen) ! replace lower unprintable characters with spaces

   ! print ADE value of character underneath it
   write(*,202)     (ichar(string(i:i))/100,    i=1,ilen)
   write(*,202)(mod( ichar(string(i:i)),100)/10,i=1,ilen)
   write(*,202)(mod((ichar(string(i:i))),10),   i=1,ilen)
! strings are assumed under 32767+1 characters in length because format integer constants > 32767+1 are not supported on HP-UX
! when newer compilers are available use unlimited
!101   format(32767a1:)  ! format for printing string characters
!202   format(32767i1:)  ! format for printing ADE values
101   format(*(a1:))  ! format for printing string characters
202   format(*(i1:))  ! format for printing ADE values
end subroutine pdec
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    assert(3f) - [M_framework__msg] print filename, linenumber, and
!!    message to stderr and stop program
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function assert(file,linenum,expr,g1,g2,g3,g4,g5,g6,g7,g8,g9, &
!!                    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)
!!
!!     character(len=*),intent(in)  :: file
!!     character(len=*),intent(in)  :: linenum
!!     logical,intent(in)           :: expr
!!     class(*),intent(in),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!##DESCRIPTION
!!    assert(3f) prints strings to stderr and then stops program with exit
!!    code 1 It labels the first string as the filename, the next integer
!!    parameter as the linenumber, and then up to twenty scalar values.
!!
!!    It is primarily intended for use by the prep(1) preprocessor $ASSERT
!!    directive
!!
!!##OPTIONS
!!
!!    filename   a string assumed to be the current filename when compiling
!!    linenum    assumed to be the line number of the source code the ASSERT(3f)
!!               procedure was called at.
!!    expr       logical value
!!    g[1-9a-j]  optional value(s) to print as a message before stopping. May
!!               be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!               or CHARACTER.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_assert
!!    use M_framework__msg, only : assert
!!    implicit none
!!    real :: a, toobig=1024
!!    a=2000
!!    call assert('myroutine', 101, a > toobig, &
!!            & 'The value is too large', a, ' > ', toobig)
!!    end program demo_assert
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine assert(filename, linen, expr, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
implicit none

! ident_9="@(#) M_framework__msg assert(3f) writes a message to a string composed of any standard scalar types"

character(len=*), intent(in)   :: filename
integer, intent(in)            :: linen
logical, intent(in)            :: expr
class(*), intent(in), optional  :: g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*), intent(in), optional  :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj

   ! write message to standard error
   if (.not. expr) then
      call stderr('ERROR:filename:', filename, ':line number:', linen, ':', &
      & str( g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj ) )
      stop 1
   endif

end subroutine assert
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__msg

!>>>>> build/dependencies/M_framework/src/M_framework__timing.f90
module M_framework__timing
use,intrinsic :: iso_fortran_env, only : int8,int16,int32,int64,real32,real64,real128
use,intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
implicit none
private

type timer
   real(real64)   :: cpu_start
   real(real64)   :: cpu_end
   integer(int64) :: clock_start
   integer(int64) :: clock_end
   contains
      procedure :: tic => clock_tic
      procedure :: toc => clock_toc
      procedure :: print => clock_print
      procedure :: wallclock => clock_wallclock
      procedure :: cputime => clock_cputime
end type

interface timer
     procedure :: clock_new
end interface timer

public :: timer

character(len=*),parameter :: gen='(*(g0,1x))'

contains

! initialization constructor
type(timer) function clock_new(this)
type(timer),intent(in),optional :: this
   call cpu_time(clock_new%cpu_start)
   call system_clock(clock_new%clock_start)
   clock_new%cpu_end= clock_new%cpu_start
   clock_new%clock_end= clock_new%clock_start
end function clock_new

subroutine clock_tic(this)
class(timer) :: this
   call cpu_time(this%cpu_start)
   call system_clock(this%clock_start)
   this%cpu_end= this%cpu_start
   this%clock_end= this%clock_start
end subroutine clock_tic

subroutine clock_toc(this)
class(timer) :: this
   call cpu_time(this%cpu_end)
   call system_clock(this%clock_end)
end subroutine clock_toc

subroutine clock_print(this,string,lun)
class(timer),intent(in)                  :: this
character(len=*),intent(in),optional     :: string
integer(kind=int64),intent(in),optional  :: lun
integer(kind=int64)                      :: count_rate
integer(kind=int64)                      :: lun_
real                                     :: elapsed_time
real                                     :: cpu_time
   if(present(lun))then
      lun_=lun
   else
      lun_=stdout
   endif
   elapsed_time = this%wallclock()
   cpu_time = this%cputime()
   if(present(string))then
      write( lun_,gen,advance='no' ) string
      write( lun_,gen,advance='no' )           'Elapsed time (sec) ::', elapsed_time,','
      write( lun_,gen,advance='no' )           'CPU time (sec) ::', cpu_time,','
      write( lun_,'(a,1x,f0.2)',advance='yes') 'Percentage ::', (cpu_time/elapsed_time)*100.0
   else
      write( lun_,gen)           'Elapsed time (sec) ::',elapsed_time
      write( lun_,gen)           'CPU time     (sec) ::',cpu_time
      write( lun_,'(a,1x,f0.2)') 'Percentage         ::',(cpu_time/elapsed_time)*100
   endif
end subroutine clock_print

function clock_wallclock(this) result(elapsed_time)
class(timer)        :: this
integer(kind=int64) :: count_rate
real                :: elapsed_time
real                :: cpu_time
   call system_clock(count_rate=count_rate) ! Find the time rate
   elapsed_time = real(this%clock_end-this%clock_start)/real(count_rate)
end function clock_wallclock

function clock_cputime(this) result(cpu_time)
class(timer)        :: this
real                :: cpu_time
   cpu_time = real(this%cpu_end-this%cpu_start)
end function clock_cputime

end module M_framework__timing

!>>>>> build/dependencies/M_framework/src/M_framework__utility.f90
module M_framework__utility
use, intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64
use, intrinsic :: iso_fortran_env,  only : real32, real64, real128
use, intrinsic :: iso_fortran_env,  only : ERROR_UNIT,OUTPUT_UNIT
implicit none
private
public :: fstop
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fstop(3f) - [M_framework__utility] call stop with both a number and
!!    a message
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine fstop(ierr,stdout,stderr)
!!
!!     integer,intent(in)                   :: ierr
!!     character(len=*),intent(in),optional :: stdout
!!     character(len=*),intent(in),optional :: stderr
!!##DESCRIPTION
!!    FSTOP(3f) call STOP(3f). What a call to STOP does is very system
!!    dependent, so using an abstraction layer is useful, as it allows just
!!    the fstop() routine to be changed; and STOP does not allow a variable
!!    to be used on the numeric access status (this has changed at f2015).
!!
!!##OPTIONS
!!    ierr    - value in range 0 to 32
!!    stdout  - description to be printed to standard output
!!    stderr  - description to be printed to standard error
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_fstop
!!    use M_framework__utility, only: fstop
!!    implicit none
!!    integer :: int
!!    !*!write(*,*)'Enter stop value'
!!    !*!read(*,*) int
!!    int=25
!!    select case(int)
!!    case(10) ; call fstop(int)
!!    case(20) ; call fstop(int,stderr='error: program will now stop')
!!    case(25) ; call fstop(int,stdout='stdout message', &
!!                    & stderr='stderr message')
!!    case(30) ; call fstop(int,stdout='error: program will now stop')
!!    case default
!!               call fstop(int)
!!    endselect
!!
!!    end program demo_fstop
!!
!!   Results:
!!
!!##SEE ALSO
!!   Look for common extensions, such as abort(3f), backtrace(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine fstop(ierr,stdout,stderr)

! ident_1="@(#) M_framework__utility fstop(3f) calls 'STOP VALUE' passing in a value (1-32) with optional message"

integer,intent(in)                   :: ierr
character(len=*),optional,intent(in) :: stdout
character(len=*),optional,intent(in) :: stderr
character(len=132)                   :: message
! The standard states:
!   If the stop-code is an integer, it is recommended that the value also be used as the process exit status, if the
!   processor supports that concept. If the integer stop-code is used as the process exit status, the processor
!   might be able to interpret only values within a limited range, or only a limited portion of the integer value
!   (for example, only the least-significant 8 bits).

!   If the stop-code is of type character or does not appear, or if an END PROGRAM statement is executed,
!   it is recommended that the value zero be supplied as the process exit status, if the processor supports that
!   concept.
!   A STOP statement or ALL STOP statement shall not be executed during execution of an input/output statement.
!
! Conforming variants I have encountered include
!    o printing a message such as 'STOP nnn' when the integer value is called
!    o having a limit on the length of the message string passed
!    o prefixing the message with the string 'STOP '
!    o different ranges on allowed integer values, and/or not having a one-to-one correspondence between the argument
!      value and what the system is given (usually encountered with large values, which are masked or run thru modulo math, ...)
!    o whether messages appear on stdout or stderr.
!    o no value being returned to the system at all.
!
!  So it is best to test (csh/tcsh sets $status, sh/ksh/bash/... sets $?) to verify what exit codes are supported.
!  What happens with negative values, values above 256; how long of a message is supported? Are messages line-terminated?
!
!  And for some reason STOP only takes constant values. I sometimes want to be able to pass a variable value.
!  Only allowing constants would have the advantage of letting the compiler detect values invalid for a particular system,
!  but I sometimes want to return variables.
!
!  So, using STOP with an argument is not as straight-forward as one might guess, especially if you do not want a message
!  to appear when using integer values
!
!  In practice the C exit(int signal) routine seems to work successfully when called from Fortran but I consider it risky
!  as it seems reasonable to assume Fortran cleanup operations such as removing scratch files and closing and flushing Fortran
!  files may not be properly performed. So it is tempting to call the C function, especially on systems where C returns a
!  value to the system and Fortran does not, but I do not recommend it.
!
!  Note that the C function "exit(int signal)" not only works more consistently but that the global values EXIT_SUCCESS and
!  EXIT_FAILURE are defined for portability, and that the signal value can be a variable instead of a constant.
!
!  If the system supports calls to produce a traceback on demand, that is a useful option to add to this procedure.
!-----------------------------------------------------------------------------------------------------------------------------------
!STOP       'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!&aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab'
!-----------------------------------------------------------------------------------------------------------------------------------
if(present(stderr))then       ! write message to stderr, assuming string length is allowed
   if(stderr /= '')then
      write(error_unit,'(a)')trim(stderr)
   endif
!f2015!   select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED)
!f2015!      case(0); allstop 0
!f2015!      case(1); allstop 1
!f2015!      case(2); allstop 2
!f2015!      case(3); allstop 3
!f2015!      case(4); allstop 4
!f2015!      case(5); allstop 5
!f2015!      case(6); allstop 6
!f2015!      case(7); allstop 7
!f2015!      case(8); allstop 8
!f2015!      case(9); allstop 8
!f2015!      case(10); allstop 10
!f2015!      case(11); allstop 11
!f2015!      case(12); allstop 12
!f2015!      case(13); allstop 13
!f2015!      case(14); allstop 14
!f2015!      case(15); allstop 15
!f2015!      case(16); allstop 16
!f2015!      case(17); allstop 17
!f2015!      case(18); allstop 18
!f2015!      case(19); allstop 19
!f2015!      case(20); allstop 20
!f2015!      case(21); allstop 21
!f2015!      case(22); allstop 22
!f2015!      case(23); allstop 23
!f2015!      case(24); allstop 24
!f2015!      case(25); allstop 25
!f2015!      case(26); allstop 26
!f2015!      case(27); allstop 27
!f2015!      case(28); allstop 28
!f2015!      case(29); allstop 29
!f2015!      case(30); allstop 30
!f2015!      case(31); allstop 31
!f2015!      case(32); allstop 32
!f2015!   case default
!f2015!      write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system'
!f2015!      write(error_unit,'(a)')trim(message) ! write message to standard error
!f2015!      allstop 1
!f2015!   end select
endif
if(present(stdout))then       ! write message to stdout, assuming string length is allowed
   if(stdout /= '')then
      write(*,'(a)')trim(stdout)
   endif
endif
select case(ierr)             ! have executable return an exit status to the system (IF SUPPORTED)
   case(0); stop 0
   case(1); stop 1
   case(2); stop 2
   case(3); stop 3
   case(4); stop 4
   case(5); stop 5
   case(6); stop 6
   case(7); stop 7
   case(8); stop 8
   case(9); stop 8
   case(10); stop 10
   case(11); stop 11
   case(12); stop 12
   case(13); stop 13
   case(14); stop 14
   case(15); stop 15
   case(16); stop 16
   case(17); stop 17
   case(18); stop 18
   case(19); stop 19
   case(20); stop 20
   case(21); stop 21
   case(22); stop 22
   case(23); stop 23
   case(24); stop 24
   case(25); stop 25
   case(26); stop 26
   case(27); stop 27
   case(28); stop 28
   case(29); stop 29
   case(30); stop 30
   case(31); stop 31
   case(32); stop 32
case default
   write(message,'(a,i0,a)')'*fstop*: stop value of ',ierr,' returning 1 to system'
   write(error_unit,'(a)')trim(message) ! write message to standard error
   stop 1
end select
end subroutine fstop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__utility

!>>>>> build/dependencies/M_msg/src/M_msg.F90
module M_msg
use,intrinsic :: iso_fortran_env, only : ERROR_UNIT,OUTPUT_UNIT    ! access computing environment
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
private
!-----------------------------------------------------------------------------------------------------------------------------------
! USED SO FREQUENTLY IN OTHER MODULES PUT IN THIS ONE WITH NO DEPENDENCIES TO PREVENT CIRCULAR DEPENDENCY
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_1="@(#) M_msg str(3f) {msg_scalar msg_one}"

public str
public wrt
public fmt
public set
public stderr
!!public :: a,i,f,g

interface str
   module procedure msg_scalar, msg_one
end interface str

interface set
   module procedure set_scalar
   module procedure set_single
end interface set

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    str(3f) - [M_msg] converts up to twenty standard scalar type values to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      pure function str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep)
!!      class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!      class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!      character(len=*),intent(in),optional :: sep
!!      character,len=(:),allocatable :: str
!!
!!##DESCRIPTION
!!    str(3f) builds a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!                Optionally, all the generic values can be
!!                single-dimensioned arrays. Currently, mixing scalar
!!                arguments and array arguments is not supported.
!!
!!    sep         separator string used between values. Defaults to a space.
!!
!!##RETURNS
!!    str     description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_str
!!    use M_msg, only : str
!!    implicit none
!!    character(len=:),allocatable :: pr
!!    character(len=:),allocatable :: frmt
!!    integer                      :: biggest
!!
!!    pr=str('HUGE(3f) integers',huge(0),&
!!    &'and real',huge(0.0),'and double',huge(0.0d0))
!!    write(*,'(a)')pr
!!    pr=str('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!    write(*,'(a)')pr
!!    pr=str('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!    write(*,'(a)')pr
!!    pr=str('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!    write(*,'(a)')pr
!!
!!    ! create a format on the fly
!!    biggest=huge(0)
!!    frmt=str('(*(i',int(log10(real(biggest))),':,1x))',sep='')
!!    write(*,*)'format=',frmt
!!
!!    ! although it will often work, using str(3f)
!!    ! in an I/O statement is not recommended
!!    ! because if an error occurs str(3f) will try
!!    ! to write while part of an I/O statement
!!    ! which not all compilers can handle and is currently non-standard
!!    write(*,*)str('program will now stop')
!!
!!    end program demo_str
!!
!!  Output
!!
!!    HUGE(3f) integers 2147483647 and real 3.40282347E+38 and double 1.7976931348623157E+308
!!    real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!    doubleprecision : 1.7976931348623157E+308 0.0000000000000000 12345.678900000001 2.2250738585072014E-308
!!    complex         : (3.40282347E+38,1.17549435E-38)
!!     format=(*(i9:,1x))
!!     program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                       & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                       & sep)
implicit none

! ident_2="@(#) M_msg msg_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=:),allocatable  :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      increment=2
      sep_local=' '
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_scalar=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
#endif
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep
end subroutine print_generic
!===================================================================================================================================
end function msg_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,&
                    & generica,genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj,&
                    & sep)
implicit none

! ident_3="@(#) M_msg msg_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
class(*),intent(in),optional  :: generica(:), genericb(:), genericc(:), genericd(:), generice(:)
class(*),intent(in),optional  :: genericf(:), genericg(:), generich(:), generici(:), genericj(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      increment=1+len(sep)
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0,line,istart,increment,sep_local)
   if(present(generic1))call print_generic(generic1,line,istart,increment,sep_local)
   if(present(generic2))call print_generic(generic2,line,istart,increment,sep_local)
   if(present(generic3))call print_generic(generic3,line,istart,increment,sep_local)
   if(present(generic4))call print_generic(generic4,line,istart,increment,sep_local)
   if(present(generic5))call print_generic(generic5,line,istart,increment,sep_local)
   if(present(generic6))call print_generic(generic6,line,istart,increment,sep_local)
   if(present(generic7))call print_generic(generic7,line,istart,increment,sep_local)
   if(present(generic8))call print_generic(generic8,line,istart,increment,sep_local)
   if(present(generic9))call print_generic(generic9,line,istart,increment,sep_local)
   if(present(generica))call print_generic(generica,line,istart,increment,sep_local)
   if(present(genericb))call print_generic(genericb,line,istart,increment,sep_local)
   if(present(genericc))call print_generic(genericc,line,istart,increment,sep_local)
   if(present(genericd))call print_generic(genericd,line,istart,increment,sep_local)
   if(present(generice))call print_generic(generice,line,istart,increment,sep_local)
   if(present(genericf))call print_generic(genericf,line,istart,increment,sep_local)
   if(present(genericg))call print_generic(genericg,line,istart,increment,sep_local)
   if(present(generich))call print_generic(generich,line,istart,increment,sep_local)
   if(present(generici))call print_generic(generici,line,istart,increment,sep_local)
   if(present(genericj))call print_generic(genericj,line,istart,increment,sep_local)
   msg_one=trim(line)
contains
!===================================================================================================================================
pure subroutine print_generic(generic,line,istart,increment,sep)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
character(len=4096),intent(inout) :: line
integer,intent(inout) :: istart
integer,intent(in) :: increment
character(len=*),intent(in) :: sep
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
#endif
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         !error_stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment+1
   line=trim(line)//']'//sep_local
end subroutine print_generic
!===================================================================================================================================
end function msg_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmt(3f) - [M_msg] convert any intrinsic to a string using specified format
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function fmt(value,format) result(string)
!!
!!     class(*),intent(in),optional :: value
!!     character(len=*),intent(in),optional  :: format
!!     character(len=:),allocatable :: string
!!##DESCRIPTION
!!    FMT(3f) converts any standard intrinsic value to a string using the specified
!!    format.
!!##OPTIONS
!!    value    value to print the value of. May be of type INTEGER, LOGICAL,
!!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    format   format to use to print value. It is up to the user to use an
!!             appropriate format. The format does not require being
!!             surrounded by parenthesis. If not present a default is selected
!!             similar to what would be produced with free format.
!!##RETURNS
!!    string   A string value
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_fmt
!!     use :: M_msg, only : fmt
!!     implicit none
!!     character(len=:),allocatable :: output
!!
!!        output=fmt(10,"'[',i0,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(10.0/3.0,"'[',g0.5,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(.true.,"'The final answer is [',g0,']'")
!!        write(*,*)'result is ',output
!!
!!     end program demo_fmt
!!
!!   Results:
!!
!!     result is [10]
!!     result is [3.3333]
!!     result is The final answer is [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive function fmt(generic,format) result (line)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

! ident_4="@(#) M_msg fmt(3f) convert any intrinsic to a string using specified format"

class(*),intent(in)          :: generic
character(len=*),intent(in),optional  :: format
character(len=:),allocatable :: line
character(len=:),allocatable :: fmt_local
integer                      :: ios
character(len=255)           :: msg
character(len=1),parameter   :: null=char(0)
integer                      :: ilen
   if(present(format))then
      fmt_local=format
   else
      fmt_local=''
   endif
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local == '')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     fmt_local='(1pg0,a)'
#endif
         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
      end select
   else
      if(format(1:1) == '(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   ios=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (integer(kind=int16));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (integer(kind=int32));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (integer(kind=int64));    write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (real(kind=real32));      write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (real(kind=real64));      write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
#endif
      type is (logical);                write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (character(len=*));       write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
      type is (complex);                write(line,fmt_local,iostat=ios,iomsg=msg) generic,null
   end select
   if(ios /= 0)then
      line='<ERROR>'//trim(msg)
   else
      ilen=index(line,null,back=.true.)
      if(ilen == 0)ilen=len(line)
      line=line(:ilen-1)
   endif
end function fmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stderr(3f) - [M_msg] write message to stderr
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine stderr(msg,[generic])
!!
!!     class(*),intent(in),optional :: msg
!!     class(*),intent(in),optional :: generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: generic5,generic6,generic7,generic8,generic9
!!##DESCRIPTION
!!    STDERR(3f) writes a message to standard error using a standard f2003 method.
!!    Up to ten generic options are available.
!!##OPTIONS
!!    msg           - description to print
!!    generic[0-9]  - optional value to print the value of after the message. May
!!                    be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!                    or CHARACTER.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_stderr
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use,intrinsic :: iso_fortran_env, only : real=> real32, integer=> int32
!!    use M_msg, only: stderr
!!    implicit none
!!
!!    call stderr('A simple message')
!!    call stderr('error: RVALUE=',3.0/4.0)
!!    call stderr('error: IVALUE=',123456789)
!!    call stderr('error: LVALUE=',.true.)
!!
!!    SEVERAL: block
!!    integer :: least=10, most=999, ival=-10
!!    call stderr('error: value',ival,'should be between',least,'and',most)
!!    endblock SEVERAL
!!
!!    call stderr('real32  :',huge(0.0_real32),0.0_real32,12345.6789_real32,tiny(0.0_real32))
!!    call stderr('real64  :',huge(0.0_real64),0.0_real64,12345.6789_real64,tiny(0.0_real64))
!!    !#ifdef __NVCOMPILER
!!    !#else
!!    call stderr('real128 :',huge(0.0_real128),0.0_real128,12345.6789_real128,tiny(0.0_real128))
!!    !#endif
!!    call stderr('complex :',cmplx(huge(0.0_real),tiny(0.0_real)))
!!
!!    call stderr('error: program will now stop')
!!    stop 1
!!
!!    end program demo_stderr
!!
!!   Results:
!!     A simple message
!!     error: RVALUE= 0.750000000
!!     error: IVALUE= 123456789
!!     error: LVALUE= T
!!     error: value -10 should be between 10 and 999
!!     real32  : 3.40282347E+38 ...
!!               0.00000000 ...
!!               12345.6787 ...
!!               1.17549435E-38
!!     real64  : 1.7976931348623157E+308 ...
!!               0.0000000000000000 ...
!!               12345.678900000001 ...
!!               2.2250738585072014E-308
!!     real128 : 1.18973149535723176508575932662800702E+4932 ...
!!               0.00000000000000000000000000000000000  ...
!!               12345.6789000000000000000000000000002 ...
!!               3.36210314311209350626267781732175260E-4932
!!     complex : (3.40282347E+38,1.17549435E-38)
!!     error: program will now stop
!!     STOP 1
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine stderr(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
implicit none

! ident_5="@(#) M_msg stderr(3f) writes a message to standard error using a standard f2003 method"

class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer                      :: ios
   write(error_unit,'(a)',iostat=ios) str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj)
   flush(unit=output_unit,iostat=ios)
   flush(unit=error_unit,iostat=ios)
end subroutine stderr
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wrt(3f) - [M_msg] write multiple scalar values to any number of files
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine wrt(luns,generic(s),iostat)
!!
!!     integer,intent(in)           :: luns(:)
!!     class(*),intent(in),optional :: generic0,generic1,generic2,generic3,generic4
!!     class(*),intent(in),optional :: generic5,generic6,generic7,generic8,generic9
!!     class(*),intent(in),optional :: generica,genericb,genericc,genericd,generice
!!     class(*),intent(in),optional :: genericf,genericg,generich,generici,genericj
!!     integer,intent(out),optional :: ios
!!##DESCRIPTION
!!    WRT(3f) writes a list of scalar values  to the list of unit numbers in LUNS(:).
!!##OPTIONS
!!    LUNS            Unit numbers to write to. If of size zero no output is generated
!!    generic[1-20]   optional value to print the value of after the message. May
!!                    be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!                    or CHARACTER.
!!##RETURNS
!!    IOSTAT          The value of the last non-zero IOSTAT value. Returns zero if
!!                    no errors occurred.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wrt
!!    use, intrinsic :: iso_fortran_env, only : &
!!     & stdin=>input_unit, &
!!     & stdout=>output_unit, &
!!     & stderr=>error_unit
!!    use M_msg, only: wrt, fmt
!!    implicit none
!!    integer,allocatable :: luns(:)
!!    integer :: iostat=0
!!    integer,parameter :: ints(3)=[1,2,3]
!!
!!    ! a null list allows for turning off verbose or debug mode output
!!    luns=[integer ::]
!!    call wrt(luns,'NULL LIST:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! multiple files can be used to create a log file, for example
!!    luns=[stderr,stdout]
!!    call wrt(luns,'TWO FILES:',huge(0),'PI=',asin(1.0d0)*2.0d0,iostat=iostat)
!!    write(*,*)'IOSTAT=',iostat
!!
!!    ! using fmt
!!    call wrt([stdout,stdout,stdout],'USING FMT :', &
!!     & huge(0),'PI=',asin(1.0d0)*2.0d0,fmt(ints(2),'i0.4'),iostat=iostat)
!!
!!
!!    end program demo_wrt
!!
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!##TWO FILES: 2147483647 PI= 3.1415926535897931
!!  IOSTAT=           0
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!##USING FMT : 2147483647 PI= 3.1415926535897931 0002
!!  IOSTAT=           0
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine wrt(luns,g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj,iostat)
implicit none

! ident_6="@(#) M_msg write(3f) writes a message to any number of open files with any scalar values"

integer,intent(in)           :: luns(:)
class(*),intent(in),optional :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9
class(*),intent(in),optional :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
integer,intent(out),optional :: iostat
integer                      :: i
character(len=256)           :: msg
   do i=1,size(luns)
      write(luns(i),'(a)',iostat=iostat,iomsg=msg)str(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)
      if(iostat /= 0)then
         call stderr('<ERROR>*write*:',msg)
      endif
   enddo
end subroutine wrt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set(3f) - [M_msg] set scalars from an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      function set(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!      & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk)
!!      class(*),intent(in)           :: g0
!!      class(*),intent(out),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga
!!      class(*),intent(out),optional  :: gb,gc,gd,ge,gf,gg,gh,gi,gj,gk
!!
!!##DESCRIPTION
!!    set(3f) sets up to twenty scalars to elements from an array.
!!    Sort of like an equivalence.
!!
!!##OPTIONS
!!    g0(:)       array to read values from. Can be of type INTEGER or REAL
!!    g[1-9a-k]   optional values to set to an array element. Can
!!                be of type INTEGER or REAL
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_set
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use M_msg, only : set
!!    implicit none
!!    real(kind=real32)    :: a; namelist /all/a
!!    real(kind=real64)    :: b; namelist /all/b
!!    real(kind=real128)   :: c; namelist /all/c
!!    integer(kind=int8)   :: i; namelist /all/i
!!    integer(kind=int16)  :: j; namelist /all/j
!!    integer(kind=int32)  :: k; namelist /all/k
!!    integer(kind=int64)  :: l; namelist /all/l
!!    integer              :: iarr(7)=[1,2,3,4,5,6,7]
!!       call set(iarr,a,b,c,i,j,k,l)
!!       write(*,nml=all)
!!       call set(10,a)
!!       call set(100,l)
!!       write(*,nml=all)
!!    end program demo_set
!!
!!   Results:
!!
!!     &ALL
!!     A       =   1.000000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                     7
!!     /
!!     &ALL
!!     A       =   10.00000    ,
!!     B       =   2.00000000000000     ,
!!     C       =   3.00000000000000000000000000000000      ,
!!     I       =    4,
!!     J       =      5,
!!     K       =           6,
!!     L       =                   100
!!     /
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine set_single(generic0, generic1)
implicit none
class(*),intent(in)            :: generic0
class(*),intent(out)           :: generic1
   call set_generic(generic1)
contains
subroutine set_generic(gen)
class(*),intent(out) :: gen
   select type(generic0)

   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
#ifdef __NVCOMPILER
#else
   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0
         type is (integer(kind=int16));    gen=generic0
         type is (integer(kind=int32));    gen=generic0
         type is (integer(kind=int64));    gen=generic0
         type is (real(kind=real32));      gen=generic0
         type is (real(kind=real64));      gen=generic0
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0
#endif
      end select
#endif
   end select
end subroutine set_generic
end subroutine set_single
subroutine set_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
          & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, generick)
implicit none

! ident_7="@(#)M_msg::set_scalar(3fp): set scalars from array elements"

class(*),intent(in)            :: generic0(:)
class(*),intent(out),optional  ::           generic1, generic2, generic3, generic4
class(*),intent(out),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(out),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(out),optional  :: genericf, genericg, generich, generici, genericj
class(*),intent(out),optional  :: generick

   if(present(generic1))call set_generic(generic1,1)
   if(present(generic2))call set_generic(generic2,2)
   if(present(generic3))call set_generic(generic3,3)
   if(present(generic4))call set_generic(generic4,4)
   if(present(generic5))call set_generic(generic5,5)
   if(present(generic6))call set_generic(generic6,6)
   if(present(generic7))call set_generic(generic7,7)
   if(present(generic8))call set_generic(generic8,8)
   if(present(generic9))call set_generic(generic9,9)
   if(present(generica))call set_generic(generica,10)
   if(present(genericb))call set_generic(genericb,11)
   if(present(genericc))call set_generic(genericc,12)
   if(present(genericd))call set_generic(genericd,13)
   if(present(generice))call set_generic(generice,14)
   if(present(genericf))call set_generic(genericf,15)
   if(present(genericg))call set_generic(genericg,16)
   if(present(generich))call set_generic(generich,17)
   if(present(generici))call set_generic(generici,18)
   if(present(genericj))call set_generic(genericj,19)
   if(present(generick))call set_generic(generick,20)
contains
!===================================================================================================================================
subroutine set_generic(gen,i)
class(*),intent(out) :: gen
integer,intent(in)   :: i
   if(size(generic0) < i)then
      write(ERROR_UNIT,'()')'<ERROR> i=',i,' is out of bounds (<',size(generic0),')'
      stop 1
   endif
   select type(generic0)
   type is(integer(kind=int8))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int16))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(integer(kind=int64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(real(kind=real32))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
   type is(real(kind=real64))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
#ifdef __NVCOMPILER
#else
   type is(real(kind=real128))
      select type(gen)
         type is (integer(kind=int8));     gen=generic0(i)
         type is (integer(kind=int16));    gen=generic0(i)
         type is (integer(kind=int32));    gen=generic0(i)
         type is (integer(kind=int64));    gen=generic0(i)
         type is (real(kind=real32));      gen=generic0(i)
         type is (real(kind=real64));      gen=generic0(i)
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     gen=generic0(i)
#endif
      end select
#endif
   end select
end subroutine set_generic
!===================================================================================================================================
end subroutine set_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_msg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_strings/src/M_strings.F90
!>
!!##NAME
!!    M_strings(3f) - [M_strings::INTRO] Fortran string module
!!
!!##DESCRIPTION
!!    The M_strings(3fm) module is a collection of Fortran procedures
!!    that supplement the built-in intrinsic string routines. Routines
!!    for parsing, tokenizing, changing case, substituting new strings for
!!    substrings, locating strings with simple wildcard expressions, removing
!!    tabs and line terminators and other string manipulations are included.
!!
!!    M_strings__oop(3fm) is a companion module that provides an OOP
!!    interface to the M_strings module.
!!
!!##SYNOPSIS
!!
!!  public entities:
!!
!!      use M_strings,only : split, slice, sep, delim, chomp, strtok
!!      use M_strings,only : split2020, find_field
!!      use M_strings,only : substitute, change, modif, transliterate, &
!!              & reverse, squeeze
!!      use M_strings,only : replace, join
!!      use M_strings,only : upper, lower, upper_quoted, lower_quoted
!!      use M_strings,only : rotate13, percent_encode, percent_decode
!!      use M_strings,only : encode_base64, decode_base64
!!      use M_strings,only : adjustc, compact, nospace, indent
!!      use M_strings,only : crop, clip, unquote, quote, matching_delimiter
!!      use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &
!!              & stretch, lenset, merge_str
!!      use M_strings,only : switch, s2c, c2s
!!      use M_strings,only : noesc, notabs, dilate, expand, visible
!!      use M_strings,only : longest_common_substring
!!      use M_strings,only : string_to_value, string_to_values, s2v, s2vs
!!      use M_strings,only : int, real, dble, nint
!!      use M_strings,only : atoi, atol, aton
!!      use M_strings,only : value_to_string, v2s, str, fmt
!!      use M_strings,only : listout, getvals
!!      use M_strings,only : glob, ends_with
!!      use M_strings,only : paragraph
!!      use M_strings,only : base, decodebase, codebase, base2
!!      use M_strings,only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings,only : isgraph, islower, isprint, ispunct
!!      use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings,only : isnumber
!!      use M_strings,only : fortran_name
!!      use M_strings,only : describe
!!      use M_strings,only : edit_distance
!!      use M_strings,only : bundle
!!
!!   TOKENS
!!
!!       split   subroutine parses string using specified delimiter characters
!!               and stores tokens into an array
!!       sep     function interface to split(3f)
!!       slice   subroutine parses string using specified delimiter characters
!!               and stores beginning and ending positions in arrays
!!       delim   subroutine parses string using specified delimiter characters
!!               and store tokens into an array and records beginning and end
!!       chomp   function consumes input line as it returns next token in a
!!               string using specified delimiters
!!       paragraph    convert a string into a paragraph
!!       strtok  tokenize a string like C strtok(3c) routine
!!
!!       CONTRIBUTIONS
!!
!!       split2020   split a string using prototype of proposed standard
!!                   procedure
!!       find_field  parse a string into tokens
!!
!!   EDITING
!!
!!       substitute      subroutine non-recursively globally replaces old
!!                       substring with new substring
!!       replace         function non-recursively globally replaces old
!!                       substring with new substring using allocatable string
!!                       (version of substitute(3f) without limitation on
!!                       length of output string)
!!       change          subroutine non-recursively globally replaces old
!!                       substring with new substring with a directive like
!!                       line editor
!!       modif           subroutine modifies a string with a directive like the
!!                       XEDIT line editor MODIFY command
!!       transliterate   replace characters found in set one with characters
!!                       from set two
!!       reverse         reverse character order in a string
!!       join            join an array of CHARACTER variables with specified
!!                       separator
!!       rotate13        apply trivial encryption algorithm ROT13 to a string
!!       percent_encode  apply percent-encryption (aka. URL encryption) to characters
!!       percent_decode  apply percent-decryption (aka. URL decryption) to characters
!!       encode_base64   apply base64 encoding (as defined in RFC-4648)
!!                       to an array of bytes
!!       decode_base64   apply base64 decoding (as defined in RFC-4648)
!!                       to an array of bytes
!!       squeeze         delete adjacent duplicate characters from a string
!!
!!   CASE
!!
!!       upper           function converts string to uppercase
!!       lower           function converts string to miniscule
!!       upper_quoted    function converts string to uppercase skipping strings
!!                       quoted per Fortran rules
!!       lower_quoted    function converts string to lowercase skipping strings
!!                       quoted per Fortran rules
!!
!!   STRING LENGTH AND PADDING
!!
!!       len_white  find location of last non-whitespace character
!!       lenset     return a string of specified length
!!       pad        return a string of at least specified length
!!       zpad       pad integer or string to length with zero characters
!!                  on left
!!       lpad       convert scalar intrinsic to a string padded on left to
!!                  specified length
!!       cpad       convert scalar intrinsic to a centered string of the
!!                  specified length
!!       rpad       convert scalar intrinsic to a string padded on right to
!!                  specified length
!!       stretch    return a string of at least specified length with suffix
!!       merge_str  make strings of equal length and then call MERGE(3f)
!!                  intrinsic
!!   WHITE SPACE
!!
!!       adjustc  elemental function centers text within the length of the
!!                input string
!!       compact  left justify string and replace duplicate whitespace with
!!                single characters or nothing
!!       nospace  function replaces whitespace with nothing
!!       indent   find number of leading spaces
!!       crop     function trims leading and trailing spaces and control
!!                characters
!!       clip     trim leading and trailings spaces or set of characters
!!                from string
!!
!!       See Also: squeeze
!!
!!   QUOTES
!!
!!       matching_delimiter  find position of matching delimiter
!!       unquote  remove quotes from string as if read with list-directed input
!!       quote    add quotes to string as if written with list-directed output
!!
!!
!!   CHARACTER ARRAY VERSUS STRING
!!
!!       switch  switch between a string and an array of single characters
!!       s2c     convert string to array of single characters and add null
!!               terminator for passing to C
!!       c2s     convert null-terminated array of single characters to
!!               string for converting strings returned from C
!!
!!   NONALPHA
!!
!!       noesc    convert non-printable ASCII8 characters to a space
!!       notabs   convert tabs to spaces while maintaining columns,
!!                assuming tabs are set every 8 characters
!!       dilate   function to convert tabs to spaces assuming tabs are set
!!                every 8 characters
!!       expand   expand escape sequences in a string
!!       visible  expand escape sequences in a string to "control" and
!!                meta-control representations
!!
!!   NUMERIC STRINGS
!!
!!       string_to_value   generic subroutine returns numeric value (REAL,
!!                         DOUBLEPRECISION, INTEGER) from string
!!       string_to_values  subroutine reads an array of numbers from a string
!!       getvals           subroutine reads a relatively arbitrary number
!!                         of values from a string using list-directed read
!!       s2v               function returns DOUBLEPRECISION numeric value
!!                         from string
!!       s2vs              function returns a DOUBLEPRECISION array of numbers
!!                         from a string
!!       atol              function returns INTEGER(kind=int64)  from a string
!!       aton              changes string to numeric value
!!
!!       str               append the values of up to twenty values into
!!                         a string, including user-specified separator
!!                         and a CSV-style option
!!       fmt               return string from generic  intrinsic value
!!                         using optionally specified format.
!!       value_to_string   generic subroutine returns string given numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER, LOGICAL )
!!       v2s               generic function returns string from numeric value
!!                         (REAL, DOUBLEPRECISION, INTEGER )
!!       listout           expand a list of numbers where negative numbers
!!                         denote range ends (1 -10 means 1 thru 10)
!!       isnumber          determine if string represents a number
!!
!!   CHARACTER TESTS
!!
!!       glob        compares given string for match to pattern which may
!!                   contain wildcard characters
!!       ends_with   test whether strings ends with one of the specified suffixes
!!
!!       o isalnum   returns .true. if character is a letter or digit
!!       o isalpha   returns .true. if character is a letter and
!!                   .false. otherwise
!!       o iscntrl   returns .true. if character is a delete character or
!!                   ordinary control character
!!       o isdigit   returns .true. if character is a digit (0,1,...,9)
!!                   and .false. otherwise
!!       o isgraph   returns .true. if character is a printable character
!!                   except a space is considered non-printable
!!       o islower   returns .true. if character is a miniscule letter (a-z)
!!       o isprint   returns .true. if character is an ASCII printable
!!                   character
!!       o ispunct   returns .true. if character is a printable punctuation
!!                   character
!!       o isspace   returns .true. if character is a null, space, tab,
!!                   carriage return, new line, vertical tab, or formfeed
!!       o isupper   returns .true. if character is an uppercase letter (A-Z)
!!       o isascii   returns .true. if the character is in the range char(0)
!!                   to char(127)
!!       o isblank   returns .true. if character is a blank character
!!                   (space or horizontal tab.
!!       o isxdigit  returns .true. if character is a hexadecimal digit
!!                   (0-9, a-f, or A-F).
!!
!!       fortran_name   returns .true. if input string is a valid Fortran name
!!
!!   BASE CONVERSION
!!
!!       base       convert whole number string in base [2-36] to string
!!                  in alternate base [2-36]
!!       base2      convert INTEGER to a string representing a binary value
!!       codebase   convert whole number string in base [2-36] to base
!!                  10 number
!!       decodebase convert whole number in base 10 to string in base [2-36]
!!
!!   MISCELLANEOUS
!!
!!       bundle         return up to twenty strings of arbitrary length as
!!                      an array
!!       describe       returns a string describing the name of a single
!!                      character
!!       edit_distance  returns a naive edit distance using the Levenshtein
!!                      distance algorithm
!!       longest_common_substring  function that returns the longest common
!!                                 substring of two strings.
!!
!!   INTRINSICS
!!
!!    The M_strings(3fm) module supplements and works in combination with
!!    the Fortran built-in intrinsics. Stand-alone Fortran lets you access
!!    the characters in a string using ranges much like they are character
!!    arrays, assignment, comparisons with standard operators, supports
!!    dynamically allocatable strings and supports concatenation using the //
!!    operator, as well as a number of intrinsic string routines:
!!
!!        adjustl             Left adjust a string
!!        adjustr             Right adjust a string
!!        index               Position of a substring within a string
!!        repeat              Repeated string concatenation
!!        scan                Scan a string for the presence of a set
!!                            of characters
!!        trim                Remove trailing blank characters of a string
!!        verify              Scan a string for the absence of a set of
!!                            characters
!!        len                 It returns the length of a character string
!!        achar               converts an integer into a character
!!        iachar              converts a character into an integer
!!        len_trim            finds length of string with trailing spaces
!!                            ignored
!!        new_line            Newline character
!!        selected_char_kind  Choose character kind
!!        lge                 Lexical greater than or equal
!!        lgt                 Lexical greater than
!!        lle                 Lexical less than or equal
!!        llt                 Lexical less than
!!
!!   OOPS INTERFACE
!!
!!    The M_strings__oop(3fm) module (included with the M_strings(3fm)
!!    module) provides an OOP (Object-Oriented Programming) interface to
!!    the M_strings(3fm) module.
!!
!!##SEE ALSO
!!    There are additional routines in other GPF modules for working with
!!    expressions (M_calculator), time strings (M_time), random strings
!!    (M_random, M_uuid), lists (M_list), and interfacing with the C regular
!!    expression library (M_regex).
!!
!!##EXAMPLES
!!
!!    Each of the procedures includes an [example](example/) program in
!!    the corresponding man(1) page for the function.
!!
!!    Sample program:
!!
!!      program demo_M_strings
!!      use M_strings,only : SPLIT, slice, sep, delim, chomp, strtok
!!      use M_strings,only : split2020, find_field
!!      use M_strings,only : substitute, change, modif, transliterate, &
!!              & reverse, squeeze
!!      use M_strings,only : REPLACE, join
!!      use M_strings,only : UPPER, LOWER, upper_quoted, lower_quoted
!!      use M_strings,only : rotate13, percent_encode, percent_decode
!!      use M_strings,only : encode_base64, decode_base64
!!      use M_strings,only : adjustc, compact, nospace, indent
!!      use M_strings,only : crop, clip, unquote, quote, matching_delimiter
!!      use M_strings,only : len_white, pad, lpad, cpad, rpad, zpad, &
!!              & stretch, lenset, merge_str
!!      use M_strings,only : switch, s2c, c2s
!!      use M_strings,only : noesc, notabs, dilate, expand, visible
!!      use M_strings,only : longest_common_substring
!!      use M_strings,only : string_to_value, string_to_values, s2v, s2vs
!!      use M_strings,only : int, real, dble, nint
!!      use M_strings,only : atoi, atol, aton
!!      use M_strings,only : value_to_string, v2s, str, fmt
!!      use M_strings,only : listout, getvals
!!      use M_strings,only : glob, ends_with
!!      use M_strings,only : paragraph
!!      use M_strings,only : base, decodebase, codebase, base2
!!      use M_strings,only : isalnum, isalpha, iscntrl, isdigit
!!      use M_strings,only : isgraph, islower, isprint, ispunct
!!      use M_strings,only : isspace, isupper, isascii, isblank, isxdigit
!!      use M_strings,only : isnumber
!!      use M_strings,only : fortran_name
!!      use M_strings,only : describe
!!      use M_strings,only : edit_distance
!!      use M_strings,only : bundle
!!      character(len=:),allocatable :: string
!!      character(len=:),allocatable :: array(:) ! output array of tokens
!!      character(len=*),parameter   :: gen='(*(g0))'
!!      character(len=*),parameter   :: genx='(*("[",g0,"] ":))'
!!      string='abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890'
!!      write(*,gen)string
!!      write(*,gen)upper(string)
!!      write(*,gen)lower(string)
!!      call split(string,array)
!!      write(*,genx)array
!!      write(*,gen)replace(string,'qrs','--RePlace--',ignorecase=.true.)
!!      end program demo_M_strings
!!
!! Results:
!!
!!  > abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890
!!  > ABCDEFGHIJKLMNOPQRSTUVWXYZ ABCDEFGHIJKLMNOPQRSTUVWXYZ 01234567890
!!  > abcdefghijklmnopqrstuvwxyz abcdefghijklmnopqrstuvwxyz 01234567890
!!  > [abcdefghijklmnopqrstuvwxyz] [ABCDEFGHIJKLMNOPQRSTUVWXYZ] [01234567890               ]
!!  > abcdefghijklmnop--RePlace--tuvwxyz ABCDEFGHIJKLMNOP--RePlace--TUVWXYZ 01234567890
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_strings !
use,intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
use,intrinsic :: iso_fortran_env, only : byte=>int8
implicit none

! ident_1="@(#) M_strings(3f) Fortran module containing routines that deal with character strings"

!-----------------------------------------------------------------------------------------------------------------------------------
private

!-------------------------# TOKENS
public split              !  subroutine parses a string on specified delimiter characters and store tokens into an allocatable array
public slice              !  subroutine parses a string on specified delimiter characters and stores positions into arrays
public sep                !  function interface to split
public chomp              !  function consumes input line as it returns next token in a string using specified delimiters
public delim              !  subroutine parses a string using specified delimiter characters and store tokens into an array
public strtok             !  gets next token. Used by change(3f)
public paragraph          !  convert a long string into a paragraph
!-------------------------# EDITING
public substitute         !  subroutine non-recursively globally replaces old substring with new substring in string
public replace            !  function non-recursively globally replaces old substring with new substring in string
public change             !  replaces old substring with new substring in string with a directive like a line editor
public modif              !  change string using a directive using rules similar to XEDIT line editor MODIFY command
public transliterate      !  when characters in set one are found replace them with characters from set two
public reverse            !  elemental function reverses character order in a string
public join               !  append an array of character variables with specified separator into a single CHARACTER variable
public squeeze            !  delete adjacent duplicate characters from a string
public rotate13           !  apply trivial encryption algorithm ROT13 to string
public percent_encode     !  percent-encode characters or a string
interface percent_encode;    module procedure percent_encode_string, percent_encode_characters;  end interface
public percent_decode     !  percent-decode characters or a string
interface percent_decode;    module procedure percent_decode_string, percent_decode_characters;  end interface
public encode_base64      !  apply base64 encoding (as defined in RFC-4648) to an array of bytes
public decode_base64      !  apply base64 decoding (as defined in RFC-4648) to an array of bytes
!-------------------------# CHARACTER ARRAY VERSUS STRING
public switch             !  generic switch between a string and an array of single characters (a2s,s2a)
private a2s               !  function to copy char array to string
private s2a               !  function to copy string(1:Clen(string)) to char array
public s2c                !  convert character variable to array of character(len=1) with null terminator for C compatibility
public c2s                !  convert null-terminated array of character(len=1) to string for strings returned by C
!-------------------------# CASE
public upper              !  elemental function converts string to uppercase
interface upper;    module procedure upper_all, upper_range;  end interface
public lower              !  elemental function converts string to miniscule
public upper_quoted       !  elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules
public lower_quoted       !  elemental function converts string to lowercase skipping strings quoted per Fortran syntax rules
!-------------------------# WHITE SPACE
public adjustc            !  elemental function centers string within the length of the input string
public compact            !  left justify string and replace duplicate whitespace with single characters or nothing
public nospace            !  function replaces whitespace with nothing
public indent             !  count number of leading spaces
public crop               !  function trims leading and trailing spaces and control characters
public clip               !  function trims leading and trailing spaces or set of characters from string
!-------------------------# QUOTES
public matching_delimiter !  find position of matching delimiter
public unquote            !  remove quotes from string as if read with list-directed input
public quote              !  add quotes to string as if written with list-directed output
!-------------------------# STRING LENGTH
public lenset             !  return a string as specified length
public pad                !  return a string of at least specified length
public zpad               !  return a string of at least specified length padded on left with zeros
interface zpad;    module procedure zpad_scalar, zpad_vector;  end interface
public lpad               !  convert value to a string of at least specified length padded on left with zeros
interface lpad;    module procedure lpad_scalar, lpad_vector;  end interface
public cpad               !  convert value to a centered string of at least specified length
interface cpad;    module procedure cpad_scalar, cpad_vector;  end interface
public rpad               !  convert value to a string of at least specified length padded on right with zeros
interface rpad;    module procedure rpad_scalar, rpad_vector;  end interface
public stretch            !  return a string of at least specified length with suffix
public merge_str          !  make strings of equal length and then call MERGE(3f) intrinsic
public len_white          !  find location of last non-whitespace character
!-------------------------# NONALPHA
public noesc              !  elemental function converts non-printable ASCII8 characters to a space
public notabs             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public dilate             !  convert tabs to spaces in output while maintaining columns, assuming a tab is set every 8 characters
public expand             !  expand escape sequences in a string
public visible            !  expand escape sequences in a string to control and meta-control representations
!-------------------------# NUMERIC STRINGS
public string_to_value    !  generic subroutine returns REAL|DOUBLEPRECISION|INTEGER value from string (a2d,a2r,a2i)
 private a2d              !  subroutine returns double value from string
 private a2r              !  subroutine returns real value from string
 private a2i              !  subroutine returns integer value from string
public string_to_values   !  subroutine returns values from a string
public getvals            !  subroutine returns values from a string
public s2v                !  function returns doubleprecision value from string
public s2vs               !  function returns a doubleprecision array of numbers from a string
                          !  NOT USING INTERNAL READ FOR CONVERSION
public atoi               !   function returns an INTEGER(kind=int32) value from a string
public atol               !   function returns an INTEGER(kind=int64) value from a string
public aton               !   function returns true or false as to whether string converts to numeric value, and numeric value
!------------------------------------------------------------------------------------------------------------
public str                !  function returns a string representing up to twenty scalar intrinsic values, including CSV style
public fmt                !  function returns a string representing an intrinsic value using optionally specified format
public value_to_string    !  generic subroutine returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
public v2s                !  generic function returns string given numeric REAL|DOUBLEPRECISION|INTEGER|LOGICAL value
 private d2s              !  function returns string from doubleprecision value
 private r2s              !  function returns string from real value
 private i2s              !  function returns string from integer value
 private l2s              !  function returns string from logical value
public isnumber           !  determine if string represents a number
 private trimzeros_       !  Delete trailing zeros from numeric decimal string
public listout            !  expand a list of numbers where  negative numbers denote range ends (1 -10 means 1 thru 10)
!-----------------------------------------------------------------------------------------------------------------------------------
!
! extend intrinsics to accept CHARACTER values
!
public int, real, dble, nint

interface int;     module procedure atoi;              end interface
interface real;    module procedure real_s2v;          end interface
interface dble;    module procedure dble_s2v;          end interface
interface nint;    module procedure nint_s2v;          end interface

interface aton
module procedure ator_real32
module procedure ator_real64
module procedure atoi_int8
module procedure atoi_int16
module procedure atoi_int32
module procedure atoi_int64
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!----------------------# BIT ROUTINES
public setbits8        !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits16       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits32       !  use a string representing a positive binary value to fill the bits of an INTEGER value
public setbits64       !  use a string representing a positive binary value to fill the bits of an INTEGER value
!----------------------# BASE CONVERSION
public base            !  convert whole number string in base [2-36] to string in alternate base [2-36]
public codebase        !  convert whole number string in base [2-36] to base 10 number
public decodebase      !  convert whole number in base 10 to string in base [2-36]
public base2           !  convert INTEGER to a string representing a binary value
!----------------------# LOGICAL TESTS
public glob            !  compares given string for match to pattern which may contain wildcard characters
public ends_with       !  test whether strings ends with one of the specified suffix
public isalnum         !  elemental function returns .true. if CHR is a letter or digit
public isalpha         !  elemental function returns .true. if CHR is a letter and .false. otherwise
public isascii         !  elemental function returns .true. if the low order byte of c is in the range char(0) to char(127)
public isblank         !  elemental function returns .true. if CHR is a blank character (space or horizontal tab.
public iscntrl         !  elemental function returns .true. if CHR is a delete character or ordinary control character
public isdigit         !  elemental function returns .true. if CHR is a digit (0,1,...,9) and .false. otherwise
public isgraph         !  elemental function true if CHR is an ASCII printable character except considers a space non-printable
public islower         !  elemental function returns .true. if CHR is a miniscule letter (a-z)
public isprint         !  elemental function determines if CHR is an ASCII printable character
public ispunct         !  elemental function returns .true. if CHR is a printable punctuation character
public isspace         !  elemental function true if CHR is a null, space, tab, carriage return, new line, vertical tab, or formfeed
public isupper         !  elemental function returns .true. if CHR is an uppercase letter (A-Z)
public isxdigit        !  elemental function returns .true. if CHR is a hexadecimal digit (0-9, a-f, or A-F).
!----------------------#
!-------------------------------#
public fortran_name             !  elemental function returns .true. if LINE is a valid Fortran name
public describe                 !  returns a string describing character
public edit_distance            !  returns a naive edit distance using the Levenshtein distance algorithm
public bundle                   !  return up to twenty strings of arbitrary length as an array
public longest_common_substring !  function that returns the longest common substring of two strings.
!-------------------------------#

!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_strings switch(3f) toggle between string and array of characters; generic{a2s s2a}"

interface switch
   module procedure a2s, s2a
end interface switch
! note how returned result is "created" by the function
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_3="@(#) M_strings string_to_value(3f) Generic subroutine converts numeric string to a number (a2d a2r a2i)"

interface string_to_value
   module procedure a2d, a2r, a2i
end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_4="@(#) M_strings v2s(3f) Generic function returns string given REAL|INTEGER|DOUBLEPRECISION value(d2s r2s i2s)"

interface v2s
   module procedure d2s, r2s, i2s, l2s
end interface
!-----------------------------------------------------------------------------------------------------------------------------------
!-!interface setbits ! boz
!-!        module procedure setbits8, setbits16, setbits32, setbits64
!-!end interface
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_5="@(#) M_strings str(3f) convert up to twenty scalar values or arrays to a string with optional CSV mode."

interface str
   module procedure str_scalar, str_one
end interface str
!-----------------------------------------------------------------------------------------------------------------------------------
! ASCII character constants
character, public, parameter :: ascii_nul = char(0)   ! null
character, public, parameter :: ascii_bel = char(7)   ! bell
character, public, parameter :: ascii_bs  = char(8)   ! backspace
character, public, parameter :: ascii_ht  = char(9)   ! horizontal tab
character, public, parameter :: ascii_lf  = char(10)  ! line feed or newline
character, public, parameter :: ascii_ff  = char(12)  ! form feed or newpage
character, public, parameter :: ascii_cr  = char(13)  ! carriage return
character, public, parameter :: ascii_esc = char(27)  ! escape
!-----------------------------------------------------------------------------------------------------------------------------------
interface ends_with
    procedure :: ends_with_str
    procedure :: ends_with_any
end interface ends_with
!-----------------------------------------------------------------------------------------------------------------------------------
public :: split2020, string_tokens
public :: find_field

interface split2020
   module procedure :: split_tokens, split_first_last, split_pos
end interface split2020
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
!This contains a conditionally built mini-version of M_journal which allows the M_strings.f90 module
!to be built using make as a stand-alone distribution but still have make.shell build a true version
!
!This is so when built with make.shell(1) or fpm(1) it will use the
!real M_journal.f90 file but that fpm(1) will not auto-discover the mini
!M_journal.f90 file and build it and cause duplicates.

interface journal
   module procedure flush_trail                    ! journal()        ! no options
   module procedure write_message_only             ! journal(c)       ! must have one string
   module procedure where_write_message            ! journal(where,c)
end interface journal

!$@(#) M_journal::journal(3fg): provides public message routine, no paging or graphic mode change

! global variables

integer,save,private :: stdout=OUTPUT_UNIT
logical,save         :: debug=.false.
integer,save         :: last_int=0
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
! for compatibility allow old name for renamed procedures
interface matchw;   module procedure  glob;                end interface
interface atleast;  module procedure  pad;                 end interface
interface cc;       module procedure  bundle;              end interface
interface msg;      module procedure  str_scalar,str_one;  end interface  msg
public matchw          !  clone of glob -- for backward compatibility
public atleast         !  clone of pad -- for backward compatibility
public cc              !  clone of pad -- for backward compatibility
public msg             !  function returns a string representing up to twenty scalar intrinsic values, including CSV style
!-----------------------------------------------------------------------------------------------------------------------------------
CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob(3f) compares an (entire) STRING for a match to a PATTERN which
!!    may contain basic wildcard "globbing" characters.
!!
!!    "*" matches any string. "?" matches any single character.
!!
!!    In this version to get a match the entire string must be described by
!!    PATTERN. Trailing whitespace is significant, so trim the input string
!!    to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the first
!!    match found is not at the end of the string so 'baba' does not match
!!    'babababa'. So the algorithm is said to find an early match.
!!
!!    To skip over the early matches insert an extra character at the end of
!!    the string and pattern that does not occur in the pattern. Typically a
!!    NULL is used (char(0)). So searching for b*ba\0 in babababa\0 matches
!!    the entire string.
!!
!!##OPTIONS
!!    string   the input string to be tested for a match to the pattern.
!!    pattern  the globbing pattern to search for. The following simple
!!             globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or trimmed
!!               before the comparison.
!!             o There is no escape character, so matching strings with
!!               a literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    implicit none
!!    ! This main routine passes a bunch of test strings
!!    ! into the above code. In performance comparison mode,
!!    ! it does that over and over. Otherwise, it does it just
!!    ! once. Either way, it outputs a passed/failed result.
!!    !
!!    integer :: nReps
!!    logical :: allpassed
!!    integer :: i
!!    allpassed = .true.
!!
!!    nReps = 10000
!!    ! Can choose as many repetitions as you're expecting
!!    ! in the real world.
!!    nReps = 1
!!
!!    do i=1,nReps
!!       ! Cases with repeating character sequences.
!!       allpassed= test("a*abab",      "a*b",   .true.)  .and. allpassed
!!       allpassed= test("ab",          "*?",    .true.)  .and. allpassed
!!       allpassed= test("abc",         "*?",    .true.)  .and. allpassed
!!       allpassed= test("abcccd",      "*ccd",  .true.)  .and. allpassed
!!       allpassed= test("bLah",        "bLaH",  .false.) .and. allpassed
!!       allpassed= test("mississippi", "*sip*", .true.)  .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("mississipissippi", "*issip*ss*", .true.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) .and. allpassed
!!       allpassed= &
!!        & test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) .and. allpassed
!!       allpassed= test("xyxyxyzyxyz", "xy*z*xyz", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",   .true.)  .and. allpassed
!!       allpassed= test("mississippi", "mi*sip*",  .true.)  .and. allpassed
!!       allpassed= test("ababac",      "*abac*",   .true.)  .and. allpassed
!!       allpassed= test("aaazz",       "a*zz*",    .true.)  .and. allpassed
!!       allpassed= test("a12b12",      "*12*23",   .false.) .and. allpassed
!!       allpassed= test("a12b12",      "a12b",     .false.) .and. allpassed
!!       allpassed= test("a12b12",      "*12*12*",  .true.)  .and. allpassed
!!
!!       ! Additional cases where the '*' char appears in the tame string.
!!       allpassed= test("*",     "*",      .true.)  .and. allpassed
!!       allpassed= test("a*r",   "a*",     .true.)  .and. allpassed
!!       allpassed= test("a*ar",  "a*aar",  .false.) .and. allpassed
!!
!!       ! More double wildcard scenarios.
!!       allpassed= test("XYXYXYZYXYz", "XY*Z*XYz",  .true.)  .and. allpassed
!!       allpassed= test("missisSIPpi", "*SIP*",     .true.)  .and. allpassed
!!       allpassed= test("mississipPI", "*issip*PI", .true.)  .and. allpassed
!!       allpassed= test("xyxyxyxyz",   "xy*xyz",    .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*sip*",   .true.)  .and. allpassed
!!       allpassed= test("miSsissippi", "mi*Sip*",   .false.) .and. allpassed
!!       allpassed= test("abAbac",      "*Abac*",    .true.)  .and. allpassed
!!       allpassed= test("aAazz",       "a*zz*",     .true.)  .and. allpassed
!!       allpassed= test("A12b12",      "*12*23",    .false.) .and. allpassed
!!       allpassed= test("a12B12",      "*12*12*",   .true.)  .and. allpassed
!!       allpassed= test("oWn",         "*oWn*",     .true.)  .and. allpassed
!!
!!       ! Completely tame (no wildcards) cases.
!!       allpassed= test("bLah", "bLah", .true.) .and. allpassed
!!
!!       ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert.
!!       allpassed= test("a", "*?", .true.) .and. allpassed
!!
!!       ! More mixed wildcard tests including coverage for false positives.
!!       allpassed= test("a",      "??",         .false.) .and. allpassed
!!       allpassed= test("ab",     "?*?",        .true.)  .and. allpassed
!!       allpassed= test("ab",     "*?*?*",      .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*?",     .true.)  .and. allpassed
!!       allpassed= test("abc",    "?**?*&?",    .false.) .and. allpassed
!!       allpassed= test("abcd",   "?b*??",      .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?a*??",      .false.) .and. allpassed
!!       allpassed= test("abcd",   "?**?c?",     .true.)  .and. allpassed
!!       allpassed= test("abcd",   "?**?d?",     .false.) .and. allpassed
!!       allpassed= test("abcde",  "?*b*?*d*?",  .true.)  .and. allpassed
!!
!!       ! Single-character-match cases.
!!       allpassed= test("bLah",   "bL?h",  .true.)  .and. allpassed
!!       allpassed= test("bLaaa",  "bLa?",  .false.) .and. allpassed
!!       allpassed= test("bLah",   "bLa?",  .true.)  .and. allpassed
!!       allpassed= test("bLaH",   "?Lah",  .false.) .and. allpassed
!!       allpassed= test("bLaH",   "?LaH",  .true.)  .and. allpassed
!!
!!       allpassed= test('abcdefghijk' ,  '?b*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*',     .true.)  .and. allpassed
!!       allpassed= test('abcdefghijk' ,  '*c',      .false.) .and.  allpassed
!!       allpassed= test('abcdefghijk' ,  '*c*k',    .true.)  .and. allpassed
!!       allpassed= test('LS'          ,  '?OW',     .false.) .and.  allpassed
!!       allpassed= test('teztit'      ,  'tez*t*t', .true.)  .and. allpassed
!!         ! Two pattern match problems that might pose difficulties
!!       allpassed= test('e '           , '*e* ',      .true.) .and. allpassed
!!       allpassed= test('abcde       ' , '*e      *', .true.) .and. allpassed
!!       allpassed= test('bababa'       , 'b*ba',      .true.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*ax',      .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*ax',      .false.) .and. allpassed
!!       allpassed= test('baaaaax'      , 'b*a',       .false.) .and. allpassed
!!       allpassed= test(''             , 'b*',        .false.) .and. allpassed
!!       allpassed= test(''             , '*',         .true.) .and.  allpassed
!!       allpassed= test('b'            , '',          .false.) .and. allpassed
!!       allpassed= test('3'            , '??',        .false.) .and. allpassed
!!       ! known flaws
!!       allpassed= test(''             , '',          .true.) .and. allpassed
!!       allpassed= test('baaaaa'       , 'b*a',       .true.) .and. allpassed
!!       ! add unused character to work around
!!       allpassed= test(''//char(0),      ''//char(0),   .true.).and.allpassed
!!       allpassed= test('baaaaa'//char(0),'b*a'//char(0),.true.).and.allpassed
!!
!!       ! Many-wildcard scenarios.
!!       allpassed= test(&
!!       &"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&
!!       &aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",&
!!       &"a*a*a*a*a*a*aa*aaa*a*a*b",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacac&
!!       &adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacaca&
!!       &cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*a*x*aaa*fa*ga*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abababababababababababababababababababaacacacacacacacad&
!!       &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",&
!!       &"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("aaabbaabbaab","*aabbaa*a*",.true.).and.allpassed
!!       allpassed= &
!!       test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",&
!!       &"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) .and. allpassed
!!       allpassed= test("aaaaaaaaaaaaaaaa",&
!!       &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       & "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc&
!!       &*abc*abc*abc*",&
!!       &.false.) .and. allpassed
!!       allpassed= test(&
!!       &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij&
!!       &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",&
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc*abcd*abcd*abc*abcd",&
!!       &"abc*abc*abc*abc*abc", .false.) .and. allpassed
!!       allpassed= test( "abc*abcd*abcd*abc*abcd*abcd&
!!       &*abc*abcd*abc*abc*abcd", &
!!       &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",&
!!       &.true.) .and. allpassed
!!       allpassed= test("abc",&
!!       &"********a********b********c********", .true.) .and. allpassed
!!       allpassed=&
!!       &test("********a********b********c********", "abc",.false.)&
!!       & .and.allpassed
!!       allpassed= &
!!       &test("abc", "********a********b********b********",.false.)&
!!       & .and.allpassed
!!       allpassed= test("*abc*", "***a*b*c***", .true.) .and. allpassed
!!
!!       ! A case-insensitive algorithm test.
!!       ! allpassed=test("mississippi", "*issip*PI", .true.) .and. allpassed
!!     enddo
!!
!!     if (allpassed)then
!!        write(*,'(*(g0,1x))')"Passed",nReps
!!     else
!!        write(*,'(a)')"Failed"
!!     endif
!!    contains
!!    ! This is a test program for wildcard matching routines.
!!    ! It can be used either to test a single routine for correctness,
!!    ! or to compare the timings of two (or more) different wildcard
!!    ! matching routines.
!!    !
!!    function test(tame, wild, bExpectedResult) result(bPassed)
!!    use M_strings, only : glob
!!       character(len=*) :: tame
!!       character(len=*) :: wild
!!       logical          :: bExpectedResult
!!       logical          :: bResult
!!       logical          :: bPassed
!!       bResult = .true.    ! We'll do "&=" cumulative checking.
!!       bPassed = .false.   ! Assume the worst.
!!       write(*,*)repeat('=',79)
!!       bResult = glob(tame, wild) ! Call a wildcard matching routine.
!!
!!       ! To assist correctness checking, output the two strings in any
!!       ! failing scenarios.
!!       if (bExpectedResult .eqv. bResult) then
!!          bPassed = .true.
!!          if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild
!!       else
!!          if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild
!!       endif
!!
!!    end function test
!!    end program demo_glob
!!
!!   Expected output
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCES
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob(tame,wild)

! ident_6="@(#) M_strings glob(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                      :: glob
character(len=*)             :: tame       ! A string without wildcards
character(len=*)             :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1)   :: tametext
character(len=len(wild)+1)   :: wildtext
character(len=1),parameter   :: NULL=char(0)
integer                      :: wlen
integer                      :: ti, wi
integer                      :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi) == '*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi) == NULL) then        ! "x" matches "*"
            glob=.true.
            return
         endif
         if(wildtext(wi:wi)  /=  '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti)  /=  wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti) == NULL)then
                  glob=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark /= NULL) then
            if(wildtext(wi:) /=  wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti)  /=  wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti) /= NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti > len(tametext)) then
         glob=.false.
         return
      elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi) /= NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi) == NULL)exit
            enddo
         endif
         if (wildtext(wi:wi) == NULL)then
            glob=.true.
            return                               ! "x" matches "x"
         endif
         glob=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    ends_with(3f) - [M_strings:COMPARE] test if string ends with specified
!!                    suffix(es)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! pure function ends_with(string,ending[,ignorecase])
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: ending(..)
!!     logical,intent(in),optional :: ignorecase
!!     logical                     :: ends_with
!!
!!##DESCRIPTION
!!
!!    ends_with(3f) tests if a string ends with any specified suffix. Differs
!!    from using index(3f) in that the input string and multiple suffices
!!    are trimmed by ends_with(3f),
!!
!!##OPTIONS
!!     STRING         string to search
!!     ENDING         list of separator strings. May be scalar or an array.
!!                    Trailing spaces in ENDING are ignored.
!!     IGNORECASE     If .true. case is ignored.
!!
!!##RETURNS
!!     ENDS_WITH      returns .TRUE. if one of the suffix match the end
!!                    of STRING.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_ends_with
!!    use M_strings, only : ends_with
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!    character(len=:),allocatable :: line, pattern
!!    !
!!       write(*,*)'basic usage'
!!       write(stdout,*)ends_with('prog.a','.a'), 'should be true'
!!       write(stdout,*)ends_with('prog.a','.o'), 'should be false'
!!       write(stdout,*)ends_with('prog.a',['.o','.i','.s'])
!!       write(stdout,*)ends_with('prog.f90',['.F90','.f90','.f  ','.F  '])
!!       !
!!       write(*,*)'ignored case'
!!       write(stdout,*)ends_with('prog.F90',['.f90','.f  '],ignorecase=.true.)
!!       !
!!       write(*,*)'trailing whitespace is ignored'
!!       write(stdout,*)ends_with('prog.pdf','.pdf')
!!       write(stdout,*)ends_with('prog.pdf','.pdf ')
!!       write(stdout,*)ends_with('prog.pdf ','.pdf ')
!!       write(stdout,*)ends_with('prog.pdf  ','.pdf ')
!!       !
!!       write(*,*)'equivalent using index(3f)'
!!       line=   'myfile.doc  '
!!       pattern='.doc        '
!!       write(stdout,*)&
!!       &index(trim(line),trim(pattern),back=.true.)==len_trim(line)-len_trim(pattern)+1
!!       write(stdout,*)ends_with(line,pattern)
!!    end program demo_ends_with
!!
!! Results:
!!
!!     >  basic usage
!!     >  T should be true
!!     >  F should be false
!!     >  F
!!     >  T
!!     >  ignored case
!!     >  T
!!     >  trailing whitespace is ignored
!!     >  T
!!     >  T
!!     >  T
!!     >  T
!!     >  equivalent using index(3f)
!!     >  T
!!     >  T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function ends_with_str(string, ending,ignorecase) result(matched)
character(*), intent(in)     :: string, ending
logical,intent(in),optional  :: ignorecase
integer                      :: n1, n2
logical                      :: matched
logical                      :: ignorecase_local
   if(present(ignorecase))then
           ignorecase_local=ignorecase
   else
           ignorecase_local=.false.
   endif
   n1 = len_trim(string) - len_trim(ending) + 1
   n2 = len_trim(string)
   if (n1 < 1) then
       matched = .false.
   else
       if(ignorecase_local)then
          matched = (upper(string(n1:n2)) == upper(ending))
       else
          matched = (string(n1:n2) == ending)
       endif
   endif
end function ends_with_str
!-----------------------------------------------------------------------------------------------------------------------------------
pure function ends_with_any(string, endings,ignorecase) result(matched)
character(*), intent(in)     :: string
character(*), intent(in)     :: endings(:)
logical,intent(in),optional  :: ignorecase
logical                      :: matched
integer                      :: i
   matched = .true.
   FINDIT: block
   do i=1, size(endings)
       if( ends_with_str(string,endings(i),ignorecase) ) exit FINDIT
   enddo
   matched = .false.
   endblock FINDIT
end function ends_with_any
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sep(3f) - [M_strings:TOKENS] function to parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function sep(input_line,delimiters,nulls)
!!
!!     character(len=*),intent(in)          :: input_line
!!     character(len=*),optional,intent(in) :: delimiters
!!     character(len=*),optional,intent(in) :: nulls
!!     character(len=:),allocatable         :: sep(:)
!!
!!##DESCRIPTION
!!     sep(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!    ORDER='ASCENDING'|'DESCENDING'  by default the tokens are returned from
!!                                    last to first; order='ASCENDING' returns
!!                                    them from first to last (left to right).
!!##RETURNS
!!    SEP       Output array of tokens
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_sep
!!    use M_strings, only: sep
!!    character(len=*),parameter :: fo='(/,a,*(/,"[",g0,"]":,","))'
!!    character(len=*),parameter :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!       write(*,'(a)') 'INPUT LINE:['//LINE//']'
!!       write(*,fo) 'typical call:',sep(line)
!!       write(*,fo) 'delimiters ":|":',sep(line,':|')
!!       write(*,fo) 'count null fields ":|":',sep(line,':|','return')
!!    end program demo_sep
!!
!!  Output
!!
!!    INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!
!!    typical call:
!!    [cc        ],
!!    [B         ],
!!    [a         ],
!!    [333|333   ],
!!    [1:|:2     ],
!!    [qrstuvwxyz],
!!    [ghijklmnop],
!!    [aBcdef    ]
!!
!!    delimiters ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!    count null fields ":|":
!!    [333 a B cc                         ],
!!    [2     333                          ],
!!    [                                   ],
!!    [                                   ],
!!    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function sep(input_line,delimiters,nulls,order)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_7="@(#) M_strings sep(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=*),optional,intent(in)     :: order       ! return strings composed of delimiters or not ignore|return|ignoreend

character(len=:),allocatable             :: sep(:)      ! output array of tokens
integer                                  :: isize
   call split(input_line,sep,delimiters,'right',nulls)
   if(present(order))then
   select case(order)
   case('ascending','ASCENDING')
    isize=size(sep)
    if(isize > 1)then
       sep=sep(isize:1:-1)
    endif
   end select
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function sep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!
!!##DESCRIPTION
!!     SPLIT(3f) parses a string using specified delimiter characters and
!!     store tokens into an allocatable array
!!
!!##OPTIONS
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!                (This can be accomplished with array syntax in modern
!!                Fortran, but was more useful pre-fortran90).
!!
!!    NULLS=IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_split
!!    use M_strings, only: split
!!    implicit none
!!    integer                      :: i
!!    character(len=*),parameter   :: title='(80("="),t1,a)'
!!    character(len=*),parameter   :: line=&
!!    '  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!    character(len=:),allocatable :: array(:) ! output array of tokens
!!       write(*,*)'INPUT LINE:['//line//']'
!!       !
!!       write(*,title)'typical call: '
!!       call split(line,array)
!!       call printme()
!!       !
!!       write(*,title)'custom delimiters=":|" : '
!!       call split(line,array,delimiters=':|',&
!!       & order='sequential',nulls='ignore')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'delimiters=":|",reverse array order and count null fields:'
!!       call split(line,array,delimiters=':|',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!       !
!!       write(*,title)&
!!       'default delimiters, reverse array order and return null fields:'
!!       call split(line,array,delimiters='',&
!!       & order='reverse',nulls='return')
!!       call printme()
!!    contains
!!    subroutine printme()
!!       write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!       write(*,*)'SIZE:',size(array)
!!    end subroutine printme
!!    end program demo_split
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  > 1 ==> aBcdef
!!  > 2 ==> ghijklmnop
!!  > 3 ==> qrstuvwxyz
!!  > 4 ==> 1:|:2
!!  > 5 ==> 333|333
!!  > 6 ==> a
!!  > 7 ==> B
!!  > 8 ==> cc
!!  >  SIZE:           8
!!  > custom delimiters=":|" : =============================================
!!  > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  > 2 ==> 2     333
!!  > 3 ==> 333 a B cc
!!  >  SIZE:           3
!!  > delimiters=":|",reverse array order and count null fields:============
!!  > 1 ==> 333 a B cc
!!  > 2 ==> 2     333
!!  > 3 ==>
!!  > 4 ==>
!!  > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!  >  SIZE:           5
!!  > default delimiters, reverse array order and return null fields:=======
!!  > 1 ==>
!!  > 2 ==>
!!  > 3 ==>
!!  > 4 ==> cc
!!  > 5 ==> B
!!  > 6 ==> a
!!  > 7 ==> 333|333
!!  > 8 ==>
!!  > 9 ==>
!!  > 10 ==>
!!  > 11 ==>
!!  > 12 ==> 1:|:2
!!  > 13 ==>
!!  > 14 ==> qrstuvwxyz
!!  > 15 ==> ghijklmnop
!!  > 16 ==>
!!  > 17 ==>
!!  > 18 ==> aBcdef
!!  > 19 ==>
!!  > 20 ==>
!!  >  SIZE:          20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_8="@(#) M_strings split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iend(:)                ! positions in input string where tokens end
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: i20                    ! loop counters
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   call  slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=trim(lower(adjustl(nulls))); else; nlls='ignore'    ; endif ! optional parameter
   if(present(order))then; ordr=trim(lower(adjustl(order))); else; ordr='sequential'; endif ! decide on value for ORDER parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ordr)                                             ! decide which order to store tokens
   case ('reverse','right') ; ii=size(ibegin) ; iiii=-1           ! last to first
   case default             ; ii=1            ; iiii=1            ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   ! maxval() of a zero-size array is set to a flag value not zero or length of character string
   if(size(ibegin).eq.0)then
      imax=0
   else
      imax=maxval(iend-ibegin)+1
   endif
   allocate(character(len=imax) :: array(size(ibegin)))           ! allocate the array to return
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,size(ibegin)                                          ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (nlls)
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iend(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    slice(3f) - [M_strings:TOKENS] parse string into an array using
!!    specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!!
!!     character(len=*),intent(in)          :: input_line
!!     integer,allocatable,intent(out)      :: ibegin(:),iend(:)
!!     character(len=*),optional,intent(in) :: delimiters
!!     character(len=*),optional,intent(in) :: nulls
!!
!!##DESCRIPTION
!!     slice(3f) parses a string using specified delimiter characters and
!!     store token beginning and ending positions into allocatable arrays
!!
!!##OPTIONS
!!    INPUT_LINE   Input string to tokenize
!!
!!    IBEGIN,IEND  arrays containing start and end positions of tokens.
!!                 IEND(I)<IBEGIN(I) designates a null token.
!!
!!    DELIMITERS   List of delimiter characters.
!!                 The default delimiters are the "whitespace" characters
!!                 (space, tab,new line, vertical tab, formfeed, carriage
!!                 return, and null). You may specify an alternate set of
!!                 delimiter characters.
!!
!!                 Multi-character delimiters are not supported (Each
!!                 character in the DELIMITERS list is considered to be
!!                 a delimiter).
!!
!!                 Quoting of delimiter characters is not supported.
!!
!!    NULLS="IGNORE"|"RETURN"|"IGNOREEND"  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_slice
!!     use M_strings, only: slice
!!     implicit none
!!     integer                    :: i
!!     character(len=*),parameter :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     integer,allocatable        :: ibegin(:), iend(:) ! output arrays of positions
!!     character(len=*),parameter :: title='(80("="),t1,a)'
!!        write(*,*)'INPUT LINE:['//line//']'
!!        !
!!        write(*,title)'typical call: '
!!        call slice(line,ibegin,iend)
!!        call printme()
!!        !
!!        write(*,title)'custom list of delimiters=":|" : '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='ignore')
!!        call printme()
!!        !
!!        write(*,title)'delimiters=":|", and count null fields: '
!!        call slice(line,ibegin,iend,delimiters=':|',nulls='return')
!!        call printme()
!!        !
!!        write(*,title)'default delimiters and return null fields: '
!!        call slice(line,ibegin,iend,delimiters='',nulls='return')
!!        call printme()
!!     contains
!!     subroutine printme()
!!        write(*,'((*(:/,3x,"[",g0,"]")))')&
!!                & (line(ibegin(i):iend(i)),i=1,size(ibegin))
!!        write(*,'(*(g0,1x))')'SIZE:',size(ibegin)
!!     end subroutine printme
!!     end program demo_slice
!!
!! Results:
!!
!!  > INPUT LINE:
!!  > [  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!  > typical call: ========================================================
!!  >
!!  >    [aBcdef]
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    [1:|:2]
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  > SIZE: 8
!!  > custom list of delimiters=":|" : =====================================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 3
!!  > delimiters=":|", and count null fields: ==============================
!!  >
!!  >    [  aBcdef   ghijklmnop qrstuvwxyz  1]
!!  >    []
!!  >    []
!!  >    [2     333]
!!  >    [333 a B cc    ]
!!  > SIZE: 5
!!  > default delimiters and return null fields: ===========================
!!  >
!!  >    []
!!  >    []
!!  >    [aBcdef]
!!  >    []
!!  >    []
!!  >    [ghijklmnop]
!!  >    [qrstuvwxyz]
!!  >    []
!!  >    [1:|:2]
!!  >    []
!!  >    []
!!  >    []
!!  >    []
!!  >    [333|333]
!!  >    [a]
!!  >    [B]
!!  >    [cc]
!!  >    []
!!  >    []
!!  >    []
!!  > SIZE: 20
!! ======================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine slice(input_line,ibegin,iend,delimiters,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_9="@(#) M_strings slice(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
integer,allocatable,intent(out)          :: ibegin(:)   ! positions in input string where tokens start
integer,allocatable,intent(out)          :: iend(:)     ! positions in input string where tokens end
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
!-----------------------------------------------------------------------------------------------------------------------------------
integer                         :: n                      ! max number of strings INPUT_LINE could slice into if all delimiter
character(len=:),allocatable    :: dlim                   ! string containing delimiter characters
character(len=:),allocatable    :: nlls                   ! string containing nulls keyword
integer                         :: icount                 ! number of tokens found
integer                         :: ii                     ! loop parameters used to control print order
integer                         :: lgth                   ! length of input string with trailing spaces trimmed
integer                         :: i10,i20,i30            ! loop counters
integer                         :: icol                   ! pointer into input string as it is being parsed
integer                         :: idlim                  ! number of delimiter characters
integer                         :: ifound                 ! where next delimiter character is found in remaining input string data
integer                         :: inotnull               ! count strings not composed of delimiters
integer                         :: ireturn                ! number of tokens returned
integer                         :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could slice into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ?
   if(allocated(iend))deallocate(iend)        !x! intel compiler says allocated already ?
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iend(n))                          ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iend(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   lgth=len(input_line)                                           ! lgth is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lgth > 0)then                                               ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,lgth,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iend(i30)=lgth                                        ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               IF(ifound > 0)then
                  iend(i30)=min(iend(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iend(i30)+2                                      ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iend(i30)=icol-1                                      ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iend(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > lgth)then                                      ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   ii=0
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iend(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            ii=ii+1
            ibegin(ii)=ibegin(i20)
            iend(ii)=iend(i20)
         end select
      else
         ii=ii+1
         ibegin(ii)=ibegin(i20)
         iend(ii)=iend(i20)
      endif
   enddo
   ibegin=ibegin(:ii)
   iend=iend(:ii)
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine slice
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    chomp(3f) - [M_strings:TOKENS] Tokenize a string, consuming it one
!!    token per call
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function chomp(source_string,token[,delimiters])
!!
!!     character(len=*)                     :: source_string
!!     character(len=:),intent(out)         :: token
!!     character(len=:),intent(in),optional :: delimiters
!!     integer                              :: chomp
!!
!!##DESCRIPTION
!!    The CHOMP(3f) function is used to isolate sequential tokens in a
!!    string, SOURCE_STRING. These tokens are delimited in the string by at
!!    least one of the characters in DELIMITERS. This routine consumes the
!!    source_string one token per call. It returns -1 when complete. The
!!    default delimiter list is "space,tab,carriage return,newline".
!!
!!##OPTIONS
!!     SOURCE_STRING  string to tokenize
!!     DELIMITERS     list of separator characters
!!
!!##RETURNS
!!     TOKEN          returned token
!!     CHOMP          status flag. 0 = success, -1 = no tokens remain
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_chomp
!!
!!    use M_strings, only : chomp
!!    implicit none
!!    character(len=100)            :: inline
!!    character(len=:),allocatable  :: token
!!    character(len=*),parameter    :: delimiters=' ;,'
!!    integer                       :: iostat
!!    integer                       :: icount
!!    integer                       :: itoken
!!       icount=0
!!       do        ! read lines from stdin until end-of-file or error
!!          read (unit=*,fmt="(a)",iostat=iostat) inline
!!          if(iostat /= 0)stop
!!          icount=icount+1
!!          itoken=0
!!          write(*,*)'INLINE ',trim(inline)
!!          do while ( chomp(inline,token,delimiters) >=  0)
!!             itoken=itoken+1
!!             print *, itoken,'TOKEN=['//trim(token)//']'
!!          enddo
!!       enddo
!!
!!    end program demo_chomp
!!
!!   sample input file
!!
!!     this is a test of chomp; A:B :;,C;;
!!
!!   sample output file
!!
!!     > INLINE     this is a test of chomp; A:B :;,C;;
!!     >           1 TOKEN=[this]
!!     >           2 TOKEN=[is]
!!     >           3 TOKEN=[a]
!!     >           4 TOKEN=[test]
!!     >           5 TOKEN=[of]
!!     >           6 TOKEN=[chomp]
!!     >           7 TOKEN=[A:B]
!!     >           8 TOKEN=[:]
!!     >           9 TOKEN=[C]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function chomp(source_string,token,delimiters)

! ident_10="@(#) M_strings chomp(3f) Tokenize a string JSU- 20151030"

character(len=*)                         :: source_string    ! string to tokenize
character(len=:),allocatable,intent(out) :: token            ! returned token
character(len=*),intent(in),optional     :: delimiters       ! list of separator characters
integer                                  :: chomp            ! returns copy of shifted source_string
character(len=:),allocatable             :: delimiters_local
integer                                  :: token_start      ! beginning of token found if function result is .true.
integer                                  :: token_end        ! end of token found if function result is .true.
integer                                  :: isource_len
!-----------------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(present(delimiters))then
      delimiters_local=delimiters
   else                                          ! increment start to previous end + 1
      delimiters_local=char(32)//char(09)//char(10)//char(13) ! space,horizontal tab, newline, carriage return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   token_start=1
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)                         ! step thru each character to find next delimiter, if any
      if(index(delimiters_local,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
   !write(*,*)'TOKEN_START ',token_start
   !write(*,*)'TOKEN_END   ',token_end
   chomp=isource_len-token_end
   if(chomp >= 0)then
      token=source_string(token_start:token_end)
      source_string=source_string(token_end+1:)
   else
      token=''
      source_string=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end function chomp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      delim(3f) - [M_strings:TOKENS] parse a string and store tokens into
!!      an array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)
!!
!!     character(len=*),intent(in)  :: line
!!     integer,integer(in)          :: n
!!     integer,intent(out)          :: icount
!!     character(len=*)             :: array(n)
!!     integer,intent(out)          :: ibegin(n)
!!     integer,intent(out)          :: iterm(n)
!!     integer,intent(out)          :: lgth
!!     character(len=*)             :: dlim
!!
!!##DESCRIPTION
!!      Given a LINE of structure " par1 par2 par3 ... parn "
!!      store each par(n) into a separate variable in ARRAY (UNLESS
!!      ARRAY(1) == '#N#')
!!
!!      Also set ICOUNT to number of elements of array initialized, and
!!      return beginning and ending positions for each element in IBEGIN(N)
!!      and ITERM(N).
!!
!!      Return position of last non-blank character (even if more
!!      than N elements were found) in lgth
!!
!!      No quoting or escaping of delimiter is allowed, so the delimiter
!!      character can not be placed in a token.
!!
!!      No checking for more than N parameters; If any more they are ignored.
!!
!!      This routine originates pre-Fortran90. A version using optional parameters
!!      and allocatable arrays is on the TODO list.
!!
!!##OPTIONS
!!    LINE       input string to parse into tokens
!!    ARRAY(N)   array that receives tokens
!!    N          size of arrays ARRAY, IBEGIN, ITERM
!!    ICOUNT     number of tokens found
!!    IBEGIN(N)  starting columns of tokens found
!!    ITERM(N)   ending columns of tokens found
!!    LGTH       position of last non-blank character in input string LINE
!!    DLIM       delimiter characters
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_delim
!!
!!     use M_strings, only: delim
!!     implicit none
!!     character(len=80) :: line
!!     character(len=80) :: dlm
!!     integer,parameter :: n=80
!!     character(len=20) :: array(n)=' '
!!     integer           :: ibegin(n),iterm(n)
!!     integer           :: i20, icount, lgth, i10,i30
!!     line=' first  second 10.3 words_of_stuff  '
!!     do i20=1,4
!!        ! change delimiter list and what is calculated or parsed
!!        if(i20 == 1)dlm=' '
!!        if(i20 == 2)dlm='o'
!!        if(i20 == 3)dlm=' aeiou'    ! NOTE SPACE IS FIRST
!!        if(i20 == 3)ARRAY(1)='#N#'  ! QUIT RETURNING STRING ARRAY
!!        if(i20 == 4)line='AAAaBBBBBBbIIIIIi  J K L'
!!
!!        ! write out a break line composed of =========== ..
!!        write(*,'(57("="))')
!!        ! show line being parsed
!!        write(*,'(a)')'PARSING=['//trim(line)//'] on '//trim(dlm)
!!        ! call parsing procedure
!!        call delim(line,array,n,icount,ibegin,iterm,lgth,dlm)
!!        write(*,*)'number of tokens found=',icount
!!        write(*,*)'last character in column ',lgth
!!        if(icount > 0)then
!!           if(lgth /= iterm(icount))then
!!              write(*,*)'ignored from column ',iterm(icount)+1,' to ',lgth
!!           endif
!!           do i10=1,icount
!!              ! check flag to see if ARRAY() was set
!!              if(array(1) /= '#N#')then
!!                 ! from returned array
!!                 write(*,'(a,a,a)',advance='no')&
!!                 &'[',array(i10)(:iterm(i10)-ibegin(i10)+1),']'
!!              endif
!!           enddo
!!           ! using start and end positions in IBEGIN() and ITERM()
!!           write(*,*)
!!           do i10=1,icount
!!              ! from positions in original line
!!              write(*,'(a,a,a)',advance='no')&
!!              &'[',line(ibegin(i10):iterm(i10)),']'
!!           enddo
!!           write(*,*)
!!        endif
!!     enddo
!!        line='four    score and   seven  years ago'
!!        call delim(line,["#N#"],n,icount,ibegin,iterm,lgth,' ')
!!        do i30=1,icount
!!           write(*,*)ibegin(i30),iterm(i30),&
!!           & '['//line(ibegin(i30):iterm(i30))//']'
!!        enddo
!!
!!     end program demo_delim
!!
!! Results:
!!
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [first][second][10.3][words_of_stuff]
!!  > [first][second][10.3][words_of_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on o
!!  >  number of tokens found=           4
!!  >  last character in column           34
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > [ first  sec][nd 10.3 w][rds_][f_stuff]
!!  > =========================================================
!!  > PARSING=[ first  second 10.3 words_of_stuff] on  aeiou
!!  >  number of tokens found=          10
!!  >  last character in column           34
!!  >
!!  > [f][rst][s][c][nd][10.3][w][rds_][f_st][ff]
!!  > =========================================================
!!  > PARSING=[AAAaBBBBBBbIIIIIi  J K L] on  aeiou
!!  >  number of tokens found=           5
!!  >  last character in column           24
!!  >
!!  > [AAA][BBBBBBbIIIII][J][K][L]
!!  >            1           4 [four]
!!  >            9          13 [score]
!!  >           15          17 [and]
!!  >           21          25 [seven]
!!  >           28          32 [years]
!!  >           34          36 [ago]
!! ================================================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine delim(line,array,n,icount,ibegin,iterm,lgth,dlim)

! ident_11="@(#) M_strings delim(3f) parse a string and store tokens into an array"

!
!     given a line of structure " par1 par2 par3 ... parn "
!     store each par(n) into a separate variable in array.
!
!     IF ARRAY(1) == '#N#' do not store into string array  (KLUDGE))
!
!     also count number of elements of array initialized, and
!     return beginning and ending positions for each element.
!     also return position of last non-blank character (even if more
!     than n elements were found).
!
!     no quoting of delimiter is allowed
!     no checking for more than n parameters, if any more they are ignored
!
character(len=*),intent(in)    :: line
integer,intent(in)             :: n
character(len=*)               :: array(n)
integer,intent(out)            :: icount
integer,intent(out)            :: ibegin(n)
integer,intent(out)            :: iterm(n)
integer,intent(out)            :: lgth
character(len=*),intent(in)    :: dlim
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(line)):: line_local
logical             :: lstore
integer             :: i10
integer             :: iarray
integer             :: icol
integer             :: idlim
integer             :: iend
integer             :: ifound
integer             :: istart
!-----------------------------------------------------------------------------------------------------------------------------------
      icount=0
      lgth=len_trim(line)
      line_local=line

      idlim=len(dlim)
      if(idlim > 5)then
         idlim=len_trim(dlim)      ! dlim a lot of blanks on some machines if dlim is a big string
         if(idlim == 0)then
            idlim=1     ! blank string
         endif
      endif

      if(lgth == 0)then                                        ! command was totally blank
         return
      endif
!
!     there is at least one non-blank character in the command
!     lgth is the column position of the last non-blank character
!     find next non-delimiter
      icol=1

      if(array(1) == '#N#')then                                ! special flag to not store into character array
         lstore=.false.
      else
         lstore=.true.
      endif

      do iarray=1,n,1                                          ! store into each array element until done or too many words
         NOINCREMENT: do
            if(index(dlim(1:idlim),line_local(icol:icol)) == 0)then  ! if current character is not a delimiter
               istart=icol                                     ! start new token on the non-delimiter character
               ibegin(iarray)=icol
               iend=lgth-istart+1+1                            ! assume no delimiters so put past end of line
               do i10=1,idlim
                  ifound=index(line_local(istart:lgth),dlim(i10:i10))
                  if(ifound > 0)then
                     iend=min(iend,ifound)
                  endif
               enddo
               if(iend <= 0)then                               ! no remaining delimiters
                 iterm(iarray)=lgth
                 if(lstore)then
                    array(iarray)=line_local(istart:lgth)
                 endif
                 icount=iarray
                 return
               else
                 iend=iend+istart-2
                 iterm(iarray)=iend
                 if(lstore)then
                    array(iarray)=line_local(istart:iend)
                 endif
               endif
               icol=iend+2
               exit NOINCREMENT
            endif
            icol=icol+1
         enddo NOINCREMENT
!        last character in line was a delimiter, so no text left
!        (should not happen where blank=delimiter)
         if(icol > lgth)then
           icount=iarray
           if( (iterm(icount)-ibegin(icount)) < 0)then         ! last token was all delimiters
              icount=icount-1
           endif
           return
         endif
      enddo
      icount=n  ! more than n elements
end subroutine delim
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_strings:EDITING] function replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!! syntax:
!!
!!      function replace(targetline,old,new,cmd,&
!!       & occurrence, &
!!       & repeat, &
!!       & ignorecase, &
!!       & ierr) result (newline)
!!      character(len=*)                     :: targetline
!!      character(len=*),intent(in),optional :: old
!!      character(len=*),intent(in),optional :: new
!!      character(len=*),intent(in),optional :: cmd
!!      integer,intent(in),optional          :: occurrence
!!      integer,intent(in),optional          :: repeat
!!      logical,intent(in),optional          :: ignorecase
!!      integer,intent(out),optional         :: ierr
!!      character(len=:),allocatable         :: newline
!!
!!##DESCRIPTION
!!    Replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     cmd         alternate way to specify old and new string, in
!!                 the form c/old/new/; where "/" can be any character
!!                 not in "old" or "new".
!!     occurrence  if present, start changing at the Nth occurrence of the
!!                 OLD string. If negative start replacing from the left
!!                 end of the string.
!!     repeat      number of replacements to perform. Defaults to a global
!!                 replacement.
!!     ignorecase  whether to ignore ASCII case or not. Defaults
!!                 to .false. .
!!##RETURNS
!!     newline     allocatable string returned
!!     ierr        error code. If ier = -1 bad directive, >= 0 then
!!                 count of changes made.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_replace
!!    use M_strings, only : replace
!!    implicit none
!!    character(len=:),allocatable :: line
!!
!!    write(*,*)replace('Xis is Xe string','X','th')
!!    write(*,*)replace('Xis is xe string','x','th',ignorecase=.true.)
!!    write(*,*)replace('Xis is xe string','X','th',ignorecase=.false.)
!!
!!    ! a null old substring means "at beginning of line"
!!    write(*,*) replace('my line of text','','BEFORE:')
!!
!!    ! a null new string deletes occurrences of the old substring
!!    write(*,*) replace('I wonder i ii iii','i','')
!!
!!    ! Examples of the use of RANGE
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=1,repeat=1)
!!    write(*,*)'replace first a with A ['//line//']'
!!
!!    line=replace('aaaaaaaaa','a','A',occurrence=3,repeat=3)
!!    write(*,*)'replace a with A for 3rd to 5th occurrence ['//line//']'
!!
!!    line=replace('ababababa','a','',occurrence=3,repeat=3)
!!    write(*,*)'replace a with null instances 3 to 5 ['//line//']'
!!
!!    line=replace( &
!!     & 'a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!     & 'aa','CCCC',occurrence=-1,repeat=1)
!!    write(*,*)'replace lastaa with CCCC ['//line//']'
!!
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-1,repeat=1)
!!    write(*,*)replace('myf90stuff.f90.f90','f90','for',occurrence=-2,repeat=2)
!!
!!    end program demo_replace
!!
!!   Results:
!!
!!     this is the string
!!     this is the string
!!     this is xe string
!!     BEFORE:my line of text
!!     I wonder
!!     replace first a with A [Aaaaaaaaa]
!!     replace a with A for 3rd to 5th occurrence [aaAAAaaaa]
!!     replace a with null instances 3 to 5 [ababbb]
!!     replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC]
!!     myf90stuff.f90.for
!!     myforstuff.for.f90
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine crack_cmd(cmd,old,new,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)              :: cmd
character(len=:),allocatable,intent(out) :: old,new                ! scratch string buffers
integer                                  :: ierr
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=1)                         :: delimiters
integer                                  :: itoken
integer,parameter                        :: id=2                   ! expected location of delimiter
logical                                  :: ifok
integer                                  :: lmax                   ! length of target string
integer                                  :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   ierr=0
   old=''
   new=''
   lmax=len_trim(cmd)                       ! significant length of change directive

   if(lmax >= 4)then                      ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)               ! find delimiter in expected location
      itoken=0                            ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*crack_cmd* incorrect change directive -too short')
   endif

end subroutine crack_cmd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function replace(targetline,old,new,cmd,occurrence,repeat,ignorecase,ierr) result (newline)

! ident_12="@(#) M_strings replace(3f) replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in),optional   :: old          ! old substring to replace
character(len=*),intent(in),optional   :: new          ! new substring
character(len=*),intent(in),optional   :: cmd          ! contains the instructions changing the string
integer,intent(in),optional            :: occurrence   ! Nth occurrence of OLD string to start replacement at
integer,intent(in),optional            :: repeat       ! how many replacements
logical,intent(in),optional            :: ignorecase
integer,intent(out),optional           :: ierr         ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
character(len=:),allocatable  :: new_local, old_local, old_local_for_comparison
integer                       :: icount,ichange,ier2
integer                       :: original_input_length
integer                       :: len_old, len_new
integer                       :: ladd
integer                       :: left_margin, right_margin
integer                       :: ind
integer                       :: ic
integer                       :: ichr
integer                       :: range_local(2)
character(len=:),allocatable  :: targetline_for_comparison   ! input line to be changed
logical                       :: ignorecase_local
logical                       :: flip
character(len=:),allocatable  :: targetline_local   ! input line to be changed
!-----------------------------------------------------------------------------------------------------------------------------------
   flip=.false.
   ignorecase_local=.false.
   original_input_length=len_trim(targetline)          ! get non-blank length of input line

!  get old_local and new_local from cmd or old and new
   if(present(cmd))then
      call crack_cmd(cmd,old_local,new_local,ier2)
      if(ier2 /= 0)then
         newline=targetline  ! if no changes are made return original string on error
         if(present(ierr))ierr=ier2
         return
      endif
   elseif(present(old).and.present(new))then
      old_local=old
      new_local=new
   else
      newline=targetline  ! if no changes are made return original string on error
      call journal('sc','*replace* must specify OLD and NEW or CMD')
      return
   endif
   if(present(ignorecase))then
      ignorecase_local=ignorecase
   else
      ignorecase_local=.false.
   endif
   if(present(occurrence))then
      range_local(1)=abs(occurrence)
   else
      range_local(1)=1
   endif
   if(present(repeat))then
      range_local(2)=range_local(1)+repeat-1
   else
      range_local(2)=original_input_length
   endif
   if(ignorecase_local)then
      targetline_for_comparison=lower(targetline)
      old_local_for_comparison=lower(old_local)
   else
      targetline_for_comparison=targetline
      old_local_for_comparison=old_local
   endif
   if(present(occurrence))then
      if(occurrence < 0)then
         flip=.true.
         targetline_for_comparison=reverse(targetline_for_comparison)
         targetline_local=reverse(targetline)
         old_local_for_comparison=reverse(old_local_for_comparison)
         old_local=reverse(old_local)
         new_local=reverse(new_local)
      else
         targetline_local=targetline
      endif
   else
      targetline_local=targetline
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   len_old=len(old_local)                              ! length of old substring to be replaced
   len_new=len(new_local)                              ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(len_new > 0)then
         newline=new_local(:len_new)//targetline_local(left_margin:original_input_length)
      else
         newline=targetline_local(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      if(flip) newline=reverse(newline)
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=left_margin                                    ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
                                                       ! try finding start of OLD in remaining part of input in change window
      ind=index(targetline_for_comparison(ic:),old_local_for_comparison(:len_old))+ic-1
      if(ind == ic-1.or.ind > right_margin)then       ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:ichr-1)//targetline_local(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(icount >= range_local(1).and.icount <= range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new /= 0)then                                          ! put in new string
            newline=newline(:ichr-1)//new_local(:len_new)
            ichr=ichr+len_new
         endif
      else
         if(len_old /= 0)then                                          ! put in copy of old string
            newline=newline(:ichr-1)//old_local(:len_old)
            ichr=ichr+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline_local                         ! if no changes made output should be input
   case default
      if(ic <= len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:ichr-1)//targetline_local(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
   if(flip) newline=reverse(newline)
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes
!!    one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!
!!##DESCRIPTION
!!    Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_substitute
!!    use M_strings, only : substitute
!!    implicit none
!!    ! must be long enough to hold changed line
!!    character(len=80) :: targetline
!!
!!    targetline='this is the input string'
!!    write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!    ! changes the input to 'THis is THe input string'
!!    call substitute(targetline,'th','TH')
!!    write(*,*)'th => TH    : '//trim(targetline)
!!
!!    ! a null old substring means "at beginning of line"
!!    ! changes the input to 'BEFORE:this is the input string'
!!    call substitute(targetline,'','BEFORE:')
!!    write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!    ! a null new string deletes occurrences of the old substring
!!    ! changes the input to 'ths s the nput strng'
!!    call substitute(targetline,'i','')
!!    write(*,*)'i => ""     : '//trim(targetline)
!!
!!    end program demo_substitute
!!
!!   Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental subroutine substitute(targetline,old,new,ierr,start,end)

! ident_13="@(#) M_strings substitute(3f) Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(inout) :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option ! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichr=len_new + original_input_length
      if(ichr > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichr=il                                            ! place to put characters into output string
   ic=il                                              ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1   ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                    ! no more changes left to make
      endif
      ier1=ier1+1                                     ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                  ! find length of character range to copy as-is from input to output
         if(ichr-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichr+ladd > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    change(3f) - [M_strings:EDITING] change old string to new string with
!!    a directive like a line editor
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine change(target_string,cmd,ierr)
!!
!!     character(len=*),intent(inout) :: target_string
!!     character(len=*),intent(in)    :: cmd
!!     integer                        :: ierr
!!
!!##DESCRIPTION
!!    change an old substring into a new substring in a character variable
!!    like a line editor. Primarily used to create interactive utilities
!!    such as input history editors for interactive line-mode programs. The
!!    output string is assumed long enough to accommodate the change.
!!    a directive resembles a line editor directive of the form
!!
!!       C/old_string/new_string/
!!
!!    where / may be any character which is not included in old_string
!!    or new_string.
!!
!!    a null old_string implies "beginning of string".
!!
!!##OPTIONS
!!    target_string  line to be changed
!!    cmd            contains instructions to change the string
!!    ierr           error code.
!!
!!       o =-1 bad directive
!!       o =0 no changes made
!!       o >0 count of changes made
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_change
!!
!!     use M_strings, only : change
!!     implicit none
!!     character(len=132) :: line='This is a test string to change'
!!     integer            :: ierr
!!        write(*,*)trim(line)
!!        ! change miniscule a to uppercase A
!!        call change(line,'c/a/A/',ierr)
!!        write(*,*)trim(line)
!!        ! put string at beginning of line
!!        call change(line,'c//prefix: /',ierr)
!!        write(*,*)trim(line)
!!        ! remove blanks
!!        call change(line,'c/ //',ierr)
!!        write(*,*)trim(line)
!!    end program demo_change
!!
!!   Expected output
!!
!!     This is a test string to change
!!     This is A test string to chAnge
!!     prefix: This is A test string to chAnge
!!     prefix:ThisisAteststringtochAnge
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine change(target_string,cmd,ierr)
! Change a string assumed long enough to accommodate the change, with a directive that resembles a line editor directive of the form
!    C/old_string/new_string/
! where / may be any character which is not included in old_string or new_string.
! a null old_string implies "beginning of string"
!===================================================================================================================================

! ident_14="@(#) M_strings change(3f) change a character string like a line editor"

character(len=*),intent(inout)   :: target_string          ! line to be changed
character(len=*),intent(in)      :: cmd                    ! contains the instructions changing the string
character(len=1)                 :: delimiters
integer                          :: ierr                   ! error code. ier=-1 bad directive;=0 no changes made;>0 ier changes made
integer                          :: itoken
integer,parameter                :: id=2                   ! expected location of delimiter
character(len=:),allocatable     :: old,new                ! scratch string buffers
logical                          :: ifok
integer                          :: lmax                   ! length of target string
integer                          :: start_token,end_token
!-----------------------------------------------------------------------------------------------------------------------------------
   lmax=len_trim(cmd)                                                          ! significant length of change directive
   if(lmax >= 4)then                         ! strtok ignores blank tokens so look for special case where first token is really null
      delimiters=cmd(id:id)                                                    ! find delimiter in expected location
      itoken=0                                                                 ! initialize strtok(3f) procedure

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then        ! find OLD string
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else                                                                     ! normal case
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)         ! find NEW string
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))       ! if missing ending delimiter
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))    ! change old substrings to new substrings
   else                                                                        ! command was two or less characters
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine change
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     strtok(3f) - [M_strings:TOKENS] Tokenize a string
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!  function strtok(source_string,itoken,token_start,token_end,delimiters)
!!  result(strtok_status)
!!
!!   ! returned value
!!   logical                      :: strtok_status
!!   ! string to tokenize
!!   character(len=*),intent(in)  :: source_string
!!   ! token count since started
!!   integer,intent(inout)        :: itoken
!!   ! beginning of token
!!   integer,intent(out)          :: token_start
!!   ! end of token
!!   integer,intent(inout)        :: token_end
!!   ! list of separator characters
!!   character(len=*),intent(in)  :: delimiters
!!
!!##DESCRIPTION
!!     The STRTOK(3f) function is used to isolate sequential tokens in a
!!     string, SOURCE_STRING. These tokens are delimited in the string by
!!     at least one of the characters in DELIMITERS. The first time that
!!     STRTOK(3f) is called, ITOKEN should be specified as zero. Subsequent
!!     calls, wishing to obtain further tokens from the same string,
!!     should pass back in TOKEN_END  and ITOKEN until the function result
!!     returns .false.
!!
!!     This routine assumes no other calls are made to it using any other
!!     input string while it is processing an input line.
!!
!!##OPTIONS
!!     source_string  input string to parse
!!     itoken         token count should be set to zero for a new string
!!     delimiters     characters used to determine the end of tokens
!!
!!##RETURNS
!!     token_start    beginning position in SOURCE_STRING where token was found
!!     token_end      ending position in SOURCE_STRING where token was found
!!     strtok_status
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_strtok
!!     use M_strings, only : strtok
!!     implicit none
!!     character(len=264)          :: inline
!!     character(len=*),parameter  :: delimiters=' ;,'
!!     integer                     :: iostat, itoken, ibegin, iend
!!        do ! read lines from stdin until end-of-file or error
!!           read (unit=*,fmt="(a)",iostat=iostat) inline
!!           if(iostat /= 0)stop
!!           ! must set ITOKEN=0 before looping on strtok(3f)
!!           ! on a new string.
!!           itoken=0
!!           do while &
!!           &( strtok(inline,itoken,ibegin,iend,delimiters) )
!!              print *, itoken,&
!!              & 'TOKEN=['//(inline(ibegin:iend))//']',ibegin,iend
!!           enddo
!!        enddo
!!     end program demo_strtok
!!
!!     sample input file
!!
!!      this is a test of strtok; A:B :;,C;;
!!
!!     sample output file
!!
!!     1  TOKEN=[this]    2   5
!!     2  TOKEN=[is]      7   8
!!     3  TOKEN=[a]       10  10
!!     4  TOKEN=[test]    12  15
!!     5  TOKEN=[of]      17  18
!!     6  TOKEN=[strtok]  20  25
!!     7  TOKEN=[A:B]     28  30
!!     8  TOKEN=[:]       32  32
!!     9  TOKEN=[C]       35  35
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

! ident_15="@(#) M_strings strtok(3f) Tokenize a string"

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer,save                 :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken <= 0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start > isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start  >  isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    modif(3f) - [M_strings:EDITING] emulate the MODIFY command from the
!!    line editor XEDIT
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine modif(cline,cmod)
!!
!!     character(len=*) :: cline ! input string to change
!!     ! directive provides directions on changing string
!!     character(len=*) :: cmod
!!
!!##DESCRIPTION
!!   MODIF(3f) Modifies the line currently pointed at using a directive
!!   that acts much like a line editor directive.
!!   Primarily used to create interactive utilities such as input history
!!   editors for interactive line-mode programs.
!!
!!   the modify directives are as follows-
!!
!!    DIRECTIVE EXPLANATION
!!
!!    ^STRING#   Causes the string of characters between the ^ and the
!!               next # to be inserted before the characters pointed to
!!               by the ^. an ^ or & within the string is treated as a
!!               regular character. If the closing # is not specified,
!!               MODIF(3f) inserts the remainder of the line as if a # was
!!               specified after the last nonblank character.
!!
!!               There are two exceptions. the combination ^# causes a #
!!               to be inserted before the character pointed to by the
!!               ^, and an ^ as the last character of the directives
!!               causes a blank to be inserted.
!!
!!    #          (When not the first # after an ^) causes the character
!!               above it to be deleted.
!!
!!    &          Replaces the character above it with a space.
!!
!!    (SPACE)    A space below a character leaves it unchanged.
!!
!!    Any other character replaces the character above it.
!!
!!##EXAMPLES
!!
!!   Example input/output:
!!
!!    THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
!!    THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
!!    ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!!
!!   Sample program:
!!
!!    program demo_modif
!!    use M_strings, only : modif
!!    implicit none
!!    character(len=256)           :: line
!!    integer                      :: iostat
!!    integer                      :: count
!!    integer                      :: COMMAND_LINE_LENGTH
!!    character(len=:),allocatable :: COMMAND_LINE
!!       ! get command name length
!!       call get_command_argument(0,length=count)
!!       ! get command line length
!!       call get_command(length=COMMAND_LINE_LENGTH)
!!       ! allocate string big enough to hold command line
!!       allocate(character(len=COMMAND_LINE_LENGTH+200) :: COMMAND_LINE)
!!       ! get command line as a string
!!       call get_command(command=COMMAND_LINE)
!!       ! trim leading spaces just in case
!!       COMMAND_LINE=adjustl(COMMAND_LINE)
!!       ! remove command name
!!       COMMAND_LINE=adjustl(COMMAND_LINE(COUNT+2:))
!!       INFINITE: do
!!          read(*,'(a)',iostat=iostat)line
!!          if(iostat /= 0)exit
!!          call modif(line,COMMAND_LINE)
!!          write(*,'(a)')trim(line)
!!       enddo INFINITE
!!    end program demo_modif
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine modif(cline,mod)

!$@(#) M_strings::modif(3f): Emulate the MODIFY command from the line editor XEDIT

!
! MODIF
! =====
! ACTION- Modifies the line currently pointed at. The input string CLINE
!         is assumed to be long enough to accommodate the changes.
!         The MODIFY directives are as follows-
!
!   DIRECTIVE                       EXPLANATION
!   ---------                       ------------
!   ^STRING#   Causes the string of characters between the ^ and the
!              next  # to be inserted before the characters pointed to
!              by the ^. An ^ or & within the string is treated as a
!              regular character. If the closing # is not specified,
!              MODIF(3f) inserts the remainder of the line as if a # was
!              specified after the last nonblank character.
!
!              There are two exceptions. The combination ^# causes a #
!              to be inserted before the character pointed to by the
!              ^,  and an ^ as the last character of the directives
!              causes a blank to be inserted.
!
!   #          (When not the first # after an ^) causes the character
!              above it to be deleted.
!
!   &          Replaces the character above it with a space.
!
!   (SPACE)    A Space below a character leaves it unchanged.
!
!   Any other character replaces the character above it.
!
! EXAMPLE-
! THE INPUT LINE........ 10 THIS STRING  TO BE MORTIFD
! THE DIRECTIVES LINE...        ^ IS THE#        D#  ^IE
! ALTERED INPUT LINE.... 10 THIS IS THE STRING  TO BE MODIFIED
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
character(len=*)            :: cline           !STRING TO BE MODIFIED
character(len=*),intent(in) :: mod             !STRING TO DIRECT MODIFICATION
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'         !ASSIGN DEFAULT EDIT CHARACTERS
integer                     :: maxscra         !LENGTH OF SCRATCH BUFFER
character(len=len(cline))   :: dum2            !SCRATCH CHARACTER BUFFER
logical                     :: linsrt          !FLAG FOR INSERTING DATA ON LINE
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(mod)
   lmax=min0(len(cline),maxscra)               !DETERMINE MAXIMUM LINE LENGTH
   lmx1=lmax-1                                 !MAX LINE LENGTH -1
   dum2=' '                                    !INITIALIZE NEW LINE
   linsrt=.false.                              !INITIALIZE INSERT MODE
   iend=len_trim(cmod)                         !DETERMINE END OF MODS
   i=0                                         !CHAR COUNTER FOR MOD LINE CMOD
   ic=0                                        !CHAR COUNTER FOR CURRENT LINE CLINE
   ichr=0                                      !CHAR COUNTER NEW LINE DUM2
   INFINITE: do
      if(i >= lmax)exit INFINITE               !CHECK FOR END OF LINE REACHED
      i=i+1                                    !NEXT CHAR IN MOD LINE
      if(ichr > lmx1)exit INFINITE             !IF TOO MANY CHARS IN NEW LINE
      if(linsrt) then                          !IF INSERTING NEW CHARS
         if(i > iend) cmod(i:i)=c(1:1)         !FORCE END OF INSERT MODE
         if(cmod(i:i) == c(1:1))then           !IF END OF INSERT MODE
            linsrt=.false.                     !RESET INSERT MODE FLAG
            if(ic+1 == i)then                  !NULL INSERT STRING
               ichr=ichr+1                     !INCREMENT COUNTER FOR NEW LINE
               dum2(ichr:ichr)=c(1:1)          !INSERT INSERT MODE TERMINATOR
            endif
            do j=ic,i                          !LOOP OF NUMBER OF CHARS INSERTED
               ichr=ichr+1                     !INCREMENT COUNTER FOR NEW LINE
               if(ichr > lmax)exit INFINITE    !IF AT BUFFER LIMIT, QUIT
               dum2(ichr:ichr)=cline(j:j)      !APPEND CHARS FROM ORIG LINE
            enddo                              !...WHICH ALIGN WITH INSERTED CHARS
            ic=i                               !RESET CHAR COUNT TO END OF INSERT
            cycle INFINITE                     !CHECK NEW LINE LENGTH AND CYCLE
         endif                                 !END OF TERMINATED INSERT LOGIC
         ichr=ichr+1                           !INCREMENT NEW LINE COUNT
         dum2(ichr:ichr)=cmod(i:i)             !SET NEWLINE CHAR TO INSERTED CHAR
      else                                     !IF NOT INSERTING CHARACTERS
         ic=ic+1                               !INCREMENT ORIGINAL LINE COUNTER
         if(cmod(i:i) == c(1:1))cycle INFINITE !IF DELETE CHAR. NO COPY AND CYCLE
         if(cmod(i:i) == c(3:3))then           !IF BEGIN INSERT MODE
            linsrt=.true.                      !SET INSERT FLAG TRUE
            cycle INFINITE                     !CHECK LINE LENGTH AND CONTINUE
         endif                                 !IF NOT BEGINNING INSERT MODE
         ichr=ichr+1                           !INCREMENT NEW LINE COUNTER
         if(cmod(i:i) == c(2:2))then           !IF REPLACE WITH BLANK
            dum2(ichr:ichr)=' '                !SET NEWLINE CHAR TO BLANK
            cycle INFINITE                     !CHECK LINE LENGTH AND CYCLE
         endif                                 !IF NOT REPLACE WITH BLANK
         if(cmod(i:i) == ' ')then              !IF BLANK, KEEP ORIGINAL CHARACTER
            dum2(ichr:ichr)=cline(ic:ic)       !SET NEW CHAR TO ORIGINAL CHAR
         else                                  !IF NOT KEEPING OLD CHAR
            dum2(ichr:ichr)=cmod(i:i)          !REPLACE ORIGINAL CHAR WITH NEW
         endif                                 !END CHAR KEEP OR REPLACE
      endif                                    !END INSERT OR NO-INSERT
   enddo INFINITE
                                               !AND CYCLE IF OK
   cline=dum2                                  !SET ORIGINAL CHARS TO NEW CHARS
end subroutine modif                           !RETURN
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      len_white(3f) - [M_strings:LENGTH] get length of string trimmed
!!      of whitespace.
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental integer function len_white(string)
!!
!!     character(len=*) :: string
!!
!!##DESCRIPTION
!!      len_white(3f) returns the position of the last character in
!!      string that is not a whitespace character. The Fortran90 intrinsic
!!      LEN_TRIM(3) should be used when trailing whitespace can be assumed
!!      to always be spaces.
!!
!!      This procedure was heavily used in the past because ANSI FORTRAN
!!      77 character objects are fixed length and blank padded and the
!!      LEN_TRIM(3) intrinsic did not exist. It should now be used only when
!!      whitespace characters other than blanks are likely.
!!
!!##OPTIONS
!!      string     input string whose trimmed length is being calculated
!!                 ignoring all trailing whitespace characters.
!!##RETURNS
!!      len_white  the number of characters in the trimmed string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_len_white
!!
!!      use M_strings, only : len_white
!!      implicit none
!!      character(len=80) :: s
!!      integer           :: lgth, lastnb
!!      intrinsic len
!!
!!      s=' ABCDEFG abcdefg '
!!      lgth = len(s)
!!      lastnb = len_white(s)
!!
!!      write(*,*) 'total length of variable is ',lgth
!!      write(*,*) 'trimmed length of variable is ',lastnb
!!      write(*,*) 'trimmed string=[',s(:lastnb),']'
!!
!!     end program demo_len_white
!!
!!   Results:
!!
!!     total length of variable is           80
!!     trimmed length of variable is           16
!!     trimmed string=[ ABCDEFG abcdefg]
!!
!!##NOTES
!!
!! o len_white
!!
!!      is a resource-intensive routine. Once the end of
!!      the string is found, it is probably best to keep track of it in
!!      order to avoid repeated calls to len_white. Because they
!!      might be more efficient, consider looking for vendor-supplied or
!!      system-optimized equivalents. For example:
!!
!!         o lnblnk - Solaris f77
!!         o len_trim - FORTRAN 90
!!
!! o Some compilers seem to have trouble passing a string of variable
!!   length properly. To be safe, use something like this:
!!
!!       subroutine message(s)
!!        character(len=*) :: s ! s is of variable length
!!           lgth=len(s)        ! get total length of variable
!!           ! explicitly specify a substring instead of just variable name
!!           lastnb = len_white(s(:lgth))
!!           write(*,*)'error:[',s(:lastnb),']'
!!       end subroutine messages
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental integer function len_white(string)
!  DEPRECATED. Use len_trim(3f),trim(3f) unless you might have trailing nulls (common when interacting with C procedures)"
!  John S. Urban, 1984, 1997-12-31
!  Note that if the string is blank, a length of 0 is returned; which is not a legal string length in Fortran77.
!  this routine used to return one instead of zero.
!   - mod 1:     1994
!                added null (char(0)) because HP and some Suns not padding
!                strings with blank, but with null characters; 1994 JSU
!   - mod 2:     1999
!                update syntax with INTENT(), ENDDO, no RETURN
!                still need instead of LEN_TRIM(3) because some systems still pad CHARACTER with NULL
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_16="@(#) M_strings len_white(3f) return position of last non-blank/non-null character in string"

character(len=*),intent(in):: string ! input string to determine length of
integer                    :: i10
intrinsic len
   len_white=0
   do i10=len(string),1,-1
      select case(string(i10:i10))
      case(' ')                 ! space(32)
      case(char(0))             ! null(0)
      case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13)
      case default
         len_white=i10
         exit
      end select
   enddo
end function len_white
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    crop(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!               and control characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function crop(strin) result (strout)
!!
!!     character(len=*),intent(in)  :: strin
!!     character(len=:),allocatable :: strout
!!
!!##DESCRIPTION
!!    Tabs are expanded assuming a stop every eight characters. All other
!!    control characters throughout the string are replaced with spaces
!!    and leading and trailing spaces are trimmed from the resulting string.
!!
!!    This means trailing characters like linefeed and carriage returns are
!!    removed. If this is not desired, see clip(3f).
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing space and control
!!            characters from
!!
!!##RETURNS
!!    strout  cropped version of input string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_crop
!!    use M_strings, only: crop
!!    implicit none
!!    character(len=20) :: untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'cropped string=[',crop(untrimmed),']'
!!    end program demo_crop
!!
!!   Results:
!!
!!     >  untrimmed string=[   ABCDEFG abcdefg  ]
!!     >  cropped string=[ABCDEFG abcdefg]
!!
!!##SEE ALSO
!!    clip(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function crop(strin) result (strout)

! ident_17="@(#) M_strings crop(3f) replace control characters with whitespace and trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(noesc(dilate(strin))))
end function crop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    clip(3f) - [M_strings:WHITESPACE] trim leading and trailing blanks
!!    or set of characters from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function clip(strin,set) result (strout)
!!
!!     character(len=*),intent(in)          :: strin
!!     character(len=*),intent(in),optional :: set
!!     character(len=:),allocatable         :: strout
!!
!!##DESCRIPTION
!!    leading and trailing spaces or set of characters are trimmed from
!!    the input string.
!!
!!##OPTIONS
!!    strin   input string to trim leading and trailing characters from
!!    set     set of characters to trim. Defaults to a space.
!!
!!##RETURNS
!!    strout  clipped version of input string
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_clip
!!    use M_strings, only: clip
!!    implicit none
!!    character(len=20) ::  untrimmed = '   ABCDEFG abcdefg  '
!!       write(*,*) 'untrimmed string=[',untrimmed,']'
!!       write(*,*) 'clipped string=[',clip(untrimmed),']'
!!       ! which is equivalent to
!!       write(*,*) 'clipped string=[',trim(adjustl(untrimmed)),']'
!!       write(*,*)'non-space:'
!!       write(*,*) '['//clip('----single-character----',set='-')//']'
!!       write(*,*) '['//clip('  ... . .multi-character . ...',set='. ')//']'
!!    end program demo_clip
!!
!!   Results:
!!
!!       >  untrimmed string=[   ABCDEFG abcdefg  ]
!!       >  clipped string=[ABCDEFG abcdefg]
!!       >  clipped string=[ABCDEFG abcdefg]
!!       >  non-space:
!!       >  [single-character]
!!       >  [multi-character]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function clip(string,set) result(lopped)

! ident_18="@(#) M_strings clip(3f) trim leading and trailings spaces or set of characters from string"

logical,parameter                     :: T=.true.,F=.false.
character(len=*),intent(in)           :: string
character(len=*),intent(in),optional  :: set
character(len=:),allocatable          :: lopped
integer                               :: ends(2)

   ! find first and last non-blank character positions, or the same for specified character set
   if(present(set))then
      ends=verify(string, set=set, back=[F,T]) ! Position of a character in a string that does not appear in given set
   else
      ends=verify(string, set=' ', back=[F,T])
   endif

   if(ends(1) == 0)then
      lopped=""
   else
      lopped=string(ends(1):ends(2))
   endif

end function clip
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    transliterate(3f) - [M_strings:EDITING] replace characters from old
!!                        set with new set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function transliterate(instr,old_set,new_set) result(outstr)
!!
!!     character(len=*),intent(in)  :: instr
!!     character(len=*),intent(in)  :: old_set
!!     character(len=*),intent(in)  :: new_set
!!     character(len=len(instr))    :: outstr
!!
!!##DESCRIPTION
!!    Translate, squeeze, and/or delete characters from the input string.
!!
!!##OPTIONS
!!    instr    input string to change
!!    old_set  list of letters to change in INSTR if found
!!
!!             Each character in the input string that matches a character
!!             in the old set is replaced.
!!
!!    new_set  list of letters to replace letters in OLD_SET with.
!!
!!             If the new_set is the empty set the matched characters
!!             are deleted.
!!
!!             If the new_set is shorter than the old set the last character
!!             in the new set is used to replace the remaining characters
!!             in the new set.
!!
!!##RETURNS
!!    outstr   instr with substitutions applied
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_transliterate
!!
!!     use M_strings, only : transliterate
!!     implicit none
!!     character(len=80)   :: STRING
!!
!!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
!!     write(*,'(a)') STRING
!!
!!     ! convert a string to uppercase:
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
!!
!!     ! change all miniscule letters to a colon (":"):
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz',':')
!!
!!     ! delete all miniscule letters
!!     write(*,*) TRANSLITERATE(STRING, &
!!     & 'abcdefghijklmnopqrstuvwxyz','')
!!
!!    end program demo_transliterate
!!
!!    Expected output
!!
!!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
!!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
!!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
!!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
PURE FUNCTION transliterate(instr,old_set,new_set) RESULT(outstr)

! ident_19="@(#) M_strings transliterate(3f) replace characters from old set with new set"

!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=*),INTENT(IN)  :: instr                  ! input string to change
CHARACTER(LEN=*),intent(in)  :: old_set                ! set of characters to replace
CHARACTER(LEN=*),intent(in)  :: new_set                ! new characters to replace old characters
!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=LEN(instr))    :: outstr                 ! output string to generate
!-----------------------------------------------------------------------------------------------------------------------------------
INTEGER                      :: i10                    ! loop counter for stepping thru string
INTEGER                      :: ii,jj
!-----------------------------------------------------------------------------------------------------------------------------------
   jj=LEN(new_set)
   IF(jj /= 0)THEN
      outstr=instr                                     ! initially assume output string equals input string
      stepthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))              ! see if current character is in old_set
         IF (ii /= 0)THEN
            if(ii <= jj)then                           ! use corresponding character in new_set
               outstr(i10:i10) = new_set(ii:ii)
            else
               outstr(i10:i10) = new_set(jj:jj)        ! new_set not as long as old_set; use last character in new_set
            endif
         ENDIF
      ENDDO stepthru
   else                                                ! new_set is null string so delete characters in old_set
      outstr=' '
      hopthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))              ! see if current character is in old_set
         IF (ii == 0)THEN                              ! only keep characters not in old_set
            jj=jj+1
            outstr(jj:jj) = instr(i10:i10)
         ENDIF
      ENDDO hopthru
   endif
END FUNCTION transliterate
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    rotate13(3f) - [M_strings:ENCODE] apply trivial ROT13 encryption to a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    rotate13(input) result(output)
!!
!!     character(len=*),intent(in) :: input
!!     character(len=len(input))   :: output
!!
!!##DESCRIPTION
!!    ROT13 ("rotate by 13 places", sometimes hyphenated ROT-13) is a simple
!!    letter substitution cipher that replaces a letter with the 13th letter
!!    after it in the alphabet; wrapping around if necessary.
!!
!!    The transformation can be done using a lookup table, such as the
!!    following:
!!
!!       Input  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
!!       Output NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm
!!
!!    ROT13 is used in online forums as a means of hiding spoilers,
!!    punchlines, puzzle solutions, and offensive materials from the casual
!!    glance. ROT13 has inspired a variety of letter and word games on-line,
!!    and is frequently mentioned in newsgroup conversations.
!!
!!    The algorithm provides virtually no cryptographic security, and is
!!    often cited as a canonical example of weak encryption.
!!
!!    ROT13 is a special case of the Caesar cipher which was developed in
!!    ancient Rome.
!!
!!    ALGORITHM
!!
!!    Applying ROT13 to a piece of text merely requires examining its
!!    alphabetic characters and replacing each one by the letter 13 places
!!    further along in the alphabet, wrapping back to the beginning if
!!    necessary. A becomes N, B becomes O, and so on up to M, which becomes
!!    Z, then the sequence continues at the beginning of the alphabet: N
!!    becomes A, O becomes B, and so on to Z, which becomes M. Only those
!!    letters which occur in the English alphabet are affected; numbers,
!!    symbols, whitespace, and all other characters are left unchanged.
!!
!!    SAME ALGORITHM FOR ENCODING AND DECODING
!!
!!    Because there are 26 letters in the English alphabet and 26 = 2 x 13,
!!    the ROT13 function is its own inverse: so the same action can be used
!!    for encoding and decoding. In other words, two successive applications
!!    of ROT13 restore the original text (in mathematics, this is sometimes
!!    called an involution; in cryptography, a reciprocal cipher).
!!
!!    TRIVIAL SECURITY
!!
!!    The use of a constant shift means that the encryption effectively
!!    has no key, and decryption requires no more knowledge than the fact
!!    that ROT13 is in use. Even without this knowledge, the algorithm is
!!    easily broken through frequency analysis.
!!
!!    In encrypted normal English-language text of any significant size,
!!    ROT13 is recognizable from some letter/word patterns. The words "n",
!!    "V" (capitalized only), and "gur" (ROT13 for "a", "I", and "the"),
!!    and words ending in "yl" ("ly") are examples.
!!
!!##REFERENCES
!!    Wikipedia, the free encyclopedia
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_rotate13
!!    use M_strings, only : rotate13
!!    implicit none
!!    character(len=256) :: line
!!    integer            :: iostat
!!    do
!!       read(*,'(a)',iostat=iostat)line
!!       if(iostat /= 0)exit
!!       write(*,'(a)')rotate13(line)
!!    enddo
!!    end program demo_rotate13
!!
!!  Sample usage:
!!
!!    demo_rotate13
!!    United we stand, divided we fall.
!!    Havgrq jr fgnaq, qvivqrq jr snyy.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rotate13 (input)

! ident_20="@(#) M_strings rotate13(3f) converts a character to its ROT13 equivalent which is a trivial encryption."

character(len=*),intent(in) :: input
character(len=len(input))   :: rotate13
integer                     :: itemp
integer                     :: i
   rotate13=' '
   do i=1,len_trim(input)
      itemp = iachar(input(i:i))
      select case(itemp)
       case(65:77,97:109)
         itemp = itemp + 13
       case(78:90,110:122)
         itemp = itemp - 13
      end select
      rotate13(i:i) = char ( itemp )
   enddo

end function rotate13
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    percent_encode(3f) - [M_strings:ENCODE] percent-encode strings and
!!    character arrays
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     function percent_encode(text)
!!
!!      character(len=1),intent(in)  :: text(:)
!!      character(len=;),allocatable :: percent_encode
!!
!!     or
!!
!!     function percent_encode(text)
!!
!!      character(len=*),intent(in)  :: text
!!      character(len=;),allocatable :: percent_encode
!!
!!##DESCRIPTION
!!
!!    This function percent-encodes ASCII strings or ASCII character arrays.
!!    "Reserved" characters are encoded.
!!
!!    URI containing spaces or most other non-alphanumeric characters must
!!    be encoded using percent encoding (aka. URL encoding).
!!
!!    The characters allowed in a URI are either reserved or unreserved
!!    (or a percent character as part of a percent-encoding). Reserved
!!    characters are those characters that sometimes have special meaning,
!!    while unreserved characters have no such meaning. Using percent-encoding,
!!    characters which otherwise would not be allowed are represented using
!!    allowed characters. The sets of reserved and unreserved characters and
!!    the circumstances under which certain reserved characters have special
!!    meaning have changed slightly with each revision of specifications that
!!    govern URIs and URI schemes.
!!
!!    According to RFC 3986, the characters in a URL have to be taken from
!!    a defined set of unreserved and reserved ASCII characters. Any other
!!    characters are not allowed in a URL.
!!
!!    The unreserved characters can be encoded, but should not be. The
!!    unreserved characters are:
!!
!!       > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!       > abcdefghijklmnopqrstuvwxyz
!!       > 0123456789-_.~
!!
!!    The reserved characters have to be encoded only under certain
!!    circumstances. The reserved characters are:
!!
!!       >  * ' ( ) ; : @ & = + $ , / ? % # [ ]
!!
!!##OPTIONS
!!     SOURCE_STRING   string or character array to encode
!!
!!##RETURNS
!!     percent_encode  a string holding a percent-encoded copy of the input
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_percent_encode
!!    use M_strings, only : percent_encode
!!    use, intrinsic :: iso_fortran_env, only : stdout=>output_unit
!!    implicit none
!!       write(*,*)percent_encode('[this is a string]')
!!    end program demo_percent_encode
!!
!! Results:
!!
!!  >  %5Bthis%20is%20a%20string%5D
!!
!!##AUTHOR
!!    John S. Urban
function percent_encode_string(text)
character(len=*),intent(in)  :: text
character(len=:),allocatable :: percent_encode_string
   percent_encode_string=percent_encode_characters(switch(text))
end function percent_encode_string
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_encode_characters(text)
character(len=1),intent(in)          :: text(:)
character(len=:),allocatable         :: percent_encode_characters
integer                              :: i,pos
allocate(character(len=3*size(text)) :: percent_encode_characters )
percent_encode_characters(:)=repeat(' ',len(percent_encode_characters))
   pos=1
   do i=1,size(text)
      select case(text(i))
      case('a':'z','A':'Z','0':'9','-','_','.','~')
         percent_encode_characters(pos:pos)=text(i)
         pos=pos+1
      case default
         write(percent_encode_characters(pos:pos+2),'(a1,z2.2)')'%',text(i)
         pos=pos+3
      end select
   enddo
   percent_encode_characters=trim(percent_encode_characters)
end function percent_encode_characters
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    percent_decode(3f) - [M_strings:ENCODE] percent-decode strings and
!!    character arrays
!!    (LICENSE:ISC)
!!
!!##SYNOPSIS
!!
!!
!!     function percent_decode(text,exit_code)
!!
!!      character(len=1),intent(in)  :: text(:)
!!      integer,optional,intent(out) :: exit_code
!!      character(len=:),allocatable :: percent_decode
!!
!!     or
!!
!!     function percent_decode(text,exit_code)
!!
!!      character(len=*),intent(in)  :: text
!!      integer,optional,intent(out) :: exit_code
!!      character(len=:),allocatable :: percent_decode
!!
!!##DESCRIPTION
!!
!!    percent_decode(3f) percent-decodes percent-encoded strings or character
!!    arrays.
!!
!!    URI containing spaces or most other non-alphanumeric characters must
!!    be encoded using percent encoding (aka. URL encoding). This procedure
!!    unwinds the encryption.
!!
!!    The characters allowed in a URI are either reserved or unreserved
!!    (or a percent character as part of a percent-encoding). Reserved
!!    characters are those characters that sometimes have special meaning,
!!    while unreserved characters have no such meaning. Using percent-encoding,
!!    characters which otherwise would not be allowed are represented using
!!    allowed characters. The sets of reserved and unreserved characters and
!!    the circumstances under which certain reserved characters have special
!!    meaning have changed slightly with each revision of specifications that
!!    govern URIs and URI schemes.
!!
!!    According to RFC 3986, the characters in a URL have to be taken from
!!    a defined set of unreserved and reserved ASCII characters. Any other
!!    characters are not allowed in a URL.
!!
!!    The unreserved characters can be encoded, but should not be. The
!!    unreserved characters are:
!!
!!       > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!       > abcdefghijklmnopqrstuvwxyz
!!       > 0123456789-_.~
!!
!!    The reserved characters have to be encoded only under certain
!!    circumstances. The reserved characters are:
!!
!!       >  * ' ( ) ; : @ & = + $ , / ? % # [ ]
!!
!!##OPTIONS
!!     SOURCE_STRING   string or character array to decode
!!     EXIT_CODE       non-zero if decoding failed
!!
!!##RETURNS
!!     percent_decode  a string holding a percent-decoded copy of the input
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_percent_decode
!!       use M_strings, only : percent_encode, percent_decode
!!       implicit none
!!       character(len=:),allocatable :: input,output
!!       character(len=*),parameter   :: see='(g0,*("""",g0,"""":))'
!!       character(len=*),parameter   :: expected='&
!!       &%01%02%03%04%05%06%07%08%09%0A%0B%0C%0D%0E%0F%10%11%12%13%14%15%&
!!       &16%17%18%19%1A%1B%1C%1D%1E%1F%20%21%22%23%24%25%26%27%28%29%2A%2&
!!       &B%2C-.%2F0123456789%3A%3B%3C%3D%3E%3F%40ABCDEFGHIJKLMNOPQRSTUVWX&
!!       &YZ%5B%5C%5D%5E_%60abcdefghijklmnopqrstuvwxyz%7B%7C%7D~%7F%80%81%&
!!       &82%83%84%85%86%87%88%89%8A%8B%8C%8D%8E%8F%90%91%92%93%94%95%96%9&
!!       &7%98%99%9A%9B%9C%9D%9E%9F%A0%A1%A2%A3%A4%A5%A6%A7%A8%A9%AA%AB%AC&
!!       &%AD%AE%AF%B0%B1%B2%B3%B4%B5%B6%B7%B8%B9%BA%BB%BC%BD%BE%BF%C0%C1%&
!!       &C2%C3%C4%C5%C6%C7%C8%C9%CA%CB%CC%CD%CE%CF%D0%D1%D2%D3%D4%D5%D6%D&
!!       &7%D8%D9%DA%DB%DC%DD%DE%DF%E0%E1%E2%E3%E4%E5%E6%E7%E8%E9%EA%EB%EC&
!!       &%ED%EE%EF%F0%F1%F2%F3%F4%F5%F6%F7%F8%F9%FA%FB%FC%FD%FE%FF%20'
!!       integer                      :: j
!!          input='[this is a string]'
!!          write(*,see)'INPUT=',input
!!          output=percent_encode(input)
!!          write(*,see)'ENCODED=',output
!!          output=percent_decode(output)
!!          write(*,see)'DECODED=',output
!!          input=repeat(' ',256)
!!          do j=0,255
!!                input(j:j)=char(j)
!!          enddo
!!          output=percent_encode(input)
!!          write(*,*)'ENCODING PASSED:',output==expected
!!          output=percent_decode(output)
!!          write(*,*)'DECODING PASSED:',input == output
!!       end program demo_percent_decode
!!
!! Results:
!!
!!     > INPUT="[this is a string]"
!!     > ENCODED="%5Bthis%20is%20a%20string%5D"
!!     > DECODED="[this is a string]"
!!     >  ENCODING PASSED: T
!!     >  DECODING PASSED: T
!!
!!##AUTHOR
!!    o based on dm_cgi_encode.f90, Copyright (c) 2023, Philipp Engel
!!    o Modified to be more aligned with percent_encode(3f), John S. Urban, 2024
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_decode_characters(text,exit_code)
character(len=1),intent(in)  :: text(:)
integer,intent(out),optional :: exit_code
character(len=:),allocatable :: percent_decode_characters
   percent_decode_characters=percent_decode_string(switch(text),exit_code)
end function percent_decode_characters
!-----------------------------------------------------------------------------------------------------------------------------------
function percent_decode_string(input, exit_code) result(output)
!! Unwinds percent-encoding in given input string.
!
! based on dm_cgi_encode.f90
! Copyright (c) 2023, Philipp Engel
! modified 2024-06-22, JSU

! Original Copyright:
! Permission to use, copy, modify, and/or distribute this software for any
! purpose with or without fee is hereby granted, provided that the above
! copyright notice and this permission notice appear in all copies.
!
! THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
! WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
! MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
! ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
! WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
! ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
! OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
!
character(len=*), intent(in)   :: input  !! Encoded input string.
character(len=:), allocatable  :: output !! Decoded output string.
integer,intent(out),optional   :: exit_code
character(len=2)  :: hex
integer           :: input_col, output_col, hex_chars, input_len, output_len
integer           :: iostat
integer,parameter :: ERROR_BOUNDS=1, ERROR_NONE=0
   if(present(exit_code))then
      exit_code = ERROR_BOUNDS ! initially assume an error has occurred if return
   endif
   input_len = len_trim(input)
   output=repeat(' ',len(input)) ! output should be at most length of input
   output_len = len(output)
   if (output_len < input_len) return ! should not occur in this version
   input_col = 1
   output_col = 1
   do
      if (input_col > input_len) exit
      if (output_col > output_len) return
      CONVERT: select case (input(input_col:input_col))
      case ('%')
         if (input_col + 2 > input_len) exit CONVERT ! ignoring, which is probably not right
         hex = input(input_col + 1:input_col + 2)
         read (hex, '(z2)', iostat=iostat) hex_chars
         if (iostat == 0) then
            output(output_col:output_col) = achar(hex_chars)   ! Bytes are in hex.
            input_col = input_col + 2
         else
            output(output_col:output_col) = input(input_col:input_col) ! Bytes are not in hex.
         endif
      case ('+')
         output(output_col:output_col) = ' '
      case default
         output(output_col:output_col) = input(input_col:input_col)
      end select CONVERT
      input_col = input_col + 1
      output_col = output_col + 1
   enddo
   output=output(:output_col-1)
   if(present(exit_code))then
      exit_code = ERROR_NONE
   endif
end function percent_decode_string
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    join(3f) - [M_strings:EDITING] append CHARACTER variable array into
!!    a single CHARACTER variable with specified separator
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function join(str,sep,trm,left,right,start,end) result (string)
!!
!!     character(len=*),intent(in)          :: str(:)
!!     character(len=*),intent(in),optional :: sep
!!     logical,intent(in),optional          :: trm
!!     character(len=*),intent(in),optional :: right
!!     character(len=*),intent(in),optional :: left
!!     character(len=*),intent(in),optional :: start
!!     character(len=*),intent(in),optional :: end
!!     character(len=:),allocatable         :: string
!!
!!##DESCRIPTION
!!   JOIN(3f) appends the elements of a CHARACTER array into a single
!!   CHARACTER variable, with elements 1 to N joined from left to right.
!!   By default each element is trimmed of trailing spaces and the
!!   default separator is a null string.
!!
!!##OPTIONS
!!      STR(:)  array of CHARACTER variables to be joined
!!      SEP     separator string to place between each variable. defaults
!!              to a null string.
!!      LEFT    string to place at left of each element
!!      RIGHT   string to place at right of each element
!!      START   prefix string
!!      END     suffix string
!!      TRM     option to trim each element of STR of trailing
!!              spaces. Defaults to .TRUE.
!!
!!##RETURNS
!!      STRING  CHARACTER variable composed of all of the elements of STR()
!!              appended together with the optional separator SEP placed
!!              between the elements.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_join
!!     use M_strings, only: join
!!     implicit none
!!     character(len=*),parameter :: w='(/,*(g0,/,g0))'
!!     character(len=:),allocatable  :: s(:)
!!       s=[character(len=10) :: &
!!         & ' United', &
!!         & 'we', &
!!         & 'stand,', &
!!       & 'divided', &
!!         & 'we fall.']
!!       write(*,w) 'SIMPLE JOIN:                  ',&
!!          join(s)
!!       write(*,w) 'SIMPLE JOIN WITH SEPARATOR:   ',&
!!          join(s,sep=' ')
!!       write(*,w) 'CUSTOM SEPARATOR:             ',&
!!          join(s,sep='==>')
!!       write(*,w) 'LEFT AND RIGHT AND SEPARATOR: ',&
!!          join(s,sep=';',left='[',right=']')
!!       write(*,w) 'NO TRIMMING:                  ',&
!!          join(s,trm=.false.)
!!       write(*,w) 'LEFT AND RIGHT:               ',&
!!          join(s,left='[',right=']')
!!       write(*,w) 'START,END AND EVERYTHING:     ',&
!!          join(s,trm=.false.,sep=',',start='[',end=']',left='"',right='"')
!!       write(*,w) 'TABLE'
!!       call line()
!!       write(*,'(a)') join(s(1:3),trm=.false.,sep='|',start='|',end='|')
!!       write(*,'(a)') join([s(4:5),repeat(' ',len(s))],&
!!       & trm=.false.,sep='|',start='|',end='|')
!!       call line()
!!     contains
!!     subroutine line()
!!     integer :: i
!!       write(*,'(a)') join([(repeat('-',len(s)),i=1,3)],&
!!       & sep='#',start='#',end='#')
!!     end subroutine line
!!     end program demo_join
!!
!! Results:
!!
!!  >
!!  > SIMPLE JOIN:
!!  >  Unitedwestand,dividedwe fall.
!!  >
!!  > SIMPLE JOIN WITH SEPARATOR:
!!  >  United we stand, divided we fall.
!!  >
!!  > CUSTOM SEPARATOR:
!!  >  United==>we==>stand,==>divided==>we fall.
!!  >
!!  > LEFT AND RIGHT AND SEPARATOR:
!!  > [ United];[we];[stand,];[divided];[we fall.]
!!  >
!!  > NO TRIMMING:
!!  >  United   we        stand,    divided   we fall.
!!  >
!!  > LEFT AND RIGHT:
!!  > [ United][we][stand,][divided][we fall.]
!!  >
!!  > START,END AND EVERYTHING:
!!  > [" United   ","we        ","stand,    ","divided   ","we fall.  "]
!!  >
!!  > TABLE
!!  >
!!  > #----------#----------#----------#
!!  > | United   |we        |stand,    |
!!  > |divided   |we fall.  |          |
!!  > #----------#----------#----------#
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function join(str,sep,trm,left,right,start,end) result (string)

! ident_21="@(#) M_strings join(3f) merge string array into a single CHARACTER value adding specified separators caps prefix and suffix"

character(len=*),intent(in)          :: str(:)
character(len=*),intent(in),optional :: sep, right, left, start, end
logical,intent(in),optional          :: trm
character(len=:),allocatable         :: sep_local, left_local, right_local
character(len=:),allocatable         :: string
logical                              :: trm_local
integer                              :: i
   if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif
   if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif
   if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif
   if(present(right))then ; right_local=right ; else ; right_local=''   ; endif
   string=''
   if(size(str) == 0)then
      string=string//left_local//right_local
   else
      do i = 1,size(str)-1
         if(trm_local)then
            string=string//left_local//trim(str(i))//right_local//sep_local
         else
            string=string//left_local//str(i)//right_local//sep_local
         endif
      enddo
      if(trm_local)then
         string=string//left_local//trim(str(i))//right_local
      else
         string=string//left_local//str(i)//right_local
      endif
   endif
   if(present(start))string=start//string
   if(present(end))string=string//end
end function join
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      reverse(3f) - [M_strings:EDITING] Return a string reversed
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function reverse(str) result (string)
!!
!!     character(*), intent(in) :: str
!!     character(len(str))      :: string
!!
!!##DESCRIPTION
!!      reverse(string) returns a copy of the input string with
!!      all characters reversed from right to left.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_reverse
!!       use M_strings, only: reverse
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          write(*,*)'REVERSE STRINGS:',reverse('Madam, I''m Adam')
!!          s='abcdefghijklmnopqrstuvwxyz'
!!          write(*,*) 'original input string is ....',s
!!          write(*,*) 'reversed output string is ...',reverse(s)
!!       end program demo_reverse
!!
!!  Results:
!!
!!      >  REVERSE STRINGS:madA m'I ,madaM
!!      >  original input string is ....abcdefghijklmnopqrstuvwxyz
!!      >  reversed output string is ...zyxwvutsrqponmlkjihgfedcba
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function reverse(string) result (rev)

! ident_22="@(#) M_strings reverse(3f) Return a string reversed"

character(len=*),intent(in)    :: string   ! string to reverse
character(len=len(string))     :: rev      ! return value (reversed string)
integer                        :: length
integer                        :: i
   length = len(string)

   do i = 1,length
      rev(i:i)=string(length-i+1:length-i+1)
   enddo
end function reverse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! lower_quoted(3f) - [M_strings:CASE] elemental function converts string to
!!                lowercase skipping strings quoted per Fortran syntax rules
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower_quoted(str) result (string)
!!
!!     character(*), intent(in)    :: str
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!    lower_quoted(string) returns a copy of the input string with all not-quoted
!!    characters converted to lowercase, assuming ASCII character sets
!!    are being used. The quoting rules are the same as for Fortran source.
!!    Either a single or double quote starts a quoted string, and a quote
!!    character of the same type is doubled when it appears internally in
!!    the quoted string. If a double quote quotes the string single quotes
!!    may appear in the quoted string as single characters, and vice-versa
!!    for single quotes.
!!
!!##OPTIONS
!!    str    string to convert to lowercase
!!
!!##RETURNS
!!    lower  copy of the input string with all unquoted characters converted
!!           to lowercase
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_lower_quoted
!!     use M_strings, only: lower_quoted
!!     implicit none
!!     character(len=:),allocatable  :: s
!!     s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with ""&
!!        & Quote" everything else'
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'lower-case output string is ...',lower_quoted(s)
!!        write(*,'(1x,a,*(a:,"+"))') 'lower_quoted(3f) is elemental ==>', &
!!        & lower_quoted(["abc","def","ghi"])
!!     end program demo_lower_quoted
!!
!! Results:
!!
!!  >  mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted" ...
!!     ... 'Single-Quoted' "with "" Quote" everything else
!!  >  lower-case output string is ... abcdefg abcdefg "Double-Quoted" ...
!!     ... 'Single-Quoted' "with "" Quote" everything else
!!  >  lower_quoted(3f) is elemental ==>abc+def+ghi
!!
!!##SEE ALSO
!!     flower(1)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function lower_quoted(str) result (string)

! ident_23="@(#) M_strings lower_quoted(3f) elemental function converts string to lowercase skipping strings quoted per Fortran syntax rules"

character(len=*), intent(in)   :: str     ! The input string
character(len=len(str))        :: string  ! The output string
logical                        :: toggle
character(len=1)               :: togglechar
integer                        :: irnk
integer                        :: i
character(len=26), parameter   :: large="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(len=26), parameter   :: small="abcdefghijklmnopqrstuvwxyz"

   string=str
   toggle = .TRUE.
   do i = 1, len_trim(string)
      if(toggle) then
         if(string(i:i) == '"' .or. string(i:i) == "'") then
            toggle = .not. toggle
            togglechar = string(i:i)
         endif
         irnk = index(large, string(i:i))
         if(irnk > 0) then
            string(i:i) = small(irnk:irnk)
         endif
      else
         if(string(i:i) == togglechar) toggle = .not. toggle
      endif
   enddo
end function lower_quoted
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper_quoted(3f) - [M_strings:CASE] elemental function converts string to
!!                uppercase skipping strings quoted per Fortran syntax rules
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper_quoted(str) result (string)
!!
!!     character(*), intent(in)    :: str
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!    upper_quoted(string) returns a copy of the input string with all not-quoted
!!    characters converted to uppercase, assuming ASCII character sets
!!    are being used. The quoting rules are the same as for Fortran source.
!!    Either a single or double quote starts a quoted string, and a quote
!!    character of the same type is doubled when it appears internally in
!!    the quoted string. If a double quote quotes the string single quotes
!!    may appear in the quoted string as single characters, and vice-versa
!!    for single quotes.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!
!!##RETURNS
!!    upper  copy of the input string with all unquoted characters converted
!!           to uppercase
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_upper_quoted
!!     use M_strings, only: upper_quoted
!!     implicit none
!!     character(len=:),allocatable  :: s
!!     s=' ABCDEFG abcdefg "Double-Quoted" ''Single-Quoted'' "with ""&
!!        & Quote" everything else'
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper_quoted(s)
!!        write(*,'(1x,a,*(a:,"+"))') 'upper_quoted(3f) is elemental ==>', &
!!        & upper_quoted(["abc","def","ghi"])
!!     end program demo_upper_quoted
!!
!!    Expected output:
!!
!!     mixed-case input string is .... ABCDEFG abcdefg "Double-Quoted" ...
!!     ... 'Single-Quoted' "with "" Quote" everything else
!!     upper-case output string is ... ABCDEFG ABCDEFG "Double-Quoted" ...
!!     ... 'Single-Quoted' "with "" Quote" EVERYTHING ELSE
!!     upper_quoted(3f) is elemental ==>ABC+DEF+GHI
!!
!!##SEE ALSO
!!     flower(1)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function upper_quoted(str) result (string)

! ident_24="@(#) M_strings upper_quoted(3f) elemental function converts string to uppercase skipping strings quoted per Fortran syntax rules"

character(len=*), intent(in)   :: str     ! The input string
character(len=len(str))        :: string  ! The output string
logical                        :: toggle
character(len=1)               :: togglechar
integer                        :: irnk
integer                        :: i
character(len=26), parameter   :: large="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
character(len=26), parameter   :: small="abcdefghijklmnopqrstuvwxyz"

   string=str
   toggle = .TRUE.
   do i = 1, len_trim(string)
      if(toggle) then
         if(string(i:i) == '"' .or. string(i:i) == "'") then
            toggle = .not. toggle
            togglechar = string(i:i)
         endif
         irnk = index(small, string(i:i))
         if(irnk > 0) then
            string(i:i) = large(irnk:irnk)
         endif
      else
         if(string(i:i) == togglechar) toggle = .not. toggle
      endif
   enddo
end function upper_quoted
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper(3f) - [M_strings:CASE] changes a string to uppercase
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper(str,begin,end) result (string)
!!
!!     character(*), intent(in)    :: str
!!     integer,optional,intent(in) :: begin,end
!!     character(len(str))         :: string  ! output string
!!
!!##DESCRIPTION
!!      upper(string) returns a copy of the input string with all characters
!!      converted in the optionally specified range to uppercase, assuming
!!      ASCII character sets are being used. If no range is specified the
!!      entire string is converted to uppercase.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!    begin  optional starting position in "str" to begin converting to
!!           uppercase
!!    end    optional ending position in "str" to stop converting to
!!           uppercase
!!
!!##RETURNS
!!    upper  copy of the input string with all characters converted to
!!           uppercase over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_upper
!!     use M_strings, only: upper
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper(s)
!!        write(*,*) 'make first character uppercase  ... ',&
!!        & upper('this is a sentence.',1,1)
!!        write(*,'(1x,a,*(a:,"+"))') 'UPPER(3f) is elemental ==>',&
!!        & upper(["abc","def","ghi"])
!!     end program demo_upper
!!
!!    Expected output
!!
!!     mixed-case input string is .... ABCDEFG abcdefg
!!     upper-case output string is ... ABCDEFG ABCDEFG
!!     make first character uppercase  ... This is a sentence.
!!     UPPER(3f) is elemental ==>ABC+DEF+GHI
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
! Timing
!
!    Several different methods have been proposed for changing case.
!    A simple program that copies a large file and converts it to
!    uppercase was timed and compared to a simple copy. This was used
!    to select the default function.
!
! NULL:    83.41user  9.25system 1:37.94elapsed 94%CPU
! upper:  101.44user 10.89system 1:58.36elapsed 94%CPU
! upper2: 105.04user 10.69system 2:04.17elapsed 93%CPU
! upper3: 267.21user 11.69system 4:49.21elapsed 96%CPU
elemental pure function upper_all(str) result (string)

! ident_25="@(#) M_strings upper_all(3f) returns an uppercase string"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
! note using kind=byte is faster than int32 in gfortran
integer(kind=byte), parameter :: ade_a = iachar('a'), ade_z = iachar('z')
integer(kind=byte), parameter :: diff = iachar('A',kind=byte) - iachar('a',kind=byte)
integer(kind=byte)            :: ade_char

   do concurrent(i=1:len(str))                       ! step thru each letter in the string in specified range
      ade_char = iachar(str(i:i), byte)              ! ASCII Decimal Equivalent
      if (ade_char >= ade_a .and. ade_char <= ade_z) ade_char = ade_char + diff
      string(i:i) = achar(ade_char)
   enddo

   if(len(str).eq.0)string = str

end function upper_all
elemental pure function upper_range(str,begin,end) result (string)

! ident_26="@(#) M_strings upper_range(3f) returns a string with the specified range converted to uppercase"

character(*), intent(in)      :: str                 ! input string to convert to all uppercase
integer, intent(in)           :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
! note using kind=int8 is faster than int32 in gfortran
integer(kind=byte), parameter :: diff = iachar('A',kind=byte) - iachar('a',kind=byte)

   iend=len(str)
   if(iend.ne.0.and.(end.le.iend.and.end.ge.1).and.(begin.ge.1.and.begin.le.iend))then
      ibegin=begin
      iend=end
      string = str                                      ! initialize output string to input string
      ! note doing everything in a loop instead of just assigning string=str and then doing just changed values in loop is faster!
      do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
          select case (str(i:i))
          case ('a':'z')                                ! located miniscule letter
             string(i:i) = achar(iachar(str(i:i),kind=byte) + diff)    ! change miniscule letter to majascule
          case default
             string(i:i) = str(i:i)
          end select
      enddo
   else
      string=str
   endif
end function upper_range
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lower(3f) - [M_strings:CASE] changes a string to lowercase over
!!    specified range
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower(str,begin,end) result (string)
!!
!!     character(*), intent(in) :: str
!!     integer,optional         :: begin, end
!!     character(len(str))      :: string  ! output string
!!
!!##DESCRIPTION
!!      lower(str) returns a copy of the ASCII input string with all
!!      characters converted to miniscule (ie. "lowercase") over the
!!      specified range, If no range is specified the entire string is
!!      converted to miniscule.
!!
!!##OPTIONS
!!    str    string to convert to miniscule
!!    begin  optional starting position in "str" to begin converting to
!!           miniscule. Defaults to the beginning of the string (ie. "1").
!!    end    optional ending position in "str" to stop converting to
!!           miniscule. Defaults to the end of the string (ie. "len(str)").
!!
!!##RETURNS
!!    lower  copy of the entire input string with all characters converted to
!!           miniscule over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days
!!    of the mechanical printing press. Individual metal alloy casts of
!!    each needed letter or punctuation symbol were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These metal
!!    casts were stored and organized in wooden cases. The more-often-needed
!!    miniscule letters were placed closer to hand, in the lower cases of
!!    the work bench. The less often needed, capitalized, majuscule letters,
!!    ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_lower
!!       use M_strings, only: lower
!!       implicit none
!!       character(len=:),allocatable  :: s
!!          s=' ABCDEFG abcdefg '
!!          write(*,*) 'mixed-case input string is ....',s
!!          write(*,*) 'lower-case output string is ...',lower(s)
!!       end program demo_lower
!!
!!    Expected output
!!
!!       mixed-case input string is .... ABCDEFG abcdefg
!!       lower-case output string is ... abcdefg abcdefg
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental pure function lower(str,begin,end) result (string)

! ident_27="@(#) M_strings lower(3f) Changes a string to lowercase over specified range"

character(*), intent(in)    :: str
character(len(str))         :: string
integer,intent(in),optional :: begin, end
integer                     :: i
integer                     :: ibegin, iend
integer,parameter           :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                    ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    switch(3f) - [M_strings:ARRAY] converts between CHARACTER scalar and
!!    array of single characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function switch(array) result (string)
!!
!!     character(len=1),intent(in) :: array(:)
!!     character(len=SIZE(array))  :: string
!!
!!      or
!!
!!    pure function switch(string) result (array)
!!
!!     character(len=*),intent(in) :: string
!!     character(len=1)            :: array(len(string))
!!
!!##DESCRIPTION
!!    SWITCH(3f): generic function that switches CHARACTER string to an array
!!    of single characters or an array of single characters to a CHARACTER
!!    string. Useful in passing strings to C. New Fortran features may
!!    supersede these routines.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!    program demo_switch
!!    use M_strings, only : switch, isalpha, islower, nospace
!!    character(len=*),parameter :: &
!!    & dashes='-----------------------------------'
!!    character(len=*),parameter :: string='This is a string'
!!    character(len=1024)        :: line
!!
!!    ! First, examples of standard Fortran features
!!    ! returns array [F,T,T,T,T,T]
!!    write(*,*)['A','=','=','=','=','='] == '='
!!    ! this would return T
!!    write(*,*)all(['=','=','=','=','=','='] == '=')
!!    ! this would return F
!!    write(*,*)all(['A','=','=','=','=','='] == '=')
!!
!!    ! so to test if the string DASHES is all dashes
!!    ! using SWITCH(3f) is
!!    if(all(switch(dashes) == '-'))then
!!       write(*,*)'DASHES is all dashes'
!!    endif
!!
!!    ! so to test is a string is all letters
!!    ! isalpha(3f) returns .true. only if character is a letter
!!    ! false because dashes are not a letter
!!    write(*,*) all(isalpha(switch(dashes)))
!!    ! false because of spaces
!!    write(*,*) all(isalpha(switch(string)))
!!    ! true because removed whitespace
!!    write(*,*) all(isalpha(switch(nospace(string))))
!!
!!    ! to see if a string is all uppercase
!!    ! show the string
!!    write(*,*) string
!!    ! converted to character array
!!    write(*,'(1x,*("[",a,"]":))') switch(string)
!!    write(*,'(*(l3))') islower(switch(string))
!!
!!    ! we need a string that is all letters
!!    line=nospace(string)
!!    write(*,*)'LINE=',trim(line)
!!    ! all true except first character
!!    write(*,*) islower(switch(nospace(string)))
!!    ! should be false
!!    write(*,*) all(islower(switch(nospace(string))))
!!    ! should be true
!!    write(*,*) all(islower(switch(nospace(string(2:)))))
!!
!!    end program demo_switch
!!
!!  Expected output
!!
!!     > F T T T T T
!!     > T
!!     > F
!!     > DASHES is all dashes
!!     > F
!!     > F
!!     > T
!!     > This is a string
!!     > [T][h][i][s][ ][i][s][ ][a][ ][s][t][r][i][n][g]
!!     >  F  T  T  T  F  T  T  F  T  F  T  T  T  T  T  T
!!     > LINE=Thisisastring
!!     > F T T T T T T T T T T T T
!!     > F
!!     > T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function a2s(array)  result (string)

! ident_28="@(#) M_strings a2s(3fp) function to copy char array to string"

character(len=1),intent(in) :: array(:)
character(len=SIZE(array))  :: string
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall( i = 1:size(array)) string(i:i) = array(i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  string=transfer(array,string)
end function a2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

! ident_29="@(#) M_strings s2a(3fp) function to copy string(1 Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
!  array=transfer(string,array)
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2c(3f) - [M_strings:ARRAY] convert character variable to array of
!!      characters with last element set to null
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function s2c(string)  RESULT (array)
!!
!!     character(len=*),intent=(in)  :: string
!!     character(len=1),allocatable  :: s2c(:)
!!
!!##DESCRIPTION
!!    Given a character variable convert it to an array of single-character
!!    character variables with the last element set to a null character.
!!    This is generally used to pass character variables to C procedures.
!!
!!##EXAMPLES
!!
!!
!! character(len=3),allocatable :: array(:)
!! integer                      :: i
!!    ! put one character into each 3-character element of array
!!    array = [(string(i:i),i=1,len(string))]
!!    ! write array with ASCII Decimal Equivalent below it except show
!!    ! unprintable characters like NULL as "XXX"
!!    write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!    write(*,g) iachar(array(:)(1:1))
!!
!!    Sample Program:
!!
!!     program demo_s2c
!!     use M_strings, only : s2c
!!     implicit none
!!     character(len=*),parameter   :: string="single string"
!!     character(len=*),parameter   :: g= '(1x,*("[",g3.3,"]":))'
!!     character(len=3),allocatable :: array(:)
!!        write(*,*)'INPUT STRING ',trim(string)
!!        ! put one character into each 3-character element of array
!!        array=s2c(string)
!!        ! write array with ASCII Decimal Equivalent below it except show
!!        ! unprintable characters like NULL as "XXX"
!!        write(*,g) merge('XXX',array,iachar(array(:)(1:1)) < 32)
!!        write(*,g) iachar(array(:)(1:1))
!!     end program demo_s2c
!!
!!   Expected output:
!!
!!    INPUT STRING single string
!!    [s  ][i  ][n  ][g  ][l  ][e  ][   ][s  ][t  ][r  ][i  ][n  ][g  ][XXX]
!!    [115][105][110][103][108][101][ 32][115][116][114][105][110][103][  0]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function s2c(string)  RESULT (array)
use,intrinsic :: ISO_C_BINDING, only : C_CHAR

! ident_30="@(#) M_strings s2c(3f) copy string(1 Clen(string)) to char array with null terminator"

character(len=*),intent(in)     :: string

! This is changing, but currently the most portable way to pass a CHARACTER variable to C is to convert it to an array of
! character variables with length one and add a null character to the end of the array. The s2c(3f) function helps do this.
character(kind=C_CHAR,len=1)    :: array(len_trim(string)+1)
integer                         :: i
   do i = 1,size(array)-1
      array(i) = string(i:i)
   enddo
   array(size(array):)=achar(0)
end function s2c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      c2s(3f) - [M_strings:ARRAY] convert C string pointer to Fortran
!!      character string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function c2s(c_string_pointer) result(f_string)
!!
!!     type(c_ptr), intent(in)       :: c_string_pointer
!!     character(len=:), allocatable :: f_string
!!
!!##DESCRIPTION
!!    Given a C pointer to a character string return a Fortran character
!!    string.
!!
!!##OPTIONS
!!    c_string_pointer  C pointer to convert
!!
!!##RETURNS
!!    f_string          Fortran character variable to return
!!
!!##EXAMPLES
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function c2s(c_string_pointer) result(f_string)
! gets a C string (pointer), and returns the corresponding Fortran string;
! If the C string is null, it returns "NULL", similar to C's "(null)" printed in similar cases:
use, intrinsic :: iso_c_binding, only: c_ptr,c_f_pointer,c_char,c_null_char

! ident_31="@(#) M_strings c2s(3f) copy pointer to C char array till a null is encountered to a Fortran string up to 4096 characters"

integer,parameter                             :: max_length=4096
type(c_ptr), intent(in)                       :: c_string_pointer
character(len=:), allocatable                 :: f_string
character(kind=c_char), dimension(:), pointer :: char_array_pointer => null()
character(len=max_length)                     :: aux_string
integer                                       :: i,length=0

   call c_f_pointer(c_string_pointer,char_array_pointer,[max_length])
   if (.not.associated(char_array_pointer)) then
     allocate(character(len=4)::f_string)
     f_string="NULL"
     return
   endif
   aux_string=" "
   do i=1,max_length
     if (char_array_pointer(i)==c_null_char) then
       length=i-1
       exit
     endif
     aux_string(i:i)=char_array_pointer(i)
   enddo
   allocate(character(len=length)::f_string)
   f_string=aux_string(1:length)

end function c2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      indent(3f) - [M_strings:WHITESPACE] count number of leading spaces
!!      in a string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function indent(line)
!!
!!     integer                        :: indent
!!     character(len=*),intent(in)    :: line
!!
!!##DESCRIPTION
!!    Count number of leading spaces in a CHARACTER variable.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_indent
!!    !  test filter to count leading spaces in a character variable
!!    !  might want to call notabs(3f) to expand tab characters
!!    use M_strings, only : indent
!!    implicit none
!!    character(len=1024) :: in
!!    integer             :: iostat
!!       READFILE: do
!!          read(*,'(A)',iostat=iostat)in
!!          if(iostat /= 0) exit READFILE
!!          write(*,'(i3,"",a)')indent(in),trim(in)
!!       enddo READFILE
!!    end program demo_indent
!!
!! Results:
!!
!!      > 3   a b c
!!      > 0a b c
!!      > 6      a b c
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function indent(line)

! ident_32="@(#) M_strings indent(3f) find number of leading spaces in a string"

integer                        :: indent
character(len=*),intent(in)    :: line
integer                        :: i
   indent=0
   NOTSPACE: block
      SCAN: do i=1,len(line)
         if(line(i:i) /= ' ')then
            indent=i-1
            exit NOTSPACE
         endif
      enddo SCAN
      indent=len(line)
   endblock NOTSPACE
end function indent
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    visible(3f) - [M_strings:NONALPHA] expand a string to control and
!!    meta-control representations
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function visible(input) result(output)
!!
!!     character(len=*),intent(in)           :: input
!!     character(len=:),allocatable          :: output
!!
!!##DESCRIPTION
!!     visible(3f) expands characters to commonly used sequences used
!!     to represent the characters as control sequences or meta-control
!!     sequences.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_visible
!!     use M_strings, only : visible
!!     integer :: i
!!        do i=0,255
!!           write(*,'(i0,1x,a)')i,visible(char(i))
!!        enddo
!!     end program demo_visible
!!##BUGS
!!     The expansion is not reversible, as input sequences such as "M-" or
!!     "^a" will look like expanded sequences.
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function visible(input) result(output)
character(len=*),intent(in)  :: input
character(len=:),allocatable :: output

! ident_33="@(#) M_strings visible(3f) expand escape sequences in a string to control and meta-control representations"

integer                      :: i
character(len=1)             :: c

character(len=*),parameter :: chars(0:255)= [ &
'^@  ', '^A  ', '^B  ', '^C  ', '^D  ', '^E  ', '^F  ', '^G  ', '^H  ', '^I  ', &
'^J  ', '^K  ', '^L  ', '^M  ', '^N  ', '^O  ', '^P  ', '^Q  ', '^R  ', '^S  ', &
'^T  ', '^U  ', '^V  ', '^W  ', '^X  ', '^Y  ', '^Z  ', '^[  ', '^\  ', '^]  ', &
'^^  ', '^_  ', '    ', '!   ', '"   ', '#   ', '$   ', '%   ', '&   ', '''   ', &
'(   ', ')   ', '*   ', '+   ', ',   ', '-   ', '.   ', '/   ', '0   ', '1   ', &
'2   ', '3   ', '4   ', '5   ', '6   ', '7   ', '8   ', '9   ', ':   ', ';   ', &
'<   ', '=   ', '>   ', '?   ', '@   ', 'A   ', 'B   ', 'C   ', 'D   ', 'E   ', &
'F   ', 'G   ', 'H   ', 'I   ', 'J   ', 'K   ', 'L   ', 'M   ', 'N   ', 'O   ', &
'P   ', 'Q   ', 'R   ', 'S   ', 'T   ', 'U   ', 'V   ', 'W   ', 'X   ', 'Y   ', &
'Z   ', '[   ', '\   ', ']   ', '^   ', '_   ', '`   ', 'a   ', 'b   ', 'c   ', &
'd   ', 'e   ', 'f   ', 'g   ', 'h   ', 'i   ', 'j   ', 'k   ', 'l   ', 'm   ', &
'n   ', 'o   ', 'p   ', 'q   ', 'r   ', 's   ', 't   ', 'u   ', 'v   ', 'w   ', &
'x   ', 'y   ', 'z   ', '{   ', '|   ', '}   ', '~   ', '^?  ', 'M-^@', 'M-^A', &
'M-^B', 'M-^C', 'M-^D', 'M-^E', 'M-^F', 'M-^G', 'M-^H', 'M-^I', 'M-^J', 'M-^K', &
'M-^L', 'M-^M', 'M-^N', 'M-^O', 'M-^P', 'M-^Q', 'M-^R', 'M-^S', 'M-^T', 'M-^U', &
'M-^V', 'M-^W', 'M-^X', 'M-^Y', 'M-^Z', 'M-^[', 'M-^\', 'M-^]', 'M-^^', 'M-^_', &
'M-  ', 'M-! ', 'M-" ', 'M-# ', 'M-$ ', 'M-% ', 'M-& ', 'M-'' ', 'M-( ', 'M-) ', &
'M-* ', 'M-+ ', 'M-, ', 'M-- ', 'M-. ', 'M-/ ', 'M-0 ', 'M-1 ', 'M-2 ', 'M-3 ', &
'M-4 ', 'M-5 ', 'M-6 ', 'M-7 ', 'M-8 ', 'M-9 ', 'M-: ', 'M-; ', 'M-< ', 'M-= ', &
'M-> ', 'M-? ', 'M-@ ', 'M-A ', 'M-B ', 'M-C ', 'M-D ', 'M-E ', 'M-F ', 'M-G ', &
'M-H ', 'M-I ', 'M-J ', 'M-K ', 'M-L ', 'M-M ', 'M-N ', 'M-O ', 'M-P ', 'M-Q ', &
'M-R ', 'M-S ', 'M-T ', 'M-U ', 'M-V ', 'M-W ', 'M-X ', 'M-Y ', 'M-Z ', 'M-[ ', &
'M-\ ', 'M-] ', 'M-^ ', 'M-_ ', 'M-` ', 'M-a ', 'M-b ', 'M-c ', 'M-d ', 'M-e ', &
'M-f ', 'M-g ', 'M-h ', 'M-i ', 'M-j ', 'M-k ', 'M-l ', 'M-m ', 'M-n ', 'M-o ', &
'M-p ', 'M-q ', 'M-r ', 'M-s ', 'M-t ', 'M-u ', 'M-v ', 'M-w ', 'M-x ', 'M-y ', &
'M-z ', 'M-{ ', 'M-| ', 'M-} ', 'M-~ ', 'M-^?']
output=''
do i=1,len(input)
   c=input(i:i)
   if(c == ' ')then
      output=output//' '
   else
      output=output//trim(chars(iachar(c)))
   endif
enddo
end function visible
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    expand(3f) - [M_strings:NONALPHA] expand C-like escape sequences
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function expand(line,escape) result(lineout)
!!
!!    character(len=*)                      :: line
!!    character(len=1),intent(in),optional  :: escape
!!    character(len=:),allocatable          :: lineout
!!
!!##DESCRIPTION
!!     EXPAND(3) expands sequences used to represent commonly used escape
!!     sequences or control characters. By default ...
!!
!!     Escape sequences
!!
!!       \      backslash
!!       a      alert (BEL) -- g is an alias for a
!!       b      backspace
!!       c      suppress further output
!!       e      escape
!!       f      form feed
!!       n      new line
!!       r      carriage return
!!       t      horizontal tab
!!       v      vertical tab
!!       oNNN   byte with octal value NNN (3 digits)
!!       dNNN   byte with decimal value NNN (3 digits)
!!       xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
!!
!!     The default escape character is the backslash, but this may be
!!     changed using the optional parameter ESCAPE.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_expand
!!       ! demonstrate filter to expand C-like escape sequences in input lines
!!       use M_strings, only : expand
!!       integer,parameter     :: iwidth=1024
!!       integer               :: i
!!       character(len=iwidth),parameter :: input(*)=[ character(len=iwidth) :: &
!!          '\e[H\e[2J',&   ! home cursor and clear screen on ANSI terminals
!!          '\tABC\tabc',&  ! write some tabs in the output
!!          '\tA\a',&       ! ring bell at end if supported
!!          '\nONE\nTWO\nTHREE',&  ! place one word per line
!!          '\\']
!!          write(*,'(a)')(trim(expand(input(i))),i=1,size(input))
!!    end program demo_expand
!!
!! Results (with nonprintable characters shown visible):
!!
!!     > ^[[H^[[2J
!!     > ^IABC^Iabc
!!     > ^IA^G
!!     >
!!     > ONE
!!     > TWO
!!     > THREE
!!     > \
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function expand(line,escape) result(lineout)
!x!USE ISO_C_BINDING ,ONLY: c_horizontal_tab

! ident_34="@(#) M_strings expand(3f) return string with escape sequences expanded"

character(len=*),parameter            :: c_horizontal_tab=char(9)
character(len=*),intent(in)           :: line
character(len=1),intent(in),optional  :: escape ! escape character. Default is backslash
! expand escape sequences found in input string
! Escape sequences
!    %%      escape character           %a     alert (BEL) -- gi is an alias for a
!    %b      backspace                  %c     suppress further output
!    %e      escape                     %E     escape
!    %f      form feed                  %n     new line
!    %r      carriage return            %t     horizontal tab
!    %v      vertical tab
!    %oNNN   byte with octal value NNN (3 digits)
!    %dNNN   byte with decimal value NNN (3 digits)
!    %xHH    byte with hexadecimal value HH (2 digits) -- h is an alias for x
character(len=1)                      :: esc    ! escape character. Default is %
character(len=:),allocatable          :: lineout
integer                               :: i
integer                               :: lgth
character(len=3)                      :: thr
integer                               :: xxx
integer                               :: iostat
   i=0 ! pointer into input

   lgth=len_trim(line)
   lineout=''

   if(lgth == 0)return

   if (present(escape))then
      esc=escape
   else
      esc=char(92)
   endif

   EXP: do
      i=i+1
      if(i > lgth)exit
      if(line(i:i) == esc)then
         i=i+1
         if(i > lgth)exit
         if(line(i:i) /= esc)then
            BACKSLASH: select case(line(i:i))
            case('a','A','g','G');lineout=lineout//char(  7) ! %a     alert (BEL)
            case('b','B');lineout=lineout//char(  8)         ! %b     backspace
            case('c','C');exit EXP                           ! %c     suppress further output
            case('d','D')                                    ! %d     Dnnn decimal value
                      thr=line(i+1:)
                   read(thr,'(i3)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('e','E');lineout=lineout//char( 27)         ! %e     escape
            case('f','F');lineout=lineout//char( 12)         ! %f     form feed
            case('n','N');lineout=lineout//char( 10)         ! %n     new line
           !case('n','N');lineout=lineout//new_line('A')     ! %n     new line
            case('o','O')
                      thr=line(i+1:)
                   read(thr,'(o3)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+3
            case('r','R');lineout=lineout//char( 13)         ! %r     carriage return
            case('t','T');lineout=lineout//c_horizontal_tab  ! %t     horizontal tab
            case('v','V');lineout=lineout//char( 11)         ! %v     vertical tab
            case('x','X','h','H')                            ! %x     xHH  byte with hexadecimal value HH (1 to 2 digits)
                      thr=line(i+1:)
                   read(thr,'(z2)',iostat=iostat)xxx
                      lineout=lineout//char(xxx)
                   i=i+2
            end select BACKSLASH
         else
            lineout=lineout//esc                             ! escape character, defaults to backslash
         endif
      else
         lineout=lineout//line(i:i)
      endif
      if(i >= lgth)exit EXP
   enddo EXP

end function expand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notabs(3f) - [M_strings:NONALPHA] expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental impure subroutine notabs(instr,outstr,lgth)
!!
!!     character(len=*),intent=(in)           :: INSTR
!!     character(len=*),intent=(out),optional :: OUTSTR
!!     integer,intent=(out),optional          :: lgth
!!
!!##DESCRIPTION
!!     NOTABS(3) converts tabs in INSTR to spaces in OUTSTR while maintaining
!!     columns. It assumes a tab is set every 8 characters. Trailing spaces
!!     are removed.
!!
!!     In addition, trailing carriage returns and line feeds are removed
!!     (they are usually a problem created by going to and from MSWindows).
!!
!!     What are some reasons for removing tab characters from an input line?
!!     Some Fortran compilers have problems with tabs, as tabs are not
!!     part of the Fortran character set. Some editors and printers will
!!     have problems with tabs. It is often useful to expand tabs in input
!!     files to simplify further processing such as tokenizing an input line.
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RETURNS
!!     outstr    Output string with tabs expanded. Assumed to be of sufficient
!!               length
!!     lgth      Significant length of returned string. If greater than
!!               len(outstr) truncation has occurred.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_notabs
!!    use M_strings, only : notabs
!!    character(len=255)           :: in,out
!!    character(len=:),allocatable :: string
!!    character(len=1),parameter   :: t=char(9) ! horizontal tab
!!    integer                      :: iostat,iout,lun
!!    call makefile(lun) ! create scratch file
!!    ! read file and expand tabs
!!    do
!!       read(lun,'(A)',iostat=iostat)in
!!       if(iostat /= 0) exit
!!       call notabs(in,out,iout)
!!       write(*,'(a)')out(:iout)
!!    enddo
!!    string='one'//t//'two'//t//'three'
!!    call notabs(string,lgth=iout)
!!    out=repeat(' ',iout)
!!    call notabs(string,out)
!!    write(*,*)'['//string//']'
!!    contains
!!    subroutine makefile(lun)
!!    integer :: lun
!!    integer :: i
!!    character(len=80),parameter  :: fakefile(*)=[character(len=80) :: &
!!    'col1'//t//'col2' ,&
!!    'a'//t//'one'     ,&
!!    'bb'//t//'two'    ,&
!!    'ccc'//t//'three' ,&
!!    'dddd'//t//'four' ,&
!!    '']
!!    ! create input file
!!       open(newunit=lun,status='scratch')
!!       write(lun,'(a)')(trim(fakefile(i)),i=1,size(fakefile))
!!       rewind(lun)
!!    end subroutine makefile
!!    end program demo_notabs
!! ```
!!
!!##SEE ALSO
!!     GNU/Unix commands expand(1) and unexpand(1)
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental impure subroutine notabs(instr,outstr,lgth)

! ident_35="@(#) M_strings notabs(3f) convert tabs to spaces while maintaining columns remove CRLF chars"

character(len=*),intent(in)            :: instr        ! input line to scan for tab characters
character(len=*),intent(out),optional  :: outstr       ! tab-expanded version of INSTR produced
integer,intent(out),optional           :: lgth         ! column position of last character put into output string
                                                       ! that is, lgth holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
integer,parameter             :: tabsize=8    ! assume a tab stop is set every 8th column
integer                       :: ipos         ! position in OUTSTR to put next character of INSTR
integer                       :: lenin        ! length of input string trimmed of trailing spaces
integer                       :: lenout       ! number of characters output string can hold
integer                       :: istep        ! counter that advances thru input string INSTR one character at a time
character(len=1)              :: c            ! character in input line being processed
integer                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
character(len=:),allocatable  :: outstr_      ! tab-expanded version of INSTR produced
integer                       :: i
integer                       :: icount
   icount=0                                   ! ensure the expanded string is of sufficient length
   do i=1,len(instr)
      if(instr(i:i) == char(9))icount=icount+1
   enddo
   allocate(character(len=(len(instr)+8*icount)) :: outstr_)
!===================================================================================================================================
   ipos=1                                     ! where to put next character in output string OUTSTR_
   lenin=len_trim(instr( 1:len(instr) ))      ! length of INSTR trimmed of trailing spaces
   lenout=len(outstr)                         ! number of characters output string OUTSTR_ can hold
   outstr_(:)=" "                             ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: do istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=iachar(c)                       ! get ADE of the character
         EXPAND_TABS : select case (iade)     ! take different actions depending on which character was found
         case(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         case default                         ! c is anything else other than a tab,newline,or return  insert it in output string
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr_(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select EXPAND_TABS
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=min(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      if(present(lgth))then
         lgth=len_trim(outstr_(:ipos))        ! trim trailing spaces
      endif
      if(present(outstr))then
         outstr=outstr_
      endif
!===================================================================================================================================
end subroutine notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dilate(3f) - [M_strings:NONALPHA] function to expand tab characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dilate(INSTR) result(OUTSTR)
!!
!!     character(len=*),intent=(in)  :: INSTR
!!     character(len=:),allocatable  :: OUTSTR
!!
!!##DESCRIPTION
!!    dilate(3) converts tabs in INSTR to spaces in OUTSTR. It assumes a
!!    tab is set every 8 characters. Trailing spaces are removed.
!!
!!    In addition, trailing carriage returns and line feeds are removed
!!    (they are usually a problem created by going to and from MSWindows).
!!
!!##OPTIONS
!!     instr     Input line to remove tabs from
!!
!!##RETURNS
!!     outstr    Output string with tabs expanded.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dilate
!!
!!    use M_strings, only : dilate, visible
!!    implicit none
!!    character(len=:),allocatable :: in
!!    integer                      :: i
!!       in='  this is my string  '
!!       ! change spaces to tabs to make a sample input
!!       do i=1,len(in)
!!          if(in(i:i) == ' ')in(i:i)=char(9)
!!       enddo
!!       write(*,'("[",a,"]")')visible(in)
!!       write(*,'("[",a,"]")')visible(dilate(in))
!!    end program demo_dilate
!!
!!   Results:
!!
!!    > [^I^Ithis^Iis^Imy^Istring^I^I]
!!    > [                this    is      my      string]
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!    Public Domain
function dilate(instr) result(outstr)
! ident_36="@(#) M_strings dilate(3f) convert tabs to spaces and trim line removing CRLF chars"
character(len=*),intent(in)  :: instr     ! input line to scan for tab characters
character(len=:),allocatable :: outstr    ! tab-expanded version of INSTR produced
integer,parameter            :: tabsize=8 ! assume a tab stop is set every 8th column
integer                      :: ipos      ! position in OUTSTR to put next character of INSTR
integer                      :: istep     ! counter advances thru string INSTR one char at a time
integer                      :: icount    ! number of tab characters in input
integer                      :: i
   ! count number of tab characters in input
   icount=0
   do i=1,len(instr)
      if(iachar(instr(i:i))==9)icount=icount+1
   enddo
   ! knowing number of tabs initially set length of output to the maxiumum length that might result
   allocate(character(len=(len(instr)+8*icount)) :: outstr)
   outstr(:)=" "                              ! this SHOULD blank-fill string
   ipos=1                                     ! where to put next character in output string OUTSTR
   SCAN_LINE: do istep=1,len_trim(instr)      ! look through input string one character at a time
      EXPAND_TABS : select case (iachar(instr(istep:istep)))! take different actions based on character found
      case(9)        ! character is a horizontal tab so move pointer out to appropriate column
         ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
      case(10,13)    ! convert carriage-return and new-line to space ,typically to handle DOS-format files
         ipos=ipos+1
      case default   ! character is anything else other than a tab,newline,or return.
         outstr(ipos:ipos)=instr(istep:istep)
         ipos=ipos+1
      end select EXPAND_TABS
   enddo SCAN_LINE
   outstr=trim(outstr)
end function dilate
! ident_37="@(#) M_strings dilate(3f) convert tabs to spaces and trims line removing CRLF chars"
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    adjustc(3f) - [M_strings:WHITESPACE] center text
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   pure function adjustc(string[,length])
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in),optional  :: length
!!    character(len=:),allocatable :: adjustc
!!
!!##DESCRIPTION
!!     Centers input text in a string of the length specified. Returns a
!!     string of length LENGTH if LENGTH is present. Otherwise returns a
!!     string of the length of the input string.
!!
!!##OPTIONS
!!     string  input string to trim and center
!!     length  line length to center text in, optional.
!!
!!##RETURNS
!!     adjustc  centered output string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_adjustc
!!    use M_strings, only : adjustc
!!    !  using length of the input string
!!       write(*,'(a)')       '================================'
!!       write(*,'(a)')adjustc('centered string                 ')
!!       write(*,'(a)')adjustc('                 centered string')
!!       write(*,'(a)')adjustc('  centered string               ')
!!    !  using explicit output string length
!!       write(*,'(a)')repeat('=',50)
!!       write(*,'(a)')adjustc('this is a centered string',50)
!!       write(*,'(a)')repeat('=',50)
!!    end program demo_adjustc
!!
!!   Expected output
!!
!!    ================================
!!            centered string
!!            centered string
!!            centered string
!!    ==================================================
!!                this is a centered string
!!    ==================================================
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
pure function adjustc(string,length)

! ident_38="@(#) M_strings adjustc(3f) center text"

!>
!! PROCEDURE:   adjustc(3f)
!! DESCRIPTION: center text using implicit or explicit length
!!##VERSION:     2.0, 20160711
!! AUTHOR:      John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: string         ! input string to trim and center
integer,intent(in),optional  :: length         ! line length to center text in
character(len=:),allocatable :: adjustc        ! output string
integer                      :: inlen
integer                      :: ileft          ! left edge of string if it is centered
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(length))then                     ! optional length
      inlen=length                             ! length will be requested length
      if(inlen <= 0)then                       ! bad input length
         inlen=len(string)                     ! could not use input value, fall back to length of input string
      endif
   else                                        ! output length was not explicitly specified, use input string length
      inlen=len(string)
   endif
   allocate(character(len=inlen):: adjustc)    ! create output at requested length
   adjustc(1:inlen)=' '                        ! initialize output string to all blanks
!-----------------------------------------------------------------------------------------------------------------------------------
   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it
   if(ileft > 0)then                           ! if string will fit centered in output
      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string
   else                                        ! input string will not fit centered in output string
      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can
   endif
end function adjustc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!!    input string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function nospace(str) - remove all whitespace from input string
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),allocatable :: nospace
!!
!!##DESCRIPTION
!!    nospace(3f) removes space, tab, carriage return, new line, vertical
!!    tab, formfeed and null characters (called "whitespace"). The output
!!    is returned trimmed.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_nospace
!!     use M_strings, only: nospace
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s='  This     is      a     test  '
!!        write(*,*) 'original input string is ....',s
!!        write(*,*) 'processed output string is ...',nospace(s)
!!        if(nospace(s) == 'Thisisatest')then
!!           write(*,*)'nospace test passed'
!!        else
!!           write(*,*)'nospace test error'
!!        endif
!!     end program demo_nospace
!!
!!   Expected output
!!
!!     original input string is ....  This     is      a     test
!!     processed output string is ...Thisisatest
!!     nospace test passed
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function nospace(line)

! ident_39="@(#) M_strings nospace(3f) remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    stretch(3f) - [M_strings:LENGTH] return string padded to at least
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function stretch(str,length,pattern,suffix) result(strout)
!!
!!     character(len=*),intent(in)         :: str
!!     integer,intent(in)                  :: length
!!     character(len=*)intent(in),optional :: pattern
!!     character(len=*)intent(in),optional :: suffix
!!     character(len=:),allocatable        :: strout
!!
!!##DESCRIPTION
!!    stretch(3f) pads a string with spaces to at least the specified
!!    length. If the trimmed input string is longer than the requested
!!    length the original string is returned trimmed of trailing spaces.
!!
!!##OPTIONS
!!    str      the input string to return trimmed, but then padded to
!!             the specified length if shorter than length
!!    length   The minimum string length to return
!!    pattern  optional string to use as padding. Defaults to a space.
!!    suffix   optional string to append to output string
!!
!!##RETURNS
!!    strout  The input string padded to the requested length or
!!            the trimmed input string if the input string is
!!            longer than the requested length.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!   program demo_stretch
!!    use M_strings, only : stretch
!!    implicit none
!!    character(len=10)            :: string='abcdefghij'
!!    character(len=:),allocatable :: answer
!!    integer                      :: i
!!       answer=stretch(string,5)
!!       write(*,'("[",a,"]")') answer
!!       answer=stretch(string,20)
!!       write(*,'("[",a,"]")') answer
!!       i=30
!!       write(*,*)
!!       write(*,'(1x,a,i0)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,'(1x,a,i7)') &
!!        & stretch('CHAPTER 1 : The beginning ',i,'.'), 1    ,&
!!        & stretch('CHAPTER 2 : The end ',i,'.'),       1234 ,&
!!        & stretch('APPENDIX ',i,'.'),                  1235
!!       write(*,*)
!!       write(*,*) &
!!        & stretch('CHAPTER 1 : The beginning ',i,suffix=': '), 1
!!       write(*,*) &
!!        & stretch('CHAPTER 2 : The end ',i,suffix=': '),1234
!!       write(*,*) &
!!        & stretch('APPENDIX ',i,suffix=': '),           1235
!!   end program demo_stretch
!!
!!   Results:
!!
!!    [abcdefghij]
!!    [abcdefghij          ]
!!
!!     CHAPTER 1 : The beginning ....1
!!     CHAPTER 2 : The end ..........1234
!!     APPENDIX .....................1235
!!
!!     CHAPTER 1 : The beginning ....      1
!!     CHAPTER 2 : The end ..........   1234
!!     APPENDIX .....................   1235
!!
!!     CHAPTER 1 : The beginning     :            1
!!     CHAPTER 2 : The end           :         1234
!!     APPENDIX                      :         1235
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function stretch(line,length,pattern,suffix) result(strout)

! ident_40="@(#) M_strings stretch(3f) return string padded to at least specified length"

character(len=*),intent(in)                  :: line
integer,intent(in)                           :: length
character(len=*),intent(in),optional         :: pattern
character(len=*),intent(in),optional         :: suffix
!-!character(len=max(length,len(trim(line)))) :: strout
character(len=:),allocatable                 :: strout
   if(present(pattern))then
      strout=pad(line,length,pattern)
   else
      strout=pad(line,length)
   endif
   if(present(suffix))then
      strout=strout//suffix
   endif
end function stretch
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    rpad(3f) - [M_strings:LENGTH] convert to a string and pad on the right
!!    to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function rpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    rpad(3f) converts a scalar intrinsic value to a string and then pads
!!    it on the right with spaces to at least the specified length. If the
!!    trimmed input string is longer than the requested length the string
!!    is returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the right with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_rpad
!!       use M_strings, only : rpad
!!       implicit none
!!          write(*,'("[",a,"]")') rpad( 'my string', 20)
!!          write(*,'("[",a,"]")') rpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string', 20)
!!          write(*,'("[",a,"]")') rpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') rpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') rpad( valuein=1.0/9.0 , length=20)
!!      end program demo_rpad
!!
!!  Results:
!!
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [my string           ]
!!      > [42     ]
!!      > [0.111111112         ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function rpad_scalar(valuein,length) result(strout)

! ident_41="@(#) M_strings rpad_scalar(3f) return value padded to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present(length))then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = pad(valuein,local_length,' ',clip=.true.)
         return
      class default
         stop '<ERROR>*rpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true. )
   else
      strout = crop( line )
   endif

end function rpad_scalar
!===================================================================================================================================
function rpad_vector(valuein,length) result(strout)

! ident_42="@(#) M_strings rpad_vector(3f) return strings or arguments converted to string right-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(rpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=rpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function rpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    cpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    centers the string to specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function cpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    cpad(3f) converts a scalar value to a cropped string and then pads
!!    it with spaces to center it to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded with spaces to
!!             center it at the the specified length if shorter than
!!             length. The input may be any intrinsic scalar which is
!!             converted to a cropped string much as if written with
!!             list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string center-padded to the requested length
!!            with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_cpad
!!       use M_strings, only : cpad
!!       implicit none
!!          write(*,'("[",a,"]")') cpad( 'my string', 20)
!!          write(*,'("[",a,"]")') cpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string', 20)
!!          write(*,'("[",a,"]")') cpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') cpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') cpad( valuein=1.0/9.0 , length=20)
!!      end program demo_cpad
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function cpad_scalar(valuein,length) result(strout)

! ident_43="@(#) M_strings cpad_scalar(3f) convert value to string center-padded to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write( line, '(i0)' ) valuein
      type is (integer(kind=int16));   write( line, '(i0)' ) valuein
      type is (integer(kind=int32));   write( line, '(i0)' ) valuein
      type is (integer(kind=int64));   write( line, '(i0)' ) valuein
      type is (real(kind=real32));     write( line, '(1pg0)' ) valuein
      type is (real(kind=real64));     write( line, '(1pg0)' ) valuein
      type is (logical);               write( line, '(l1)' ) valuein
      type is (complex);               write( line, '("(",1pg0,",",1pg0,")")' ) valuein
      type is (character(len = *))
         if(present( length ) )then
            local_length = length
         else
            local_length = len(valuein)
         endif
         strout = adjustc( crop(valuein), local_length )
         return
      class default
         stop '<ERROR>*cpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = adjustc( crop(line), length )
   else
      strout = crop( line )
   endif

end function cpad_scalar
!===================================================================================================================================
function cpad_vector(valuein,length) result(strout)

! ident_44="@(#) M_strings cpad_vector(3f) return strings or arguments converted to string center-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(cpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=cpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function cpad_vector
!===================================================================================================================================
!>
!!
!!##NAME
!!    lpad(3f) - [M_strings:LENGTH] convert to a cropped string and then
!!    blank-pad on the left to requested length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lpad(valuein,length) result(strout)
!!
!!     class*,intent(in)  :: valuein(..)
!!     integer,intent(in) :: length
!!
!!##DESCRIPTION
!!    lpad(3f) converts a scalar value to a cropped string and then pads
!!    it on the left with spaces to at least the specified length. If
!!    the trimmed input is longer than the requested length the string is
!!    returned trimmed of leading and trailing spaces.
!!
!!##OPTIONS
!!    str      The input may be scalar or a vector.
!!             the input value to return as a string, padded on the left to
!!             the specified length if shorter than length. The input may be
!!             any intrinsic scalar which is converted to a cropped string
!!             much as if written with list-directed output.
!!    length   The minimum string length to return
!!
!!##RETURNS
!!    strout  The input string padded to the requested length
!!            on the left with spaces.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_lpad
!!       use M_strings, only : lpad
!!       implicit none
!!          write(*,'("[",a,"]")') lpad( 'my string', 20)
!!          write(*,'("[",a,"]")') lpad( 'my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string', 20)
!!          write(*,'("[",a,"]")') lpad( '   my string   ', 20)
!!          write(*,'("[",a,"]")') lpad( valuein=42 , length=7)
!!          write(*,'("[",a,"]")') lpad( valuein=1.0/9.0 , length=20)
!!      end program demo_lpad
!!
!! Results:
!!
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [           my string]
!!     > [     42]
!!     > [         0.111111112]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lpad_scalar(valuein,length) result(strout)

! ident_45="@(#) M_strings lpad_scalar(3f) convert value to string padded on left to at least specified length"

class(*),intent(in)          :: valuein
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout

character(len=96)            :: line
integer                      :: local_length

   select type(valuein)
      type is (integer(kind=int8));    write(line,'(i0)') valuein
      type is (integer(kind=int16));   write(line,'(i0)') valuein
      type is (integer(kind=int32));   write(line,'(i0)') valuein
      type is (integer(kind=int64));   write(line,'(i0)') valuein
      type is (real(kind=real32));     write(line,'(1pg0)') valuein
      type is (real(kind=real64));     write(line,'(1pg0)') valuein
      type is (logical);               write(line,'(l1)') valuein
      type is (complex);               write(line,'("(",1pg0,",",1pg0,")")') valuein
      type is (character(len=*))
         if(present( length ))then
            local_length=length
         else
            local_length=len( valuein )
         endif
         strout = pad( valuein, local_length, ' ', right=.false., clip=.true. )
         return
      class default
         stop '<ERROR>*lpad_scalar* unknown type'
   end select

   if(present(length))then
      strout = pad( line, length, ' ', clip=.true., right=.false. )
   else
      strout = crop( line )
   endif

end function lpad_scalar
!===================================================================================================================================
function lpad_vector(valuein,length) result(strout)

! ident_46="@(#) M_strings lpad_vector(3f) return vector of strings or arguments converted to string left-padded to at least specified length"

class(*),intent(in)          :: valuein(:)
integer,intent(in),optional  :: length
character(len=:),allocatable :: strout(:)
integer                      :: i
integer                      :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(lpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=lpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function lpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    zpad(3f) - [M_strings:LENGTH] pad a string on the left with zeros to
!!    specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function zpad(valuein,length) result(strout)
!!
!!     class*,intent(in)           :: valuein(..)
!!     integer,intent(in),optional :: length
!!
!!##DESCRIPTION
!!    zpad(3f) crops the input string (or integer, which will be converted
!!    to a string) and then pads it on the left with zeros to the specified
!!    length.
!!
!!    Note that if the trimmed input string is already as long or longer
!!    than the requested length the trimmed original string is returned.
!!
!!    For strings representing unsigned numbers this is basically an
!!    alias for
!!
!!        strout=pad(str,length,'0',clip=.true.,right=.false.)
!!
!!    For integers the same is often done with internal WRITE(3f) statements
!!    such as
!!
!!        write(strout,'(i5.5)')ivalue
!!
!!    but unlike internal I/O the function call can be used in expressions
!!    or passed as a procedure argument.
!!
!!##OPTIONS
!!    valuein  The input value to left-pad. May be a scalar or vector
!!             string or integer. If the leftmost non-blank character is
!!             a sign character it is moved to the left-most position of
!!             the output.
!!    length   The minimum string length to return. If not present, the
!!             length of the input parameter VALUEIN is used. If the input
!!             value VALUEIN is an integer no zero padding occurs if LENGTH
!!             is not supplied.
!!
!!##RETURNS
!!    strout  A trimmed string padded on the left with zeros to
!!            the requested length
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!      program demo_zpad
!!       use M_strings, only : zpad
!!       implicit none
!!       character(len=*),parameter :: boxed='("[",a,"]",*(g0,1x))'
!!       integer :: lun, i
!!          print boxed, zpad( '111', 5),'basic use'
!!          print boxed, zpad( valuein=42 , length=7),'by argument name'
!!          print boxed, zpad( '  34567  ', 7),'cropped before padding'
!!          print boxed, zpad( '123456789', 5),'input longer than length'
!!          print boxed, zpad( '  +34567  ', 7),'starts with plus sign'
!!          print boxed, zpad( '  -34567  ', 7),'starts with minus sign'
!!          print boxed, zpad(1234),'some integers instead of strings'
!!          print boxed, zpad(-1234)
!!          print boxed, zpad(1234,8)
!!          print boxed, zpad(-1234,8)
!!          print boxed, zpad(''),'a null gets you nothing'
!!          print boxed, zpad('0'),'but blanks are used for default length'
!!          print boxed, zpad('0    ')
!!          print boxed, zpad('     ')
!!          print *, 'input value may be an array:'
!!          print '("[",a,"]")', zpad([1,10,100,1000,10000,100000],8)
!!
!!          ! example usage:
!!          ! open output_00085.dat
!!          i=85
!!          open(newunit=lun,file='output_'//zpad(i,5)//'.dat')
!!          close(unit=lun,status='delete')
!!
!!      end program demo_zpad
!!
!! Results:
!!
!!     > [00111]basic use
!!     > [0000042]by argument name
!!     > [0034567]cropped before padding
!!     > [123456789]input longer than length
!!     > [+0034567]starts with plus sign
!!     > [-0034567]starts with minus sign
!!     > [1234]some integers instead of strings
!!     > [-1234]
!!     > [00001234]
!!     > [-00001234]
!!     > []a null gets you nothing
!!     > [0]but blanks are used for default length
!!     > [00000]
!!     > [00000]
!!     >  input value may be an array:
!!     > [00000001]
!!     > [00000010]
!!     > [00000100]
!!     > [00001000]
!!     > [00010000]
!!     > [00100000]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function zpad_scalar(valuein,length) result(strout)

! ident_47="@(#) M_strings zpad_vector(3f) return string or argument converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout
character(len=4096)              :: line
integer                          :: local_length
   if(present(length))then
      local_length=length
   else
      local_length=-1
   endif
   select type(valuein)
      type is (integer(kind=int8));     write(line,'(i0)') valuein
      type is (integer(kind=int16));    write(line,'(i0)') valuein
      type is (integer(kind=int32));    write(line,'(i0)') valuein
      type is (integer(kind=int64));    write(line,'(i0)') valuein
      type is (real(kind=real32));      write(line,'(1pg0)') valuein
      type is (real(kind=real64));      write(line,'(1pg0)') valuein
      type is (logical);                write(line,'(l1)') valuein
      type is (character(len=*));       line=valuein
         if(local_length==-1)local_length=len(valuein)
      type is (complex);                write(line,'("(",1pg0,",",1pg0,")")') valuein
   end select
   if(local_length == -1)then
     strout=clip(line)
   else
      line=clip(line)//'  '
      if(scan(line(1:1),'+-') == 1)then
         strout= line(1:1)//pad(line(2:),local_length,'0',clip=.true.,right=.false.)
      else
         strout= pad(line,local_length,'0',clip=.true.,right=.false.)
      endif
   endif
end function zpad_scalar
!===================================================================================================================================
function zpad_vector(valuein,length) result(strout)

! ident_48="@(#) M_strings zpad_vector(3f) return vector of strings or arguments converted to string zero-padded to at least specified length"

class(*),intent(in)              :: valuein(:)
integer,intent(in),optional      :: length
character(len=:),allocatable     :: strout(:)
integer                          :: i
integer                          :: mxlen
   if(present(length))then
      allocate(character(len=length) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),length)
      enddo
   else  ! doing this twice is a lot of overhead
      mxlen=0
      do i=1,size(valuein)
         mxlen=max(mxlen, len_trim(zpad_scalar(valuein(i))) )
      enddo
      allocate(character(len=mxlen) :: strout(size(valuein) ))
      do i=1,size(valuein)
         strout(i)=zpad_scalar(valuein(i),mxlen)
      enddo
   endif
end function zpad_vector
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   pad(3f) - [M_strings:LENGTH] return string padded to at least
!!   specified length
!!   (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   function pad(str,length,pattern,right,clip) result(strout)
!!
!!    character(len=*)                           :: str
!!    integer,intent(in)                         :: length
!!    character(len=max(length,len(trim(line)))) :: strout
!!    character(len=*),intent(in),optional       :: pattern
!!    logical,intent(in),optional                :: right
!!    logical,intent(in),optional                :: clip
!!
!!##DESCRIPTION
!!   pad(3f) pads a string with a pattern to at least the specified
!!   length. If the trimmed input string is longer than the requested
!!   length the trimmed string is returned.
!!
!!##OPTIONS
!!   str      the input string to return trimmed, but then padded to
!!            the specified length if shorter than length
!!   length   The minimum string length to return
!!   pattern  optional string to use as padding. Defaults to a space.
!!   right    if true pads string on the right, else on the left
!!   clip     trim spaces from input string but otherwise retain length.
!!            Except for simple cases you typically would trim the input
!!            yourself.
!!
!!##RETURNS
!!   strout  The input string padded to the requested length or
!!           the trimmed input string if the input string is
!!           longer than the requested length.
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!    program demo_pad
!!     use M_strings, only : pad
!!     implicit none
!!     character(len=10)            :: string='abcdefghij'
!!     character(len=:),allocatable :: answer
!!     integer                      :: i
!!     character(len=*),parameter   :: g='(*(g0))'
!!        answer=pad(string,5)
!!        write(*,'("[",a,"]")') answer
!!        answer=pad(string,20)
!!        write(*,'("[",a,"]")') answer
!!        i=30
!!        write(*,g)
!!        write(*,'(1x,a,1x,i0)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!        write(*,*)
!!        write(*,'(1x,a,i7)') &
!!         & pad('CHAPTER 1 : The beginning ',i,'.'), 1   , &
!!         & pad('CHAPTER 2 : The end ',i,'.'),       1234, &
!!         & pad('APPENDIX ',i,'.'),                  1235
!!
!!         write(*,g)pad('12',5,'0',right=.false.)
!!
!!         write(*,g)pad('12345 ',30,'_',right=.false.)
!!         write(*,g)pad('12345 ',30,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.)
!!         write(*,g)pad('12345 ',7,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.)
!!         write(*,g)pad('12345 ',6,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.)
!!         write(*,g)pad('12345 ',5,'_',right=.false.,clip=.true.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.)
!!         write(*,g)pad('12345 ',4,'_',right=.false.,clip=.true.)
!!    end program demo_pad
!!
!!  Results:
!!
!!  > [abcdefghij]
!!  > [abcdefghij          ]
!!  >
!!  >  CHAPTER 1 : The beginning .... 1
!!  >  CHAPTER 2 : The end .......... 1234
!!  >  APPENDIX ..................... 1235
!!  >
!!  >  CHAPTER 1 : The beginning ....      1
!!  >  CHAPTER 2 : The end ..........   1234
!!  >  APPENDIX .....................   1235
!!  > 00012
!!  > ________________________12345
!!  > _________________________12345
!!  > _12345
!!  > __12345
!!  > 12345
!!  > _12345
!!  > 12345
!!  > 12345
!!  > 12345
!!  > 12345
!!
!!##SEE ALSO
!!     adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f)
!!
!!     adjustc(3f), stretch(3f), lpad(3f), rpad(3f), cpad(3f), zpad(3f), lenset(3f)
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function pad(line,length,pattern,right,clip) result(strout)

!$@(#) M_strings::pad(3f): return string padded to at least specified length

character(len=*),intent(in)          :: line
integer,intent(in)                   :: length
character(len=*),intent(in),optional :: pattern
logical,optional,intent(in)          :: right
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: strout
logical                              :: local_right
logical                              :: local_clip
character(len=:),allocatable         :: local_pattern
character(len=:),allocatable         :: local_line

if(  present(right)    )then;  local_right=right;      else;  local_right=.true.;  endif
if(  present(clip)     )then;  local_clip=clip;        else;  local_clip=.false.;  endif
if(  present(pattern)  )then;  local_pattern=pattern;  else;  local_pattern=' ';   endif

if(len(local_pattern) == 0)then
   strout=line
else

   if(local_clip)then
      local_line=trim(adjustl(line))
      allocate(character(len=max(length,len(local_line))) :: strout)
   else
      local_line=line
      allocate(character(len=max(length,len(line))) :: strout)
   endif

   if(local_right)then
      strout(:)=local_line//repeat(local_pattern,len(strout)/len(local_pattern)+1)
   else
      strout(:)=repeat(local_pattern, ceiling(real(len(strout))/len(local_pattern)))
      strout(max(0,len(strout)-len(local_line))+1:)=local_line
   endif

endif
end function pad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lenset(3f) - [M_strings:LENGTH] return string trimmed or padded to
!!                 specified length
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function lenset(str,length) result(strout)
!!
!!     character(len=*)      :: str
!!     character(len=length) :: strout
!!     integer,intent(in)    :: length
!!
!!##DESCRIPTION
!!    lenset(3f) truncates a string or pads it with spaces to the specified
!!    length.
!!
!!##OPTIONS
!!    str     input string
!!    length  output string length
!!
!!##RETURNS
!!    strout  output string
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_lenset
!!      use M_strings, only : lenset
!!      implicit none
!!      character(len=10)            :: string='abcdefghij'
!!      character(len=:),allocatable :: answer
!!         answer=lenset(string,5)
!!         write(*,'("[",a,"]")') answer
!!         answer=lenset(string,20)
!!         write(*,'("[",a,"]")') answer
!!     end program demo_lenset
!!
!!    Expected output:
!!
!!     [abcde]
!!     [abcdefghij          ]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function lenset(line,length) result(strout)

! ident_49="@(#) M_strings lenset(3f) return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    merge_str(3f) - [M_strings:LENGTH] pads strings to same length and
!!    then calls MERGE(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function merge_str(str1,str2,expr) result(strout)
!!
!!     character(len=*),intent(in),optional :: str1
!!     character(len=*),intent(in),optional :: str2
!!     logical,intent(in)                   :: expr
!!     character(len=:),allocatable         :: strout
!!
!!##DESCRIPTION
!!    merge_str(3f) pads the shorter of str1 and str2 to the longest length
!!    of str1 and str2 and then calls MERGE(padded_str1,padded_str2,expr).
!!    It trims trailing spaces off the result and returns the trimmed
!!    string. This makes it easier to call MERGE(3f) with strings, as
!!    MERGE(3f) requires the strings to be the same length.
!!
!!    NOTE: STR1 and STR2 are always required even though declared optional.
!!          this is so the call "STR_MERGE(A,B,present(A))" is a valid call.
!!          The parameters STR1 and STR2 when they are optional parameters
!!          can be passed to a procedure if the options are optional on the
!!          called procedure.
!!
!!##OPTIONS
!!    STR1    string to return if the logical expression EXPR is true
!!    STR2    string to return if the logical expression EXPR is false
!!    EXPR    logical expression to evaluate to determine whether to return
!!            STR1 when true, and STR2 when false.
!!##RETURNS
!!     MERGE_STR  a trimmed string is returned that is otherwise the value
!!                of STR1 or STR2, depending on the logical expression EXPR.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!     program demo_merge_str
!!     use M_strings, only : merge_str
!!     implicit none
!!     character(len=:), allocatable :: answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 == 10)
!!        write(*,'("[",a,"]")') answer
!!        answer=merge_str('first string', &
!!         & 'second string is longer',10 /= 10)
!!        write(*,'("[",a,"]")') answer
!!     end program demo_merge_str
!!
!!   Expected output
!!
!!     [first string]
!!     [second string is longer]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

! ident_50="@(#) M_strings merge_str(3f) pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in),optional :: str1
character(len=*),intent(in),optional :: str2
character(len=:),allocatable         :: str1_local
character(len=:),allocatable         :: str2_local
logical,intent(in)                   :: expr
character(len=:),allocatable         :: strout
integer                              :: big
   if(present(str2))then
      str2_local=str2
   else
      str2_local=''
   endif
   if(present(str1))then
      str1_local=str1
   else
      str1_local=''
   endif
   big=max(len(str1_local),len(str2_local))
   ! note: perhaps it would be better to warn or fail if an optional value that is not present is returned, instead of returning ''
   strout=trim(merge(lenset(str1_local,big),lenset(str2_local,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    squeeze(3f) - [M_strings:EDITING] delete adjacent duplicate occurrences
!!    of a character from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function squeeze(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    squeeze(3f) reduces adjacent duplicates of the specified character
!!    to a single character
!!
!!##OPTIONS
!!    STR     input string in which to reduce adjacent duplicate characters
!!            to a single character
!!    CHAR    The character to remove adjacent duplicates of
!!
!!##RETURNS
!!    OUTSTR  string with all contiguous adjacent occurrences of CHAR removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_squeeze
!!    use M_strings, only : squeeze
!!    implicit none
!!    character(len=:),allocatable :: strings(:)
!!
!!    strings=[ character(len=72) :: &
!!    &'', &
!!    &'"If I were two-faced,&
!!    &would I be wearing this one?" --- Abraham Lincoln',  &
!!    &'..1111111111111111111&
!!    &111111111111111111111111111111111111111111117777888', &
!!    &'I never give ''em hell,&
!!    &I just tell the truth, and they think it''s hell.',&
!!    &'                                                  &
!!    & --- Harry S Truman'    &
!!    &]
!!       call printme( trim(strings(1)), ' ' )
!!       call printme( strings(2:4),     ['-','7','.'] )
!!       call printme( strings(5),       [' ','-','r'] )
!!    contains
!!    impure elemental subroutine printme(str,chr)
!!    character(len=*),intent(in) :: str
!!    character(len=1),intent(in) :: chr
!!    character(len=:),allocatable :: answer
!!       write(*,'(a)')repeat('=',11)
!!       write(*,'("IN:   <<<",g0,">>>")')str
!!       answer=squeeze(str,chr)
!!       write(*,'("OUT:  <<<",g0,">>>")')answer
!!       write(*,'("LENS: ",*(g0,1x))')"from",len(str),"to",len(answer), &
!!               & "for a change of",len(str)-len(answer)
!!       write(*,'("CHAR: ",g0)')chr
!!    end subroutine printme
!!    end program demo_squeeze
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function squeeze(str,charp) result (outstr)

character(len=*),intent(in)  :: str
character(len=1),intent(in)  :: charp
character(len=:),allocatable :: outstr
character(len=1)             :: ch, last_one
integer                      :: i, pio ! position in output

   outstr=repeat(' ',len(str))      ! start with a string big enough to hold any output
   if(len(outstr)==0)return         ! handle edge condition
   last_one=str(1:1)                ! since at least this long start output with first character
   outstr(1:1)=last_one
   pio=1

   do i=2,len(str)
      ch=str(i:i)
      pio=pio+merge(0,1, ch == last_one.and.ch == charp) ! decide whether to advance before saving
      outstr(pio:pio)=ch  ! store new one or overlay the duplication
      last_one=ch
   enddo

   outstr=outstr(:pio)              ! trim the output string to just what was set
end function squeeze
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace
!!    to a single character (or nothing)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function compact(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!
!!##DESCRIPTION
!!    COMPACT(3f) converts multiple spaces, tabs and control characters
!!    (called "whitespace") to a single character or nothing. Leading
!!    whitespace is removed.
!!
!!##OPTIONS
!!    STR     input string to reduce or remove whitespace from
!!    CHAR    By default the character that replaces adjacent
!!            whitespace is a space. If the optional CHAR parameter is supplied
!!            it will be used to replace the whitespace. If a null character is
!!            supplied for CHAR whitespace is removed.
!!
!!##RETURNS
!!    OUTSTR  string of same length as input string but with all contiguous
!!            whitespace reduced to a single space and leading whitespace
!!            removed
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_compact
!!     use M_strings, only : compact
!!     implicit none
!!     ! produces 'This is a test               '
!!     write(*,*)compact('  This     is      a     test  ')
!!     ! produces 'Thisisatest                  '
!!     write(*,*)compact('  This     is      a     test  ',char='')
!!     ! produces 'This:is:a:test               '
!!     write(*,*)compact('  This     is      a     test  ',char=':')
!!     ! note CHAR is used to replace the whitespace, but if CHAR is
!!     ! in the original string it is just copied
!!     write(*,*)compact('A  AA    A   AAAAA',char='A')
!!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
!!     ! not 'A'
!!    end program demo_compact
!!
!!    Expected output
!!
!!     >This is a test
!!     >Thisisatest
!!     >This:is:a:test
!!     >AAAAAAAAAAAA
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

! ident_51="@(#) M_strings compact(3f) Converts white-space to single spaces; removes leading spaces"

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char) == 0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(iachar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output == 0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   enddo IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     noesc(3f) - [M_strings:NONALPHA] convert non-printable characters
!!     to a space
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental function noesc(INSTR)
!!
!!     character(len=*),intent(in) :: INSTR
!!     character(len=len(instr))   :: noesc
!!
!!##DESCRIPTION
!!      Convert non-printable characters to a space.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_noesc
!!
!!     use M_strings, only : noesc
!!     implicit none
!!     character(len=128) :: ascii
!!     character(len=128) :: cleared
!!     integer            :: i
!!     ! fill variable with base ASCII character set
!!     do i=1,128
!!        ascii(i:i)=char(i-1)
!!     enddo
!!     cleared=noesc(ascii)
!!     write(*,*)'characters and their ADE (ASCII Decimal Equivalent)'
!!     call ade(ascii)
!!     write(*,*)'Cleared of non-printable characters'
!!     call ade(cleared)
!!     write(*,*)'Cleared string:'
!!     write(*,*)cleared
!!     contains
!!       subroutine ade(string)
!!       implicit none
!!       ! the string to print
!!       character(len=*),intent(in) :: string
!!       ! number of characters in string to print
!!       integer :: lgth
!!       ! counter used to step thru string
!!       integer :: i
!!          ! get trimmed length of input string
!!          lgth=len_trim(string(:len(string)))
!!
!!          ! replace lower unprintable characters with spaces
!!          write(*,101)(merge(string(i:i),' ',&
!!          & iachar(string(i:i)) >= 32        &
!!          & .and.                            &
!!          & iachar(string(i:i)) <= 126)      &
!!          & ,i=1,lgth)
!!
!!          ! print ADE value of character underneath it
!!          write(*,202)     (iachar(string(i:i))/100,    i=1,lgth)
!!          write(*,202)(mod( iachar(string(i:i)),100)/10,i=1,lgth)
!!          write(*,202)(mod((iachar(string(i:i))),10),   i=1,lgth)
!!       ! format for printing string characters
!!       101   format(*(a1:))
!!       ! format for printing ADE values
!!       202   format(*(i1:))
!!       end subroutine ade
!!     end program demo_noesc
!!
!!    Expected output
!!
!!    The string is printed with the ADE value vertically beneath.
!!    The original string has all the ADEs from 000 to 127. After
!!    NOESC(3f) is called on the string all the "non-printable"
!!    characters are replaced with a space (ADE of 032).
!!
!!   characters and their ADE (ASCII Decimal Equivalent)
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    0000000000000000000000000000000000000000001111111111111111111111111111
!!    >00000000001111111111222222222233333333334444444444555555555566666666
!!    667777777777888888888899999999990000000000111111111122222222
!!    >012345678901234567890123456789012345678901234567890123456789012345678
!!    90123456789012345678901234567890123456789012345678901234567
!!
!!   Cleared of non-printable characters
!!
!!    >                                 !"#$%&'()*+,-./0123456789
!!    :;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!    >0000000000000000000000000000000000000000000000000000000000
!!    000000000000000000000000000000000000000000111111111111111111111111111
!!    >3333333333333333333333333333333333333333444444444455555555
!!    556666666666777777777788888888889999999999000000000011111111112222222
!!    >2222222222222222222222222222222223456789012345678901234567
!!    890123456789012345678901234567890123456789012345678901234567890123456
!!
!!   Cleared string:
!!
!!    >                                  !"#$%&'()*+,-./0123456789:;<=>?@
!!    ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function noesc(INSTR)

! ident_52="@(#) M_strings noesc(3f) convert non-printable characters to a space"

character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
!-----------------------------------------------------------------------------------------------------------------------------------
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_value(3f) - [M_strings:TYPE] subroutine returns numeric
!!      value from string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine string_to_value(chars,valu,ierr)
!!
!!     character(len=*),intent(in)              :: chars   ! input string
!!     integer|real|doubleprecision,intent(out) :: valu
!!     integer,intent(out)                      :: ierr
!!
!!##DESCRIPTION
!!    Returns a numeric value from a numeric character string.
!!
!!    Works with any g-format input, including integer, real, and
!!    exponential. If the input string begins with "B", "Z", or "O"
!!    and otherwise represents a positive whole number it is assumed to
!!    be a binary, hexadecimal, or octal value. If the string contains
!!    commas they are removed. If the string is of the form NN:MMM... or
!!    NN#MMM then NN is assumed to be the base of the whole number.
!!
!!    If an error occurs in the READ, IOSTAT is returned in IERR and
!!    value is set to zero. if no error occurs, IERR=0.
!!
!!##OPTIONS
!!       CHARS  input string to read numeric value from
!!
!!##RETURNS
!!    VALU   numeric value returned. May be INTEGER, REAL, or
!!              DOUBLEPRECISION.
!!    IERR   error flag (0 == no error)
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_string_to_value
!!     use M_strings, only: string_to_value
!!     implicit none
!!     real :: value
!!     integer :: ierr
!!     character(len=80) :: string
!!        string=' -40.5e-2 '
!!        call string_to_value(string,value,ierr)
!!        write(*,*) 'value of string ['//trim(string)//'] is ',value
!!    end program demo_string_to_value
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine a2r(chars,valu,ierr)

! ident_53="@(#) M_strings a2r(3fp) subroutine returns real value from string"

character(len=*),intent(in) :: chars                      ! input string
real,intent(out)            :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(ierr == 0)then
      if(valu8 <= huge(valu))then
         valu=real(valu8)
      else
         call journal('sc','*a2r* - value too large'//str(valu8)//'>'//str(huge(valu)))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2r
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2i(chars,valu,ierr)

! ident_54="@(#) M_strings a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i* - value too large'//str(valu8)//'>'//str(huge(valu)))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_55="@(#) M_strings a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!    IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                           ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                            ! value read from input string
integer,intent(out)          :: ierr                            ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"        ! format used to build frmt
character(len=15)            :: frmt                            ! holds format built to read input string
character(len=256)           :: iomsg                           ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   iomsg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=iomsg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=iomsg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=iomsg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                              ! print warning message except for special value "eod"
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(iomsg /= '')then
            call journal('sc','*a2d* - ['//trim(iomsg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    s2v(3f) - [M_strings:TYPE] function returns doubleprecision
!!    numeric value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2v(string[,ierr][,onerr])
!!
!!     character(len=*)             :: string
!!     doubleprecision              :: s2v
!!     integer,intent(out),optional :: ierr
!!     class(*),intent(in),optional :: onerr
!!
!!##DESCRIPTION
!!    This function converts a string to a DOUBLEPRECISION numeric value.
!!
!!    The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended
!!    to take CHARACTER variables. The KIND= keyword is not supported
!!    on the extensions.
!!
!!##OPTIONS
!!
!!     string   holds string assumed to represent a numeric value
!!     ierr     If an error occurs the program is stopped if the optional
!!              parameter IERR is not present. If IERR returns a non-zero
!!              value an error occurred.
!!     onerr    The value to return on error. A value of NaN is
!!              returned on error by default.
!!
!!##RETURNS
!!     s2v      numeric value read from string
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_s2v
!!
!!     use M_strings, only: s2v, int, real, dble
!!     implicit none
!!     character(len=8)              :: s=' 10.345 '
!!     integer                       :: i
!!     character(len=14),allocatable :: strings(:)
!!     doubleprecision               :: dv
!!     integer                       :: errnum
!!
!!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!     strings=[&
!!     &' 10.345       ',&
!!     &'+10           ',&
!!     &'    -3        ',&
!!     &'    -4.94e-2  ',&
!!     &'0.1           ',&
!!     &'12345.678910d0',&
!!     &'              ',& ! Note: will return zero without an error message
!!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!     &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!     ! a numeric value is returned,
!!     ! so it can be used in numeric expression
!!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
!!     write(*,*)
!!     write(*,*)' STRING            VALUE                    ERROR_NUMBER'
!!     do i=1,size(strings)
!!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
!!        ! as it does I/O when errors occur, so called on a separate line
!!        dv=s2v(strings(i),errnum)
!!        write(*,*) strings(i)//'=',dv,errnum
!!     enddo
!!     write(*,*)"Extended intrinsics"
!!     write(*,*)'given inputs:',s,strings(:8)
!!     write(*,*)'INT(3f):',int(s),int(strings(:8))
!!     write(*,*)'REAL(3f):',real(s),real(strings(:8))
!!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
!!     write(*,*)"That's all folks!"
!!
!!     end program demo_s2v
!!
!!    Expected output
!!
!!     >1/2 value of string is    5.1725000000000003
!!     >
!!     > STRING            VALUE                    ERROR_NUMBER
!!     > 10.345       =   10.345000000000001                0
!!     >+10           =   10.000000000000000                0
!!     >    -3        =  -3.0000000000000000                0
!!     >    -4.94e-2  =  -4.9399999999999999E-002           0
!!     >0.1           =  0.10000000000000001                0
!!     >12345.678910d0=   12345.678910000001                0
!!     >              =   0.0000000000000000                0
!!     >1 2 1 2 1 . 0 =   12121.000000000000                0
!!     >*a2d* - cannot produce number from string [WHAT?]
!!     >*a2d* - [Bad value during floating point read]
!!     >WHAT?         =   0.0000000000000000             5010
!!     >Extended intrinsics
!!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1
!!     12345.678910d0 1 2 1 2 1 . 0
!!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121
!!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000
!!     -4.94000018E-02
!!     >          0.100000001 12345.6787 0.00000000 12121.0000
!!     >DBLE(3f): 10.345000000000001 10.345000000000001
!!     10.000000000000000
!!     >          -3.0000000000000000 -4.9399999999999999E-002
!!     0.10000000000000001
!!     >          12345.678910000001 0.0000000000000000
!!     12121.000000000000
!!     >That's all folks!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!!##PROCEDURE:
!! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs
!!##VERSION:     2.0, 20160704
!! AUTHOR:      John S. Urban
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

! ident_56="@(#) M_strings s2v(3f) returns doubleprecision number from string;zero if error occurs"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(stderr,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      dble(3f) - [M_strings:TYPE] overloads DBLE(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function dble(string)
!!
!!     character(len=*) :: string
!!     integer          :: dble
!!
!!##DESCRIPTION
!!    dble(3f) returns a DOUBLE value when given a numeric representation of a
!!    numeric value. This overloads the DBLE(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a dble value
!!
!!##RETURNS
!!    DBLE  double precision value represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_dble
!!      use M_strings, only: dble
!!      implicit none
!!      write(*,*)dble('100'),dble('20.4')
!!      write(*,*)'dble still works',dble(20),dble(20.4)
!!      write(*,*)'elemental',&
!!      & dble([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_dble
!!
!! Results:
!!
!!      >    100.00000000000000        20.399999999999999
!!      >  dble still works   20.000000000000000 20.399999618530273
!!      >  elemental   10.00000000000000  20.30000000000000
!!      >  20.50000000000000 20.60000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      real(3f) - [M_strings:TYPE] overloads REAL(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function real(string)
!!
!!     character(len=*) :: string
!!     integer          :: real
!!
!!##DESCRIPTION
!!    real(3f) returns a REAL value when given a numeric representation of a
!!    numeric value. This overloads the REAL(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to a real value
!!
!!##RETURNS
!!       REAL  real value represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_real
!!      use M_strings, only: real
!!      implicit none
!!      write(*,*)real('100'),real('20.4')
!!      write(*,*)'real still works',real(20)
!!      write(*,*)'elemental',&
!!      & real([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_real
!!
!! Results:
!!
!!      >    100.000000       20.3999996
!!      >  real still works   20.0000000
!!      >  elemental   10.0000000  20.2999992  20.5000000  20.6000004
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      int(3f) - [M_strings:TYPE] overloads INT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function int(string)
!!
!!     character(len=*)    :: string
!!     integer(kind=int32) :: int
!!
!!##DESCRIPTION
!!    int(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the INT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an INT32 integer
!!
!!##RETURNS
!!       INT  integer represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_int
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: int
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)int('100'),int('20.4')
!!         write(*,g)'intrinsic int(3f) still works',int(20,int32)
!!         write(*,g)'elemental',&
!!         & int([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_int
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic int(3f) still works 20
!!     > elemental 10 20 20 20
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      nint(3f) - [M_strings:TYPE] overloads NINT(3f) so it can handle character arguments
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental function nint(string)
!!
!!     character(len=*) :: string
!!     integer          :: nint
!!
!!##DESCRIPTION
!!    nint(3f) returns an integer when given a numeric representation of a
!!    numeric value. This overloads the NINT(3f) intrinsic so that CHARACTER
!!    arguments assumed to represent a numeric value may be input.
!!
!!##OPTIONS
!!       STRING  input string to be converted to an integer
!!
!!##RETURNS
!!       NINT  integer represented by input string
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_nint
!!      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!      use M_strings, only: nint
!!      implicit none
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)nint('100'),nint('20.4')
!!         write(*,g)'intrinsic nint(3f) still works',nint(20.4)
!!         write(*,g)'elemental',&
!!         & nint([character(len=23) :: '10','20.3','20.5','20.6'])
!!      end program demo_nint
!!
!! Results:
!!
!!     > 100 20
!!     > intrinsic nint(3f) still works 20
!!     > elemental 10 20 21 21
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
impure elemental integer function nint_s2v(chars)
character(len=*),intent(in) :: chars
   nint_s2v=nint(s2v(chars))
end function nint_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_strings:TYPE] return numeric string
!!      from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,lgth,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)           :: value
!!     real,intent(in)                      :: value
!!     integer,intent(in)                   :: value
!!     logical,intent(in)                   :: value
!!     !--------
!!     character(len=*),intent(out)         :: chars
!!     integer,intent(out),optional         :: lgth
!!     integer,optional                     :: ierr
!!     character(len=*),intent(in),optional :: fmt
!!     logical,intent(in)                   :: trimz
!!
!!##DESCRIPTION
!!    value_to_string(3f) returns a numeric representation of a numeric
!!    value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the string using internal writes. It
!!    then removes trailing zeros from non-zero values, and left-justifies
!!    the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT
!!               if longer.
!!       LGTH    position of last non-blank character in returned string;
!!               optional.
!!       IERR    If not zero, error occurred; optional.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_value_to_string
!!      use M_strings, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: lgth
!!         call value_to_string(3.0/4.0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(3.0/4.0,string,lgth,fmt='')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string&
!!         &(3.0/4.0,string,lgth,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1234,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,lgth)
!!         write(*,*) 'The value is [',string(:lgth),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

! ident_57="@(#) M_strings value_to_string(3fp) subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: iomsg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=iomsg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=iomsg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
       ! cannot currently do I/O from a function being called from I/O
       !write(stderr,'(a)')'*value_to_string* WARNING:['//trim(iomsg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(iomsg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      v2s(3f) - [M_strings:TYPE] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function v2s(value) result(outstr)
!!
!!        integer|real|doubleprecision|logical,intent(in ) :: value
!!        character(len=:),allocatable                     :: outstr
!!        character(len=*),optional,intent(in)             :: fmt
!!
!!##DESCRIPTION
!!    v2s(3f) returns a representation of a numeric value as a
!!    string when given a numeric value of type REAL, DOUBLEPRECISION,
!!    INTEGER or LOGICAL. It creates the strings using internal WRITE()
!!    statements. Trailing zeros are removed from non-zero values, and the
!!    string is left-justified.
!!
!!##OPTIONS
!!    VALUE   input value to be converted to a string
!!    FMT     format can be explicitly given, but is limited to
!!            generating a string of eighty or less characters.
!!
!!##RETURNS
!!    OUTSTR  returned string representing input value,
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_v2s
!!    use M_strings, only: v2s
!!    write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
!!    write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
!!    write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
!!    write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
!!    write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
!!    end program demo_v2s
!!
!!   Expected output
!!
!!     The value of 3.0/4.0 is [0.75]
!!     The value of 1234    is [1234]
!!     The value of 0d0     is [0]
!!     The value of .false. is [F]
!!     The value of .true. is  [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function d2s(dvalue,fmt) result(outstr)

! ident_58="@(#) M_strings d2s(3fp) private function returns string given doubleprecision value"

doubleprecision,intent(in)           :: dvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(dvalue,string,fmt=fmt)
   else
      call value_to_string(dvalue,string)
   endif
   outstr=trim(string)
end function d2s
!===================================================================================================================================
function r2s(rvalue,fmt) result(outstr)

! ident_59="@(#) M_strings r2s(3fp) private function returns string given real value"

real,intent(in)                      :: rvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(rvalue,string,fmt=fmt)
   else
      call value_to_string(rvalue,string)
   endif
   outstr=trim(string)
end function r2s
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

! ident_60="@(#) M_strings i2s(3fp) private function returns string given integer value"

integer,intent(in)                   :: ivalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
function l2s(lvalue,fmt) result(outstr)

! ident_61="@(#) M_strings l2s(3fp) private function returns string given logical value"

logical,intent(in)                   :: lvalue                  ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable         :: outstr                  ! output string to generate
character(len=80)                    :: string
   if(present(fmt))then
      call value_to_string(lvalue,string,fmt=fmt)
   else
      call value_to_string(lvalue,string)
   endif
   outstr=trim(string)
end function l2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isnumber(3f) - [M_strings:TYPE] determine if a string represents a number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function isnumber(str,msg)
!!
!!     character(len=*),intent(in)  :: str
!!     character(len=:),intent(out),allocatable,optional  :: msg
!!
!!##DESCRIPTION
!!     ISNUMBER(3f) returns a value greater than zero if the string represents
!!     a number, and a number less than or equal to zero if it is a bad number.
!!     Blank characters are ignored.
!!
!!##OPTIONS
!!     str  the string to evaluate as to whether it represents a numeric value
!!          or not
!!     msg  An optional message describing the string
!!
!!##RETURNS
!!     isnumber  the following values are returned
!!
!!                1 for an integer             [-+]NNNNN
!!                2 for a whole number         [-+]NNNNN.
!!                3 for a real value           [-+]NNNNN.MMMM
!!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!!
!!               values less than 1 represent an error
!!
!!##EXAMPLES
!!
!!   As the example shows, you can use an internal READ(3f) along with the
!!   IOSTAT= parameter to check (and read) a string as well.
!!
!!     program demo_isnumber
!!     use M_strings, only : isnumber
!!     implicit none
!!     character(len=256)           :: line
!!     real                         :: value
!!     integer                      :: ios1, ios2
!!     integer                      :: answer
!!     character(len=256)           :: message
!!     character(len=:),allocatable :: description
!!        write(*,*)'Begin entering values, one per line'
!!        do
!!           read(*,'(a)',iostat=ios1)line
!!           !
!!           ! try string as number using list-directed input
!!           line=''
!!           read(line,*,iostat=ios2,iomsg=message) value
!!           if(ios2 == 0)then
!!              write(*,*)'VALUE=',value
!!           elseif( is_iostat_end(ios1) ) then
!!              stop 'end of file'
!!           else
!!              write(*,*)'ERROR:',ios2,trim(message)
!!           endif
!!           !
!!           ! try string using isnumber(3f)
!!           answer=isnumber(line,msg=description)
!!           if(answer > 0)then
!!              write(*,*) &
!!              & ' for ',trim(line),' ',answer,':',description
!!           else
!!              write(*,*) &
!!              & ' ERROR for ',trim(line),' ',answer,':',description
!!           endif
!!           !
!!        enddo
!!     end program demo_isnumber
!!
!!  Example run
!!
!!    > Begin entering values
!!    > ERROR:          -1 End of file
!!    >  ERROR for            -1 :null string
!!    >10
!!    > VALUE=   10.0000000
!!    >  for 10            1 :integer
!!    >20
!!    > VALUE=   20.0000000
!!    >  for 20            1 :integer
!!    >20.
!!    > VALUE=   20.0000000
!!    >  for 20.            2 :whole number
!!    >30.1
!!    > VALUE=   30.1000004
!!    >  for 30.1            3 :real number
!!    >3e1
!!    > VALUE=   30.0000000
!!    >  for 3e1            4 :value with exponent
!!    >1-2
!!    > VALUE=   9.99999978E-03
!!    >  for 1-2            4 :value with exponent
!!    >100.22d-4
!!    > VALUE=   1.00220004E-02
!!    >  for 100.22d-4            4 :value with exponent
!!    >1--2
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1--2           -5 :bad number
!!    >e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e           -6 :missing leading value before exponent
!!    >e1
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for e1           -6 :missing leading value before exponent
!!    >1e
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e           -3 :missing exponent
!!    >1e+
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+           -4 :missing exponent after sign
!!    >1e+2.0
!!    > ERROR:        5010 Bad real number in item 1 of list input
!!    >  ERROR for 1e+2.0           -5 :bad number
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function isNumber(string,msg,verbose)

! ident_62="@(#) M_strings isnumber(3f) Determines if a string is a number of not."

character(len=*),intent(in)                       :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                       :: verbose
integer                                           :: isnumber

integer                                           :: i,iend
character(len=1),allocatable                      :: z(:)
character(len=:),allocatable                      :: message
logical                                           :: founddigit
logical                                           :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=switch(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                 ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros_(3fp) - [M_strings:TYPE] Delete trailing zeros from
!!    numeric decimal string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine trimzeros_(str)
!!
!!     character(len=*)  :: str
!!
!!##DESCRIPTION
!!    TRIMZEROS_(3f) deletes trailing zeros from a string representing a
!!    number. If the resulting string would end in a decimal point, one
!!    trailing zero is added.
!!
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have
!!          trailing zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros_
!!       !use M_strings, only : trimzeros_
!!       character(len=:),allocatable :: string
!!          string= '123.450000000000'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.'
!!          call trimzeros_(string)
!!          write(*,*)string
!!          string='12345.00e3'
!!          call trimzeros_(string)
!!          write(*,*)string
!!       end program demo_trimzeros_
!!
!!   Results:
!!
!!     > 123.45
!!     > 12345
!!     > 12345
!!     > 12345e3
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine trimzeros_(string)

! ident_63="@(#) M_strings trimzeros_(3fp) Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)               :: string
character(len=len(string) + 2) :: str
character(len=len(string))     :: exp        ! the exponent string if present
integer                        :: ipos       ! where exponent letter appears if present
integer                        :: i, ii
   str = string                              ! working copy of string
   ipos = scan(str, 'eEdD')                  ! find end of real number if string uses exponent notation
   if (ipos > 0) then                        ! letter was found
      exp = str(ipos:)                       ! keep exponent string so it can be added back as a suffix
      str = str(1:ipos - 1)                  ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if (index(str, '.') == 0) then            ! if no decimal character in original string add one to end of string
      ii = len_trim(str)
      str(ii + 1:ii + 1) = '.'               ! add decimal to end of string
   endif
   do i = len_trim(str), 1, -1               ! scanning from end find a non-zero character
      select case (str(i:i))
      case ('0')                             ! found a trailing zero so keep trimming
         cycle
      case ('.')                             ! found a decimal character at end of remaining string
         if (i <= 1) then
            str = '0'
         else
            str = str(1:i - 1)
         endif
         exit
      case default
         str = str(1:i)                      ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if (ipos > 0) then                        ! if originally had an exponent place it back on
      string = trim(str)//trim(exp)
   else
      string = str
   endif
end subroutine trimzeros_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    listout(3f) - [M_strings:NUMERIC] expand a list of numbers where negative
!!    numbers denote range ends (1 -10 means 1 thru 10)
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine listout(icurve_lists,icurve_expanded,inums,ierr)
!!
!!    integer,intent(in)    :: icurve_lists(:)
!!    integer,intent(out)   :: icurve_expanded(:)
!!    integer,intent(out)   :: inums
!!    integer,intent(out)   :: ierr
!!
!!##DESCRIPTION
!!    expand a list of whole numbers where negative numbers indicate a range.
!!    So [10,-20] would be expanded to [10,11,12,13,14,15,16,17,18,19,20].
!!
!!##OPTIONS
!!    icurve_lists(:)      input array
!!
!!##RETURNS
!!    icurve_expanded(:)   output array; assumed large enough to hold
!!                         returned list
!!    inums                number of icurve_expanded numbers on output
!!    ierr                 zero if no error occurred
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_listout
!!     use M_strings, only : listout
!!     implicit none
!!     integer,allocatable :: icurve_lists(:)
!!     integer :: icurve_expanded(1000)
!!     ! icurve_lists is input array
!!     integer :: inums
!!     ! icurve_expanded is output array
!!     integer :: i
!!     ! number of icurve_lists values on input,
!!     ! number of icurve_expanded numbers on output
!!     integer :: ierr
!!        icurve_lists=[1, 20, -30, 101, 100, 99, 100, -120, 222, -200]
!!        inums=size(icurve_lists)
!!        call listout(icurve_lists,icurve_expanded,inums,ierr)
!!        if(ierr == 0)then
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        else
!!           write(*,'(a,i0)')'error occurred in *listout* ',ierr
!!           write(*,'(i0)')(icurve_expanded(i),i=1,inums)
!!        endif
!!     end program demo_listout
!!
!! Results:
!!
!!     > 1 20 21 22 23
!!     > 24 25 26 27 28
!!     > 29 30 101 100 99
!!     > 100 101 102 103 104
!!     > 105 106 107 108 109
!!     > 110 111 112 113 114
!!     > 115 116 117 118 119
!!     > 120 222 221 220 219
!!     > 218 217 216 215 214
!!     > 213 212 211 210 209
!!     > 208 207 206 205 204
!!     > 203 202 201 200
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine listout(icurve_lists,icurve_expanded,inums_out,ierr)

! ident_64="@(#) M_strings listout(3f) copy icurve_lists to icurve_expanded expanding negative numbers to ranges (1 -10 means 1 thru 10)"

!   Created: 19971231
integer,intent(in)    :: icurve_lists(:)             ! input array
integer,intent(out)   :: icurve_expanded(:)          ! output array
integer,intent(out)   :: inums_out                   ! number of icurve_expanded numbers on output
integer,intent(out)   :: ierr                        ! status variable

character(len=80)     :: temp1
integer               :: i80, i90
integer               :: imin, imax
integer               :: idirection, icount
integer               :: iin
integer               :: inums_max

   ierr=0
   icurve_expanded=0                          ! initialize output array
   inums_out=0                                ! initialize number of significant values in output array

   inums_max=size(icurve_expanded)
   if(inums_max == 0)then
      ierr=-2
      return
   endif

   iin=size(icurve_lists)
   if(iin > 0)then
      icurve_expanded(1)=icurve_lists(1)
   endif

   icount=2
      do i90=2,iin
         if(icurve_lists(i90) < 0)then
            imax=abs(icurve_lists(i90))
            imin=abs(icurve_lists(i90-1))
            if(imin > imax)then
               idirection=-1
               imin=imin-1
            elseif(imax > imin)then
               idirection=1
               imin=imin+1
            else
               idirection=1
            endif
            do i80=imin,imax,idirection
               if(icount > inums_max) then
                  write(temp1,'(a,i5,a)')'*listout* only ',inums_max,' values allowed'
                  ierr=-1
                  call journal(temp1)
                  inums_out=icount-1
                  exit
               endif
               icurve_expanded(icount)=i80
               icount=icount+1
            enddo
         else
            icurve_expanded(icount)=icurve_lists(i90)
            icount=icount+1
         endif
      enddo
   inums_out=icount-1

end subroutine listout
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     quote(3f) - [M_strings:QUOTES] add quotes to string as if written
!!     with list-directed output
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed output. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str    input string to add quotes to, using the rules of
!!           list-directed output (single quotes are replaced by two
!!           adjacent quotes)
!!    mode   alternate quoting methods are supported:
!!
!!             DOUBLE   default. replace quote with double quotes
!!             ESCAPE   replace quotes with backslash-quote instead of
!!                      double quotes
!!
!!    clip   default is to trim leading and trailing spaces from the
!!           string. If CLIP is .FALSE. spaces are not trimmed
!!
!!##RETURNS
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_quote
!!    use M_strings, only : quote
!!    implicit none
!!    integer                      :: i
!!    character(len=*),parameter   :: f='(*(g0))'
!!    character(len=:),allocatable :: str
!!    character(len=80),parameter  :: data(3)=[character(len=80)::&
!!       'test string',&
!!       'quote="',&
!!       '"word1" "word2"']
!!       do i=1,size(data)
!!          ! the original string
!!          write(*,'(a)')'ORIGINAL      '//trim(data(i))
!!
!!          ! the string processed by quote(3f)
!!          str=quote(data(i))
!!          write(*,'(a)')'QUOTED        '//str
!!
!!          ! write the string list-directed to compare the results
!!          write(*,f,advance='no') 'LIST DIRECTED'
!!          ! default is often NONE or APOSTROPHE
!!          write(*,*,delim='quote') trim(data(i))
!!       enddo
!!    end program demo_quote
!!
!! Results:
!!
!!  > ORIGINAL      test string
!!  > QUOTED        "test string"
!!  > LIST DIRECTED "test string"
!!  > ORIGINAL      quote="
!!  > QUOTED        "quote="""
!!  > LIST DIRECTED "quote="""
!!  > ORIGINAL      "word1" "word2"
!!  > QUOTED        """word1"" ""word2"""
!!  > LIST DIRECTED """word1"" ""word2"""
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(clip))then
      if(clip)then
         quoted_str=adjustl(str)
      else
         quoted_str=str
      endif
   else
      quoted_str=str
   endif

   local_mode=merge_str(mode,'DOUBLE',present(mode))

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace(quoted_str,'"','\"'))//double_quote
   case default
      call journal('sc','*quote* ERROR: unknown quote mode '//local_mode)
      quoted_str=str
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!     unquote(3f) - [M_strings:QUOTES] remove quotes from string as if
!!     read with list-directed input
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!
!!##RETURNS
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unquote
!!       use M_strings, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: iomsg
!!       integer                      :: iostat
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=iostat,iomsg=iomsg)quoted_str
!!          if(iostat /= 0)then
!!             write(*,*)trim(iomsg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=iostat,iomsg=iomsg)dummy
!!          if(iostat /= 0)then
!!             write(*,*)trim(iomsg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!    end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=iachar(esc)                            ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen >= 1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1) == single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before == iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current == quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    edit_distance(3f) - [M_strings:DESCRIBE] returns a naive edit distance using
!!    the Levenshtein distance algorithm
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function edit_distance(str1,str2) result (distance)
!!
!!     character(len=*),intent(in)   :: str1, str2
!!     integer :: distance
!!
!!##DESCRIPTION
!!
!!   The Levenshtein distance function returns how many edits (deletions,
!!   insertions, transposition) are required to turn one string into another.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_edit_distance
!!    use M_strings, only : edit_distance
!!       write(*,*)edit_distance('kittens','sitting')==3
!!       write(*,*)edit_distance('geek','gesek')==1
!!       write(*,*)edit_distance('Saturday','Sunday')==3
!!    end program demo_edit_distance
!!
!!   Expected output
!!
!!     > T
!!     > T
!!     > T
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
! The Levenshtein distance function returns how many edits (deletions,
! insertions, transposition) are required to turn one string into another.

pure elemental integer function edit_distance (a,b)
character(len=*), intent(in) :: a, b
integer                      :: len_a, len_b, i, j, cost
! matrix for calculating Levenshtein distance
!integer                      :: matrix(0:len_trim(a), 0:len_trim(b)) ! not supported by all compilers yet
integer,allocatable          :: matrix(:,:)
   len_a = len_trim(a)
   len_b = len_trim(b)
   !-------------------------------------- ! required by older compilers instead of above declaration
   if(allocated(matrix))deallocate(matrix)
   allocate(matrix(0:len_a,0:len_b))
   !--------------------------------------
   matrix(:,0) = [(i,i=0,len_a)]
   matrix(0,:) = [(j,j=0,len_b)]
   do i = 1, len_a
      do j = 1, len_b
         cost=merge(0,1,a(i:i)==b(j:j))
         matrix(i,j) = min(matrix(i-1,j)+1, matrix(i,j-1)+1, matrix(i-1,j-1)+cost)
      enddo
   enddo
   edit_distance = matrix(len_a,len_b)
end function edit_distance
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    bundle(3f) - [M_strings:ARRAY] return up to twenty strings of arbitrary length
!!                 as an array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function bundle(str1,str2,...str20,len) result (vec)
!!
!!     character(len=*),intent(in),optional   :: str1, str2 ... str20
!!     integer,intent(in),optional            :: len
!!
!!##DESCRIPTION
!!    Given a list of up to twenty strings create a string array. The
!!    length of the variables will be the same as the maximum length
!!    of the input strings unless explicitly specified via LEN.
!!
!!    This is an alternative to the syntax
!!
!!      [ CHARACTER(LEN=NN) :: str1, str2, ... ]
!!
!!    that by default additionally calculates the minimum length required
!!    to prevent truncation.
!!
!!##OPTIONS
!!    str1,str2, ... str20  input strings to combine into a vector
!!    len   length of returned array variables
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_bundle
!!    use M_strings, only: bundle
!!    implicit none
!!    character(len=*),parameter :: fmt= "(*('""',a,'""':,',',1x))"
!!    character(len=:),allocatable :: array(:)
!!       print fmt, bundle("one")
!!       print fmt, bundle("one","two")
!!       print fmt, bundle("one","two","three")
!!       array=bundle("one","two","three","four","five","six","seven")
!!       write(*,'(*(g0))')'size=',size(array),',len=',len(array)
!!       write(*,'("[",a,"]")')array
!!    end program demo_bundle
!!
!! Results:
!!
!!  > "one"
!!  > "one", "two"
!!  > "one  ", "two  ", "three"
!!  > size=7,len=5
!!  > [one  ]
!!  > [two  ]
!!  > [three]
!!  > [four ]
!!  > [five ]
!!  > [six  ]
!!  > [seven]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function bundle(x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,len) result(vec)
! return character array containing present arguments
character(len=*),intent(in),optional  :: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10
character(len=*),intent(in),optional  :: x11,x12,x13,x14,x15,x16,x17,x18,x19,x20
integer,intent(in),optional           :: len
character(len=:),allocatable          :: vec(:)
integer                               :: ilen, icount, iset
   ilen=0
   icount=0
   iset=0
   call increment(x1)
   call increment(x2)
   call increment(x3)
   call increment(x4)
   call increment(x5)
   call increment(x6)
   call increment(x7)
   call increment(x8)
   call increment(x9)
   call increment(x10)
   call increment(x11)
   call increment(x12)
   call increment(x13)
   call increment(x14)
   call increment(x15)
   call increment(x16)
   call increment(x17)
   call increment(x18)
   call increment(x19)
   call increment(x20)

   if(present(len)) ilen=len
   allocate (character(len=ilen) :: vec(icount))

   call set(x1)
   call set(x2)
   call set(x3)
   call set(x4)
   call set(x5)
   call set(x6)
   call set(x7)
   call set(x8)
   call set(x9)
   call set(x10)
   call set(x11)
   call set(x12)
   call set(x13)
   call set(x14)
   call set(x15)
   call set(x16)
   call set(x17)
   call set(x18)
   call set(x19)
   call set(x20)

contains

subroutine increment(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      ilen=max(ilen,len_trim(str))
      icount=icount+1
   endif
end subroutine increment

subroutine set(str)
character(len=*),intent(in),optional :: str
   if(present(str))then
      iset=iset+1
      vec(iset)=str
   endif
end subroutine set

end function bundle
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    describe(3f) - [M_strings:DESCRIBE] returns a string describing the name of
!!    a single character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function describe(ch) result (string)
!!
!!     character(len=1),intent(in)   :: ch
!!     character(len=:),allocatable  :: string
!!
!!##DESCRIPTION
!!    describe(3f) returns a string describing long name of a single
!!    character
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_describe
!!     use M_strings, only : describe
!!     implicit none
!!     integer :: i
!!        do i=1,128  ! fill variable with base ASCII character set
!!           write(*,*)describe(char(i-1))
!!        enddo
!!    end program demo_describe
!!
!!   Expected output
!!
!!     ctrl-@ or ctrl-? (NUL) null
!!     ctrl-A (SOH) start of heading
!!     ctrl-B (STX) start of text
!!     ctrl-C (ETX) end of text
!!     ctrl-D (EOT) end of transmission
!!     ctrl-E (ENQ) enquiry
!!     ctrl-F (ACK) acknowledge
!!     ctrl-G (BEL) bell
!!     ctrl-H (BS) backspace
!!     ctrl-I (HT) horizontal tabulation
!!     ctrl-J (LF) line feed
!!     ctrl-K (VT) vertical tabulation
!!     ctrl-L (FF) form feed
!!     ctrl-M (CR) carriage return
!!     ctrl-N (SO) shift out
!!     ctrl-O (SI) shift in
!!     ctrl-P (DLE) data link escape
!!     ctrl-Q (DC1) device control 1
!!     ctrl-R (DC2) device control 2
!!     ctrl-S (DC3) device control 3
!!     ctrl-T (DC4) device control 4
!!     ctrl-U (NAK) negative acknowledge
!!     ctrl-V (SYN) synchronous idle
!!     ctrl-W (ETB) end of transmission block
!!     ctrl-X (CAN) cancel
!!     ctrl-Y (EM) end of medium
!!     ctrl-Z (SUB) substitute
!!     ctrl-[ (ESC) escape
!!     ctrl-\ or ctrl-@ (FS) file separator
!!     ctrl-] (GS) group separator
!!     ctrl-^ or ctrl-= (RS) record separator
!!     ctrl-_ (US) unit separator
!!     space
!!     ! exclamation point
!!     " quotation marks
!!     # number sign
!!     $ currency symbol
!!     % percent
!!     & ampersand
!!     ' apostrophe
!!     ( left parenthesis
!!     ) right parenthesis
!!     * asterisk
!!     + plus
!!     , comma
!!     - minus
!!     . period
!!     / slash
!!     0 zero
!!     1 one
!!     2 two
!!     3 three
!!     4 four
!!     5 five
!!     6 six
!!     7 seven
!!     8 eight
!!     9 nine
!!     : colon
!!     ; semicolon
!!     < less than
!!     = equals
!!     > greater than
!!     ? question mark
!!     @ at sign
!!     majuscule A
!!     majuscule B
!!     majuscule C
!!     majuscule D
!!     majuscule E
!!     majuscule F
!!     majuscule G
!!     majuscule H
!!     majuscule I
!!     majuscule J
!!     majuscule K
!!     majuscule L
!!     majuscule M
!!     majuscule N
!!     majuscule O
!!     majuscule P
!!     majuscule Q
!!     majuscule R
!!     majuscule S
!!     majuscule T
!!     majuscule U
!!     majuscule V
!!     majuscule W
!!     majuscule X
!!     majuscule Y
!!     majuscule Z
!!     [ left bracket
!!     \ backslash
!!     ] right bracket
!!     ^ caret
!!     _ underscore
!!     ` grave accent
!!     miniscule a
!!     miniscule b
!!     miniscule c
!!     miniscule d
!!     miniscule e
!!     miniscule f
!!     miniscule g
!!     miniscule h
!!     miniscule i
!!     miniscule j
!!     miniscule k
!!     miniscule l
!!     miniscule m
!!     miniscule n
!!     miniscule o
!!     miniscule p
!!     miniscule q
!!     miniscule r
!!     miniscule s
!!     miniscule t
!!     miniscule u
!!     miniscule v
!!     miniscule w
!!     miniscule x
!!     miniscule y
!!     miniscule z
!!     { left brace
!!     | vertical line
!!     } right brace
!!     ~ tilde
!!     ctrl-? (DEL) delete
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function describe(ch) result (string)

! ident_65="@(#) M_strings describe(3f) return string describing long name of a single character"

character(len=1),intent(in)   :: ch
character(len=:),allocatable  :: string
! LATER: add hex, octal, decimal, key-press description, alternate names
!  ASCII character codes
   select case (iachar(ch))
   case(     0  ); STRING="ctrl-@ or ctrl-? (NUL) null"
   case(     1  ); STRING="ctrl-A (SOH) start of heading"
   case(     2  ); STRING="ctrl-B (STX) start of text"
   case(     3  ); STRING="ctrl-C (ETX) end of text"
   case(     4  ); STRING="ctrl-D (EOT) end of transmission"
   case(     5  ); STRING="ctrl-E (ENQ) enquiry"
   case(     6  ); STRING="ctrl-F (ACK) acknowledge"
   case(     7  ); STRING="ctrl-G (BEL) bell"
   case(     8  ); STRING="ctrl-H (BS) backspace"
   case(     9  ); STRING="ctrl-I (HT) horizontal tabulation"
   case(    10  ); STRING="ctrl-J (LF) line feed"
   case(    11  ); STRING="ctrl-K (VT) vertical tabulation"
   case(    12  ); STRING="ctrl-L (FF) form feed"
   case(    13  ); STRING="ctrl-M (CR) carriage return"
   case(    14  ); STRING="ctrl-N (SO) shift out"
   case(    15  ); STRING="ctrl-O (SI) shift in"
   case(    16  ); STRING="ctrl-P (DLE) data link escape"
   case(    17  ); STRING="ctrl-Q (DC1) device control 1"
   case(    18  ); STRING="ctrl-R (DC2) device control 2"
   case(    19  ); STRING="ctrl-S (DC3) device control 3"
   case(    20  ); STRING="ctrl-T (DC4) device control 4"
   case(    21  ); STRING="ctrl-U (NAK) negative acknowledge"
   case(    22  ); STRING="ctrl-V (SYN) synchronous idle"
   case(    23  ); STRING="ctrl-W (ETB) end of transmission block"
   case(    24  ); STRING="ctrl-X (CAN) cancel"
   case(    25  ); STRING="ctrl-Y (EM) end of medium"
   case(    26  ); STRING="ctrl-Z (SUB) substitute"
   case(    27  ); STRING="ctrl-[ (ESC) escape"
   case(    28  ); STRING="ctrl-\ or ctrl-@ (FS) file separator"
   case(    29  ); STRING="ctrl-] (GS) group separator"
   case(    30  ); STRING="ctrl-^ or ctrl-= (RS) record separator"
   case(    31  ); STRING="ctrl-_ (US) unit separator"
   case(    32  ); STRING="space"
   case(    33  ); STRING="! exclamation point (screamer, gasper, slammer, startler, bang, shriek, pling)"
   case(    34  ); STRING=""" quotation marks"
   case(    35  ); STRING="# number sign (hash, pound sign, hashtag)"
   case(    36  ); STRING="$ currency symbol"
   case(    37  ); STRING="% percent"
   case(    38  ); STRING="& ampersand"
   case(    39  ); STRING="' apostrophe"
   case(    40  ); STRING="( left parenthesis"
   case(    41  ); STRING=") right parenthesis"
   case(    42  ); STRING="* asterisk"
   case(    43  ); STRING="+ plus"
   case(    44  ); STRING=", comma"
   case(    45  ); STRING="- minus"
   case(    46  ); STRING=". period"
   case(    47  ); STRING="/ slash"
   case(    48  ); STRING="0 zero"
   case(    49  ); STRING="1 one"
   case(    50  ); STRING="2 two"
   case(    51  ); STRING="3 three"
   case(    52  ); STRING="4 four"
   case(    53  ); STRING="5 five"
   case(    54  ); STRING="6 six"
   case(    55  ); STRING="7 seven"
   case(    56  ); STRING="8 eight"
   case(    57  ); STRING="9 nine"
   case(    58  ); STRING=": colon"
   case(    59  ); STRING="; semicolon"
   case(    60  ); STRING="< less than"
   case(    61  ); STRING="= equals"
   case(    62  ); STRING="> greater than"
   case(    63  ); STRING="? question mark"
   case(    64  ); STRING="@ at (at cost of, at sign, each at, commercial at, commat, rollmop, monkey|pigs|elephant tail,&
                   & snail, arroba, strudel, asperand, ampersat, rose, cabbage, swirl, whorl)"
   case(    65  ); STRING="A majuscule A"
   case(    66  ); STRING="B majuscule B"
   case(    67  ); STRING="C majuscule C"
   case(    68  ); STRING="D majuscule D"
   case(    69  ); STRING="E majuscule E"
   case(    70  ); STRING="F majuscule F"
   case(    71  ); STRING="G majuscule G"
   case(    72  ); STRING="H majuscule H"
   case(    73  ); STRING="I majuscule I"
   case(    74  ); STRING="J majuscule J"
   case(    75  ); STRING="K majuscule K"
   case(    76  ); STRING="L majuscule L"
   case(    77  ); STRING="M majuscule M"
   case(    78  ); STRING="N majuscule N"
   case(    79  ); STRING="O majuscule O"
   case(    80  ); STRING="P majuscule P"
   case(    81  ); STRING="Q majuscule Q"
   case(    82  ); STRING="R majuscule R"
   case(    83  ); STRING="S majuscule S"
   case(    84  ); STRING="T majuscule T"
   case(    85  ); STRING="U majuscule U"
   case(    86  ); STRING="V majuscule V"
   case(    87  ); STRING="W majuscule W"
   case(    88  ); STRING="X majuscule X"
   case(    89  ); STRING="Y majuscule Y"
   case(    90  ); STRING="Z majuscule Z"
   case(    91  ); STRING="[ left bracket"
   case(    92  ); STRING="\ backslash"
   case(    93  ); STRING="] right bracket"
   case(    94  ); STRING="^ caret"
   case(    95  ); STRING="_ underscore"
   case(    96  ); STRING="` grave accent"
   case(    97  ); STRING="a miniscule a"
   case(    98  ); STRING="b miniscule b"
   case(    99  ); STRING="c miniscule c"
   case(   100  ); STRING="d miniscule d"
   case(   101  ); STRING="e miniscule e"
   case(   102  ); STRING="f miniscule f"
   case(   103  ); STRING="g miniscule g"
   case(   104  ); STRING="h miniscule h"
   case(   105  ); STRING="i miniscule i"
   case(   106  ); STRING="j miniscule j"
   case(   107  ); STRING="k miniscule k"
   case(   108  ); STRING="l miniscule l"
   case(   109  ); STRING="m miniscule m"
   case(   110  ); STRING="n miniscule n"
   case(   111  ); STRING="o miniscule o"
   case(   112  ); STRING="p miniscule p"
   case(   113  ); STRING="q miniscule q"
   case(   114  ); STRING="r miniscule r"
   case(   115  ); STRING="s miniscule s"
   case(   116  ); STRING="t miniscule t"
   case(   117  ); STRING="u miniscule u"
   case(   118  ); STRING="v miniscule v"
   case(   119  ); STRING="w miniscule w"
   case(   120  ); STRING="x miniscule x"
   case(   121  ); STRING="y miniscule y"
   case(   122  ); STRING="z miniscule z"
   case(   123  ); STRING="{ left brace"
   case(   124  ); STRING="| vertical line"
   case(   125  ); STRING="} right brace"
   case(   126  ); STRING="~ tilde"
   case(   127  ); STRING="ctrl-? (DEL) delete"
   case default
         STRING='UNKNOWN'//v2s(IACHAR(ch))
   end select
end function describe
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getvals(3f) - [M_strings:TYPE] read arbitrary number of REAL values
!!    from a character variable up to size of VALUES() array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine getvals(line,values,icount,ierr)
!!
!!     character(len=*),intent(in)  :: line
!!     class(*),intent(out)         :: values(:)
!!     integer,intent(out)          :: icount
!!     integer,intent(out),optional :: ierr
!!
!!##DESCRIPTION
!!   GETVALS(3f) reads a relatively arbitrary number of numeric values from
!!   a character variable into a REAL array using list-directed input.
!!
!!   NOTE: In this version null values are skipped instead of meaning to leave
!!         that value unchanged
!!
!!        1,,,,,,,2 / reads VALUES=[1.0,2.0]
!!
!!   Per list-directed rules when reading values, allowed delimiters are
!!   comma, semi-colon and space.
!!
!!   the slash separator can be used to add inline comments.
!!
!!        10.1, 20.43e-1 ; 11 / THIS IS TREATED AS A COMMENT
!!
!!   Repeat syntax can be used up to the size of the output array. These are
!!   equivalent input lines:
!!
!!        4*10.0
!!        10.0, 10.0, 10.0, 10.0
!!
!!##OPTIONS
!!   LINE      A character variable containing the characters representing
!!             a list of numbers
!!
!!##RETURNS
!!   VALUES()  array holding numbers read from string. May be of type
!!             INTEGER, REAL, DOUBLEPRECISION, or CHARACTER. If CHARACTER the
!!             strings are returned as simple words instead of numeric values.
!!   ICOUNT    number of defined numbers in VALUES(). If ICOUNT reaches
!!             the size of the VALUES() array parsing stops.
!!   IERR      zero if no error occurred in reading numbers. Optional.
!!             If not present and an error occurs the program is terminated.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_getvals
!!       use M_strings, only: getvals
!!       implicit none
!!       integer,parameter  :: longest_line=256
!!       character(len=longest_line) :: line
!!       real               :: values(longest_line/2+1)
!!       integer            :: iostat,icount,ierr
!!       INFINITE: do
!!          read(*,'(a)',iostat=iostat) line
!!          if(iostat /= 0)exit INFINITE
!!          call getvals(line,values,icount,ierr)
!!          write(*,'(4(g0,1x))')'VALUES=',values(:icount)
!!       enddo INFINITE
!!       end program demo_getvals
!!
!!  Sample input lines
!!
!!        10,20 30.4
!!        1 2 3
!!        1
!!
!!        3 4*2.5 8
!!        32.3333 / comment 1
!!        30e3;300,    30.0, 3
!!        even 1 like this! 10
!!        11,,,,22,,,,33
!!
!!  Expected output:
!!
!!     VALUES=   10.0000000       20.0000000       30.3999996
!!     VALUES=   1.00000000       2.00000000       3.00000000
!!     VALUES=   1.00000000
!!     VALUES=
!!     VALUES=   3.00000000       2.50000000       2.50000000
!!     2.50000000       2.50000000       8.00000000
!!     VALUES=   32.3333015
!!     VALUES=   30000.0000       300.000000       30.0000000
!!     3.00000000
!!     *getvals* WARNING:[even] is not a number
!!     *getvals* WARNING:[like] is not a number
!!     *getvals* WARNING:[this!] is not a number
!!     VALUES=   1.00000000       10.0000000
!!     VALUES=   11.0000000       22.0000000       33.0000000
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine getvals(line,values,icount,ierr)

! ident_66="@(#) M_strings getvals(3f) read arbitrary number of values from a character variable"

! JSU 20170831

character(len=*),intent(in)  :: line
class(*),intent(out)         :: values(:)
integer,intent(out)          :: icount
integer,intent(out),optional :: ierr

character(len=:),allocatable :: buffer
character(len=len(line))     :: words(size(values))
integer                      :: iostat, i, ierr_local,isize

   isize=0
   select type(values)
   type is (integer);          isize=size(values)
   type is (real);             isize=size(values)
   type is (doubleprecision);  isize=size(values)
   type is (character(len=*)); isize=size(values)
   end select

   ierr_local=0

   words=' '                            ! make sure words() is initialized to null+blanks
   buffer=trim(unquote(line))//"/"      ! add a slash to the end so how the read behaves with missing values is clearly defined
   read(buffer,*,iostat=iostat) words   ! undelimited strings are read into an array
   icount=0
   do i=1,isize                         ! loop thru array and convert non-blank words to numbers
      if(words(i) == ' ')cycle

      select type(values)
      type is (integer);          read(words(i),*,iostat=iostat)values(icount+1)
      type is (real);             read(words(i),*,iostat=iostat)values(icount+1)
      type is (doubleprecision);  read(words(i),*,iostat=iostat)values(icount+1)
      type is (character(len=*)); values(icount+1)=words(i)
      end select

      if(iostat == 0)then
         icount=icount+1
      else
         ierr_local=iostat
         write(stderr,*)'*getvals* WARNING:['//trim(words(i))//'] is not a number of specified type'
      endif
   enddo

   if(present(ierr))then
      ierr=ierr_local
   elseif(ierr_local /= 0)then        ! error occurred and not returning error to main program to print message and stop program
      write(stderr,*)'*getval* error reading line ['//trim(line)//']'
      stop 2
   endif

end subroutine getvals
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_values(3f) - [M_strings:TYPE] read a string representing
!!      numbers into a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine string_to_values(line,iread,values,inums,delims,ierr)
!!
!!        character(len=*) :: line
!!        integer          :: iread
!!        real             :: values(*)
!!        integer          :: inums
!!        character(len=*) :: delims
!!        integer          :: ierr
!!
!!##DESCRIPTION
!!    This routine can take a string representing a series of numbers and
!!    convert it to a numeric array and return how many numbers were found.
!!
!!##OPTIONS
!!       LINE     Input string containing numbers
!!       IREAD    maximum number of values to try to read from input string
!!
!!##RETURNS
!!       VALUES   real array to be filled with numbers
!!       INUMS    number of values successfully read (before error occurs
!!                if one does)
!!       DELIMS   delimiter character(s), usually a space. must not be a
!!                null string. If more than one character, a space must
!!                not be the last character or it will be ignored.
!!       IERR     error flag (0=no error, else column number string starts
!!                at that error occurred on).
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!      program demo_string_to_values
!!       use M_strings, only : string_to_values
!!       implicit none
!!       character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!       integer,parameter  :: isz=10
!!       real               :: array(isz)
!!       integer            :: inums, ierr, ii
!!
!!       call string_to_values(s,10,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
!!       call reportit()
!!
!!       contains
!!          subroutine reportit()
!!             write(*,*)'string_to_values:'
!!             write(*,*)'input string.............',trim(s)
!!             write(*,*)'number of values found...',inums
!!             write(*,*)'values...................',(array(ii),ii=1,inums)
!!          end subroutine reportit
!!      end program demo_string_to_values
!!
!!    Expected output
!!
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000  20000.0000  3.45000005
!!     -4.00299978  1234.00000  5678.00000
!!     string_to_values:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           3
!!     values...................   10.0000000  2.29999995  3.14159989
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine string_to_values(line,iread,values,inums,delims,ierr)
!----------------------------------------------------------------------------------------------------------------------------------
!   1989,1997-12-31,2014 John S. Urban

!   given a line of structure , string , string , string process each
!   string as a numeric value and store into an array.
!   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS.
!   There is no direct checking for more values than can fit in VALUES.
!   Quits if encounters any errors in read.
!----------------------------------------------------------------------------------------------------------------------------------

! ident_67="@(#) M_strings string_to_values(3f) reads an array of numbers from a numeric string"

character(len=*),intent(in)  :: line          ! input string
integer,intent(in)           :: iread         ! maximum number of values to try to read into values
real,intent(inout)           :: values(iread) ! real array to be filled with values
integer,intent(out)          :: inums         ! number of values successfully read from string
character(len=*),intent(in)  :: delims        ! allowed delimiters
integer,intent(out)          :: ierr          ! 0 if no error, else column number undecipherable string starts at
!----------------------------------------------------------------------------------------------------------------------------------
character(len=256)           :: delims_local        ! mutable copy of allowed delimiters
integer                      :: ibegin,iend,lgth,icol
integer                      :: i10,i20,i40
real                         :: rval
integer                      :: ier
integer                      :: delimiters_length
!----------------------------------------------------------------------------------------------------------------------------------
      delims_local=delims                           ! need a mutable copy of the delimiter list
      if(delims_local == '')then                    ! if delimiter list is null or all spaces make it a space
         delims_local=' '                           ! delimiter is a single space
         delimiters_length=1                        ! length of delimiter list
      else
         delimiters_length=len_trim(delims)         ! length of variable WITH TRAILING WHITESPACE TRIMMED
      endif
!----------------------------------------------------------------------------------------------------------------------------------
      ierr=0                                        ! initialize error code returned
      inums=0                                       ! initialize count of values successfully returned
      ibegin=0
!----------------------------------------------------------------------------------------------------------------------------------
      lgth=0                                        ! lgth will be the position of the right-most non-delimiter in the input line
      do i20=len(line),1,-1                         ! loop from end of string to beginning to find right-most non-delimiter
         if(index(delims_local(:delimiters_length),line(i20:i20)) == 0)then   ! found a non-delimiter
            lgth=i20
            exit
         endif
      enddo
      if(lgth == 0)then                             ! command was totally composed of delimiters
         call journal('*string_to_values* blank line passed as a list of numbers')
         return
      endif
!----------------------------------------------------------------------------------------------------------------------------------
!     there is at least one non-delimiter sub-string
!     lgth is the column position of the last non-delimiter character
!     now, starting at beginning of string find next non-delimiter
      icol=1                                                     ! pointer to beginning of unprocessed part of LINE
      LOOP: dO i10=1,iread,1                                     ! each pass should find a value
         if(icol > lgth) EXIT LOOP                               ! everything is done
         INFINITE: do
            if(index(delims_local(:delimiters_length),line(icol:icol)) == 0)then           ! found non-delimiter
               ibegin=icol
               iend=0                                            ! FIND END OF SUBSTRING
               do i40=ibegin,lgth                                ! look at each character starting at left
                  if(index(delims_local(:delimiters_length),line(i40:i40)) /= 0)then       ! determine if character is a delimiter
                     iend=i40                                    ! found a delimiter. record where it was found
                     EXIT                                        ! found end of substring so leave loop
                  endif
               enddo
              if(iend == 0)iend=lgth+1                           ! no delimiters found, so this substring goes to end of line
               iend=iend-1                                       ! do not want to pass delimiter to be converted
               rval=0.0
               call string_to_value(line(ibegin:iend),rval,ier)  ! call procedure to convert string to a numeric value
               if(ier == 0)then                                  ! a substring was successfully converted to a numeric value
                  values(i10)=rval                               ! store numeric value in return array
                  inums=inums+1                                  ! increment number of values converted to a numeric value
               else                                              ! an error occurred converting string to value
                  ierr=ibegin                                    ! return starting position of substring that could not be converted
                  return
               endif
               icol=iend+2                                       ! set to next character to look at
               CYCLE LOOP                                        ! start looking for next value
            else                                                 ! this is a delimiter so keep looking for start of next string
               icol=icol+1                                       ! increment pointer into LINE
               CYCLE INFINITE
            endif
         enddo INFINITE
      enddo LOOP
!     error >>>>> more than iread numbers were in the line.
end subroutine string_to_values
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2vs(3f) - [M_strings:TYPE] given a string representing numbers
!!      return a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function s2vs(line[,delim])
!!
!!        character(len=*) :: line
!!        doubleprecision,allocatable :: s2vs(:)
!!
!!##DESCRIPTION
!!    The function S2VS(3f) takes a string representing a series of numbers
!!    and converts it to a numeric doubleprecision array. The string values
!!    may be delimited by spaces, semi-colons, and commas by default.
!!
!!##OPTIONS
!!       LINE   Input string containing numbers
!!       DELIM  optional list of delimiter characters. If a space is
!!              included, it should appear as the left-most character
!!              in the list. The default is " ;," (spaces, semi-colons,
!!              and commas).
!!
!!##RETURNS
!!       S2VS   doubleprecision array
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_s2vs
!!      use M_strings, only : s2vs
!!      implicit none
!!      character(len=80) :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!      real,allocatable :: values(:)
!!      integer,allocatable :: ivalues(:)
!!      integer :: ii
!!
!!      values=s2vs(s)
!!      ivalues=int(s2vs(s))
!!      call reportit()
!!
!!      contains
!!        subroutine reportit()
!!          write(*,*)'S2VS:'
!!          write(*,*)'input string.............',&
!!           & trim(s)
!!          write(*,*)'number of values found...',&
!!           & size(values)
!!          write(*,*)'values...................',&
!!           & (values(ii),ii=1,size(values))
!!          write(*,'(*(g0,1x))')'ivalues..................',&
!!           & (ivalues(ii),ii=1,size(values))
!!        end subroutine reportit
!!      end program demo_s2vs
!!
!!   Expected output
!!
!!     S2VS:
!!     input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!     number of values found...           6
!!     values...................   10.0000000 20000.0000 3.45000005
!!     -4.00299978 1234.00000 5678.00000
!!    ivalues.................. 10 20000 3 -4 1234 5678
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function s2vs(string,delim) result(darray)

! ident_68="@(#) M_strings s2vs(3f) function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isprint(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     ASCII printable character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isprint(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isprint
!!
!!##DESCRIPTION
!!     isprint(3f) returns .true. if character is an ASCII printable character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isprint  logical value returns true if character is a
!!             printable ASCII character else false.
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isprint
!!    use M_strings, only : isprint
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISPRINT: ',pack( string, isprint(string) )
!!    end program demo_isprint
!!
!!   Results:
!!
!!    ISPRINT:  !"#$%&'()*+,-./0123456789:;<=>?@ABCDEF
!!    GHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmn
!!    opqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isprint(onechar)

! ident_69="@(#) M_strings isprint(3f) indicates if input character is a printable ASCII character"

character,intent(in) :: onechar
logical              :: isprint
   select case (onechar)
      case (' ':'~')   ; isprint=.TRUE.
      case default     ; isprint=.FALSE.
   end select
end function isprint
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isgraph(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable character except a space is considered non-printable
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isgraph(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isgraph
!!
!!##DESCRIPTION
!!    isgraph(3f) returns .true. if character is a printable character
!!    except a space is considered non-printable
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isgraph   logical value returns true if character is a printable
!!              non-space character
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isgraph
!!    use M_strings, only : isgraph
!!    implicit none
!!    integer                    :: i
!!    character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!       write(*,'(40(a))')'ISGRAPH: ',pack( string, isgraph(string) )
!!    end program demo_isgraph
!!
!!   Results:
!!
!!    ISGRAPH: !"#$%&'()*+,-./0123456789:;<=>?@ABCDEFG
!!    HIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmno
!!    pqrstuvwxyz{|}~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isgraph(onechar)

! ident_70="@(#) M_strings isgraph(3f) indicates if character is printable ASCII character excluding space"

character,intent(in) :: onechar
logical              :: isgraph
   select case (iachar(onechar))
   case (33:126)
     isgraph=.TRUE.
   case default
     isgraph=.FALSE.
   end select
end function isgraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalpha(3f) - [M_strings:COMPARE] returns .true. if character is a
!!    letter and .false. otherwise
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!   elemental function isalpha(onechar)
!!
!!    character,intent(in) :: onechar
!!    logical              :: isalpha
!!
!!##DESCRIPTION
!!    isalpha(3f) returns .true. if character is a letter and
!!    .false. otherwise
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isalpha  logical value returns .true. if character is a ASCII letter
!!             or false otherwise.
!!##EXAMPLES
!!
!!
!!   Sample program
!!
!!     program demo_isalpha
!!     use M_strings, only : isalpha
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISGRAPH: ',pack( string, isalpha(string) )
!!     end program demo_isalpha
!!
!!   Results:
!!
!!    ISGRAPH: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklm
!!    nopqrstuvwxyz
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
elemental function isalpha(ch) result(res)

! ident_71="@(#) M_strings isalpha(3f) Return .true. if character is a letter and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z','a':'z')
     res=.true.
   case default
     res=.false.
   end select
end function isalpha
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isxdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     hexadecimal digit (0-9, a-f, or A-F).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isxdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isxdigit
!!
!!##DESCRIPTION
!!     isxdigit(3f) returns .true. if character is a hexadecimal digit (0-9,
!!     a-f, or A-F).
!!
!!##OPTIONS
!!    onechar   character to test
!!
!!##RETURNS
!!    isxdigit  logical value returns true if character is a hexadecimal digit
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     program demo_isxdigit
!!     use M_strings, only : isxdigit
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(40(a))')'ISXDIGIT: ',pack( string, isxdigit(string) )
!!     end program demo_isxdigit
!!
!!   Results:
!!
!!    ISXDIGIT: 0123456789ABCDEFabcdef
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isxdigit(ch) result(res)

! ident_72="@(#) M_strings isxdigit(3f) returns .true. if c is a hexadecimal digit (0-9 a-f or A-F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'F','a':'f','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isxdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isdigit(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     digit (0,1,...,9) and .false. otherwise
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isdigit(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isdigit
!!
!!##DESCRIPTION
!!     isdigit(3f) returns .true. if character is a digit (0,1,...,9)
!!     and .false. otherwise
!!
!!##EXAMPLES
!!
!!
!!  Sample Program:
!!
!!     program demo_isdigit
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!            & all(isdigit(switch(string(i))).or.&
!!            & isspace(switch(string(i))))
!!        enddo
!!     end program demo_isdigit
!!
!!  Expected output:
!!
!!        For string[1 2 3 4 5 ] T
!!        For string[letters   ] F
!!        For string[1234567890] T
!!        For string[both 8787 ] F
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isdigit(ch) result(res)

! ident_73="@(#) M_strings isdigit(3f) Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isblank(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     blank character (space or horizontal tab).
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isblank(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isblank
!!
!!##DESCRIPTION
!!     isblank(3f) returns .true. if character is a blank character (space
!!     or horizontal tab).
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isblank  logical value returns true if character is a "blank"
!!             ( an ASCII  space or horizontal tab character).
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_isblank
!!     use M_strings, only : isblank
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(*(g0,1x))')'ISXBLANK: ',&
!!        & iachar(pack( string, isblank(string) ))
!!     end program demo_isblank
!!
!!   Results:
!!
!!    ISXBLANK:  9 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isblank(ch) result(res)

! ident_74="@(#) M_strings isblank(3f) returns .true. if character is a blank (space or horizontal tab)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ',char(9))
     res=.true.
   case default
     res=.false.
   end select
end function isblank
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isascii(3f) - [M_strings:COMPARE] returns .true. if the character is
!!     in the range char(0) to char(256)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isascii(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isascii
!!
!!##DESCRIPTION
!!     isascii(3f) returns .true. if the character is in the range char(0)
!!     to char(127)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isupper  logical value returns true if character is an ASCII
!!             character.
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_isascii
!!     use M_strings, only : isascii
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,255)]
!!        write(*,'(10(g0,1x))')'ISASCII: ', &
!!        & iachar(pack( string, isascii(string) ))
!!     end program demo_isascii
!!
!!  Results:
!!
!!    ISASCII:  0 1 2 3 4 5 6 7 8
!!    9 10 11 12 13 14 15 16 17 18
!!    19 20 21 22 23 24 25 26 27 28
!!    29 30 31 32 33 34 35 36 37 38
!!    39 40 41 42 43 44 45 46 47 48
!!    49 50 51 52 53 54 55 56 57 58
!!    59 60 61 62 63 64 65 66 67 68
!!    69 70 71 72 73 74 75 76 77 78
!!    79 80 81 82 83 84 85 86 87 88
!!    89 90 91 92 93 94 95 96 97 98
!!    99 100 101 102 103 104 105 106 107 108
!!    109 110 111 112 113 114 115 116 117 118
!!    119 120 121 122 123 124 125 126 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isascii(ch) result(res)

! ident_75="@(#) M_strings isascii(3f) returns .true. if character is in the range char(0) to char(127)"

character,intent(in) :: ch
logical              :: res
   select case(iachar(ch))
   case(0:127)
     res=.true.
   case default
     res=.false.
   end select
end function isascii
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & iachar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_76="@(#) M_strings isspace(3f) true if null space tab return new line vertical tab or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     iscntrl(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     delete character or ordinary control character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function iscntrl(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: iscntrl
!!
!!##DESCRIPTION
!!     iscntrl(3f) returns .true. if character is a delete character or
!!     ordinary control character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    iscntrl  logical value returns true if character is a control character
!!
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_iscntrl
!!     use M_strings, only : iscntrl
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISCNTRL: ', &
!!        & iachar(pack( string, iscntrl(string) ))
!!     end program demo_iscntrl
!!
!!   Results:
!!
!!    ISCNTRL:  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
!!    20 21 22 23 24 25 26 27 28 29 30 31 127
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function iscntrl(ch) result(res)

! ident_77="@(#) M_strings iscntrl(3f) true if a delete or ordinary control character(0x7F or 0x00-0x1F)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(char(127),char(0):char(31))
     res=.true.
   case default
     res=.false.
   end select
end function iscntrl
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     ispunct(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     printable punctuation character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function ispunct(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: ispunct
!!
!!##DESCRIPTION
!!     ispunct(3f) returns .true. if character is a printable punctuation
!!     character
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    ispunct  logical value returns true if character is a printable
!!             punctuation character.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_ispunct
!!     use M_strings, only : ispunct
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & iachar(pack( string, ispunct(string) ))
!!        write(*,'(20(g0,1x))')'ISPUNCT: ', &
!!        & pack( string, ispunct(string) )
!!     end program demo_ispunct
!!   Results:
!!
!!    ISPUNCT:  33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 58 59 60 61
!!    62 63 64 91 92 93 94 95 96 123 124 125 126
!!    ISPUNCT:  ! " # $ % & ' ( ) * + , - . / : ; < =
!!    > ? @ [ \ ] ^ _ ` { | } ~
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function ispunct(ch) result(res)

! ident_78="@(#) M_strings ispunct(3f) true if a printable punctuation character (isgraph(c)&&!isalnum(c))"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case (char(33):char(47), char(58):char(64), char(91):char(96), char(123):char(126))
     res=.true.
!  case(' ','0':'9','A':'Z','a':'z',char(128):)
!    res=.true.
!  case(char(0):char(31),char(127))
!    res=.true.
   case default
     res=.false.
   end select
end function ispunct
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     fortran_name(3f) - [M_strings:COMPARE] test if string meets criteria
!!     for being a fortran name
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     elemental function fortran_name(line) result (lout)
!!
!!      character(len=*),intent(in)  :: line
!!      logical                      :: lout
!!
!!##DESCRIPTION
!!     Determines if a string is an allowed Fortran name. To pass the input
!!     string must be composed of 1 to 63 ASCII characters and start with a
!!     letter and be composed entirely of alphanumeric characters [a-zA-Z0-9]
!!     and underscores.
!!
!!##OPTIONS
!!     LINE   input string to test. Leading spaces are significant but
!!            trailing spaces are ignored.
!!
!!##RETURNS
!!     LOUT   a logical value indicating if the input string passed or failed
!!            the test to see if it is a valid Fortran name or not.
!!
!!##EXAMPLES
!!
!!    Sample program
!!
!!      program demo_fortran_name
!!      use M_strings, only : fortran_name
!!      implicit none
!!      character(len=20),parameter :: names(*)=[character(len=20) ::  &
!!       & '_name',         'long_variable_name', 'name_',         &
!!       & '12L',           'a__b__c  ',          'PropertyOfGas', &
!!       & '3%3',           '$NAME',              ' ',             &
!!       & 'Variable-name', 'A',                  'x@x' ]
!!      integer :: i
!!         write(*,'(i3,1x,a20,1x,l1)')&
!!         & (i,names(i),fortran_name(names(i)),i=1,size(names))
!!      end program demo_fortran_name
!!
!!    Results:
!!
!!      >  1 _name                F
!!      >  2 long_variable_name   T
!!      >  3 name_                T
!!      >  4 12L                  F
!!      >  5 a__b__c              T
!!      >  6 PropertyOfGas        T
!!      >  7 3%3                  F
!!      >  8 $NAME                F
!!      >  9                      F
!!      > 10 Variable-name        F
!!      > 11 A                    T
!!      > 12 x@x                  F
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function fortran_name(line) result (lout)

! ident_79="@(#) M_strings fortran_name(3f) Return .true. if name is a valid Fortran name"

! determine if a string is a valid Fortran name ignoring trailing spaces (but not leading spaces)
character(len=*),parameter   :: int='0123456789'
character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character(len=*),parameter   :: allowed=upper//lower//int//'_'

character(len=*),intent(in)  :: line
character(len=:),allocatable :: name
logical                      :: lout
   name=trim(line)
   if(len(name) /= 0)then
      lout = verify(name(1:1), lower//upper) == 0  &  ! first character is a letter
       & .and. verify(name,allowed) == 0           &  ! composed of alphanumeric and underscore in its entirety
       & .and. len(name) <= 63                        ! length less than 64 characters
   else
      lout = .false.
   endif
end function fortran_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isupper(3f) - [M_strings:COMPARE] returns .true. if character is an
!!     uppercase letter (A-Z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isupper(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isupper
!!
!!##DESCRIPTION
!!     isupper(3f) returns .true. if character is an uppercase letter (A-Z)
!!
!!##OPTIONS
!!    onechar  character to test
!!##RETURNS
!!    isupper  logical value returns true if character is an uppercase
!!             ASCII character else false.
!!##EXAMPLES
!!
!!  Sample program:
!!
!!     program demo_isupper
!!     use M_strings, only : isupper
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & iachar(pack( string, isupper(string) ))
!!        write(*,'(10(g0,1x))')'ISUPPER: ', &
!!        & pack( string, isupper(string) )
!!     end program demo_isupper
!!
!!  Results:
!!
!!     > ISUPPER:  65 66 67 68 69 70 71 72 73
!!     > 74 75 76 77 78 79 80 81 82 83
!!     > 84 85 86 87 88 89 90
!!     > ISUPPER:  A B C D E F G H I
!!     > J K L M N O P Q R S
!!     > T U V W X Y Z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
pure elemental function isupper(ch) result(res)

! ident_80="@(#) M_strings isupper(3f) returns true if character is an uppercase letter (A-Z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('A':'Z'); res=.true.
   case default;  res=.false.
   end select
end function isupper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     islower(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     miniscule letter (a-z)
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function islower(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: islower
!!
!!##DESCRIPTION
!!     islower(3f) returns .true. if character is a miniscule letter (a-z)
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    islower  logical value returns true if character is a lowercase
!!             ASCII character else false.
!!##EXAMPLES
!!
!!  Sample program
!!
!!     program demo_islower
!!     use M_strings, only : islower
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & iachar(pack( string, islower(string) ))
!!        write(*,'(15(g0,1x))')'ISLOWER: ', &
!!        & pack( string, islower(string) )
!!     end program demo_islower
!!   Results:
!!
!!    ISLOWER:  97 98 99 100 101 102 103 104 105 106 107 108 109 110
!!    111 112 113 114 115 116 117 118 119 120 121 122
!!    ISLOWER:  a b c d e f g h i j k l m n
!!    o p q r s t u v w x y z
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function islower(ch) result(res)

! ident_81="@(#) M_strings islower(3f) returns true if character is a miniscule letter (a-z)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('a':'z'); res=.true.
   case default;  res=.false.
   end select
end function islower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    isalnum,isalpha,iscntrl,isdigit,isgraph,islower,
!!    isprint,ispunct,isspace,isupper,
!!    isascii,isblank,isxdigit(3f) - [M_strings:COMPARE] test membership in
!!    subsets of ASCII set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Where "FUNCNAME" is one of the function names in the group, the
!!    functions are defined by
!!
!!     elemental function FUNCNAME(onechar)
!!     character,intent(in) :: onechar
!!     logical              :: FUNC_NAME
!!##DESCRIPTION
!!
!!       These elemental functions test if a character belongs to various
!!       subsets of the ASCII character set.
!!
!!       isalnum    returns .true. if character is a letter (a-z,A-Z)
!!                  or digit (0-9)
!!       isalpha    returns .true. if character is a letter and
!!                  .false. otherwise
!!       isascii    returns .true. if character is in the range char(0)
!!                  to char(127)
!!       isblank    returns .true. if character is a blank (space or
!!                  horizontal tab).
!!       iscntrl    returns .true. if character is a delete character or
!!                  ordinary control character (0x7F or 0x00-0x1F).
!!       isdigit    returns .true. if character is a digit (0,1,...,9)
!!                  and .false. otherwise
!!       isgraph    returns .true. if character is a printable ASCII
!!                  character excluding space
!!       islower    returns .true. if character is a miniscule letter (a-z)
!!       isprint    returns .true. if character is a printable ASCII character
!!       ispunct    returns .true. if character is a printable punctuation
!!                  character (isgraph(c) && !isalnum(c)).
!!       isspace    returns .true. if character is a null, space, tab,
!!                  carriage return, new line, vertical tab, or formfeed
!!       isupper    returns .true. if character is an uppercase letter (A-Z)
!!       isxdigit   returns .true. if character is a hexadecimal digit
!!                  (0-9, a-f, or A-F).
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!    program demo_isdigit
!!
!!     use M_strings, only : isdigit, isspace, switch
!!     implicit none
!!     character(len=10),allocatable :: string(:)
!!     integer                       :: i
!!        string=[&
!!        & '1 2 3 4 5 ' ,&
!!        & 'letters   ' ,&
!!        & '1234567890' ,&
!!        & 'both 8787 ' ]
!!        ! if string is nothing but digits and whitespace return .true.
!!        do i=1,size(string)
!!           write(*,'(a)',advance='no')'For string['//string(i)//']'
!!           write(*,*) &
!!           all(isdigit(switch(string(i))) .or. &
!!           & isspace(switch(string(i))))
!!        enddo
!!
!!     end program demo_isdigit
!!
!!   Expected output:
!!
!!    For string[1 2 3 4 5 ] T
!!    For string[letters   ] F
!!    For string[1234567890] T
!!    For string[both 8787 ] F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental function isalnum(ch) result(res)

! ident_82="@(#) M_strings isalnum(3f) returns true if character is a letter (a-z A-Z) or digit(0-9)"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('a':'z','A':'Z','0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isalnum
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base(3f) - [M_strings:BASE] convert whole number string in base [2-36]
!!    to string in alternate base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   elemental impure logical function base(x,b,y,a)
!!
!!    character(len=*),intent(in)  :: x
!!    character(len=*),intent(out) :: y
!!    integer,intent(in)           :: b,a
!!##DESCRIPTION
!!
!!    Convert a numeric string from base B to base A. The function returns
!!    FALSE if B is not in the range [2..36] or if string X contains invalid
!!    characters in base B or if result Y is too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in a base > 10.
!!
!!##OPTIONS
!!    x   input string representing numeric whole value
!!    b   assumed base of input string
!!    y   output string.
!!        Y is assumed long enough to hold the computed value.
!!        If an error occurs Y is filled with asterisks (*).
!!    a   base specified for output string
!!##RETURNS
!!        Returns .TRUE. if no error occurred, else returns .FALSE. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_base
!!    use M_strings, only: base
!!    implicit none
!!    integer           :: ba, bd, i
!!    character(len=40) :: x, y
!!    character(len=*), parameter :: input(*) = [character(len=80) :: &
!!       '10 12345 10', &
!!       '2 10111 10', &
!!       '10 12345 20', &
!!       '10 abcdef 2', &
!!       '0 0 0']
!!    character(len=:),allocatable :: line
!!       print *, 'Base Conversion using base(3f)'
!!       do i = 1, size(input)
!!          line=input(i)
!!          read (line, *) bd, x, ba
!!          if (x == '0') exit
!!          if (base(x, bd, y, ba)) then
!!          else
!!             print *, 'Error in decoding/encoding numbers'
!!          end if
!!          write (*, '(a," in base ",i0," is ",a," in base ",i0)')&
!!          & trim(x),bd,trim(y),ba
!!       end do
!!    end program demo_base
!!
!! Results:
!!
!!    >  Base Conversion using base(3f)
!!    > 12345 in base 10 is 12345 in base 10
!!    > 10111 in base 2 is 23 in base 10
!!    > 12345 in base 10 is 1AH5 in base 20
!!    >  Error in decoding/encoding numbers
!!    > abcdef in base 10 is **************************************** in base 2
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental impure logical function base(x, b, y, a)
character(len=*), intent(in)  :: x
character(len=*), intent(out) :: y
integer, intent(in)           :: b, a
integer                       :: tempx
integer                       :: iostat

! ident_83="@(#) M_strings base(3f) convert whole number string in base [2-36] to string in alternate base [2-36]"

! Y is assumed long enough to hold the computed value

   base = .true.
   if (decodebase(x, b, tempx)) then
      if (codebase(tempx, a, y)) then
      else
         flush(unit=output_unit,iostat=iostat)
         write(stderr,'(*(g0))') 'Error in coding number ',trim(x),' in base ',a
         flush(unit=stderr,iostat=iostat)
         base = .false.
         y=repeat('*',len(y))
      endif
   else
      flush(unit=output_unit,iostat=iostat)
      write(stderr,'(*(g0))') 'Error in decoding number ',trim(x),' in base ',b
      flush(unit=stderr,iostat=iostat)
      base = .false.
      y=repeat('*',len(y))
   endif

end function base
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    base2(3f) - [M_strings:BASE] convert whole number to string in base 2
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function base2(int)
!!
!!     integer,intent(in)           :: int
!!     character(len=:),allocatable :: base2
!!
!!##DESCRIPTION
!!
!!    Convert a whole number to a string in base 2.
!!
!!    This is often done with the B edit descriptor and
!!    an internal WRITE() statement, but is done without
!!    calling the I/O routines, and as a function.
!!
!!##OPTIONS
!!    int   input string representing numeric whole value
!!
!!##RETURNS
!!    base2   string representing input value in base 2
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!      program demo_base2
!!      use M_strings, only : base2
!!      implicit none
!!         write(*,'(a)') base2(huge(0))
!!         write(*,'(a)') base2(0)
!!         write(*,'(a)') base2(64)
!!         write(*,'(a)') base2(-64)
!!         write(*,'(a)') base2(-huge(0)-1)
!!      end program demo_base2
!!
!! Results:
!!
!!     > 1111111111111111111111111111111
!!     > 0
!!     > 1000000
!!     > 11111111111111111111111111000000
!!     > 10000000000000000000000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function base2(x) result(str)
!  return string representing number as a binary number. Fixed-length string:
integer, intent(in)                        :: x
integer                                    :: i
character(len=max(1,bit_size(x)-leadz(x))) :: str
    associate(n => len(str))
      str = repeat('0',n)
      do i = 0,n-1
        if (btest(x,i)) str(n-i:n-i) = '1'
      end do
    end associate
end function base2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_strings:BASE] convert whole number string in base
!!    [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##RETURNS
!!    Returns .true. if no error occurred, else returns .false. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_decodebase
!!    use M_strings, only : codebase, decodebase
!!    implicit none
!!    integer           :: bd, i, r
!!    character(len=40) :: x
!!    character(len=*), parameter :: input(*) = [character(len=80) :: &
!!       '10  12345',   &
!!       '2   10111',   &
!!       '6   12345',   &
!!       '10  abcdef',  &
!!       '0   0']
!!    character(len=:),allocatable :: line
!!       print *, 'Base Conversion using decodebase(3f)'
!!       do i = 1, size(input)
!!          line=input(i)
!!          read (line, *) bd, x
!!          if (x == '0') exit
!!          if(.not.decodebase(x,bd,r)) then
!!            print *,'Error in decoding number.'
!!          endif
!!          write (*, '(a," in base ",i0," becomes ",i0," in base 10")')&
!!          & trim(x),bd,r
!!       end do
!!    end program demo_decodebase
!!
!! Results:
!!
!!  >  Base Conversion using decodebase(3f)
!!  > 12345 in base 10 becomes 12345 in base 10
!!  > 10111 in base 2 becomes 23 in base 10
!!  > 12345 in base 6 becomes 1865 in base 10
!!  >  Error in decoding number.
!!  > abcdef in base 10 becomes 0 in base 10
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================
logical function decodebase(string,basein,out_baseten)

! ident_84="@(#) M_strings decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten
character(len=len(string))   :: string_local
integer                      :: long, i,  j,  k
real(kind=real64)            :: y
real(kind=real64)            :: mult
character(len=1)             :: ch
real(kind=real64),parameter  :: XMAXREAL=huge(1.0)
integer                      :: out_sign
integer                      :: basein_local
integer                      :: ipound
integer                      :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                   ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=huge(0)
  y=0.0_real64
  ALL: if(basein_local<2.or.basein_local>36) then
    write(stderr,*) '(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
    out_baseten=huge(0)
  else ALL
     out_baseten=0;y=0.0_real64; mult=1.0_real64
     long=len_trim(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(stderr,*)'*decodebase* ERROR: invalid character ',ch
           out_baseten=huge(0)
           exit ALL
        endif
        if(ch<='9') then
              j=iachar(ch)-iachar('0')
        else
              j=iachar(ch)-iachar('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    codebase(3f) - [M_strings:BASE] convert whole number in base 10 to
!!    string in base [2-36]
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function codebase(in_base10,out_base,answer,uc)
!!
!!    integer,intent(in)           :: in_base10
!!    integer,intent(in)           :: out_base
!!    character(len=*),intent(out) :: answer
!!    logical,intent(in),optional  :: uc
!!
!!##DESCRIPTION
!!    Convert a number from base 10 to base OUT_BASE. The function returns
!!    .FALSE. if OUT_BASE is not in the range [2..36] or if number IN_BASE10
!!    is too big.
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    in_base10   whole number to convert to an alternate base
!!    out_base    the desired base of the output
!!    answer      the input value converted to a string representing
!!                the original number IN_BASE10 in base OUT_BASE.
!!    uc          returned letters are uppercase if .true., lowercase
!!                if .false.
!!
!!##RETURNS
!!    Returns .true. if no error occurred, else returns .false. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_codebase
!!    use M_strings, only : codebase
!!    implicit none
!!    character(len=20) :: answer
!!    integer           :: i, j
!!    logical           :: ierr
!!    do j=1,100
!!       do i=2,36
!!          ierr=codebase(j,i,answer)
!!          write(*,*)'VALUE=',j,' BASE=',i,' ANSWER=',answer
!!       enddo
!!    enddo
!!    end program demo_codebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!     Ref.: "Math matiques en Turbo-Pascal by
!!            M. Ducamp and A. Reverchon (2),
!!            Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function codebase(inval10,outbase,answer,uc)

! ident_85="@(#) M_strings codebase(3f) convert whole number in base 10 to string in base [2-36]"

integer,intent(in)           :: inval10, outbase
logical,intent(in),optional  :: uc
character(len=*),intent(out) :: answer
real(kind=real64)            :: inval10_local
integer(kind=int64)          :: i, j, n, outbase_local, in_sign
integer,parameter            :: i0=iachar('0')
integer                      :: iA
  if(present(uc))then
     ia=merge(iachar('A'),iachar('a'),uc)
  else
     ia=iachar('A')
  endif
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
     write(stderr,*) '*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
     codebase=.false.
  else
     i=0
     j=len(answer)
     do while(inval10_local>0.0 )
        n=int(inval10_local-outbase_local*int(inval10_local/outbase_local))
        i=i+1
        if(i.gt.j)then
           write(stderr,*) '*codebase* ERROR: output longer than return string',i,j
           codebase=.false.
           exit
        endif
        if(n<10) then
           answer=achar(i0+n)//answer
        else
           answer=achar(iA+n-10)//answer
        endif
        !inval10_local=floor(inval10_local/outbase_local)
        inval10_local=int(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign == -1)then
     answer='-'//trim(answer)
  endif
  if(answer == '')then
     answer='0'
  endif
end function codebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function todecimal(base, instr)

! ident_86="@(#) M_strings todecimal(3f) given string and base return decimal integer"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function tobase(base, number)

! ident_87="@(#) M_strings tobase(3f) given integer and base return string"

! based on an example at rosetta code.
character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

!SUBROUTINE DectoBase(decimal, string, base)
! CHARACTER string
!    string = '0'
!    temp = decimal
!    length = CEILING( LOG(decimal+1, base) )   !<<<<<<<< INTERESTING
!    DO i = length, 1, -1
!      n = MOD( temp, base )
!      string(i) = "0123456789abcdefghijklmnopqrstuvwxyz"(n+1)
!      temp = INT(temp / base)
!    ENDDO
! END
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    paragraph(3f) - [M_strings:TOKENS] break a long line into a paragraph
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function paragraph(source_string,length)
!!
!!    character(len=*),intent(in)       :: source_string
!!    integer,intent(in)                :: length
!!    character(allocatable(len=length)    :: paragraph(:)
!!
!!##DESCRIPTION
!!    paragraph(3f) breaks a long line into a simple paragraph of specified
!!    line length.
!!
!!    Given a long string break it on spaces into an array such that no
!!    variable is longer than the specified length. Individual words longer
!!    than LENGTH will be placed in lines by themselves and the paragraph
!!    width will be increased to the length of the longest word.
!!
!!##OPTIONS
!!     SOURCE_STRING  input string to break into an array of shorter strings
!!                    on blank delimiters
!!     LENGTH         length of lines to break the string into.
!!
!!##RETURNS
!!     PARAGRAPH  character array filled with data from source_string
!!                broken at spaces into variables of length LENGTH.
!!
!!##EXAMPLES
!!
!!  sample program
!!
!!    program demo_paragraph
!!    use M_strings, only : paragraph
!!    implicit none
!!    character(len=:),allocatable :: paragrph(:)
!!    character(len=*),parameter    :: string= '&
!!     &one two three four five &
!!     &six seven eight &
!!     &nine ten eleven twelve &
!!     &thirteen fourteen fifteen sixteen &
!!     &seventeen'
!!
!!    write(*,*)'LEN=',len(string)
!!    write(*,*)'INPUT:'
!!    write(*,*)string
!!
!!    paragrph=paragraph(string,40)
!!    write(*,*)'LEN=',len(paragrph),' SIZE=',size(paragrph)
!!    write(*,*)'OUTPUT:'
!!    write(*,'(a)')paragrph
!!
!!    write(*,'(a)')paragraph(string,0)
!!    write(*,'(3x,a)')paragraph(string,47)
!!
!!    end program demo_paragraph
!!
!!   Results:
!!
!!     LEN=         106
!!     INPUT:
!!     one two three four five six seven eight nine ten eleven twelve
!!     thirteen fourteen fifteen sixteen seventeen
!!     LEN=          40  SIZE=           3
!!     OUTPUT:
!!    one two three four five six seven eight
!!    nine ten eleven twelve thirteen fourteen
!!    fifteen sixteen seventeen
!!    one
!!    two
!!    three
!!    four
!!    five
!!    six
!!    seven
!!    eight
!!    nine
!!    ten
!!    eleven
!!    twelve
!!    thirteen
!!    fourteen
!!    fifteen
!!    sixteen
!!    seventeen
!!       one two three four five six seven eight nine
!!       ten eleven twelve thirteen fourteen fifteen
!!       sixteen seventeen
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function paragraph(source_string,length)

! ident_88="@(#) M_strings paragraph(3f) wrap a long string into a paragraph"

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: ibegin
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: paragraph(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
!-----------------------------------------------------------------------------------------------------------------------------------
!  parse string once to find out how big to make the returned array, then redo everything but store the data
!  could store array of endpoints and leave original whitespace alone or many other options
   do i=1,2
      iword_max=0                                  ! length of longest token
      ilines=1                                     ! number of output line output will go on
      ilength=0                                    ! length of output line so far
      itoken=0                                     ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
      do while ( strtok(source_string,itoken,ibegin,iend,delimiters) )
         iword=iend-ibegin+1
         iword_max=max(iword_max,iword)
         if(iword > length)then                   ! this token is longer than the desired line length so put it on a line by itself
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then     ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph
               paragraph(ilines)=source_string(ibegin:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then       ! this word will fit on current line
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=ilength+iword+1
         else                                      ! adding this word would make line too long so start new line
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then                                 ! determined number of lines needed so allocate output array
         allocate(character(len=max(length,iword_max)) :: paragraph(ilines))
         paragraph=' '
      endif
   enddo
   paragraph=paragraph(:ilines)
end function paragraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function setbits8(string) result(answer)
integer(kind=int8)          :: answer
character(len=8),intent(in) :: string
integer                     :: pos
integer                     :: lgth
   answer=0_int8
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits8* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,lgth
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits8* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits8
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits16(string) result(answer)
integer(kind=int16)          :: answer
character(len=16),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int16
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits16* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits16* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits16
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits32(string) result(answer)
integer(kind=int32)          :: answer
character(len=32),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int32
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits32* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits32* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits32
!-----------------------------------------------------------------------------------------------------------------------------------
function setbits64(string) result(answer)
integer(kind=int64)          :: answer
character(len=64),intent(in) :: string
integer                      :: pos
integer                      :: lgth
   answer=0_int64
   lgth=len(string)
   if(lgth /= bit_size(answer))then
      write(stderr,*)'*setbits64* wrong string length =',lgth
      lgth=min(lgth,int(bit_size(answer)))
   endif
   do pos=1,len(string)
      select case(string(pos:pos))
       case('1')
         answer = ibset(answer, pos-1)
       case('0')
         answer = ibclr(answer, pos-1)
       case default
         write(stderr,*)'*setbits64* unknown value. must be 0 or 1. found [',string(pos:pos),'] at position ',pos,' in ',string
      end select
   enddo
end function setbits64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     str(3f) - [M_strings:TYPE] converts multiple values to a (CSV) string
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!     function str( g1,g2,g3,g4,g5,g6,g7,g8,g9,g10, &
!!                 & g11,g12,g13,g14,g15,g16,g17,g18,g19,g20,sep,csv)
!!
!!      class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9,g10
!!      class(*),intent(in),optional  :: g11,g12,g13,g14,g15,g16,g17,g18,g19,g20
!!      character(len=*),intent(in),optional :: sep
!!      logical,intent(in),optional :: csv
!!      character(len=:),allocatable :: str
!!
!!##DESCRIPTION
!!     str(3f) builds a string from up to twenty scalar values.
!!
!!##OPTIONS
!!     g[1-20]  optional value to print the value of after the message. May
!!              be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!              or CHARACTER.
!!     sep      separator between values. Defaults to a space
!!     csv      write output conforming to RFC 1080 for CSV (Comma-Separated
!!              Values) files
!!
!!##RETURNS
!!     str      description to print
!!
!!##EXAMPLES
!!
!!
!!   Sample program:
!!
!!        program demo_str
!!        use M_strings, only : str, quote
!!        implicit none
!!        character(len=:),allocatable :: pr
!!        character(len=:),allocatable :: frmt
!!        integer                      :: biggest
!!
!!        pr=str('HUGE(3f) integers',huge(0),&
!!        & 'and real',huge(0.0),'and double',huge(0.0d0))
!!        write(*,'(a)')pr
!!        pr=str('real            :',&
!!         & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!        write(*,'(a)')pr
!!        pr=str('doubleprecision :',&
!!         & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!        write(*,'(a)')pr
!!        pr=str('complex         :',&
!!         & cmplx(huge(0.0),tiny(0.0)) )
!!        write(*,'(a)')pr
!!
!!        ! create a format on the fly
!!        biggest=huge(0)
!!        ! +0 for gfortran-11 bug
!!        frmt=str('(*(i',int(log10(real(biggest)))+0,':,1x))',sep='')
!!        write(*,*)'format=',frmt
!!
!!        ! compound output
!!        pr=str(10,100.0,"string",(11.0,22.0),.false.)
!!        write(*,'(a)')pr
!!        ! a separator and also use of quote(3f)
!!        pr=str(10,100.0,quote("string"),(11.0,22.0),.false.,sep=';')
!!        write(*,'(a)')pr
!!        ! CSV mode
!!        pr=str(10,100.0,"string",(11.0,22.0),.false.,csv=.true.)
!!        write(*,'(a)')pr
!!        ! everything a vector instead of a scalar
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.])
!!        write(*,'(a)')pr
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.],sep='|')
!!        write(*,'(a)')pr
!!        pr=str([10,20,30],["string"],[(11.0,22.0)],[.false.,.true.],csv=.true.)
!!        write(*,'(a)')pr
!!
!!        ! although it will often work, using str(3f) in an I/O statement
!!        ! is not recommended
!!        write(*,*)str('program will now attempt to stop')
!!
!!        end program demo_str
!!
!! Results:
!!
!!  > HUGE(3f) integers 2147483647 and real 3.40282347E+38 and ...
!!  > ... double 1.7976931348623157E+308
!!  > real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!  > doubleprecision : 1.7976931348623157E+308 0.0000000000000000 ...
!!  > ... 12345.678900000001 2.2250738585072014E-308
!!  > complex         : (3.40282347E+38,1.17549435E-38)
!!  >  format=(*(i9:,1x))
!!  > 10 100.000000 string (11.0000000,22.0000000) F
!!  > 10;100.000000;"string";(11.0000000,22.0000000);F
!!  > 10,100.000000,"string",11.0000000,22.0000000,F
!!  >  program will now attempt to stop
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function str_scalar(g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, sep, csv)

! ident_89="@(#) M_strings str_scalar(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20
character(len=*),intent(in),optional :: sep
logical,intent(in),optional   :: csv
character(len=:),allocatable  :: sep_local
logical                       :: csv_local
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: ibegin
integer                       :: increment

   if(present(csv))then
      csv_local=csv
   else
      csv_local=.false.
   endif

   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=merge(',',' ',csv_local)
      increment=2
   endif

   ibegin=1
   line=' '
   if(present(g1))call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(g10))call print_generic(g10)
   if(present(g11))call print_generic(g11)
   if(present(g12))call print_generic(g12)
   if(present(g13))call print_generic(g13)
   if(present(g14))call print_generic(g14)
   if(present(g15))call print_generic(g15)
   if(present(g16))call print_generic(g16)
   if(present(g17))call print_generic(g17)
   if(present(g18))call print_generic(g18)
   if(present(g19))call print_generic(g19)
   if(present(g20))call print_generic(g20)
   str_scalar=trim(line)
   if(sep_local.ne.'')str_scalar=str_scalar(:len(str_scalar)-1)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int16));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int32));    write(line(ibegin:),'(i0)') generic
      type is (integer(kind=int64));    write(line(ibegin:),'(i0)') generic
      type is (real(kind=real32));      write(line(ibegin:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real128));     write(line(ibegin:),'(1pg0)') generic
      !x!type is (real(kind=real256));     write(line(ibegin:),'(1pg0)') generic
      type is (logical);                write(line(ibegin:),'(l1)') generic
      type is (character(len=*))
         if(csv_local)then
            write(line(ibegin:),'(a)') quote(trim(generic))
         else
            write(line(ibegin:),'(a)') trim(generic)
         endif
      type is (complex)
         if(csv_local)then
            write(line(ibegin:),'(1pg0,a,1pg0)') generic%re,sep_local,generic%im
         else
            write(line(ibegin:),'("(",1pg0,",",1pg0,")")') generic
         endif
   end select
   ibegin=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end function str_scalar
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str_one(g1, g2, g3, g4, g5, g6, g7, g8, g9, g10, g11, g12, g13, g14, g15, g16, g17, g18, g19, g20, sep, csv)

! ident_90="@(#) M_strings str_one(3fp) writes a message to a string composed of any standard one dimensional types"

class(*),intent(in)                  :: g1(:)
class(*),intent(in),optional         :: g2(:),g3(:),g4(:),g5(:),g6(:),g7(:),g8(:),g9(:),g10(:)
class(*),intent(in),optional         :: g11(:),g12(:),g13(:),g14(:),g15(:),g16(:),g17(:),g18(:),g19(:),g20(:)
character(len=*),intent(in),optional :: sep
logical,intent(in),optional          :: csv
character(len=:),allocatable         :: sep_local
logical                              :: csv_local
character(len=:), allocatable        :: str_one
character(len=4096)                  :: line
integer                              :: ibegin
integer                              :: increment

   if(present(csv))then
      csv_local=csv
   else
      csv_local=.false.
   endif

   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=merge(',',' ',csv_local)
      increment=2
   endif

   ibegin=1
   line=' '
   call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(g10))call print_generic(g10)
   if(present(g11))call print_generic(g11)
   if(present(g12))call print_generic(g12)
   if(present(g13))call print_generic(g13)
   if(present(g14))call print_generic(g14)
   if(present(g15))call print_generic(g15)
   if(present(g16))call print_generic(g16)
   if(present(g17))call print_generic(g17)
   if(present(g18))call print_generic(g18)
   if(present(g19))call print_generic(g19)
   if(present(g20))call print_generic(g20)
   str_one=trim(line)
   if(sep_local.ne.'')str_one=str_one(:len(str_one)-1)
contains
!===================================================================================================================================
subroutine print_generic(generic)
class(*),intent(in),optional :: generic(:)
integer :: i
   if(csv_local)then
      select type(generic)
         type is (integer(kind=int8));     write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int16));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int32));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (integer(kind=int64));    write(line(ibegin:),'(*(i0:,","))') generic
         type is (real(kind=real32));      write(line(ibegin:),'(*(1pg0:,","))') generic
         type is (real(kind=real64));      write(line(ibegin:),'(*(1pg0:,","))') generic
         !x!type is (real(kind=real128));     write(line(ibegin:),'(*(1pg0:,","))') generic
         !x!type is (real(kind=real256));     write(line(ibegin:),'(*(1pg0:,","))') generic
         type is (logical);                write(line(ibegin:),'(*(l1:,","))') generic
         type is (character(len=*));       write(line(ibegin:),'(:*(a:,","))') (quote(trim(generic(i))),i=1,size(generic))
         type is (complex);                write(line(ibegin:),'(*(1pg0,",",1pg0:))') generic
      end select
      ibegin=len_trim(line)+increment
      line=trim(line)//sep_local
   else
      select type(generic)
         type is (integer(kind=int8));     write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int16));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int32));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (integer(kind=int64));    write(line(ibegin:),'("[",*(i0:,","))') generic
         type is (real(kind=real32));      write(line(ibegin:),'("[",*(1pg0:,","))') generic
         type is (real(kind=real64));      write(line(ibegin:),'("[",*(1pg0:,","))') generic
         !x!type is (real(kind=real128));     write(line(ibegin:),'("[",*(1pg0:,","))') generic
         !x!type is (real(kind=real256));     write(line(ibegin:),'("[",*(1pg0:,","))') generic
         type is (logical);                write(line(ibegin:),'("[",*(l1:,","))') generic
         type is (character(len=*));       write(line(ibegin:),'("[",:*(:"""",a,"""":,","))') (trim(generic(i)),i=1,size(generic))
         type is (complex);                write(line(ibegin:),'("[",*(:"(",1pg0,",",1pg0,")":,","))') generic
      end select
      line=trim(line)//"]"
      ibegin=len_trim(line)+increment
      line=trim(line)//sep_local
   endif
end subroutine print_generic

end function str_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmt(3f) - [M_strings:TYPE] convert any intrinsic to a string using specified format
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function fmt(value,format) result(string)
!!
!!     class(*),intent(in),optional         :: value
!!     character(len=*),intent(in),optional :: format
!!     character(len=:),allocatable         :: string
!!##DESCRIPTION
!!    FMT(3f) converts any standard intrinsic value to a string using the specified
!!    format.
!!##OPTIONS
!!    value    value to print the value of. May be of type INTEGER, LOGICAL,
!!             REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER.
!!    format   format to use to print value. It is up to the user to use an
!!             appropriate format. The format does not require being
!!             surrounded by parenthesis. If not present a default is selected
!!             similar to what would be produced with free format, with
!!             trailing zeros removed.
!!##RETURNS
!!    string   A string value
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_fmt
!!     use :: M_strings, only : fmt
!!     implicit none
!!     character(len=:),allocatable :: output
!!
!!        output=fmt(10,"'[',i0,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(10.0/3.0,"'[',g0.5,']'")
!!        write(*,*)'result is ',output
!!
!!        output=fmt(.true.,"'The final answer is [',g0,']'")
!!        write(*,*)'result is ',output
!!
!!     end program demo_fmt
!!
!!   Results:
!!
!!     result is [10]
!!     result is [3.3333]
!!     result is The final answer is [T]
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
recursive function fmt(generic,format) result (line)

! ident_91="@(#) M_strings fmt(3f) convert any intrinsic to a string using specified format"

class(*),intent(in)                  :: generic
character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: line
character(len=:),allocatable         :: fmt_local
character(len=:),allocatable         :: re,im
integer                              :: iostat
character(len=255)                   :: iomsg
character(len=1),parameter           :: null=char(0)
integer                              :: ilen
logical                              :: trimit
   if(present(format))then
      fmt_local=format
      trimit=.false.
   else
      fmt_local=''
      trimit=.true.
   endif
   ! add ",a" and print null and use position of null to find length of output
   ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ,
   ! and do not want to trim as trailing spaces can be significant
   if(fmt_local == '')then
      select type(generic)
         type is (integer(kind=int8));     fmt_local='(i0,a)'
         type is (integer(kind=int16));    fmt_local='(i0,a)'
         type is (integer(kind=int32));    fmt_local='(i0,a)'
         type is (integer(kind=int64));    fmt_local='(i0,a)'
         type is (real(kind=real32));      fmt_local='(1pg0,a)'
         type is (real(kind=real64));      fmt_local='(1pg0,a)'
#ifdef __NVCOMPILER
#else
         type is (real(kind=real128));     fmt_local='(1pg0,a)'
#endif
         type is (logical);                fmt_local='(l1,a)'
         type is (character(len=*));       fmt_local='(a,a)'
         type is (complex);                fmt_local='("(",1pg0,",",1pg0,")",a)'
         type is (complex(kind=real64));   fmt_local='("(",1pg0,",",1pg0,")",a)'
         class default
          fmt_local='(*(g0,1x)'
          stop '<ERROR>*fmt* unknown type.'
      end select
   else
      if(format(1:1) == '(')then
         fmt_local=format(:len_trim(format)-1)//',a)'
      else
         fmt_local='('//fmt_local//',a)'
      endif
   endif
   allocate(character(len=256) :: line) ! cannot currently write into allocatable variable
   iostat=0
   select type(generic)
      type is (integer(kind=int8));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int16));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int32));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (integer(kind=int64));    write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real32));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (real(kind=real64));      write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
#endif
      type is (logical);                write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (character(len=*));       write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
      type is (complex);
              if(trimit)then
                 re=fmt(generic%re)
                 im=fmt(generic%im)
                 call trimzeros_(re)
                 call trimzeros_(im)
                 fmt_local='("(",g0,",",g0,")",a)'
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) trim(re),trim(im),null
                 trimit=.false.
              else
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
              endif
      type is (complex(kind=real64));
              if(trimit)then
                 re=fmt(generic%re)
                 im=fmt(generic%im)
                 call trimzeros_(re)
                 call trimzeros_(im)
                 fmt_local='("(",g0,",",g0,")",a)'
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) trim(re),trim(im),null
                 trimit=.false.
              else
                 write(line,fmt_local,iostat=iostat,iomsg=iomsg) generic,null
              endif
      class default
          stop '<ERROR>*fmt* unknown type'
   end select
   if(iostat /= 0)then
      line='<ERROR>'//trim(iomsg)
   else
      ilen=index(line,null,back=.true.)
      if(ilen == 0)ilen=len(line)
      line=line(:ilen-1)
   endif

   if(index(line,'.') /= 0 .and. trimit) call trimzeros_(line)

end function fmt
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    find_field(3f) - [M_strings:TOKENS] parse a string into tokens
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine find_field (string, field, position, delims, delim, found)
!!
!!     character*(*),intent(in)           :: string
!!     character*(*),intent(out)          :: field
!!     integer,optional,intent(inout)     :: position
!!     character*(*),optional,intent(in)  :: delims
!!     character*(*),optional,intent(out) :: delim
!!     logical,optional,intent(out)       :: found
!!
!!##DESCRIPTION
!!
!!    Find a delimited field in a string.
!!
!!    Here is my equivalent, which I have used for nearly 2 decades, as you can
!!    see from the date. This does not try to mimic the C strtok (and does not
!!    have its limitations either). It is in a much more native Fortran style.
!!
!!    It is a little more complicated than some because it does some things
!!    that I regularly find useful. For example, it can tell the caller what
!!    trailing delimiter it found. This can be useful, for example, to
!!    distinguish between
!!
!!        somefield, someotherfield
!!
!!    versus
!!
!!        somefield=somevalue, someotherfield
!!
!!    Also, I have a bit of special handling for blanks. All the usage
!!    information is in the argument descriptions. Note that most of the
!!    arguments are optional.
!!
!!    from comp.lang.fortran @ Richard Maine
!!
!!##OPTIONS
!!    STRING     The string input.
!!
!!    FIELD      The returned field. Blank if no field found.
!!
!!    POSITION   On entry, the starting position for searching for the field.
!!               Default is 1 if the argument is not present.
!!               On exit, the starting position of the next field or
!!               len(string)+1 if there is no following field.
!!
!!    DELIMS     String containing the characters to be accepted as delimiters.
!!               If this includes a blank character, then leading blanks are
!!               removed from the returned field and the end delimiter may
!!               optionally be preceded by blanks. If this argument is
!!               not present, the default delimiter set is a blank.
!!
!!    DELIM      Returns the actual delimiter that terminated the field.
!!               Returns char(0) if the field was terminated by the end of
!!               the string or if no field was found.
!!               If blank is in delimiters and the field was terminated
!!               by one or more blanks, followed by a non-blank delimiter,
!!               the non-blank delimiter is returned.
!!
!!    FOUND      True if a field was found.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!        program demo_find_field
!!        use M_strings, only : find_field
!!        implicit none
!!        character(len=256)           :: string
!!        character(len=256)           :: field
!!        integer                      :: position
!!        character(len=:),allocatable :: delims
!!        character(len=1)             :: delim
!!        logical                      :: found
!!
!!        delims='[,]'
!!        position=1
!!        found=.true.
!!        string='[a,b,[ccc,ddd],and more]'
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,delims,delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">")')trim(field)
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        position=1
!!        found=.true.
!!        write(*,'(a)')trim(string)
!!        do
!!           call find_field(string,field,position,'[], ',delim,found=found)
!!           if(.not.found)exit
!!           write(*,'("<",a,">",i0,1x,a)')trim(field),position,delim
!!        enddo
!!        write(*,'(*(g0))')repeat('=',70)
!!
!!        end program demo_find_field
!!
!! Results:
!!
!!     > [a,b,[ccc,ddd],and more]
!!     > <>
!!     > <a>
!!     > <b>
!!     > <>
!!     > <ccc>
!!     > <ddd>
!!     > <>
!!     > <and more>
!!     > <>
!!     > ==================================================================
!!     > [a,b,[ccc,ddd],and more]
!!     > <>2 [
!!     > <a>4 ,
!!     > <b>6 ,
!!     > <>7 [
!!     > <ccc>11 ,
!!     > <ddd>15 ]
!!     > <>16 ,
!!     > <and>20
!!     > <more>257 ]
!!     > ==================================================================
!!
!!##AUTHOR
!!    Richard Maine
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright Nov 15 1990, Richard Maine
!!
!!    Minor editing to conform to inclusion in the string procedure module
subroutine find_field (string, field, position, delims, delim, found)

!-- Find a delimited field in a string.
!-- 15 Nov 90, Richard Maine.

!-------------------- interface.
character*(*),intent(in)           :: string
character*(*),intent(out)          :: field
integer,optional,intent(inout)     :: position
character*(*),optional,intent(in)  :: delims
character*(*),optional,intent(out) :: delim
logical,optional,intent(out)       :: found
!-------------------- local.
character  :: delimiter*1
integer    :: pos, field_start, field_end, i
logical    :: trim_blanks
!-------------------- executable code.
   field = ''
   delimiter = char(0)
   pos = 1
   if (present(found)) found = .false.
   if (present(position)) pos = position
   if (pos > len(string)) goto 9000
   !if (pos < 1) error stop 'Illegal position in find_field'
   if (pos < 1) stop 'Illegal position in find_field'

   !-- Skip leading blanks if blank is a delimiter.
   field_start = pos
   trim_blanks = .true.
   if (present(delims)) trim_blanks = index(delims,' ') /= 0
   if (trim_blanks) then
      i = verify(string(pos:),' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      field_start = pos + i - 1
   end if
   if (present(found)) found = .true.

   !-- Find the end of the field.
   if (present(delims)) then
      i = scan(string(field_start:), delims)
   else
      i = scan(string(field_start:), ' ')
   end if
   if (i == 0) then
      field_end = len(string)
      delimiter = char(0)
      pos = field_end + 1
   else
      field_end = field_start + i - 2
      delimiter = string(field_end+1:field_end+1)
      pos = field_end + 2
   end if

   !-- Return the field.
   field = string(field_start:field_end)

   !-- Skip trailing blanks if blank is a delimiter.
   if (trim_blanks) then
      i = verify(string(field_end+1:), ' ')
      if (i == 0) then
         pos = len(string) + 1
         goto 9000
      end if
      pos = field_end + i

      !-- If the first non-blank character is a delimiter,
      !-- skip blanks after it.
      i = 0
      if (present(delims)) i = index(delims, string(pos:pos))
      if (i /= 0) then
         delimiter = string(pos:pos)
         pos = pos + 1
         i = verify(string(pos:), ' ')
         if (i == 0) then
            pos = len(string) + 1
         else
            pos = pos + i - 1
         end if
      end if
   end if
   !---------- Normal exit.
   9000 continue
   if (present(delim)) delim = delimiter
   if (present(position)) position = pos
end subroutine find_field
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split2020(3f) - [M_strings:TOKENS] parse a string into tokens using
!!    proposed f2023 method
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   TOKEN form
!!
!!    subroutine split2020 (string, set, tokens, separator)
!!    character(len=*),intent(in)                       :: string
!!    character(len=*),intent(in)                       :: set
!!    character(len=:),allocatable,intent(out)          :: tokens(:)
!!    character(len=1),allocatable,intent(out),optional :: separator(:)
!!
!!   BOUNDS ARRAY form
!!
!!    subroutine split2020 (string, set, first, last)
!!    character(len=*),intent(in)     :: string
!!    character(len=*),intent(in)     :: set
!!    integer,allocatable,intent(out) :: first(:)
!!    integer,allocatable,intent(out) :: last(:)
!!
!!   STEP THROUGH BY POSITION form
!!
!!    subroutine split2020 (string, set, pos [, back])
!!    character(len=*),intent(in) :: string
!!    character(len=*),intent(in) :: set
!!    integer,intent(inout)       :: pos
!!    logical,intent(in),optional :: back
!!
!!##DESCRIPTION
!!    Parse a string into tokens. STRING, SET, TOKENS and SEPARATOR must
!!    all be of the same CHARACTER kind type parameter.
!!
!!##OPTIONS
!!    STRING      string to break into tokens
!!
!!    SET         Each character in SET is a token delimiter. A
!!                sequence of zero or more characters in STRING delimited by
!!                any token delimiter, or the beginning or end of STRING,
!!                comprise a token. Thus, two consecutive token delimiters
!!                in STRING, or a token delimiter in the first or last
!!                character of STRING, indicate a token with zero length.
!!
!!                ??? how about if null defaults to all whitespace characters
!!
!!    TOKENS      It is allocated with the lower bound equal to
!!                one and the upper bound equal to the number of tokens in
!!                STRING, and with character length equal to the length of
!!                the longest token. The tokens in STRING are assigned by
!!                intrinsic assignment, in the order found, to the elements
!!                of TOKENS, in array element order.
!!
!!                ???If input is null it still must be of size 1?
!!
!!    SEPARATOR   Each element in SEPARATOR(i) is assigned the value of
!!                the ith token delimiter in STRING.
!!                It is allocated with the lower bound equal to
!!                one and the upper bound equal to one less than the number
!!                of tokens in STRING, and with character length equal to
!!                one.
!!
!!                ???one less than? '' ' '
!!
!!    FIRST     It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the starting
!!              position of each token in STRING, in the order found. If a
!!              token has zero length, the starting position is equal to one
!!              if the token is at the beginning of STRING, and one greater
!!              than the position of the preceding delimiter otherwise.
!!
!!    LAST      It is allocated with the lower bound equal to one and the
!!              upper bound equal to the number of tokens in STRING. Each
!!              element is assigned, in array element order, the ending
!!              position of each token in STRING, in the order found. If
!!              a token has zero length, the ending position is one less
!!              than the starting position.
!!
!!    POS       If BACK is present with the value .TRUE., the value
!!              of POS shall be in the range 0 < POS     LEN (STRING)+1;
!!              otherwise it shall be in the range 0     POS LEN (STRING).
!!
!!              If BACK is absent or is present with the value .FALSE., POS
!!              is assigned the position of the leftmost token delimiter in
!!              STRING whose position is greater than POS, or if there is
!!              no such character, it is assigned a value one greater than
!!              the length of STRING. This identifies a token with starting
!!              position one greater than the value of POS on invocation,
!!              and ending position one less than the value of POS on return.
!!
!!              If BACK is present with the value true, POS is assigned the
!!              position of the rightmost token delimiter in STRING whose
!!              position is less than POS, or if there is no such character,
!!              it is assigned the value zero. This identifies a token with
!!              ending position one less than the value of POS on invocation,
!!              and starting position one greater than the value of POS
!!              on return.
!!
!!              When SPLIT is invoked with a value for POS of
!!              1 <= POS <= LEN(STRING) and STRING(POS:POS) is not a
!!              token delimiter present in SET, the token identified by
!!              SPLIT does not comprise a complete token as described in the
!!              description of the SET argument, but rather a partial token.
!!
!!    BACK      shall be a logical scalar. It is an INTENT (IN) argument. If
!!              POS does not appear and BACK is present with the value true,
!!              STRING is scanned backwards for tokens starting from the
!!              end. If POS does not appear and BACK is absent or present
!!              with the value false, STRING is scanned forwards for tokens
!!              starting from the beginning.
!!
!!##EXAMPLES
!!
!! Sample of uses
!!
!!    program demo_sort2020
!!    use M_strings, only : split2020
!!    implicit none
!!    character(len=*),parameter :: gen='(*("[",g0,"]":,","))'
!!
!!     ! Execution of TOKEN form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=:), allocatable :: tokens(:)
!!       character (len=*),parameter :: set = " ,"
!!       string = 'first,second,third'
!!       call split2020(string, set, tokens )
!!       write(*,gen)tokens
!!
!!     ! assigns the value ['first ','second','third ' ]
!!     ! to TOKENS.
!!     endblock
!!
!!     ! Execution of BOUNDS form
!!
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer, allocatable        :: first(:), last(:)
!!       string =    'first,second,,forth'
!!       call split2020 (string, set, first, last)
!!       write(*,gen)first
!!       write(*,gen)last
!!
!!     ! will assign the value [ 1, 7, 14, 15 ] to FIRST,
!!     ! and the value [ 5, 12, 13, 19 ] to LAST.
!!     endblock
!!
!!     ! Execution of STEP form
!!     block
!!       character (len=:), allocatable :: string
!!       character (len=*),parameter :: set = " ,"
!!       integer :: p, ibegin, iend
!!       string = " one,   last  example  "
!!       do while (p < len(string))
!!         ibegin = p + 1
!!         call split2020 (string, set, p)
!!         iend=p-1
!!         if(iend > ibegin)then
!!            print '(t3,a,1x,i0,1x,i0)', string (ibegin:iend),ibegin,iend
!!         endif
!!       enddo
!!     endblock
!!    end program demo_sort2020
!!
!!   Results:
!!
!!    [first ],[second],[third ]
!!    [1],[7],[14],[15]
!!    [5],[12],[13],[19]
!!      one 2 4
!!      last 9 12
!!      example 15 21
!!
!!      > ??? option to skip adjacent delimiters (not return null tokens)
!!      >     common with whitespace
!!      > ??? quoted strings, especially CSV both " and ', Fortran adjacent
!!      >     is insert versus other rules
!!      > ??? escape character like \\ .
!!      > ??? multi-character delimiters like \\n, \\t,
!!      > ??? regular expression separator
!!
!!##AUTHOR
!!    Milan Curcic, "milancurcic@hey.com"
!!
!!##LICENSE
!!    MIT
!!
!!##VERSION
!!    version 0.1.0, copyright 2020, Milan Curcic
pure subroutine split_tokens(string, set, tokens, separator)
! Splits a string into tokens using characters in set as token delimiters.
! If present, separator contains the array of token delimiters.
character(*), intent(in)                      :: string
character(*), intent(in)                      :: set
character(:), allocatable, intent(out)        :: tokens(:)
character, allocatable, intent(out), optional :: separator(:)

integer, allocatable                          :: first(:), last(:)
integer                                       :: n
integer                                       :: imax

    call split2020(string, set, first, last)
    ! maxval() of a zero-size array is set to a flag value not zero or length of character string
    if(size(first).eq.0)then
       imax=0
    else
       imax=maxval(last-first)+1
    endif
    allocate(character(len=imax) :: tokens(size(first)))

    do concurrent (n = 1:size(tokens))
      tokens(n) = string(first(n):last(n))
    enddo

    if (present(separator)) then
      allocate(separator(size(tokens) - 1))
      do concurrent (n = 1:size(tokens) - 1)
        separator(n) = string(first(n+1)-1:first(n+1)-1)
      enddo
    endif

  end subroutine split_tokens
!===================================================================================================================================
  pure subroutine split_first_last(string, set, first, last)
     ! Computes the first and last indices of tokens in input string, delimited
     ! by the characters in set, and stores them into first and last output
     ! arrays.
    character(*), intent(in)          :: string
    character(*), intent(in)          :: set
    integer, allocatable, intent(out) :: first(:)
    integer, allocatable, intent(out) :: last(:)

    character                         :: set_array(len(set))
    logical, dimension(len(string))   :: is_first, is_last, is_separator
    integer                           :: n, slen

    slen = len(string)

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    do concurrent (n = 1:slen)
      is_separator(n) = any(string(n:n) == set_array)
    enddo

    is_first = .false.
    is_last = .false.

    if (.not. is_separator(1)) is_first(1) = .true.

    do concurrent (n = 2:slen-1)
      if (.not. is_separator(n)) then
        if (is_separator(n - 1)) is_first(n) = .true.
        if (is_separator(n + 1)) is_last(n) = .true.
      else
        if (is_separator(n - 1)) then
          is_first(n) = .true.
          is_last(n-1) = .true.
        endif
      endif
    enddo

    if (.not. is_separator(slen)) is_last(slen) = .true.

    first = pack([(n, n = 1, slen)], is_first)
    last = pack([(n, n = 1, slen)], is_last)

  end subroutine split_first_last
!===================================================================================================================================
  pure subroutine split_pos(string, set, pos, back)
     ! If back is absent, computes the leftmost token delimiter in string whose
     ! position is > pos. If back is present and true, computes the rightmost
     ! token delimiter in string whose position is < pos. The result is stored
     ! in pos.
    character(*), intent(in)      :: string
    character(*), intent(in)      :: set
    integer, intent(in out)       :: pos
    logical, intent(in), optional :: back

    logical                       :: backward
    character                     :: set_array(len(set))
    integer                       :: n, result_pos

    !TODO use optval when implemented in stdlib
    !backward = optval(back, .false.)
    backward = .false.
    if (present(back)) backward = back

    do concurrent (n = 1:len(set))
      set_array(n) = set(n:n)
    enddo

    if (backward) then
      result_pos = 0
      do n = pos - 1, 1, -1
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    else
      result_pos = len(string) + 1
      do n = pos + 1, len(string)
        if (any(string(n:n) == set_array)) then
          result_pos = n
          exit
        endif
      enddo
    endif

    pos = result_pos

  end subroutine split_pos
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function string_tokens(string, set) result(tokens)
! Splits a string into tokens using characters in set as token delimiters.
character(*), intent(in)  :: string
character(*), intent(in)  :: set
character(:), allocatable :: tokens(:)
   call split_tokens(string, set, tokens)
end function string_tokens
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! Duplicate the M_journal module in condensed form for now so can be stand-alone on GITHUB
!                                                                     ll
!                                                                      l
!    j                                                                 l
!                                                                      l
!    j                                                                 l
!    j        oooooo    u      u   r rrrrrr   n nnnnn      aaaa        l
!    j       o      o   u      u   rr         nn     n         a       l
!    j       o      o   u      u   r          n      n    aaaaaa       l
! j  j       o      o   u      u   r          n      n   a     a       l
!  jj         oooooo     uuuuuu u  r          n      n    aaaaa a      l
!
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! @(#) place-holder for journal module
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

!@(#) M_journal::where_write_message(3fp): basic message routine used for journal files

character(len=*),intent(in)       :: where
character(len=*),intent(in)       :: msg
logical,save                      :: trailopen=.false.
integer,save                      :: itrail
character,save                    :: comment='#'
integer                           :: i
integer                           :: iostat
integer                           :: times             ! number of times written to stdout
character(len=3)                  :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable      :: prefix            ! the prefix string to add to output
logical,save                      :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)               :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   prefix=''
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
          !elseif(times == 0)then
          !   write(stdout,'(a)',advance=adv)prefix//trim(msg)
          !   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=iostat)
            open(unit=last_int,file=clip(msg),iostat=iostat)
            if(iostat == 0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',iostat
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=iostat)
            stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
             ! write(stdout,'(2a)',advance=adv)prefix,trim(msg)
             ! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=iostat,iomsg=mssge)
         if(iostat /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=clip(msg),&
            & form='formatted',iostat=iostat,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=clip(msg),form='formatted',iostat=iostat)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=iostat)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()
call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

!$(#) M_journal::write_message_only(3fp): calls JOURNAL('sc',message)

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     matching_delimiter(3f) - [M_strings:QUOTES] find position of matching delimiter
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   impure elemental subroutine matching_delimiter(str,ipos,imatch)
!!
!!    character(len=*),intent(in)  :: str
!!    integer,intent(in)           :: ipos
!!    integer,intent(out)          :: imatch
!!
!!##DESCRIPTION
!!    Sets imatch to the position in string of the delimiter matching the
!!    delimiter in position ipos. Allowable delimiters are (), [], {}, <>.
!!
!!##OPTIONS
!!    str     input string to locate delimiter position in
!!    ipos    position of delimiter to find match for
!!    imatch  location of matching delimiter. If no match is found, zero (0)
!!            is returned.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_matching_delimiter
!!       use M_strings, only : matching_delimiter
!!       implicit none
!!       character(len=128)  :: str
!!       integer             :: imatch
!!
!!       str=' a [[[[b] and ] then ] finally ]'
!!       write(*,*)'string=',str
!!       call matching_delimiter(str,1,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,4,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,5,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,6,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,7,imatch)
!!       write(*,*)'location=',imatch
!!       call matching_delimiter(str,32,imatch)
!!       write(*,*)'location=',imatch
!!
!!    end program demo_matching_delimiter
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
impure elemental subroutine matching_delimiter(str,ipos,imatch)

! Sets imatch to the position in string of the delimiter matching the delimiter
! in position ipos. Allowable delimiters are (), [], {}, <>.

! pedigree?

character(len=*),intent(in) :: str
integer,intent(in)          :: ipos
integer,intent(out)         :: imatch

character                   :: delim1,delim2,ch
integer                     :: lenstr
integer                     :: idelim2
integer                     :: ibegin, iend
integer                     :: inc
integer                     :: isum
integer                     :: i

imatch=0
lenstr=len_trim(str)
delim1=str(ipos:ipos)
select case(delim1)
   case('(')
      idelim2=iachar(delim1)+1
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(')')
      idelim2=iachar(delim1)-1
      ibegin=ipos-1
      iend=1
      inc=-1
   case('[','{','<')
      idelim2=iachar(delim1)+2
      ibegin=ipos+1
      iend=lenstr
      inc=1
   case(']','}','>')
      idelim2=iachar(delim1)-2
      ibegin=ipos-1
      iend=1
      inc=-1
   case default
      write(stderr,*) '*matching_delimiter*',delim1,' is not a valid delimiter'
      return
end select
if(ibegin < 1 .or. ibegin > lenstr) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
delim2=achar(idelim2) ! matching delimiter

isum=1
do i=ibegin,iend,inc
   ch=str(i:i)
   if(ch /= delim1 .and. ch /= delim2) cycle
   if(ch == delim1) isum=isum+1
   if(ch == delim2) isum=isum-1
   if(isum == 0) exit
enddo
if(isum /= 0) then
   write(stderr,*) '*matching_delimiter*',delim1,' has no matching delimiter'
   return
endif
imatch=i

end subroutine matching_delimiter
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_common_substring(3f) - [M_strings:COMPARE] function that
!!    returns the longest common substring of two strings.
!!##SYNOPSIS
!!
!!    function longest_common_substring(a,b) result(match)
!!
!!     character(len=*),intent(in)  :: a, b
!!     character(len=:),allocatable :: match
!!##DESCRIPTION
!!    function that returns the longest common substring of two strings.
!!
!!    Note that substrings are consecutive characters within a string.
!!    This distinguishes them from subsequences, which is any sequence of
!!    characters within a string, even if there are extraneous characters in
!!    between them.
!!
!!    Hence, the longest common subsequence between "thisisatest" and
!!    "testing123testing" is "tsitest", whereas the longest common substring
!!    is just "test".
!!##OPTIONS
!!    a,b  strings to search for the longest common substring.
!!##RETURNS
!!    longest_common_substring  the longest common substring found
!!##EXAMPLES
!!
!!  Sample program
!!
!!    program demo_longest_common_substring
!!    use M_strings, only : longest_common_substring
!!    implicit none
!!      call compare('testing123testingthing','thisis',             'thi')
!!      call compare('testing',             'sting',              'sting')
!!      call compare('thisisatest_stinger','testing123testingthing','sting')
!!      call compare('thisisatest_stinger', 'thisis',            'thisis')
!!      call compare('thisisatest',         'testing123testing',   'test')
!!      call compare('thisisatest',      'thisisatest',     'thisisatest')
!!    contains
!!
!!    subroutine compare(a,b,answer)
!!    character(len=*),intent(in) :: a, b, answer
!!    character(len=:),allocatable :: match
!!    character(len=*),parameter :: g='(*(g0))'
!!       match=longest_common_substring(a,b)
!!       write(*,g) 'comparing "',a,'" and "',b,'"'
!!       write(*,g) merge('(PASSED) "','(FAILED) "',answer == match), &
!!       & match,'"; expected "',answer,'"'
!!    end subroutine compare
!!
!!    end program demo_longest_common_substring
!!
!!   expected output
!!
!!    comparing "testing123testingthing" and "thisis"
!!    (PASSED) "thi"; expected "thi"
!!    comparing "testing" and "sting"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "testing123testingthing"
!!    (PASSED) "sting"; expected "sting"
!!    comparing "thisisatest_stinger" and "thisis"
!!    (PASSED) "thisis"; expected "thisis"
!!    comparing "thisisatest" and "testing123testing"
!!    (PASSED) "test"; expected "test"
!!    comparing "thisisatest" and "thisisatest"
!!    (PASSED) "thisisatest"; expected "thisisatest"
function longest_common_substring(a,b) result(match)
character(len=*),intent(in)  :: a, b
character(len=:),allocatable :: match
character(len=:),allocatable :: a2, b2
integer                      :: left, foundat, len_a, i
   if(len(a) < len(b))then ! to reduce required comparisons look for shortest string in longest string
      a2=a
      b2=b
   else
      a2=b
      b2=a
   endif

   match=''

   do i=1,len(a2)-1
      len_a=len(a2)
      do left=1,len_a
         foundat=index(b2,a2(left:))
         if(foundat /= 0.and.len(match) < len_a-left+1)then
            if(len(a2(left:)) > len(match))then
               match=a2(left:)
               exit
            endif
         endif
      enddo

      if(len(a2) < len(match))exit
      a2=a2(:len(a2)-1)

   enddo

end function longest_common_substring
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    encode_base64-(3f) - [M_strings:ENCODE] encode data using base64
!!    encoding as defined in RFC-4648
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!     function encode_base64(text,width) result(out)
!!
!!      character(len=1),intent(in) :: text(*)
!!      integer,intent(in),optional :: width
!!      character(len=1),allocatable :: out(:)
!!
!!##DESCRIPTION
!!
!!    The data is encoded as described for the base64-alphabet-encoding in
!!    RFC 4648.
!!
!!##OPTIONS
!!
!!    TEXT   Data to encode
!!    WIDTH  wrap encoded lines after specified number of characters
!!           (default 76). Use 0 to disable line wrapping
!!##OUTPUT
!!
!!    OUT    array of encoded characters representing input text
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!    program demo_encode_base64
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use M_strings, only : switch, encode_base64, decode_base64
!!    implicit none
!!    integer                      :: i
!!    character(len=1),parameter   :: nl=new_line('a')
!!    character(len=1),allocatable :: textin(:), textout(:)
!!    character(len=*),parameter   :: data(*)=[ &
!!    'This is some sample data          ',  &
!!    'To encode. Should make it long    ',  &
!!    'enough to generate multiple lines ',  &
!!    'of output so can check line wrap  ',  &
!!    'functionality as well.            '   &
!!    ]
!!    ! make a file-like byte stream by trimming lines and adding newlines
!!       textin=[(switch(trim(data(i))),new_line('a'),i=1,size(data))]
!!       write(*,'(*(a))')'input:',nl,textin
!!    !
!!       textout=encode_base64(textin,width=50)
!!       write(*,'(*(a))')'result:',nl, textout
!!    !
!!       write(*,'(*(a))')'decode result:',nl, decode_base64(textout)
!!    !
!!    ! one way to encode non-byte data
!!       call other()
!!    contains
!!    subroutine other()
!!    real                         :: arr1(100)
!!    character(len=1),allocatable :: in(:)
!!    character(len=1),allocatable :: out(:)
!!    real,allocatable             :: arr2(:)
!!       ! fill a real array with some values
!!       arr1=[(sqrt(real(i)),i=1,size(arr1))]
!!       ! use TRANSFER() to convert data to bytes
!!       in=transfer(source=arr1,mold=['+'])
!!       ! encode the bytes
!!       out=encode_base64(in)
!!       ! decode the bytes
!!       out=decode_base64(out)
!!       ! store the bytes back into arr1
!!       arr2=transfer(source=out,mold=[0.0])
!!       write(*,'(*(g0,1x))') 'are arr1 and arr2 the same?',all(arr1.eq.arr2)
!!    end subroutine other
!!    end program demo_encode_base64
!!
!! Results:
!!
!!  > input:
!!  > This is some sample data
!!  > To encode. Should make it long
!!  > enough to generate multiple lines
!!  > of output so can check line wrap
!!  > functionality as well.
!!  >
!!  > result:
!!  > VGhpcyBpcyBzb21lIHNhbXBsZSBkYXRhClRvIGVuY29kZS4gU2
!!  > hvdWxkIG1ha2UgaXQgbG9uZwplbm91Z2ggdG8gZ2VuZXJhdGUg
!!  > bXVsdGlwbGUgbGluZXMKb2Ygb3V0cHV0IHNvIGNhbiBjaGVjay
!!  > BsaW5lIHdyYXAKZnVuY3Rpb25hbGl0eSBhcyB3ZWxsLgo=
!!  >
!!  > decode result:
!!  > This is some sample data
!!  > To encode. Should make it long
!!  > enough to generate multiple lines
!!  > of output so can check line wrap
!!  > functionality as well.
!!  >
!!  > are arr1 and arr2 the same? T
!!
!!##SEE ALSO
!!     decode_base64(3), base64(1), uuencode(1), uudecode(1)
function encode_base64(data,width) result(out)
! encode data to base64 encryption as defined by RFC-4648
character(len=1),intent(in)  :: data(:)
integer,intent(in),optional  :: width
character(len=1),allocatable :: out(:)  ! array to hold encoded data in memory
integer(kind=int32)          :: i, j, column, sz, pad
character(len=1)             :: chunk(4)
integer                      :: wrap
integer,parameter            :: rfc4648_linelength=76
character(len=1),parameter   :: rfc4648_padding='='
integer                      :: ichars
integer                      :: outsize
   if(present(width))then
      wrap=width
   else
      wrap=rfc4648_linelength
   endif
   if(allocated(out))deallocate(out)
   sz=size(data)
   outsize=ceiling(sz/3.0)*4  ! need room for each set of 3 to become 4
   if(sz.gt.0.and.wrap.gt.0)then
      outsize=outsize+ceiling(real(outsize)/wrap) ! make room for newlines
   endif
   allocate( out(outsize) )
   pad=3-mod(sz,3)
   column=0
   ! place three bytes and zero into 32bit integer
   ! take sets of 6 bits from integer and place into every 8 bits
   ichars=0
   do i=1,sz,3
         if(i+3<=sz)then                  ! if not last
           chunk=three2four(data(i:i+2))
         elseif(modulo(sz,3).eq.0)then    ! last was an even multiple of three
           chunk=three2four(data(i:i+2))
         else                             ! end of data but remainder needs padded
           chunk=three2four([data(i:sz),[(char(0),j=1,3-(sz-i+1))]])
           ! replace added data with pad characters
           chunk(5-pad:)=[(rfc4648_padding,j=1,pad)]
         endif
         do j=1,4
            ichars=ichars+1
            out(ichars)=chunk(j)
            column=column+1
           if(wrap.gt.0)then
               if(column.ge.wrap)then
                       ichars=ichars+1
                       out(ichars)=new_line('a')
                  column=0
               endif
            endif
         enddo
   enddo
   if(column.ne.0.and.wrap.gt.0) then
      ichars=ichars+1
      out(ichars)=new_line('a')
   endif
end function encode_base64
!===================================================================================================================================
!>
!!##NAME
!!
!!    decode_base64-(3f) - [M_strings:ENCODE] decode data from base64
!!    encoding as defined in RFC-4648
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!     function decode_base64(text,ignore_garbage) result(out)
!!
!!      character(len=1),intent(in)  :: text(*)
!!      logical,intent(in),optional  :: ignore_garbage
!!      character(len=1),allocatable :: out(:)
!!
!!##DESCRIPTION
!!
!!    The data is deencoded as described for the base64-alphabet-encoding in
!!    RFC 4648.
!!
!!##OPTIONS
!!
!!    TEXT            Data to decode
!!
!!    IGNORE_GARBAGE  when decoding, ignore all characters not in the formal
!!                    base64 alphabet. This option will attempt to recover
!!                    from any other non-alphabet bytes in the encoded data.
!!
!!##OUTPUT
!!
!!    OUT    array of decoded characters
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!    program demo_decode_base64
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use M_strings, only : switch, encode_base64, decode_base64
!!    implicit none
!!    integer                      :: i
!!    character(len=1),parameter   :: nl=new_line('a')
!!    character(len=1),allocatable :: textin(:), textout(:)
!!    character(len=*),parameter   :: data(*)=[ &
!!    'This is some sample data          ',  &
!!    'To encode. Should make it long    ',  &
!!    'enough to generate multiple lines ',  &
!!    'of output so can check line wrap  ',  &
!!    'functionality as well.            '   &
!!    ]
!!    ! make a file-like byte stream by trimming lines and adding newlines
!!       textin=[(switch(trim(data(i))),new_line('a'),i=1,size(data))]
!!       write(*,'(*(a))')'input:',nl,textin
!!    !
!!       textout=encode_base64(textin,width=50)
!!       write(*,'(*(a))')'result:',nl, textout
!!    !
!!       write(*,'(*(a))')'decode result:',nl, decode_base64(textout)
!!    !
!!    end program demo_decode_base64
!!
!!  Results:
!!
!!     > input:
!!     > This is some sample data
!!     > To encode. Should make it long
!!     > enough to generate multiple lines
!!     > of output so can check line wrap
!!     > functionality as well.
!!     >
!!     > result:
!!     > VGhpcyBpcyBzb21lIHNhbXBsZSBkYXRhClRvIGVuY29kZS4gU2
!!     > hvdWxkIG1ha2UgaXQgbG9uZwplbm91Z2ggdG8gZ2VuZXJhdGUg
!!     > bXVsdGlwbGUgbGluZXMKb2Ygb3V0cHV0IHNvIGNhbiBjaGVjay
!!     > BsaW5lIHdyYXAKZnVuY3Rpb25hbGl0eSBhcyB3ZWxsLgo=
!!     >
!!     > decode result:
!!     > This is some sample data
!!     > To encode. Should make it long
!!     > enough to generate multiple lines
!!     > of output so can check line wrap
!!     > functionality as well.
!!     >
!!
!!##SEE ALSO
!!     encode_base64(3), base64(1), uuencode(1), uudecode(1)
function decode_base64(data,ignore_garbage) result(out)
! decode data to base64 encryption as defined by RFC-4648
use,intrinsic :: iso_fortran_env, only : int8, int32
character(len=1),intent(in)  :: data(:)
logical,intent(in),optional  :: ignore_garbage
integer(kind=int32)          :: i, j
character(len=1),allocatable :: text(:) ! array to hold file in memory
character(len=1),allocatable :: out(:)  ! array to decoded data in memory
character(len=1)             :: tri(3)
character(len=1),allocatable :: trilast(:)
character(len=*),parameter   :: rfc4648_alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
integer                      :: outsize
integer                      :: iput
   outsize=ceiling(size(data)/4.0)*3 ! conservative. might be smaller if no garbage and because last packet might be padded
   iput=0
   allocate(out(outsize))
   text=data   ! could parse out four characters at a time to avoid copy
   if(present(ignore_garbage))then
      if(ignore_garbage)then
         text=pack(text,index(rfc4648_alphabet,text).ne.0)
      else
         text=pack(text,.not.isspace(text))
      endif
   else
      text=pack(text,.not.isspace(text))
   endif
   do i=1,size(text)-7,4
      tri=four2three(text(i:i+3))
      do j=1,3
         iput=iput+1
         out(iput)=tri(j)
      enddo
   enddo
   ! the last four may represent 1,2, or 3 characters depending on the padding of the last quad of input characters
   trilast=four2three(text(i:i+3))
   do j=1,size(trilast)
      iput=iput+1
      out(iput)=trilast(j)
   enddo
   out=out(:iput)
end function decode_base64
!===================================================================================================================================
function four2three(quad) result(tri)
! place lower 6 bits of four bytes into 32bit integer
! take three sets of 8 bits from integer and place into three bytes
character(len=*),parameter   :: rfc4648_alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
character(len=1),parameter   :: rfc4648_padding='='
character(len=1),intent(in)  :: quad(4)
character(len=1)             :: out(4)
character(len=1),allocatable :: tri(:)
integer(kind=int32)          :: i32, o32, i
integer(kind=int8)           :: iquad(4)
   do i=1,4
      iquad(4-i+1)=index(rfc4648_alphabet,quad(i),kind=int8)-1_int8
   enddo
   i32 = transfer(iquad, i32 )
   ! The bits are numbered 0 to BIT_SIZE(I)-1, from right to left.
   o32=0
   call  mvbits(i32, 0,  6, o32, 0)
   call  mvbits(i32, 8,  6, o32, 6)
   call  mvbits(i32, 16, 6, o32, 12)
   call  mvbits(i32, 24, 6, o32, 18)
   out=transfer(o32, out)

   if(quad(3).eq.rfc4648_padding)then
      tri=out(3:3)
   elseif(quad(4).eq.rfc4648_padding)then
      tri=out(3:2:-1)
   else
      tri=out(3:1:-1)
   endif
end function four2three
!===================================================================================================================================
function three2four(tri) result(quad)
character(len=*),parameter  :: rfc4648_alphabet='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
character(len=1),intent(in) :: tri(3)
character(len=1)            :: quad(4)
integer(kind=int32)         :: i32, j, k, m, iout(4)
   i32 = transfer([(tri(j),j=3,1,-1),achar(0)], i32 )
   iout = 0
   do j=0,3 ! The bits are numbered 0 to BIT_SIZE(I)-1, from right to left.
      k=4-j
      call  mvbits(i32, (j)*6, 6, iout(k:k), 0)
      m=iout(k)+1
      quad(k)=rfc4648_alphabet(m:m)
   enddo
end function three2four
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

pure elemental function atoi (string) result(val)    ! Convert STRING to an integer value
integer(kind=int32) :: val
!>
!!##NAME
!!    atoi(3f) - [M_strings:TYPE] function returns a 32-bit
!!    integer value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function atoi (string) result(val)
!!
!!     character(len=*),intent(in)      :: string
!!     integer(kind=int32),intent(out)  :: val
!!
!!##DESCRIPTION
!!    function atoi(3f) converts a string representing an integer value
!!            to a numeric 32-bit integer value.
!!
!!##OPTIONS
!!     str      holds string assumed to represent a numeric integer value
!!
!!##RETURNS
!!     val      returned INTEGER.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_atoi
!!
!!       use iso_fortran_env, only: wp => int32
!!       use M_strings, only: atoi
!!       implicit none
!!       character(len=14),allocatable :: strings(:)
!!       integer(kind=wp)              :: iv
!!       integer                       :: i
!!
!!       ! different strings representing whole numbers
!!       strings=[&
!!       &'+10           ',&
!!       &'    -3        ',&
!!       &'              ',& ! Note: will return zero without an error message
!!       &'1 2 1 2 1 . 0 ',& ! Note: will just read first value
!!       &'WHAT?         ']  ! Note: will return zero without an error message
!!
!!       do i=1,size(strings)
!!          iv=atoi(strings(i))
!!          write(*,'(*(g0,1x))')'STRING:',strings(i),':VALUE:',iv
!!       enddo
!!
!!       end program demo_atoi
!!
!! Results:
!!
!!  > STRING: +10            :VALUE: 10
!!  > STRING:     -3         :VALUE: -3
!!  > STRING:                :VALUE: 0
!!  > STRING: 1 2 1 2 1 . 0  :VALUE: 1
!!  > STRING: WHAT?          :VALUE: 0
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
character(len=*), intent(in) :: string
character(len=1)             :: c
integer                      :: i
integer                      :: j
integer                      :: ilen
logical                      :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atoi

pure elemental function atol (string) result(val)    ! Convert STRING to an integer value
integer(kind=int64) :: val
!>
!!##NAME
!!    atol(3f) - [M_strings:TYPE] function returns a 64-bit
!!    integer value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure elemental function atol (string) result(val)
!!
!!     character(len=*),intent(in)      :: string
!!     integer(kind=int64),intent(out)  :: val
!!
!!##DESCRIPTION
!!    function atol(3f) converts a string representing an integer value
!!            to a numeric 64-bit integer value.
!!
!!##OPTIONS
!!     str      holds string assumed to represent a numeric integer value
!!
!!##RETURNS
!!     val      returned INTEGER.
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_atol
!!
!!       use iso_fortran_env, only: wp => int64
!!       use M_strings, only: atol
!!       implicit none
!!       character(len=14),allocatable :: strings(:)
!!       integer(kind=wp)              :: iv
!!       integer                       :: i
!!
!!       ! different strings representing whole numbers
!!       strings=[&
!!       &'+10           ',&
!!       &'    -3        ',&
!!       &'              ',& ! Note: will return zero without an error message
!!       &'1 2 1 2 1 . 0 ',& ! Note: will just read first value
!!       &'WHAT?         ']  ! Note: will return zero without an error message
!!
!!       do i=1,size(strings)
!!          iv=atol(strings(i))
!!          write(*,'(*(g0,1x))')'STRING:',strings(i),':VALUE:',iv
!!       enddo
!!
!!       end program demo_atol
!!
!! Results:
!!
!!  > STRING: +10            :VALUE: 10
!!  > STRING:     -3         :VALUE: -3
!!  > STRING:                :VALUE: 0
!!  > STRING: 1 2 1 2 1 . 0  :VALUE: 1
!!  > STRING: WHAT?          :VALUE: 0
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
character(len=*), intent(in) :: string
character(len=1)             :: c
integer                      :: i
integer                      :: j
integer                      :: ilen
logical                      :: neg

   val = 0
   neg=.false.
   i=0
   c=' '

   ilen=len(string)
   do i=1, ilen                               ! Pass over any leading spaces
      c = string(i:i)
      if (c  /=  ' ') exit
   enddo

   if (c  ==  '-') then                       ! check for +- as first digit
      neg = .true.
      i = i + 1
   elseif (c  ==  '+') then
      neg = .false.
      i = i + 1
   endif

   do j=i,ilen                                ! Continue as long as its a digit ...
      c = string(j:j)
      if (lge(c, '0') .and. lle(c, '9')) then
         val = 10*val + ichar(c)-48           ! Shift number over and add new digit
      else
         exit
      endif
   enddo

   if (neg) val = -val                        ! Negate the result if necessary

end function atol
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    aton(3f) - [M_strings:TYPE] function returns argument as a numeric
!!    value from a string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function aton(str,val[,msg])
!!
!!     character(len=*),intent(in)              :: str
!!     type(TYPE(kind=KIND)),intent(out)        :: val
!!     character(len=:),allocatable,intent(out) :: msg
!!
!!##DESCRIPTION
!!    This function converts a string to a numeric value.
!!
!!##OPTIONS
!!
!!     str      holds string assumed to represent a numeric value
!!     val      returned value. May be REAL or INTEGER.
!!     msg      message describing error when ATON returns .false.
!!
!!##RETURNS
!!     aton     .true. if the conversion was successful, .false. otherwise
!!
!!##EXAMPLES
!!
!!   Sample Program:
!!
!!      program demo_aton
!!
!!       use M_strings, only: aton
!!       implicit none
!!       character(len=14),allocatable :: strings(:)
!!       doubleprecision               :: dv
!!       integer                       :: iv
!!       real                          :: rv
!!       integer                       :: i
!!
!!       ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!       strings=[&
!!       &' 10.345       ',&
!!       &'+10           ',&
!!       &'    -3        ',&
!!       &'    -4.94e-2  ',&
!!       &'0.1           ',&
!!       &'12345.678910d0',&
!!       &'              ',& ! Note: will return zero without an error message
!!       &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!       &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!       do i=1,size(strings)
!!          write(*,'(a)',advance='no')'STRING:',strings(i)
!!          if(aton(strings(i),iv)) write(*,'(g0)',advance='no')':INTEGER ',iv
!!          if(aton(strings(i),rv)) write(*,'(g0)',advance='no')':INTEGER ',rv
!!          if(aton(strings(i),dv)) write(*,'(g0)',advance='no')':INTEGER ',dv
!!       enddo
!!
!!       end program demo_aton
!!
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
logical function ator_real32(str,val,msg)
use iso_fortran_env, only: wp => real32, ip => int64
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=byte),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=byte),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=byte)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=byte)            :: a, part
integer                       :: i, ipos, iostat, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real32 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real32 = .true.
   else
      read(str,fmt=*,iostat=iostat) val ! use internal read for INF, NAN for now
      if(iostat == 0)then
         ator_real32 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real32 = .false.
      endif
   endif
end function ator_real32
logical function ator_real64(str,val,msg)
use iso_fortran_env, only: wp => real64, ip => int64
! Convert ASCII-text to DP and return .TRUE. if OK
character(len=*),intent(in) :: str
real(kind=wp) :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter  :: upper_e=iachar('E'), lower_e=iachar('e'), upper_d=iachar('D'), lower_d=iachar('d')
integer(kind=byte),parameter  :: plus_sign=iachar('+'), minus_sign=iachar('-'), decimal=iachar('.')
integer(kind=byte),parameter  :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)              :: sval(3)
integer                       :: digit_count(3)
integer(kind=byte)            :: value(3,len(str))
real(kind=wp)                 :: whole, fractional
integer                       :: power
integer                       :: cnt(6)
integer(kind=byte)            :: a, part
integer                       :: i, ipos, iostat, too_many_digit_count

   value=0.0_wp
   cnt=0
   digit_count=0
   ipos=0
   ator_real64 = .false.
   sval = [1,0,1]
   part = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         digit_count(part) = digit_count(part) + 1
         if(digit_count(part) < 19)then
            value(part,digit_count(part)) = a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
      case(decimal)                              ! if more than once should report error
         if(part > 2)cnt(5)=99999               ! decimal in exponent
         part = 2                                ! starting fractional value
         cnt(1)=cnt(1)+1
      case(upper_e,lower_e,upper_d,lower_d)      ! if more than once should report error
         part = 3
         cnt(2)=cnt(2)+1                         ! if more than one encountered an error
         ipos=0
      case(minus_sign)                           ! sign in non-standard position or duplicated should report error
         sval(part) = -1
         if(ipos /= 1)cnt(6)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999               ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                         ! if more than one sign character an error, but caught by not being first
      case(space)                                ! should possibly not ignore all internal spaces
         ipos=ipos-1
      case default
         value(part,:) = 0.0_wp
         cnt(5)=99999                            ! unknown character
         !return
      end select
   enddo
   ! is no value after E an error?
   whole=0.0_wp
   do i = digit_count(1),1,-1
      whole=whole+value(1,i)*10**(digit_count(1)-i)
   enddo

   power=0
   do i = digit_count(3),1,-1
      power=power+value(3,i)*10**(digit_count(3)-i)
   enddo

   fractional=0.0_wp
   do i = digit_count(2),1,-1
      fractional=fractional+real(value(2,i),kind=wp)/10.0_wp**i
   enddo

   associate ( sgn=>sval(1), sexp=>sval(3) )
   val = sign(whole + fractional,real(sgn,kind=wp))* (10.0_wp**(power*sexp+too_many_digit_count))
   end associate
   if(all(cnt <= 1).and.ipos /= 0)then
      ator_real64 = .true.
   else
      read(str,fmt=*,iostat=iostat) val ! use internal read for INF, NAN for now
      if(iostat == 0)then
         ator_real64 = .true.
         if(present(msg)) msg=''
      else
         if(present(msg))then
            if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(5) /= 0)then
               msg='decimal in exponent in "'//trim(str)//'"'
            elseif(cnt(1) >= 2)then
               msg='multiple decimals in "'//trim(str)//'"'
            elseif(cnt(2) >= 2)then
               msg='more than one exponent prefix (e,d,E,D) in "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
         endif
         ator_real64 = .false.
      endif
   endif
end function ator_real64
logical function atoi_int8(str,val,msg)
use iso_fortran_env, only: ip => int64
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int8)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=byte),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=byte)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int8 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int8 = .false.
   endif
end function atoi_int8
logical function atoi_int16(str,val,msg)
use iso_fortran_env, only: ip => int64
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int16)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=byte),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=byte)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int16 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int16 = .false.
   endif
end function atoi_int16
logical function atoi_int32(str,val,msg)
use iso_fortran_env, only: ip => int64
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int32)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=byte),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=byte)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int32 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int32 = .false.
   endif
end function atoi_int32
logical function atoi_int64(str,val,msg)
use iso_fortran_env, only: ip => int64
! Convert ASCII-text to REAL and return .TRUE. if OK
character(len=*),intent(in)                       :: str
integer(kind=int64)                             :: val
character(len=:),allocatable,optional,intent(out) :: msg
integer(kind=byte),parameter                      :: plus_sign=iachar('+'), minus_sign=iachar('-')
integer(kind=byte),parameter                      :: space=iachar(' '), digit_0=iachar('0'), digit_9=iachar('9')
integer(kind=ip)                                  :: value, sval, digit_count
integer                                           :: cnt(6)
integer(kind=byte)                                :: a
integer                                           :: i, ipos, too_many_digit_count

   value=0
   cnt=0
   digit_count=0
   ipos=0
   sval = 1
   too_many_digit_count=0
   do i = 1, len(str)
      a=iachar(str(i:i),kind=byte)
      ipos=ipos+1
      select case(a)
      case(digit_0:digit_9)
         if(digit_count < 19)then
            value = value*10 + a-digit_0
         elseif(real(value*10)+real(a-digit_0) < huge(0_ip))then
            value = value*10 + a-digit_0
         else
            too_many_digit_count=too_many_digit_count+1    ! so many digit_count just use powers of ten after this
         endif
         digit_count = digit_count + 1
      case(minus_sign)                         ! sign in non-standard position or duplicated should report error
         sval = -1
         if(ipos /= 1)cnt(6)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(plus_sign)
         if(ipos /= 1)cnt(4)=99999             ! sign not first character of whole or exponent part
         cnt(3)=cnt(3)+1                       ! if more than one sign character an error, but caught by not being first
      case(space)                              ! should possibly not ignore all internal spaces (and maybe ignore commas too?)
         ipos=ipos-1
      case default
         value = 0
         cnt(5)=99999                          ! unknown character
      end select
   enddo
   val = sign(value,sval)* 10**too_many_digit_count
   if(all(cnt <= 1).and.ipos /= 0)then
      atoi_int64 = .true.
      if(present(msg)) msg=''
   else
      if(present(msg))then
         if(cnt(5) /= 0)then
               msg='illegal character in value "'//trim(str)//'"'
            elseif(cnt(3) >= 2)then
               msg='more than one sign character in "'//trim(str)//'"'
            elseif(cnt(6) /= 0)then
               msg='- sign character not first in "'//trim(str)//'"'
            elseif(cnt(4) >= 2)then
               msg='+ sign character not first in "'//trim(str)//'"'
            else
               msg='error in data conversion in "'//trim(str)//'"'
            endif
      endif
      atoi_int64 = .false.
   endif
end function atoi_int64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_strings

!>>>>> build/dependencies/M_history/src/M_history.f90
!>
!!##NAME
!!    redo(3f) - [M_history] Fortran-based Input History Editor
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine redo(inputline,r)
!!
!!      character(len=*) :: inputline
!!      character(len=1),intent(in),optional :: r
!!
!!##DESCRIPTION
!!    the redo(3f) routine lets you recall, list, save, and modify previously
!!    entered program input. Built-in help is included.
!!
!!    The redo(3f) input history editor is a simple-to-use input history
!!    editor interface modeled on the CDC NOS command REDO. It uses a
!!    line editor model that means no special escape characters or control
!!    characters are required. Typically, only a few minutes are required
!!    to master usage.
!!
!!    When using redo(3f) input lines are usually first read into a character
!!    variable and then passed to the routine. The returned string can then
!!    be parsed or read from with an internal READ(3f). So, for example,
!!    if you have an existing READ(3f) such as
!!
!!       READ(*,101) A,I,K
!!
!!    replace it with something similar to
!!
!!      USE M_HISTORY,ONLY : REDO
!!      CHARACTER(LEN=255) :: LINE ! make variable big enough to read a line
!!            :
!!            :
!!      READ(*,'(A)') LINE   ! read line into character variable
!!      CALL REDO(LINE)      ! pass line to REDO(3f). This is a no-op except
!!                           ! for storing the line into the input history
!!                           ! unless the input line is the "r" command
!!      READ(LINE,101)A,I,K  ! read from variable like you did from file
!!##OPTIONS
!!      inputline    line to record into history buffer file or to edit.
!!
!!      r            Optional character to use as command to invoke editing.
!!                   Defaults to 'r'.
!!
!!##USAGE
!!    When prompted for an input line by your program you may at any time
!!    enter "r" on a line by itself, or a line beginning with "r r_command"
!!    and you will enter the command history edit mode. Now you can recall
!!    and edit previous input or compose an input line using the editor
!!    commands.
!!
!!    By default, you will be editing the last line you entered, shifted
!!    one character to the right by an exclamation character.
!!
!!    The character you respond with in column one controls what happens next.
!!
!!    o If you enter "?" while in command edit mode, help is displayed.
!!
!!    o If the last input line is not the desired line to edit,
!!      select the line to edit by entering its line number or by
!!      using the /,l,u, and d commands (see below for details) to find the desired input line.
!!    o Next enter an editing directive (c,m) to edit the selected line. The
!!      "change" command will change all occurrences of an old string to a
!!      new string ...
!!
!!       c/old/new/
!!
!!    o or the "modify" command can be used with the special characters # &amp; and ^ ...
!!        o A # under a character will delete a character.
!!        o An "&" (ampersand) will cause the character above it to be replaced with a space.
!!        o  To insert a string enter ^string#.
!!        o Otherwise, enter a character under one in the currently displayed command and it will replace it.
!!        o hit RETURN to start another edit of the line
!!    o Once the change is executed you will be prompted for another edit
!!      directive
!!    o You will stay in edit mode until you enter a return on a
!!      blank line to feed your line to your program; or enter "." or
!!      "q" (which means cancel changes and return a blank line).
!!
!!    A detailed summary of the main edit-mode commands follows. In the
!!    descriptions, N stands for a number ...
!!
!!  LISTING COMMAND HISTORY
!!     l|p N      list from line N. -N shows N last lines
!!     L|P N      same as 'l' except no line numbers (for pasting)
!!     /string    search for simple string in all history lines
!!
!!  Note that the buffer is set to the last line displayed
!!
!!  POSITIONING TO PREVIOUS COMMANDS
!!     u N        up through buffer
!!     d N        down through buffer
!!     N          load line number
!!
!!  EDITING THE CURRENT BUFFER LINE
!!     c/oldstring/newstring/   change all occurrences of old string
!!                              to new string. Note that s
!!                              (for substitute) is a synonym for c
!!                              (for change).
!!
!!                              For the "c" directive the second character
!!                              becomes the delimiter. Traditionally one
!!                              usually uses a delimiter of / unless the
!!                              string you are editing contains /.
!!
!!     mmod_string    If the first character of your entry is m or blank,
!!              o REPLACE a string by entering a replacement character under it
!!              o LEAVE a character alone by leaving a space under it
!!              o DELETE a character by putting a # character under it
!!              o BLANK OUT a character by putting an & under it
!!              o INSERT A STRING by entering ^STRING#
!!
!!       The "modify" directive takes a little practice but this single
!!       directive accommodates positionally deleting, replacing, and
!!       inserting text. it is hardest using "modify" to put the strings
!!       "&" and "#" into your lines. to put a # or & character into a
!!       string use the 'c' command instead or ^&# or ^##.
!!
!!     ;N N N N ...  Append specified lines to current line
!!
!!  HELP
!!        h|?    display help text
!!
!!  SYSTEM COMMANDS
!!        !cmd   execute system command
!!
!!  DUMPING AND LOADING THE COMMAND HISTORY
!!
!!        w FILENAME   write entire command history to specified file
!!        r FILENAME   replace command history with file contents
!!        a FILENAME   append lines from file onto command history
!!
!!##EXAMPLE PROGRAM
!!   Sample program
!!
!!       program demo_redo
!!       use M_history, only : redo
!!       implicit none
!!       character(len=1024) ::  line
!!       integer             :: ios
!!       integer             :: cstat
!!       character(len=256)  :: sstat
!!       write(*,'(a)')                                             &
!!       & 'REDO(3f) COMMAND INPUT EDITOR',                         &
!!       & 'enter "r" or "r r_command" on the input line to go',    &
!!       & 'into history edit mode. Once in history edit mode you', &
!!       & 'may enter "?" to get some help. Enter "quit" to exit',  &
!!       & 'the program.'
!!       do
!!          write(*,'(a)',advance='no')'>->'    ! write prompt
!!          read(*,'(a)',iostat=ios) line       ! read new input line
!!          ! if "r", edit and return a line from the history editor
!!          call redo(line) ! store into history if not "r".
!!          if(line == 'quit')stop ! exit program if user enters "quit"
!!          ! now call user code to process new line of data
!!          ! As an example, call the system shell
!!          call execute_command_line(trim(line),cmdstat=cstat,cmdmsg=sstat)
!!       enddo
!!       end program demo_redo
!!
!!##SAMPLE USAGE
!!
!!    The example program is basically a loop that reads a command from
!!    standard input and then executes it as a subshell unless the "r"
!!    command is entered.
!!
!!    Now, we will enter an echo(1) command followed by a few other lines
!!    of input. Then we recall the echo(1) command and use a few of the
!!    features of redo(3) to change and then re-execute the command.
!!
!!       >echo This isss a Test
!!       This isss a Test
!!       >date
!!       Sun May 31 23:54:09 EDT 2009
!!       >pwd
!!       /cygdrive/c/urbanjs/MYCYGWIN/DISKA/public_html/public/CLONE/REDO
!!       >r                            ! enter edit mode
!!       00001 echo This isss a Test   ! last commands are displayed
!!       00002 date
!!       00003 pwd
!!       !pwd
!!       >1                            ! go to first line in history
!!       !echo This isss a Test
!!                    ##   t           ! delete and replace characters
!!       !echo This is a test          ! insert a string
!!                       ^new #
!!       !echo This is a new test
!!       c/test/TEST/                  ! change a substring
!!       !echo This is a new TEST
!!                          &          | replace character with spaces
!!       !echo This is a newTEST
!!                                     ! a blank line ends editing
!!       This is a newTEST
!!       >quit
!!
!!##AUTHOR
!!    John S. Urban, 1988,2009,2011,2015 (last change: Nov 2019)
!!##LICENSE
!!    MIT
module M_history
!
!  Acting much like a line-mode editor, the REDO(3f) procedure lets
!  you list, edit, save, and modify your interactively entered program
!  input. Built-in help and no dependence on terminal control sequences
!  makes this a simple-to-master and portable input history editor.
!
use, intrinsic :: iso_fortran_env, only : ERROR_UNIT        ! access computing environment
use, intrinsic :: iso_fortran_env, only : output_unit, stderr=>error_unit
implicit none
private

public  :: redo                    !  copy a line into history file or edit history if command is "r" and return line

private :: open_history_           !  open history file
private :: redol_                  !  edit history
private :: help_                   !  produce help text for redo(3f) usage

!  should use unused file, not just unit 1071 for history
!  add option to read in and replace history file

integer,parameter :: READLEN=1024  ! width of history file

integer,save,private       :: stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0

interface string_to_value
   module procedure a2d, a2i
end interface

interface v2s
   module procedure i2s
end interface

interface msg
   module procedure msg_scalar, msg_one
end interface msg

interface journal
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
end interface journal

interface str
   module procedure str_scalar, str_one
end interface str
contains
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine redo(inputline,r,lun)
!      if line starts with r word call redol_()
!      uses unit 1071
!       r
!       r string

! ident_1="@(#) M_history redo(3f) open binary direct access file for keeping history"

character(len=*),intent(inout) :: inputline                ! user string
character(len=1),intent(in),optional :: r                  ! character to use to trigger editing
integer,intent(in),optional          :: lun
character(len=1)                     :: r_local            ! character to use to trigger editing
integer,save                         :: iobuf=1071         ! unit number to use for redo history buffer
integer,save                         :: iredo              ! number of lines read from standard input into redo file
logical,save                         :: lcalled=.false.    ! flag whether first time this routine called or not
character(len=READLEN)               :: onerecord
integer                              :: ioparc
integer                              :: ilast
!-----------------------------------------------------------------------------------------------------------------------------------
if(present(r))then
   r_local=r
else
   r_local='r'
endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  open history file and initialize
   if(.not.lcalled)then                                     ! open the redo buffer file
      lcalled=.true.
      iredo=0   ! number of lines in redo buffer
      call open_history_(iobuf,' ','scratch',ioparc)        ! redo buffer
      if(ioparc /= 0)then
         call journal('sc','error creating history file')
         return
      endif
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ilast=len_trim(inputline)

   if(ilast == 1.and.inputline(1:1) == r_local)then                             ! redo command
      call redol_(inputline,iobuf,iredo,READLEN,' ',lun)
      ilast=len_trim(inputline)
   elseif(inputline(1:min(2,len(inputline))) == r_local//' ')then               ! redo command with a string following
      call redol_(inputline,iobuf,iredo,READLEN,inputline(3:max(3,ilast)),lun)
      ilast=len_trim(inputline)
   endif

   if(ilast /= 0)then                                                           ! put command into redo buffer
      iredo=iredo+1
      onerecord=inputline                ! make string the correct length; ASSUMING inputline IS NOT LONGER THAN onerecord
      write(iobuf,rec=iredo)onerecord
   endif
end subroutine redo
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine open_history_(iunit,fname,sname,ierr)
implicit none
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_history open_history_(3fp) open history file for REDO(3f) procedure"

integer,intent(in)          :: iunit   ! Fortran unit to open
character(len=*),intent(in) :: fname   ! filename to open
character(len=*),intent(in) :: sname   ! flag. If "scratch" ignore FNAME and open a scratch file
integer,intent(out)         :: ierr    ! error code returned by opening file
character(len=1024)         :: msg
!-----------------------------------------------------------------------------------------------------------------------------------
  if(sname == 'scratch')then
     open(unit=iunit,status='scratch',form='unformatted',access='direct',recl=READLEN,iostat=ierr,iomsg=msg,action='readwrite')
  else
     open(unit=iunit,file=trim(fname),status=trim(sname),form='unformatted',access='direct', &
     & recl=READLEN,iostat=ierr,iomsg=msg,action='readwrite')
  endif
!-----------------------------------------------------------------------------------------------------------------------------------
  if(ierr /= 0)then
     call journal('sc','*open_history_* open error ',ierr,'=',msg)
  endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine open_history_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine redol_(redoline,iobuf,iredo,ibuf0,init,lun)
!
!  to do:
!  might want to support a count on change to do the Nth to the Mth occurrence
!  support edit window in change
!  prompt to verify each change made with change()
!  maybe make .NAME stick into variable $NAME in the calculator
!  allow changing the edit characters in a modify

! ident_3="@(#) M_history redoline(3fp) redo a previous input line"

character(len=*),intent(out)   :: redoline    ! edited command line to be returned
integer,intent(in)             :: iobuf       ! history file unit to read old commands from
integer                        :: iredo       !iredo ......  (i) number of lines in history file
character(len=*),intent(in)    :: init        ! initial command string
integer,intent(in)             :: ibuf0       ! the width of the history file in characters; <= len(redoline)
integer,intent(in),optional    :: lun         ! LUN to read history commands from

doubleprecision                :: val8
integer                        :: i10, i15, i20, i30
integer                        :: iounit
integer                        :: idump
integer                        :: idown
integer                        :: lun_local
integer                        :: ipoint
integer                        :: iread
integer                        :: istart
integer                        :: ios
integer                        :: ii
integer                        :: ilong
integer                        :: icall
integer                        :: iup
integer                        :: ix
integer                        :: ibuf
integer                        :: ilast
integer                        :: cstat
character                      :: cmd
character(:),allocatable       :: cmdline
character(len=len(redoline)+1) :: cin, cinbuf ! 1 greater than length of redoline
character(len=1024),save       :: numbers
character(len=1024),save       :: msg
integer,allocatable            :: ivals(:)
integer                        :: iend
integer                        :: i
integer                        :: ierr
integer                        :: ier
logical,save                   :: ddd=.false.
data numbers/'123456789012345678901234567890123456789012345678901234567890&
   &12345678901234567890123456789012345678901234567890123456789012345678901234&
   &56789012345678901234567890123456789012345678901234567890123456789012345678&
   &90123456789012345678901234567890123456789012345678901234567890123456789012&
   &34567890123456789012345678901234567890123456789012345678901234567890123456&
   &78901234567890123456789012345678901234567890123456789012345678901234567890&
   &12345678901234567890123456789012345678901234567890123456789012345678901234&
   &56789012345678901234567890123456789012345678901234567890123456789012345678&
   &90123456789012345678901234567890123456789012345678901234567890123456789012&
   &34567890123456789012345678901234567890123456789012345678901234567890123456&
   &78901234567890123456789012345678901234567890123456789012345678901234567890&
   &'/
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(lun))then
      lun_local=lun
   else
      lun_local=5
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ipoint=iredo                                          ! initial line in history file to start with
   icall=0                                               ! flag if have been thru loop or just got here
   cin=init                                              ! initialize the directive
   ibuf=min(ibuf0,len(redoline))
   if(ibuf <= 0)return
!-----------------------------------------------------------------------------------------------------------------------------------
1  continue
   if(ipoint <= 0)then                                   ! if no lines in redo history file
      redoline=' '                                       ! make command to 'redo' a blank line since no commands entered
   else
      read(iobuf,rec=ipoint,err=999)redoline(1:ibuf)     ! get last line in history file as line to redo
      ! WARNING: OSF1 DIGITAL Fortran 77 Driver V5.2-10 DIGITAL Fortran 77 V5.2-171-428BH
      ! after this read the following storage was corrupted; switched declaration of
      ! init and redoline and problem cleared but it is probably corrupting cin and
      ! doesn't show because of logic.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   READLINE: do                                             ! display buffer and decide on command on first call or read command
      ilong=max(1,len_trim(redoline(1:ibuf)))               ! find length of command to redo
      write(*,'(a,a)')'!',redoline(:ilong)                  ! show old command
      if(icall /= 0)then                                    ! if not first call read the directive
         read(lun_local,'(a)',iostat=ios)cinbuf
         if(ios /= 0)then                                   ! if there was an I/O error reread line
            exit READLINE
         endif
         call notabs(cinbuf,cin,ilast)
      elseif(cin == ' ')then                                ! first call and no initial command passed in
         cin='l -5'                                         ! on first call do this default command if init is blank
         ilast=4
      else                                                  ! if initial command was not blank do it instead of default
         ilast=len_trim(cin)
      endif
      icall=icall+1
!-----------------------------------------------------------------------------------------------------------------------------------
      if(ilast == 0)then                                                 ! blank command line; return and execute
         return
      endif
!-----------------------------------------------------------------------------------------------------------------------------------
      cmd=cin(1:1)
      if(ddd)call journal('d','*redol* cmd=',cmd,'options=',cin)
      select case(cmd)                                                   ! first character defines edit action
!-----------------------------------------------------------------------------------------------------------------------------------
       case(' ')                                                         ! modify the string
         call modif(redoline,cin(2:))
!-----------------------------------------------------------------------------------------------------------------------------------
       case('m')                                                         ! modify the string with line number header
         write(*,'(1x,a)',iostat=ios)numbers(:len_trim(redoline))
         call modif(redoline,cin(2:))
!-----------------------------------------------------------------------------------------------------------------------------------
       case('c','s')                                                     ! change old string to new
         call change(redoline,trim(cin(1:255)),ier)                      ! xedit-like change command
!     C/STRING1/STRING2/    OR CW/STRING1/STRING2/  (CHANGE IN WINDOW)
!     WHERE / MAY BE ANY CHARACTER OTHER THAN W OR BLANK, WHICH IS NOT
!     INCLUDED IN STRING1 OR STRING2
!-----------------------------------------------------------------------------------------------------------------------------------
       case('u','b')                                                     ! up or back through buffer
         if(cin(2:) == ' ')then
            iup=1
         else
            iup=int(s2v(cin(2:),ierr,onerr=0))
         endif
         ipoint=max(ipoint-iup,1)
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case('d','f')                                                     ! down or forward through buffer
         if(cin(2:) == ' ')then
            idown=1
         else
            idown=int(s2v(cin(2:),ierr,onerr=0))
         endif
         ipoint=min(ipoint+idown,iredo)
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case(';')                                                         ! append lines
         ivals=int(s2vs(cin(2:)))
         if(allocated(ivals))then
            do i=1,size(ivals)
               ii=ivals(i)
               if(ii >= 1.and.ii <= iredo)then
                  read(iobuf,rec=ii,err=999)cinbuf(1:ibuf)               ! get last line in history file as line to redo
                  iend=len_trim(redoline)
                  redoline=redoline(:iend)//';'//trim(cinbuf)            !! should warn of truncation
               else
                  call journal('sc','*redol_* line not found in history',ii)
               endif
            enddo
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('?','h')                                                     ! display help
         call help_()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('D')                                                         ! toggle debug mode
         if(ddd .eqv. .false.)then
            ddd=.true.
            call journal('>')
         else
            ddd=.false.
            call journal('<')
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('l','p')                                                     ! display history buffer file with line numbers
         if(cin(2:) == ' ')then
            istart=iredo+1-20                                            ! default is to back up 20 lines
         else
            istart=int(s2v(cin(2:),ierr,onerr=0))
            if(ddd)call journal('d','*redol* istart=',istart,'ierr=',ierr)
            if(ierr /= 0)istart=iredo
            if(istart < 0)then
               istart=iredo+1+istart
            endif
         endif
         istart=min(max(1,istart),iredo)                                 ! make istart a safe value
         if(ddd)call journal('d','*redol* istart=',istart,'iredo=',iredo)
         do i10=istart,iredo
            read(iobuf,rec=i10,iostat=ios)redoline(1:ibuf)
            if(ios /= 0)then
               exit READLINE
            endif
            ix=max(1,len_trim(redoline))
            write(*,'(i5.5,1x,a)',iostat=ios)i10,redoline(:ix)
            if(ios /= 0)then
               exit READLINE
            endif
         enddo
!-----------------------------------------------------------------------------------------------------------------------------------
       case('w')                                                         ! dump to a file
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_w()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('e','E')                                                     ! dump and edit history file and read it back in
          cmdline=cin(2:)                                                ! assume rest of command is a system command
          if(cmdline=='')cmdline='vim'                                   ! if no system command use "vim"
          cin='scratch.tmp'                                              ! assume this is a writable scratch file name
          cmdline=trim(cmdline)//' '//cin                                ! append scratch filename to system command
          call do_w()                                                    ! dump history file
          call execute_command_line(cmdline,cmdstat=cstat,cmdmsg=msg)    ! Execute the command line specified by the string.
          if(cstat == 0)then                                             ! rewrite or append to history file
             if(cmd == 'e')iredo=0
             call do_ar()
          endif
          open(newunit=iounit,file=cin,iostat=ios)                       ! remove scratch file
          if(ios /= 0)then
            call journal('sc','*redol_* error opening scratch file file',cin,ios,'=',msg)
          endif
          close(unit=iounit,status='delete',iostat=ios,iomsg=msg)
          if(ios /= 0)then
            call journal('sc','*redol_* error removing scratch file file',cin,ios,'=',msg)
          endif
!-----------------------------------------------------------------------------------------------------------------------------------
       case('a')                                                         ! append to history from a file
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_ar()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('r')                                                         ! replace history from a file
          iredo=0
          cin=adjustl(cin(2:))                                           ! eliminate leading spaces and command name
          if(cin == ' ')then
             cin='DUMP'                                                  ! set as default and for message
          endif
          call do_ar()
!-----------------------------------------------------------------------------------------------------------------------------------
       case('P','L')                                                     ! display history buffer file without line numbers
         if(cin(2:) == ' ')then                                          ! default is to go back up to 20
            istart=iredo+1-20
         else
            istart=int(s2v(cin(2:),ierr,onerr=0))
            if(istart < 0)then
               istart=iredo+1+istart
            endif
         endif
         istart=min(max(1,istart),iredo)                                 ! make istart a safe value
         do i30=istart,iredo                                             ! easier to cut and paste if no numbers
            read(iobuf,rec=i30,iostat=ios)redoline(1:ibuf)
            if(ios /= 0)then
               goto 999
            endif
            ix=max(1,len_trim(redoline))
            write(*,'(a)',err=999)redoline(:ix)
         enddo
!-----------------------------------------------------------------------------------------------------------------------------------
       case('/')                                                         ! display matches in buffer
         if(ilast < 2)then
            cycle
         endif
         do i20=1,iredo
            read(iobuf,rec=i20,err=999,iostat=ios)redoline(1:ibuf)
            if(index(redoline(1:ibuf),cin(2:ilast)) /= 0)then
               ix=max(1,len_trim(redoline))
               write(*,'(i5.5,1x,a)',err=999)i20,redoline(:ix)
               ipoint=i20
            endif
         enddo
         goto 1
!-----------------------------------------------------------------------------------------------------------------------------------
       case('!')                                                              ! external command
         if(ilast < 2)then
            cycle
         endif
         call execute_command_line(trim(cin(2:)),cmdstat=cstat,cmdmsg=msg)    ! Execute the command line specified by the string.
         !call system(trim(cin(2:)))                                          ! Execute the command line specified by the string.
!-----------------------------------------------------------------------------------------------------------------------------------
       case('.','q')                                                          ! blank out command and quit
         exit READLINE
!-----------------------------------------------------------------------------------------------------------------------------------
       case default                                                           ! assume anything else is a number
         val8=s2v(cin,ierr,onerr=0)
         if(ierr == 0)then
            iread=int(val8)
         else
            iread=0
         endif
         if(iread > 0.and.iread <= iredo)then
            read(iobuf,rec=iread,err=999,iostat=ios)redoline(1:ibuf)
            ipoint=iread
         endif
!-----------------------------------------------------------------------------------------------------------------------------------
      end select
!-----------------------------------------------------------------------------------------------------------------------------------
   enddo READLINE
!-----------------------------------------------------------------------------------------------------------------------------------
999 continue
   redoline=' '
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine do_w()
WRITE: block
   open(newunit=idump,file=cin,iostat=ios,status='UNKNOWN',iomsg=msg)
   if(ios /= 0)then
      call journal('sc','*redol_* error opening dump file',ios,'=',msg)
      exit WRITE
   endif
   do i15=1,iredo
      read(iobuf,rec=i15,iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         call journal('sc','*redol_* error reading history file',ios,'=',msg)
         exit WRITE
      endif
      ix=max(1,len_trim(redoline))
      write(idump,'(a)',iostat=ios,iomsg=msg)redoline(:ix)
      if(ios /= 0)then
         call journal('sc','*redol_* error writing dump file',ios,'=',msg)
         close(idump,iostat=ios)
         exit WRITE
      endif
   enddo
   call journal('sc','wrote file ',cin)
endblock WRITE
close(idump,iostat=ios)
end subroutine do_w
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine do_ar()
REPLACE: block
   open(newunit=idump,file=cin,iostat=ios,status='OLD',iomsg=msg)
   if(ios /= 0)then
      call journal('sc','*redol_* error opening file',ios,'=',msg)
      exit REPLACE
   endif
   do
      read(idump,'(a)',iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         if(.not.is_iostat_end(ios))then
            call journal('sc','*redol_* error reading file ',cin,ios,'=',msg)
         endif
         exit REPLACE
      endif
      iredo=iredo+1
      write(iobuf,rec=iredo,iostat=ios,iomsg=msg)redoline(1:ibuf)
      if(ios /= 0)then
         call journal('sc','*redol_* error writing history file',ios,'=',msg)
         exit REPLACE
      endif
   enddo
endblock REPLACE
call journal('sc','read file ',cin)
close(idump,iostat=ios)
end subroutine do_ar
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine redol_
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine help_()

! ident_4="@(#) M_history help_(3fp) prints help for REDO(3f)"

character(len=80),allocatable :: usage(:)
integer                       :: i
!-----------------------------------------------------------------------------------------------------------------------------------
usage=[ &
&' History Edit commands (where N is a number):                                   ',&
&'+______________________________________________________________________________+',&
&'|List History                           |History File:                         |',&
&'| l|p N    # list from line N.          | w   file # write history to a file   |',&
&'!          # -N shows N last lines      | a   file # append file to history    |',&
&'| L|P N    # same as l sans line numbers| r   file # replace history with file |',&
&'| /string  # search for simple string   |Return to Normal Command Mode:        |',&
&'|Position in History File:              |      # return and execute command    |',&
&'| u|b N    # up/back through buffer     | .|q  # quit and return a blank line  |',&
&'| d|f N    # down/forward through buffer|Help:                                 |',&
&'| N        # load line number           |  h|?   # display this help text      |',&
&'|System:                                |Append lines to current line:         |',&
&'| !system_command # execute command     |  ;N N N N ...                        |',&
&'|______________________________________________________________________________|',&
&'|Edit Buffer:                                                                  |',&
&'| c|s/oldstring/newstring/  # change/substitute                                |',&
&'| mmod_string               # Modify with line number header                   |',&
&'|  mod_string               # Modify (replace, delete, insert)                 |',&
&'|    #         -- deletes                                                      |',&
&'|    &         -- replaces with a blank                                        |',&
&'|    ^STRING#  -- inserts a string                                             |',&
&'|              -- blank leaves as-is                                           |',&
&'|    Any other -- replaces character                                           |',&
&'+______________________________________________________________________________+']
!-----------------------------------------------------------------------------------------------------------------------------------
   !WRITE(*,'(a)'),usage(i),i=1,size(usage))
   do i=1,size(usage)
      call journal('sc',usage(i))
   enddo
end subroutine help_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function sep(input_line,delimiters,nulls)

intrinsic index, min, present, len
character(len=*),intent(in)              :: input_line
character(len=*),optional,intent(in)     :: delimiters
character(len=*),optional,intent(in)     :: nulls
character(len=:),allocatable             :: sep(:)
   call split(input_line,sep,delimiters,'right',nulls)
end function sep
subroutine split(input_line,array,delimiters,order,nulls)

intrinsic index, min, present, len
character(len=*),intent(in)              :: input_line
character(len=*),optional,intent(in)     :: delimiters
character(len=*),optional,intent(in)     :: order
character(len=*),optional,intent(in)     :: nulls
character(len=:),allocatable,intent(out) :: array(:)
integer                       :: n
integer,allocatable           :: ibegin(:)
integer,allocatable           :: iterm(:)
character(len=:),allocatable  :: dlim
character(len=:),allocatable  :: ordr
character(len=:),allocatable  :: nlls
integer                       :: ii,iiii
integer                       :: icount
integer                       :: lgth
integer                       :: i10,i20,i30
integer                       :: icol
integer                       :: idlim
integer                       :: ifound
integer                       :: inotnull
integer                       :: ireturn
integer                       :: imax
   if (present(delimiters)) then
      if(delimiters /= '')then
         dlim=delimiters
      else
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)
      endif
   else
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)
   endif
   idlim=len(dlim)
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif
   n=len(input_line)+1
   if(allocated(ibegin))deallocate(ibegin)
   if(allocated(iterm))deallocate(iterm)
   allocate(ibegin(n))
   allocate(iterm(n))
   ibegin(:)=1
   iterm(:)=1
   lgth=len(input_line)
   icount=0
   inotnull=0
   imax=0
   if(lgth > 0)then
      icol=1
      infinite: do i30=1,lgth,1
         ibegin(i30)=icol
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then
            iterm(i30)=lgth
            do i10=1,idlim
               ifound=index(input_line(ibegin(i30):lgth),dlim(i10:i10))
               if(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2
            inotnull=inotnull+1
         else
            iterm(i30)=icol-1
            icol=icol+1
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30
         if(icol > lgth)then
            exit infinite
         endif
      enddo infinite
   endif
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))
   select case (trim(adjustl(ordr)))
   case ('reverse','right') ; ii=ireturn ; iiii=-1
   case default             ; ii=1       ; iiii=1
   end select
   do i20=1,icount
      if(iterm(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
   end subroutine split

subroutine substitute(targetline,old,new,ierr,start,end)

character(len=*)               :: targetline
character(len=*),intent(in)    :: old
character(len=*),intent(in)    :: new
integer,intent(out),optional   :: ierr
integer,intent(in),optional    :: start
integer,intent(in),optional    :: end
character(len=len(targetline)) :: dum1
integer                        :: ml, mr, ier1
integer                        :: maxlengthout
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichr
   if (present(start)) then
      ml=start
   else
      ml=1
   endif
   if (present(end)) then
      mr=end
   else
      mr=len(targetline)
   endif
   ier1=0
   maxlengthout=len(targetline)
   original_input_length=len_trim(targetline)
   dum1(:)=' '
   id=mr-ml
   len_old=len(old)
   len_new=len(new)
   if(id <= 0)then
      il=1
      ir=maxlengthout
      dum1(:)=' '
   else
      il=ml
      ir=min0(mr,maxlengthout)
      dum1=targetline(:il-1)
   endif
   if(len_old == 0)then
      ichr=len_new + original_input_length
      if(ichr > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1
      if(present(ierr))ierr=ier1
      return
   endif
   ichr=il
   ic=il
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1
      if(ind == ic-1.or.ind > ir)then
         exit loop
      endif
      ier1=ier1+1
      if(ind > ic)then
         ladd=ind-ic
         if(ichr-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichr:)=targetline(ic:ind-1)
         ichr=ichr+ladd
      endif
      if(ichr-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichr:)=new(:len_new)
         ichr=ichr+len_new
      endif
      ic=ind+len_old
   enddo loop
   select case (ier1)
   case (:-1)
      call journal('sc','*substitute* new line will be too long')
   case (0)
   case default
      ladd=original_input_length-ic
      if(ichr+ladd > maxlengthout)then
         call journal('sc','*substitute* new line will be too long')
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichr:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
end subroutine substitute
subroutine change(target_string,cmd,ierr)

character(len=*),intent(inout)   :: target_string
character(len=*),intent(in)      :: cmd
character(len=1)                 :: delimiters
integer                          :: ierr
integer                          :: itoken
integer,parameter                :: id=2
character(len=:),allocatable     :: old,new
logical                          :: ifok
integer                          :: lmax
integer                          :: start_token,end_token
   lmax=len_trim(cmd)
   if(lmax >= 4)then
      delimiters=cmd(id:id)
      itoken=0

      if(strtok(cmd(id:),itoken,start_token,end_token,delimiters)) then
         old=cmd(start_token+id-1:end_token+id-1)
      else
         old=''
      endif

      if(cmd(id:id) == cmd(id+1:id+1))then
         new=old
         old=''
      else
         ifok=strtok(cmd(id:),itoken,start_token,end_token,delimiters)
         if(end_token  ==  (len(cmd)-id+1) )end_token=len_trim(cmd(id:))
         new=cmd(start_token+id-1:min(end_token+id-1,lmax))
      endif

      call substitute(target_string,old,new,ierr,1,len_trim(target_string))
   else
      ierr=-1
      call journal('sc','*change* incorrect change directive -too short')
   endif
end subroutine change
function strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)

character(len=*),intent(in)  :: source_string
character(len=*),intent(in)  :: delimiters
integer,intent(inout)        :: itoken
logical                      :: strtok_status
integer,intent(out)          :: token_start
integer,intent(inout)        :: token_end
integer,save                 :: isource_len
   if(itoken <= 0)then
      token_start=1
   else
      token_start=token_end+1
   endif
   isource_len=len(source_string)
   if(token_start > isource_len)then
      token_end=isource_len
      strtok_status=.false.
      return
   endif
   do while (token_start  <=  isource_len)
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
   token_end=token_start
   do while (token_end  <=  isource_len-1)
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then
         exit
      endif
      token_end = token_end + 1
   enddo
   if (token_start  >  isource_len) then
      strtok_status=.false.
   else
      itoken=itoken+1
      strtok_status=.true.
   endif
end function strtok
subroutine modif(cline,modi)

character(len=*)            :: cline
character(len=*),intent(in) :: modi
character(len=len(cline))   :: cmod
character(len=3),parameter  :: c='#&^'
integer                     :: maxscra
character(len=len(cline))   :: dum2
logical                     :: linsrt
integer :: i, j, ic, ichr, iend, lmax, lmx1
maxscra=len(cline)
   cmod=trim(modi)
   lmax=min0(len(cline),maxscra)
   lmx1=lmax-1
   dum2=' '
   linsrt=.false.
   iend=len_trim(cmod)
   i=0
   ic=0
   ichr=0
11 continue
   i=i+1
   if(ichr > lmx1)goto 999
   if(linsrt) then
      if(i > iend) cmod(i:i)=c(1:1)
      if(cmod(i:i) == c(1:1))then
         linsrt=.false.
         if(ic+1 == i)then
            ichr=ichr+1
            dum2(ichr:ichr)=c(1:1)
         endif
         do j=ic,i
            ichr=ichr+1
            if(ichr > lmax)goto 999
            dum2(ichr:ichr)=cline(j:j)
         enddo
         ic=i
         goto 1
      endif
      ichr=ichr+1
      dum2(ichr:ichr)=cmod(i:i)
   else
      ic=ic+1
      if(cmod(i:i) == c(1:1))goto 1
      if(cmod(i:i) == c(3:3))then
         linsrt=.true.
         goto 1
      endif
      ichr=ichr+1
      if(cmod(i:i) == c(2:2))then
         dum2(ichr:ichr)=' '
         goto 1
      endif
      if(cmod(i:i) == ' ')then
         dum2(ichr:ichr)=cline(ic:ic)
      else
         dum2(ichr:ichr)=cmod(i:i)
      endif
   endif
1  continue
   if(i < lmax)goto 11
999   continue
   cline=dum2
end subroutine modif

elemental pure function upper(str,begin,end) result (string)

character(*), intent(in)      :: str
integer, intent(in), optional :: begin,end
character(len(str))           :: string
integer                       :: i
integer                       :: ibegin,iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(ibegin,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)
       select case (str(i:i))
       case ('a':'z')
          string(i:i) = char(iachar(str(i:i))+diff)
       end select
   enddo

end function upper
elemental pure function lower(str,begin,end) result (string)

character(*), intent(in)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))-diff)
      case default
      end select
   enddo

end function lower

elemental impure subroutine notabs(instr,outstr,lgth)

character(len=*),intent(in)   :: instr
character(len=*),intent(out)  :: outstr
integer,intent(out)           :: lgth
integer,parameter             :: tabsize=8
integer                       :: ipos
integer                       :: lenin
integer                       :: lenout
integer                       :: istep
character(len=1)              :: c
integer                       :: iade
   ipos=1
   lenin=len_trim(instr( 1:len(instr) ))
   lenout=len(outstr)
   outstr=" "
      scan_line: do istep=1,lenin
         c=instr(istep:istep)
         iade=iachar(c)
         expand_tabs : select case (iade)
         case(9)
            ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))
         case(10,13)
            ipos=ipos+1
         case default
            if(ipos > lenout)then
               call journal("*notabs* output string overflow")
               exit
            else
               outstr(ipos:ipos)=c
               ipos=ipos+1
            endif
         end select expand_tabs
      enddo scan_line
      ipos=min(ipos,lenout)
      lgth=len_trim(outstr(:ipos))
end subroutine notabs

subroutine a2i(chars,valu,ierr)

character(len=*),intent(in) :: chars
integer,intent(out)         :: valu
integer,intent(out)         :: ierr
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         call journal('sc','*a2i*','- value too large',valu8,'>',huge(valu))
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
subroutine a2d(chars,valu,ierr,onerr)

character(len=*),intent(in)  :: chars
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu
integer,intent(out)          :: ierr
class(*),optional,intent(in) :: onerr
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"
character(len=15)            :: frmt
character(len=256)           :: msg
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
   ierr=0
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu
      end select
   endif
   if(ierr /= 0)then
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then
         call journal('sc','*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg /= '')then
            call journal('sc','*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
doubleprecision function s2v(chars,ierr,onerr)

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         call journal('*value_to_string* UNKNOWN TYPE')
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   else
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros_(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros_(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
function i2s(ivalue,fmt) result(outstr)

integer,intent(in)           :: ivalue
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
subroutine trimzeros_(string)

character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: expo
integer                      :: ipos
integer                      :: i, ii
   str=string
   ipos=scan(str,'eEdD')
   if(ipos>0) then
      expo=str(ipos:)
      str=str(1:ipos-1)
   endif
   if(index(str,'.') == 0)then
      ii=len_trim(str)
      str(ii+1:ii+1)='.'
   endif
   do i=len_trim(str),1,-1
      select case(str(i:i))
      case('0')
         cycle
      case('.')
         if(i <= 1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)
         exit
      end select
   enddo
   if(ipos>0)then
      string=trim(str)//trim(expo)
   else
      string=str
   endif
end subroutine trimzeros_
function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str
character(len=1),optional,intent(in) :: esc
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
   if(present(esc))then
      iesc=iachar(esc)
   else
      iesc=-1
   endif
   inlen=len(quoted_str)
   allocate(character(len=inlen) :: unquoted_str)
   if(inlen >= 1)then
      if(quoted_str(1:1) == single_quote)then
         quote=iachar(single_quote)
      else
         quote=iachar(double_quote)
      endif
   else
      quote=iachar(double_quote)
   endif
   before=-2
   unquoted_str(:)=''
   iput=1
   inside=.false.
   stepthrough: do i=1,inlen
      current=iachar(quoted_str(i:i))
      if(before == iesc)then
           iput=iput-1
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2
      elseif(current == quote)then
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo stepthrough
   unquoted_str=unquoted_str(:iput-1)
end function unquote
function s2vs(string,delim) result(darray)

character(len=*),intent(in)        :: string
character(len=*),optional          :: delim
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)

character(len=:),allocatable       :: carray(:)
integer                            :: i
integer                            :: ier
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
   call split(string,carray,delimiters=delim_local)
   allocate(darray(size(carray)))
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)
   enddo
end function s2vs

logical function base(x,b,y,a)
implicit none
character(len=*),intent(in)  :: x
character(len=*),intent(out) :: y
integer,intent(in)           :: b,a
integer                      :: temp

base=.true.
if(decodebase(x,b,temp)) then
   if(codebase(temp,a,y)) then
   else
      print *,'Error in coding number.'
      base=.false.
   endif
else
   print *,'Error in decoding number.'
   base=.false.
endif

end function base

logical function decodebase(string,basein,out_baseten)
implicit none

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: xmaxreal=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')
  if(basein == 0.and.ipound > 1)then
     call string_to_value(string_local(:ipound-1),basein_local,ierr)
     string_local=string_local(ipound+1:)
     if(basein_local >= 0)then
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  all: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else all
     out_baseten=0;y=0.0; mult=1.0
     long=len_trim(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit all
        endif
        if(ch<='9') then
              j=iachar(ch)-iachar('0')
        else
              j=iachar(ch)-iachar('A')+10
        endif
        if(j>=basein_local)then
           exit all
        endif
        y=y+mult*j
        if(mult>xmaxreal/basein_local)then
           exit all
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif all
end function decodebase
logical function codebase(inval10,outbase,answer)
implicit none

integer,intent(in)           :: inval10
integer,intent(in)           :: outbase
character(len=*),intent(out) :: answer
integer                      :: n
real                         :: inval10_local
integer                      :: outbase_local
integer                      :: in_sign
  answer=''
  in_sign=sign(1,inval10)*sign(1,outbase)
  inval10_local=abs(inval10)
  outbase_local=abs(outbase)
  if(outbase_local<2.or.outbase_local>36) then
    print *,'*codebase* ERROR: base must be between 2 and 36. base was',outbase_local
    codebase=.false.
  else
     do while(inval10_local>0.0 )
        n=int(inval10_local-outbase_local*int(inval10_local/outbase_local))
        if(n<10) then
           answer=achar(iachar('0')+n)//answer
        else
           answer=achar(iachar('A')+n-10)//answer
        endif
        inval10_local=int(inval10_local/outbase_local)
     enddo
     codebase=.true.
  endif
  if(in_sign == -1)then
     answer='-'//trim(answer)
  endif
  if(answer == '')then
     answer='0'
  endif
end function codebase
function todecimal(base, instr)

character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
character(*),intent(in)      :: instr
character(len=:),allocatable :: instr_local
integer                      :: todecimal
integer                      :: length, i, n

   instr_local=trim(lower(instr))
   todecimal = 0
   length = len(instr_local)
   do i = 1, length
      n = index(alphanum, instr_local(i:i)) - 1
      n = n * base**(length-i)
      todecimal = todecimal + n
   enddo
end function todecimal
function tobase(base, number)

character(len=36),parameter  :: alphanum = "0123456789abcdefghijklmnopqrstuvwxyz"
integer,intent(in)           :: base
integer,intent(in)           :: number
character(len=:),allocatable :: tobase
character(len=31)            :: holdit
integer                      :: number_local, i, rem
   number_local=number

   holdit = "                               "
   do i = 31, 1, -1
      if(number_local < base) then
         holdit(i:i) = alphanum(number_local+1:number_local+1)
         exit
      endif
      rem = mod(number_local, base)
      holdit(i:i) = alphanum(rem+1:rem+1)
      number_local = number_local / base
   enddo
   tobase = adjustl(holdit)
end function tobase

function fmt(source_string,length)

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: istart
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: fmt(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
   do i=1,2
      iword_max=0
      ilines=1
      ilength=0
      itoken=0
      do while ( strtok(source_string,itoken,istart,iend,delimiters) )
         iword=iend-istart+1
         iword_max=max(iword_max,iword)
         if(iword > length)then
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then
               fmt(ilines)=source_string(istart:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then
            if(i == 2)then
               fmt(ilines)=fmt(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=ilength+iword+1
         else
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               fmt(ilines)=fmt(ilines)(:ilength)//source_string(istart:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then
         allocate(character(len=max(length,iword_max)) :: fmt(ilines))
         fmt=' '
      endif
   enddo
   fmt=fmt(:ilines)
end function fmt

function msg_scalar(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

class(*),intent(in),optional  :: generic1 ,generic2 ,generic3 ,generic4 ,generic5
class(*),intent(in),optional  :: generic6 ,generic7 ,generic8 ,generic9
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_scalar=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic
end function msg_scalar
function msg_one(generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none

class(*),intent(in)           :: generic1(:)
class(*),intent(in),optional  :: generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable   :: sep_local
character(len=:), allocatable :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic
end function msg_one

subroutine where_write_message(where,msg)

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times
character(len=3)                   :: adv

character(len=:),allocatable,save  :: prefix_template
character(len=:),allocatable       :: prefix
logical,save                       :: prefix_it=.false.
character(len=4096)                :: mssge
   adv='yes'
   prefix=''
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
         endif
      case('S','s')
         write(stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      case('+'); adv='no'
      case('>'); debug=.true.
      case('<'); debug=.false.
      case('%')
         if(msg == '')then
            prefix_it=.false.
         else
            prefix_template=msg
            prefix_it=.true.
         endif
      case('N')
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            stdout=6
         endif
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
end subroutine where_write_message

subroutine where_write_message_all(where, g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,nospace)
implicit none
character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
logical,intent(in),optional   :: nospace
   call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,nospace))
end subroutine where_write_message_all

subroutine write_message_only(message)

character(len=*),intent(in)          :: message
   call where_write_message('sc',trim(message))
end subroutine write_message_only
function str_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
implicit none
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:), allocatable :: str_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
character(len=:),allocatable  :: sep_local
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   str_scalar=trim(line)
contains
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function str_scalar
function str_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: str_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   str_one=trim(line)
contains

subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   line=trim(line)//"]"//sep_local
   istart=len_trim(line)+increment
end subroutine print_generic

end function str_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_history

!>>>>> build/dependencies/M_CLI2/src/M_CLI2.F90
!VERSION 1.0 2020-01-15
!VERSION 2.0 2020-08-02
!VERSION 3.0 2020-10-21  LONG:SHORT syntax
!VERSION 3.1 2020-11-15  LONG:SHORT:: syntax
!VERSION 3.2 2023-02-05  set_mode()
!VERSION 3.3 2024-08-18  autoresponse
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    M_CLI2(3fm) - [ARGUMENTS:M_CLI2::INTRO] command line argument
!!    parsing using a prototype command
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   Available procedures and variables:
!!
!!      ! basic procedures
!!      use M_CLI2, only : set_args, get_args, specified, set_mode
!!      ! convenience functions
!!      use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!      use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!      ! variables
!!      use M_CLI2, only : unnamed, remaining, args
!!      ! working with non-allocatable strings and arrays
!!      use M_CLI2, only : get_args_fixed_length, get_args_fixed_size
!!      ! special function for creating subcommands
!!      use M_CLI2, only : get_subcommand(3f)
!!
!!##DESCRIPTION
!!    The M_CLI2 module cracks a Unix-style command line.
!!
!!    Typically one call to SET_ARGS(3f) is made to define the command
!!    arguments, set default values and parse the command line. Then a call
!!    is made to the convenience procedures or GET_ARGS(3f) proper for each
!!    command keyword to obtain the argument values.
!!
!!    Detailed descriptions of each procedure and example programs are
!!    included.
!!
!!##EXAMPLES
!!
!!
!! Sample minimal program:
!!
!!     program minimal
!!     use M_CLI2,  only : set_args, lget, rget, sgets
!!     implicit none
!!     real    :: x, y
!!     integer :: i
!!     character(len=:),allocatable :: version_text(:), help_text(:)
!!     character(len=:),allocatable :: filenames(:)
!!        ! define and crack command line.
!!        ! creates argument --yvalue with short name y with default value 0
!!        ! creates argument --xvalue with short name x with default value 0
!!        ! creates boolean argument
!!        call setup() ! define help text and version text
!!        call set_args(' --yvalue:y 0.0 --xvalue:x 0.0 --debug F',&
!!             & help_text=help_text,&
!!             & version_text=version_text)
!!        ! get values
!!        x=rget('xvalue')
!!        y=rget('yvalue')
!!        if(lget('debug'))then
!!           write(*,*)'X=',x
!!           write(*,*)'Y=',y
!!           write(*,*)'ATAN2(Y,X)=',atan2(x=x,y=y)
!!        else
!!           write(*,*)atan2(x=x,y=y)
!!        endif
!!        filenames=sgets() ! sgets(3f) with no name gets "unnamed" values
!!        if(size(filenames) > 0)then
!!           write(*,'(g0)')'filenames:'
!!           write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!        endif
!!     contains
!!     subroutine setup()
!!
!!     help_text=[character(len=80) :: &
!!                 & "wish I put instructions", &
!!                 & "here I suppose.        ", &
!!                 & " "]
!!
!!     version_text=[character(len=80) :: "version 1.0","author: me"]
!!
!!     end subroutine setup
!!     end program minimal
!!
!! which may be called in various ways:
!!
!!     mimimal -x 100.3 -y 3.0e4
!!     mimimal --xvalue=300 --debug
!!     mimimal --yvalue 400
!!     mimimal -x 10 file1 file2 file3
!!
!! Sample program using get_args() and variants
!!
!!     program demo_M_CLI2
!!     use M_CLI2,  only : set_args, get_args
!!     use M_CLI2,  only : filenames=>unnamed
!!     use M_CLI2,  only : get_args_fixed_length, get_args_fixed_size
!!     implicit none
!!     integer,parameter            :: dp=kind(0.0d0)
!!     integer                      :: i
!!      !
!!      ! Define ARGS
!!     real                         :: x, y, z
!!     logical                      :: l, lbig
!!     character(len=40)            :: label    ! FIXED LENGTH
!!     real(kind=dp),allocatable    :: point(:)
!!     logical,allocatable          :: logicals(:)
!!     character(len=:),allocatable :: title    ! VARIABLE LENGTH
!!     real                         :: p(3)     ! FIXED SIZE
!!     logical                      :: logi(3)  ! FIXED SIZE
!!      !
!!      ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!      !   o set a value for all keywords.
!!      !   o double-quote strings, strings must be at least one space
!!      !     because adjacent double-quotes designate a double-quote
!!      !     in the value.
!!      !   o set all logical values to F
!!      !   o numeric values support an "e" or "E" exponent
!!      !   o for lists delimit with a comma, colon, or space
!!     call set_args('                         &
!!             & -x 1 -y 2 -z 3                &
!!             & -p -1 -2 -3                   &
!!             & --point 11.11, 22.22, 33.33e0 &
!!             & --title "my title" -l F -L F  &
!!             & --logicals  F F F F F         &
!!             & --logi F T F                  &
!!             & --label " " &
!!             ! note space between quotes is required
!!             & ')
!!      ! Assign values to elements using G_ARGS(3f).
!!      ! non-allocatable scalars can be done up to twenty per call
!!     call get_args('x',x, 'y',y, 'z',z, 'l',l, 'L',lbig)
!!      ! As a convenience multiple pairs of keywords and variables may be
!!      ! specified if and only if all the values are scalars and the CHARACTER
!!      ! variables are fixed-length or pre-allocated.
!!      !
!!      ! After SET_ARGS(3f) has parsed the command line
!!      ! GET_ARGS(3f) retrieves the value of keywords accept for
!!      ! two special cases. For fixed-length CHARACTER variables
!!      ! see GET_ARGS_FIXED_LENGTH(3f). For fixed-size arrays see
!!      ! GET_ARGS_FIXED_SIZE(3f).
!!      !
!!      ! allocatables should be done one at a time
!!     call get_args('title',title) ! allocatable string
!!     call get_args('point',point) ! allocatable arrays
!!     call get_args('logicals',logicals)
!!      !
!!      ! less commonly ...
!!
!!      ! for fixed-length strings
!!     call get_args_fixed_length('label',label)
!!
!!      ! for non-allocatable arrays
!!     call get_args_fixed_size('p',p)
!!     call get_args_fixed_size('logi',logi)
!!      !
!!      ! all done parsing, use values
!!     write(*,*)'x=',x, 'y=',y, 'z=',z, x+y+z
!!     write(*,*)'p=',p
!!     write(*,*)'point=',point
!!     write(*,*)'title=',title
!!     write(*,*)'label=',label
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     write(*,*)'logicals=',logicals
!!     write(*,*)'logi=',logi
!!      !
!!      ! unnamed strings
!!      !
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!      !
!!     end program demo_M_CLI2
!!
!! Results:
!!
!!  >  x=1.00000000     y=2.00000000     z=3.00000000       6.00000000
!!  >  p=  -1.00000000      -2.00000000      -3.00000000
!!  >  point=   11.109999999999999 22.219999999999999 33.329999999999998
!!  >  title=my title
!!  >  label=
!!  >  l= F
!!  >  L= F
!!  >  logicals= F F F F F
!!  >  logi= F T F
!!
!!##AUTHOR
!!     John S. Urban, 2019
!!##LICENSE
!!     Public Domain
!!##SEE ALSO
!!     + get_args(3f)
!!     + get_args_fixed_size(3f)
!!     + get_args_fixed_length(3f)
!!     + get_subcommand(3f)
!!     + set_mode(3f)
!!     + specified(3f)
!!
!! Note that the convenience routines are described under get_args(3f):
!! dget(3f), iget(3f), lget(3f), rget(3f), sget(3f), cget(3f) dgets(3f),
!! igets(3f), lgets(3f), rgets(3f), sgets(3f), cgets(3f)
!===================================================================================================================================
module M_CLI2
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT, warn=>OUTPUT_UNIT
implicit none
private

integer,parameter,private :: dp=kind(0.0d0)
integer,parameter,private :: sp=kind(0.0)

character(len=*),parameter          :: gen='(*(g0))'
character(len=:),allocatable,public :: unnamed(:)
character(len=:),allocatable,public :: args(:)
character(len=:),allocatable,public :: remaining
public                              :: set_mode
public                              :: set_args
public                              :: get_subcommand
public                              :: get_args
public                              :: get_args_fixed_size
public                              :: get_args_fixed_length
public                              :: specified
public                              :: print_dictionary

public                              :: dget, iget, lget, rget, sget, cget
public                              :: dgets, igets, lgets, rgets, sgets, cgets

type option
   character(:),allocatable :: shortname
   character(:),allocatable :: longname
   character(:),allocatable :: value
   integer                  :: length
   logical                  :: present_in
   logical                  :: mandatory
end type option

character(len=:),allocatable,save :: keywords(:)
character(len=:),allocatable,save :: shorts(:)
character(len=:),allocatable,save :: values(:)
integer,allocatable,save          :: counts(:)
logical,allocatable,save          :: present_in(:)
logical,allocatable,save          :: mandatory(:)

logical,save                      :: G_DEBUG=.false.
logical,save                      :: G_UNDERDASH=.false.
logical,save                      :: G_NODASHUNDER=.false.
logical,save                      :: G_IGNORELONGCASE=.false.  ! ignore case of long keywords
logical,save                      :: G_IGNOREALLCASE=.false.   ! ignore case of long and short keywords
logical,save                      :: G_STRICT=.false.          ! strict short and long rules or allow -longname and --shortname
logical,save                      :: G_APPEND=.true.           ! whether to append or replace when duplicate keywords found

logical,save                      :: G_keyword_single_letter=.true.
character(len=:),allocatable,save :: G_passed_in
logical,save                      :: G_remaining_on, G_remaining_option_allowed
character(len=:),allocatable,save :: G_remaining
character(len=:),allocatable,save :: G_subcommand              ! possible candidate for a subcommand
character(len=:),allocatable,save :: G_STOP_MESSAGE
integer,save                      :: G_STOP
logical,save                      :: G_QUIET
character(len=:),allocatable,save :: G_PREFIX

! try out response files
! CLI_RESPONSE_FILE is left public for backward compatibility, but should be set via "set_mode('response_file')
logical,save,public               :: CLI_RESPONSE_FILE=.false. ! allow @name abbreviations
logical,save,public               :: CLI_AUTO_RESPONSE_FILE=.false. ! allow @name abbreviations but call @$0 automatically
logical,save,public               :: CLI_AUTO_QUIET=.false.
logical,save                      :: G_OPTIONS_ONLY            ! process response file only looking for options for get_subcommand()
logical,save                      :: G_RESPONSE                ! allow @name abbreviations
character(len=:),allocatable,save :: G_RESPONSE_IGNORED
character(len=:),allocatable,save :: G_RESPONSE_PREFIX

! return allocatable arrays
interface  get_args;  module  procedure  get_anyarray_d;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_i;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_r;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_x;  end interface  ! any size array
interface  get_args;  module  procedure  get_anyarray_c;  end interface  ! any size array and any length
interface  get_args;  module  procedure  get_anyarray_l;  end interface  ! any size array

! return scalars
interface  get_args;  module  procedure  get_scalar_d;               end interface
interface  get_args;  module  procedure  get_scalar_i;               end interface
interface  get_args;  module  procedure  get_scalar_real;            end interface
interface  get_args;  module  procedure  get_scalar_complex;         end interface
interface  get_args;  module  procedure  get_scalar_logical;         end interface
interface  get_args;  module  procedure  get_scalar_anylength_c;     end interface  ! any length

! multiple scalars
interface  get_args;  module  procedure  many_args;               end  interface

! return non-allocatable arrays
! said in conflict with get_args_*. Using class to get around that.
! that did not work either. Adding size parameter as optional parameter works; but using a different name
interface  get_args_fixed_size;  module procedure get_fixedarray_class;            end interface ! any length, fixed size array
!interface   get_args;           module procedure get_fixedarray_d;                end interface
!interface   get_args;           module procedure get_fixedarray_i;                end interface
!interface   get_args;           module procedure get_fixedarray_r;                end interface
!interface   get_args;           module procedure get_fixedarray_l;                end interface
!interface   get_args;           module procedure get_fixedarray_fixed_length_c;   end interface

interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_a_array; end interface  ! fixed length any size array
interface   get_args_fixed_length;  module  procedure  get_args_fixed_length_scalar_c;  end interface       ! fixed length

! Generic subroutine inserts element into allocatable array at specified position

! find PLACE in sorted character array where value can be found or should be placed
interface  locate_;  module procedure locate_c                            ; end interface

! insert entry into a sorted allocatable array at specified position
interface  insert_;  module procedure insert_c,      insert_i,  insert_l  ; end interface

! replace entry by index from a sorted allocatable array if it is present
interface  replace_; module procedure replace_c,     replace_i, replace_l ; end interface

! delete entry by index from a sorted allocatable array if it is present
interface  remove_;  module procedure remove_c,      remove_i,  remove_l  ; end interface

! convenience functions
interface cgets;module procedure cgs, cg;end interface
interface dgets;module procedure dgs, dg;end interface
interface igets;module procedure igs, ig;end interface
interface lgets;module procedure lgs, lg;end interface
interface rgets;module procedure rgs, rg;end interface
interface sgets;module procedure sgs, sg;end interface

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    check_commandline(3f) - [ARGUMENTS:M_CLI2]check command and process
!!    pre-defined options
!!
!!##SYNOPSIS
!!
!!      subroutine check_commandline(help_text,version_text,ierr,errmsg)
!!
!!       character(len=*),intent(in),optional :: help_text(:)
!!       character(len=*),intent(in),optional :: version_text(:)
!!
!!##DESCRIPTION
!!     Checks the commandline  and processes the implicit --help, --version,
!!     --verbose, and --usage parameters.
!!
!!     If the optional text values are supplied they will be displayed by
!!     --help and --version command-line options, respectively.
!!
!!##OPTIONS
!!
!!     HELP_TEXT     if present, will be displayed if program is called with
!!                   --help switch, and then the program will terminate. If
!!                   not supplied, the command line initialized string will be
!!                   shown when --help is used on the commandline.
!!
!!     VERSION_TEXT  if present, will be displayed if program is called with
!!                   --version switch, and then the program will terminate.
!!
!!        If the first four characters of each line are "@(#)" this prefix
!!        will not be displayed and the last non-blank letter will be
!!        removed from each line. This if for support of the SCCS what(1)
!!        command. If you do not have the what(1) command on GNU/Linux and
!!        Unix platforms you can probably see how it can be used to place
!!        metadata in a binary by entering:
!!
!!         strings demo_commandline|grep '@(#)'|tr '>' '\n'|sed -e 's/  */ /g'
!!
!!##EXAMPLES
!!
!!
!! Typical usage:
!!
!!      program check_commandline
!!      use M_CLI2,  only : unnamed, set_args, get_args
!!      implicit none
!!      integer                      :: i
!!      character(len=:),allocatable :: version_text(:), help_text(:)
!!      real               :: x, y, z
!!      character(len=*),parameter :: cmd='-x 1 -y 2 -z 3'
!!         version_text=[character(len=80) :: "version: 1.0","author: me"]
!!         help_text=[character(len=80) :: &
!!                 & "wish I put instructions","here","I suppose?"]
!!         call set_args(cmd,help_text,version_text)
!!         call get_args('x',x,'y',y,'z',z)
!!         ! All done cracking the command line. Use the values in your program.
!!         write (*,*)x,y,z
!!         ! the optional unnamed values on the command line are
!!         ! accumulated in the character array "UNNAMED"
!!         if(size(unnamed) > 0)then
!!            write (*,'(a)')'files:'
!!            write (*,'(i6.6,3a)') (i,'[',unnamed(i),']',i=1,size(unnamed))
!!         endif
!!      end program check_commandline
!===================================================================================================================================
subroutine check_commandline(help_text,version_text)
character(len=*),intent(in),optional :: help_text(:)
character(len=*),intent(in),optional :: version_text(:)
character(len=:),allocatable         :: line
integer                              :: i
integer                              :: istart
integer                              :: iback
!character(len=255)                   :: string
   if(get('usage') == 'T')then
      ! kludge to test interactive mode concept
      !   do
      !      call print_dictionary_usage()
      !      read(*,'(a)')string
      !      if(string.eq.'.')exit
      !      call prototype_to_dictionary(string)
      !   enddo
      call print_dictionary_usage()
      call mystop(32)
      return
   endif
   if(present(help_text))then
      if(get('help') == 'T')then
         do i=1,size(help_text)
            call journal(help_text(i))
         enddo
         call mystop(1,'displayed help text')
         return
      endif
   elseif(get('help') == 'T')then
      call default_help()
      call mystop(2,'displayed default help text')
      return
   endif
   if(present(version_text))then
      if(get('version') == 'T')then
         istart=1
         iback=0
         if(size(version_text) > 0)then
            if(index(version_text(1),'@'//'(#)') == 1)then ! allow for what(1) syntax
               istart=5
               iback=1
            endif
         endif
         do i=1,size(version_text)
            !xINTEL BUG*!call journal(version_text(i)(istart:len_trim(version_text(i))-iback))
            line=version_text(i)(istart:len_trim(version_text(i))-iback)
            call journal(line)
         enddo
         call mystop(3,'displayed version text')
         return
      endif
   elseif(get('version') == 'T')then

      if(G_QUIET)then
         G_STOP_MESSAGE = 'no version text'
      else
         call journal('*check_commandline* no version text')
      endif
      call mystop(4,'displayed default version text')
      return
   endif
contains
subroutine default_help()
character(len=:),allocatable :: cmd_name
integer :: ilength
   call get_command_argument(number=0,length=ilength)
   if(allocated(cmd_name))deallocate(cmd_name)
   allocate(character(len=ilength) :: cmd_name)
   call get_command_argument(number=0,value=cmd_name)
   G_passed_in=G_passed_in//repeat(' ',len(G_passed_in))
   G_passed_in=replace_str(G_passed_in, ' --', NEW_LINE('A')//' --')
   if(.not.G_QUIET)then
      call journal(cmd_name,G_passed_in) ! no help text, echo command and default options
   endif
   deallocate(cmd_name)
end subroutine default_help
end subroutine check_commandline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_args(3f) - [ARGUMENTS:M_CLI2] command line argument parsing
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine set_args(prototype,help_text,version_text,ierr,errmsg)
!!
!!      character(len=*),intent(in),optional              :: prototype
!!      character(len=*),intent(in),optional              :: help_text(:)
!!      character(len=*),intent(in),optional              :: version_text(:)
!!      integer,intent(out),optional                      :: ierr
!!      character(len=:),intent(out),allocatable,optional :: errmsg
!!##DESCRIPTION
!!
!!    SET_ARGS(3f) requires a unix-like command prototype which defines
!!    the command-line options and their default values. When the program
!!    is executed this and the command-line options are applied and the
!!    resulting values are placed in an internal table for retrieval via
!!    GET_ARGS(3f).
!!
!!    The built-in --help and --version options require optional help_text
!!    and version_text values to be provided to be particularly useful.
!!
!!##OPTIONS
!!
!!    PROTOTYPE   composed of all command arguments concatenated
!!                into a Unix-like command prototype string. For example:
!!
!!                 call set_args('-L F --ints 1,2,3 --title "my title" -R 10.3')
!!
!!                Note that the following options are predefined for all
!!                commands:
!!
!!                    --verbose F --usage F --help F --version F
!!
!!                see "DEFINING THE PROTOTYPE" in the next section for
!!                further details.
!!
!!    HELP_TEXT   if present, will be displayed when the program is called with
!!                a --help switch, and then the program will terminate. If
!!                help text is not supplied the command line initialization
!!                string will be echoed.
!!
!!    VERSION_TEXT  if present, any version text defined will be displayed
!!                  when the program is called with a --version switch,
!!                  and then the program will terminate.
!!    IERR          if present a non-zero option is returned when an
!!                  error occurs instead of the program terminating.
!!    ERRMSG        a description of the error if ierr is present.
!!
!!##DEFINING THE PROTOTYPE
!!
!!    o Keywords start with a single dash for short single-character
!!      keywords, and with two dashes for longer keywords.
!!
!!    o all keywords on the prototype MUST get a value.
!!
!!       * logicals must be set to an unquoted F.
!!
!!       * strings must be delimited with double-quotes.
!!         Since internal double-quotes are represented with two
!!         double-quotes the string must be at least one space.
!!
!!    o numeric keywords are not allowed; but this allows
!!      negative numbers to be used as values.
!!
!!    o lists of values should be comma-delimited unless a
!!      user-specified delimiter is used. The prototype
!!      must use the same array delimiters as the call to
!!      get the value.
!!
!!    o to define a zero-length allocatable array make the
!!      value a delimiter (usually a comma) or an empty set
!!      of braces ("[]").
!!
!!    LONG AND SHORT NAMES
!!
!!    Long keywords start with two dashes followed by more than one letter.
!!    Short keywords are a dash followed by a single letter.
!!
!!    o It is recommended long names (--keyword) should be all lowercase
!!      but are case-sensitive by default, unless
!!      "set_mode('ignorelongcase')" or "set_mode('ignoreallcase')" is
!!      in effect.
!!
!!    o Long names should always be more than one character.
!!
!!    o The recommended way to have short names is to suffix the long
!!      name with :LETTER in the definition.
!!
!!      If this syntax is used then logical shorts may be combined on the
!!      command line when "set_mode('strict')" is in effect.
!!
!!    SPECIAL BEHAVIORS
!!
!!    o A special behavior occurs if a keyword name ends in ::.
!!      When the program is called the next parameter is taken as a value
!!      even if it starts with -. This is not generally needed but is
!!      useful in rare cases where non-numeric values starting with a dash
!!      are desired.
!!
!!    o If the prototype ends with "--" a special mode is turned
!!      on where anything after "--" on input goes into the variable
!!      REMAINING with values double-quoted and also into the array ARGS
!!      instead of becoming elements in the UNNAMED array. This is not
!!      needed for normal processing, but was needed for a program that
!!      needed this behavior for its subcommands.
!!
!!      That is, for a normal call all unnamed values go into UNNAMED
!!      and ARGS and REMAINING are ignored. So for
!!
!!          call set_args('-x 10 -y 20 ')
!!
!!      A program invocation such as
!!
!!          xx a b c -- A B C " dd "
!!
!!      results in
!!
!!       UNNAMED= ['a','b','c','A','B','C',' dd']
!!       REMAINING= ''
!!       ARGS= [character(len=0) :: ] ! ie, an empty character array
!!
!!      Whereas
!!
!!       call set_args('-x 10 -y 20 --')
!!
!!      generates the following output from the same program execution:
!!
!!       UNNAMED= ['a','b','c']
!!       REMAINING= '"A" "B" "C" " dd "'
!!       ARGS= ['A','B','C,' dd']
!!
!!##USAGE NOTES
!!      When invoking the program line note the following restrictions
!!      (which often differ between various command-line parsers and are
!!      subject to change):
!!
!!      o By defaul tvalues for duplicate keywords are appended together
!!        with a space separator.
!!
!!      o shuffling is not supported. Values immediately follow their
!!        keywords.
!!
!!      o Only short Boolean keywords can be bundled together.
!!        If allowing bundling is desired call "set_mode('strict')".
!!        This will require prefixing long names with "--" and short
!!        names with "-". Otherwise M_CLI2 relaxes that requirement
!!        and mostly does not care what prefix is used for a keyword.
!!        But this would make it unclear what was meant by "-ox" if
!!        allowed options were "-o F -x F --ox F " for example, so
!!        "strict" mode is required to remove the ambiguity.
!!
!!      o if a parameter value of just "-" is supplied it is
!!        converted to the string "stdin".
!!
!!      o values not needed for a keyword value go into the character
!!        array "UNNAMED".
!!
!!        In addition if the keyword "--" is encountered on the command
!!        line the rest of the command line goes into the character array
!!        "UNNAMED".
!!
!!##EXAMPLES
!!
!!
!! Sample program:
!!
!!     program demo_set_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     use M_CLI2,  only : get_args_fixed_size
!!     implicit none
!!     integer                      :: i
!!     ! DEFINE ARGS
!!     real                         :: x, y, z
!!     real                         :: p(3)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!     integer,allocatable          :: ints(:)
!!     !
!!     !  DEFINE COMMAND (TO SET INITIAL VALUES AND ALLOWED KEYWORDS)
!!     !  AND READ COMMAND LINE
!!     call set_args(' &
!!        ! reals
!!        & -x 1 -y 2.3 -z 3.4e2 &
!!        ! integer array
!!        & -p -1,-2,-3 &
!!        ! always double-quote strings
!!        & --title "my title" &
!!        ! string should be a single character at a minimum
!!        & --label " ", &
!!        ! set all logical values to F
!!        & -l F -L F &
!!        ! set allocatable size to zero if you like by using a delimiter
!!        & --ints , &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!     !     SCALARS
!!     call get_args('x',x)
!!     call get_args('y',y)
!!     call get_args('z',z)
!!     call get_args('l',l)
!!     call get_args('L',lbig)
!!     call get_args('ints',ints)      ! ALLOCATABLE ARRAY
!!     call get_args('title',title)    ! ALLOCATABLE STRING
!!     call get_args_fixed_size('p',p) ! NON-ALLOCATABLE ARRAY
!!     ! USE VALUES
!!     write(*,*)'x=',x
!!     write(*,*)'y=',y
!!     write(*,*)'z=',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'ints=',ints
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     ! UNNAMED VALUES
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_set_args
!!
!!##RESPONSE FILES
!!
!!  If you have no interest in using external files as abbreviations
!!  you can ignore this section. Otherwise, before calling set_args(3f)
!!  add:
!!
!!     use M_CLI2, only : set_mode
!!     call set_mode('response_file')
!!
!!  M_CLI2 Response files are small files containing CLI (Command Line
!!  Interface) arguments that end with ".rsp" that can be used when command
!!  lines are so long that they would exceed line length limits or so complex
!!  that it is useful to have a platform-independent method of creating
!!  an abbreviation.
!!
!!  Shell aliases and scripts are often used for similar purposes (and
!!  allow for much more complex conditional execution, of course), but
!!  they generally cannot be used to overcome line length limits and are
!!  typically platform-specific.
!!
!!  Examples of commands that support similar response files are the Clang
!!  and Intel compilers, although there is no standard format for the files.
!!
!!  They are read if you add options of the syntax "@NAME" as the FIRST
!!  parameters on your program command line calls. They are not recursive --
!!  that is, an option in a response file cannot be given the value "@NAME2"
!!  to call another response file.
!!
!!  More than one response name may appear on a command line.
!!
!!  They are case-sensitive names.
!!
!!  Note "@" is a special character in Powershell, and therefore requires being
!!  escaped with a grave character or placed in double-quotes if the name
!!  is alphanumeric (using names like "a-b" or other non-alphanumeric
!!  characters also prevents the "@" from being treated specially).
!!
!!   LEADING UNDERSCORE IS EQUIVALENT TO AT
!!  Therefore, a leading underscore on a word is converted to an at ("@")
!!  when response file mode is enabled. It will be converted to an "@"
!!  before processing continues.
!!
!!   TRAILING AT IS EQUIVALENT TO LEADING AT
!!  Alternatively To accommodate special handling of leading "@" characters
!!  the "@" character may alternatively appear on the end
!!  of the name instead of the beginning. It will be internally moved to
!!  the beginning before processing commences.
!!
!!   CHANGING THE PREFIX IDENTIFIER
!!  It is not recommended in general but the response name prefix may
!!  be changed via the environment variable CLI_RESPONSE_PREFIX if in an
!!  environment preventing the use of the "@" character. Typically "^" or
!!  "%" or "_" are unused characters. In the very worst case an arbitrary
!!  string is allowed such as "rsp_".
!!
!!  Currently this also means changing the prefix in the response files as
!!  well. This may be changed so the @ character usage remains unchanged
!!  in the file.
!!
!!   LOCATING RESPONSE FILES
!!
!!  A search for the response file always starts with the current directory.
!!  The search then proceeds to look in any additional directories specified
!!  with the colon-delimited environment variable CLI_RESPONSE_PATH.
!!
!!  The first resource file found that results in lines being processed
!!  will be used and processing stops after that first match is found. If
!!  no match is found an error occurs and the program is stopped.
!!
!!   RESPONSE FILE SECTIONS
!!
!!  A simple response file just has options for calling the program in it
!!  prefixed with the word "options".
!!  But they can also contain section headers to denote selections that are
!!  only executed when a specific OS is being used, print messages, and
!!  execute system commands.
!!
!!   SEARCHING FOR OSTYPE IN REGULAR FILES
!!
!!  So assuming the name @NAME was specified on the command line a file
!!  named NAME.rsp will be searched for in all the search directories
!!  and then in that file a string that starts with the string @OSTYPE
!!  (if the environment variables $OS and $OSTYPE are not blank. $OSTYPE
!!  takes precedence over $OS).
!!
!!   SEARCHING FOR UNLABELED DIRECTIVES IN REGULAR FILES
!!
!!  Then, the same files will be searched for lines above any line starting
!!  with "@". That is, if there is no special section for the current OS
!!  it just looks at the top of the file for unlabeled options.
!!
!!   SEARCHING FOR OSTYPE AND NAME IN THE COMPOUND FILE
!!
!!  In addition or instead of files with the same name as the @NAME option
!!  on the command line, you can have one file named after the executable
!!  name that contains multiple abbreviation names.
!!
!!  So if your program executable is named EXEC you create a single file
!!  called EXEC.rsp and can append all the simple files described above
!!  separating them with lines of the form @OSTYPE@NAME or just @NAME.
!!
!!  So if no specific file for the abbreviation is found a file called
!!  "EXEC.rsp" is searched for where "EXEC" is the name of the executable.
!!  This file is always a "compound" response file that uses the following format:
!!
!!  Any compound EXEC.rsp file found in the current or searched directories
!!  will be searched for the string @OSTYPE@NAME first.
!!
!!  Then if nothing is found, the less specific line @NAME is searched for.
!!
!!   THE SEARCH IS OVER
!!
!!  Sounds complicated but actually works quite intuitively. Make a file in
!!  the current directory and put options in it and it will be used. If that
!!  file ends up needing different cases for different platforms add a line
!!  like "@Linux" to the file and some more lines and that will only be
!!  executed if the environment variable OSTYPE or OS is "Linux". If no match
!!  is found for named sections the lines at the top before any "@" lines
!!  will be used as a default if no match is found.
!!
!!  If you end up using a lot of files like this you can combine them all
!!  together and put them into a file called "program_name".rsp and just
!!  put lines like @NAME or @OSTYPE@NAME at that top of each selection.
!!
!!  Now, back to the details on just what you can put in the files.
!!
!!##SPECIFICATION FOR RESPONSE FILES
!!
!!   SIMPLE RESPONSE FILES
!!
!!  The first word of a line is special and has the following meanings:
!!
!!    options|-  Command options following the rules of the SET_ARGS(3f)
!!               prototype. So
!!                o It is preferred to specify a value for all options.
!!                o double-quote strings.
!!                o give a blank string value as " ".
!!                o use F|T for lists of logicals,
!!                o lists of numbers should be comma-delimited.
!!                o --usage, --help, --version, --verbose, and unknown
!!                  options are ignored.
!!
!!    comment|#  Line is a comment line
!!    system|!   System command.
!!               System commands are executed as a simple call to
!!               system (so a cd(1) or setting a shell variable
!!               would not effect subsequent lines, for example)
!!               BEFORE the command being processed.
!!    print|>    Message to screen
!!    stop       display message and stop program.
!!
!!  NOTE: system commands are executed when encountered, but options are
!!  gathered from multiple option lines and passed together at the end of
!!  processing of the block; so all commands will be executed BEFORE the
!!  command for which options are being supplied no matter where they occur.
!!
!!  So if a program that does nothing but echos its parameters
!!
!!    program testit
!!    use M_CLI2, only : set_args, rget, sget, lget, set_mode
!!    implicit none
!!       real :: x,y                           ; namelist/args/ x,y
!!       character(len=:),allocatable :: title ; namelist/args/ title
!!       logical :: big                        ; namelist/args/ big
!!       call set_mode('response_file')
!!       call set_args('-x 10.0 -y 20.0 --title "my title" --big F')
!!       x=rget('x')
!!       y=rget('y')
!!       title=sget('title')
!!       big=lget('big')
!!       write(*,nml=args)
!!    end program testit
!!
!!  And a file in the current directory called "a.rsp" contains
!!
!!     # defaults for project A
!!     options -x 1000 -y 9999
!!     options --title " "
!!     options --big T
!!
!!  The program could be called with
!!
!!     $myprog     # normal call
!!      X=10.0 Y=20.0 TITLE="my title"
!!
!!     $myprog @a  # change defaults as specified in "a.rsp"
!!     X=1000.0 Y=9999.0 TITLE=" "
!!
!!     # change defaults but use any option as normal to override defaults
!!     $myprog @a -y 1234
!!      X=1000.0 Y=1234.0 TITLE=" "
!!
!!   COMPOUND RESPONSE FILES
!!
!!  A compound response file has the same basename as the executable with a
!!  ".rsp" suffix added. So if your program is named "myprg" the filename
!!  must be "myprg.rsp".
!!
!!    Note that here `basename` means the last leaf of the
!!    name of the program as returned by the Fortran intrinsic
!!    GET_COMMAND_ARGUMENT(0,...) trimmed of anything after a period ("."),
!!    so it is a good idea not to use hidden files.
!!
!!  Unlike simple response files compound response files can contain multiple
!!  setting names.
!!
!!  Specifically in a compound file
!!  if the environment variable $OSTYPE (first) or $OS is set the first search
!!  will be for a line of the form (no leading spaces should be used):
!!
!!    @OSTYPE@alias_name
!!
!!  If no match or if the environment variables $OSTYPE and $OS were not
!!  set or a match is not found then a line of the form
!!
!!    @alias_name
!!
!!  is searched for in simple or compound files. If found subsequent lines
!!  will be ignored that start with "@" until a line not starting with
!!  "@" is encountered. Lines will then be processed until another line
!!  starting with "@" is found or end-of-file is encountered.
!!
!!   COMPOUND RESPONSE FILE EXAMPLE
!!  An example compound file
!!
!!    #################
!!    @if
!!    > RUNNING TESTS USING RELEASE VERSION AND ifort
!!    options test --release --compiler ifort
!!    #################
!!    @gf
!!    > RUNNING TESTS USING RELEASE VERSION AND gfortran
!!    options test --release --compiler gfortran
!!    #################
!!    @nv
!!    > RUNNING TESTS USING RELEASE VERSION AND nvfortran
!!    options test --release --compiler nvfortran
!!    #################
!!    @nag
!!    > RUNNING TESTS USING RELEASE VERSION AND nagfor
!!    options test --release --compiler nagfor
!!    #
!!    #################
!!    # OS-specific example:
!!    @Linux@install
!!    #
!!    # install executables in directory (assuming install(1) exists)
!!    #
!!    system mkdir -p ~/.local/bin
!!    options run --release T --runner "install -vbp -m 0711 -t ~/.local/bin"
!!    @install
!!    STOP INSTALL NOT SUPPORTED ON THIS PLATFORM OR $OSTYPE NOT SET
!!    #
!!    #################
!!    @fpm@testall
!!    #
!!    !fpm test --compiler nvfortran
!!    !fpm test --compiler ifort
!!    !fpm test --compiler gfortran
!!    !fpm test --compiler nagfor
!!    STOP tests complete. Any additional parameters were ignored
!!    #################
!!
!!  Would be used like
!!
!!    fpm @install
!!    fpm @nag --
!!    fpm @testall
!!
!!   NOTES
!!
!!    The intel Fortran compiler now calls the response files "indirect
!!    files" and does not add the implied suffix ".rsp" to the files
!!    anymore. It also allows the @NAME syntax anywhere on the command line,
!!    not just at the beginning. -- 20201212
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_args(prototype,help_text,version_text,string,prefix,ierr,errmsg)

! ident_1="@(#) M_CLI2 set_args(3f) parse prototype string"

character(len=*),intent(in)                       :: prototype
character(len=*),intent(in),optional              :: help_text(:)
character(len=*),intent(in),optional              :: version_text(:)
character(len=*),intent(in),optional              :: string
character(len=*),intent(in),optional              :: prefix
integer,intent(out),optional                      :: ierr
character(len=:),intent(out),allocatable,optional :: errmsg
character(len=:),allocatable                      :: hold               ! stores command line argument
integer                                           :: ibig
character(len=:),allocatable                      :: debug_mode

   debug_mode= upper(get_env('CLI_DEBUG_MODE','FALSE'))//' '
   select case(debug_mode(1:1))
   case('Y','T')
      G_DEBUG=.true.
   end select

   G_response=CLI_RESPONSE_FILE
   if(CLI_AUTO_RESPONSE_FILE)then
      CLI_AUTO_QUIET=.true.
      G_response=.true.
   endif

   G_options_only=.false.
   G_passed_in=''
   G_STOP=0
   G_STOP_MESSAGE=''
   if(present(prefix))then
      G_PREFIX=prefix
   else
      G_PREFIX=''
   endif
   if(present(ierr))then
      G_QUIET=.true.
   else
      G_QUIET=.false.
   endif
   ibig=longest_command_argument() ! bug in gfortran. len=0 should be fine
   IF(ALLOCATED(UNNAMED)) DEALLOCATE(UNNAMED)
   ALLOCATE(CHARACTER(LEN=IBIG) :: UNNAMED(0))
   if(allocated(args)) deallocate(args)
   allocate(character(len=ibig) :: args(0))

   call wipe_dictionary()
   hold='--version F --usage F --help F --version F '//adjustl(prototype)
   call prototype_and_cmd_args_to_nlist(hold,string)
   if(allocated(G_RESPONSE_IGNORED))then
      if(G_DEBUG)write(*,gen)'<DEBUG>SET_ARGS:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
      if(size(unnamed) /= 0)write(*,*)'LOGIC ERROR'
      call split(G_RESPONSE_IGNORED,unnamed)
   endif

   if(.not.allocated(unnamed))then
       allocate(character(len=0) :: unnamed(0))
   endif
   if(.not.allocated(args))then
       allocate(character(len=0) :: args(0))
   endif
   call check_commandline(help_text,version_text) ! process --help, --version, --usage
   if(present(ierr))then
      ierr=G_STOP
   endif
   if(present(errmsg))then
      errmsg=G_STOP_MESSAGE
   endif
end subroutine set_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_subcommand(3f) - [ARGUMENTS:M_CLI2] special-case routine for
!!    handling subcommands on a command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function get_subcommand()
!!
!!     character(len=:),allocatable :: get_subcommand
!!
!!##DESCRIPTION
!!    In the special case when creating a program with subcommands it
!!    is assumed the first word on the command line is the subcommand. A
!!    routine is required to handle response file processing, therefore
!!    this routine (optionally processing response files) returns that
!!    first word as the subcommand name.
!!
!!    It should not be used by programs not building a more elaborate
!!    command with subcommands.
!!
!!##RETURNS
!!    NAME   name of subcommand
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!    program demo_get_subcommand
!!    !x! SUBCOMMANDS
!!    !x! For a command with subcommands like git(1)
!!    !x! you can make separate namelists for each subcommand.
!!    !x! You can call this program which has two subcommands (run, test),
!!    !x! like this:
!!    !x!    demo_get_subcommand --help
!!    !x!    demo_get_subcommand run -x -y -z --title -l -L
!!    !x!    demo_get_subcommand test --title -l -L --testname
!!    !x!    demo_get_subcommand run --help
!!       implicit none
!!    !x! DEFINE VALUES TO USE AS ARGUMENTS WITH INITIAL VALUES
!!       real               :: x=-999.0,y=-999.0,z=-999.0
!!       character(len=80)  :: title="not set"
!!       logical            :: l=.false.
!!       logical            :: l_=.false.
!!       character(len=80)  :: testname="not set"
!!       character(len=20)  :: name
!!       call parse(name) !x! DEFINE AND PARSE COMMAND LINE
!!       !x! ALL DONE CRACKING THE COMMAND LINE.
!!       !x! USE THE VALUES IN YOUR PROGRAM.
!!       write(*,*)'command was ',name
!!       write(*,*)'x,y,z .... ',x,y,z
!!       write(*,*)'title .... ',title
!!       write(*,*)'l,l_ ..... ',l,l_
!!       write(*,*)'testname . ',testname
!!    contains
!!    subroutine parse(name)
!!    !x! PUT EVERYTHING TO DO WITH COMMAND PARSING HERE FOR CLARITY
!!    use M_CLI2, only : set_args, get_args, get_args_fixed_length
!!    use M_CLI2, only : get_subcommand, set_mode
!!    character(len=*)              :: name    ! the subcommand name
!!    character(len=:),allocatable  :: help_text(:), version_text(:)
!!       call set_mode('response_file')
!!    ! define version text
!!       version_text=[character(len=80) :: &
!!          '@(#)PROGRAM:     demo_get_subcommand            >', &
!!          '@(#)DESCRIPTION: My demo program  >', &
!!          '@(#)VERSION:     1.0 20200715     >', &
!!          '@(#)AUTHOR:      me, myself, and I>', &
!!          '@(#)LICENSE:     Public Domain    >', &
!!          '' ]
!!        ! general help for "demo_get_subcommand --help"
!!        help_text=[character(len=80) :: &
!!         ' allowed subcommands are          ', &
!!         '   * run  -l -L --title -x -y -z  ', &
!!         '   * test -l -L --title           ', &
!!         '' ]
!!       ! find the subcommand name by looking for first word on command
!!       ! not starting with dash
!!       name = get_subcommand()
!!       select case(name)
!!       case('run')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "run"        ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args( &
!!        & '-x 1 -y 2 -z 3 --title "my title" -l F -L F',&
!!        & help_text,version_text)
!!        call get_args('x',x)
!!        call get_args('y',y)
!!        call get_args('z',z)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!       case('test')
!!        help_text=[character(len=80) :: &
!!         '                                  ', &
!!         ' Help for subcommand "test"       ', &
!!         '                                  ', &
!!         '' ]
!!        call set_args(&
!!        & '--title "my title" -l F -L F --testname "Test"',&
!!        & help_text,version_text)
!!        call get_args_fixed_length('title',title)
!!        call get_args('l',l)
!!        call get_args('L',l_)
!!        call get_args_fixed_length('testname',testname)
!!       case default
!!        ! process help and version
!!        call set_args(' ',help_text,version_text)
!!        write(*,'(*(a))')'unknown or missing subcommand [',trim(name),']'
!!        write(*,'(a)')[character(len=80) ::  &
!!        ' allowed subcommands are          ', &
!!        '   * run  -l -L -title -x -y -z   ', &
!!        '   * test -l -L -title            ', &
!!        '' ]
!!        stop
!!       end select
!!    end subroutine parse
!!    end program demo_get_subcommand
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
function get_subcommand() result(sub)

! ident_2="@(#) M_CLI2 get_subcommand(3f) parse prototype string to get subcommand allowing for response files"

character(len=:),allocatable  :: sub
character(len=:),allocatable  :: cmdarg
character(len=:),allocatable  :: array(:)
character(len=:),allocatable  :: prototype
integer                       :: ilongest
integer                       :: i
integer                       :: j
   G_RESPONSE_PREFIX=get_env('CLI_RESPONSE_PREFIX','@')
   G_subcommand=''
   G_options_only=.true.
   sub=''

   if(.not.allocated(unnamed))then
      allocate(character(len=0) :: unnamed(0))
   endif

   ilongest=longest_command_argument()
   allocate(character(len=max(63,ilongest)):: cmdarg)
   cmdarg(:) = ''
   ! look for @NAME if CLI_RESPONSE_FILE=.TRUE. AND LOAD THEM
   do i = 1, command_argument_count()
      call get_command_argument(i, cmdarg)
      call move_from_end(cmdarg)
      cmdarg=change_leading_underscore_to_prefix(cmdarg)
      if(scan(adjustl(cmdarg(1:len(G_RESPONSE_PREFIX))),G_RESPONSE_PREFIX)  ==  1)then
         call get_prototype(cmdarg,prototype)
         call split(prototype,array)
         ! assume that if using subcommands first word not starting with dash is the subcommand
         do j=1,size(array)
            if(adjustl(array(j)(1:1))  /=  '-')then
            G_subcommand=trim(array(j))
            sub=G_subcommand
            exit
         endif
         enddo
      endif
   enddo

   if(G_subcommand /= '')then
      sub=G_subcommand
   elseif(size(unnamed) /= 0)then
      sub=unnamed(1)
   else
      cmdarg(:) = ''
      do i = 1, command_argument_count()
         call get_command_argument(i, cmdarg)
         if(adjustl(cmdarg(1:1))  /=  '-')then
            sub=trim(cmdarg)
           exit
        endif
      enddo
   endif
   G_options_only=.false.
end function get_subcommand
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine move_from_end(string)
character(len=*) :: string
integer          :: iend
! @ is treated as a special character in powershell so allow the prefix to be a suffix and move it to beginning of line
   iend=len_trim(string)
   if(string(iend-len(G_RESPONSE_PREFIX)+1:iend)== G_RESPONSE_PREFIX)then
      string(:)= G_RESPONSE_PREFIX//string(1:iend-len(G_RESPONSE_PREFIX))
   endif
end subroutine move_from_end
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function change_leading_underscore_to_prefix(string) result(newstring)
character(len=*) :: string
character(len=:),allocatable :: newstring
! @ is treated as a special character in powershell so allow the underscore to be a prefix
   if(string.eq.'')then
      newstring=string
   elseif(string(1:1).eq.'_')then
      newstring=G_RESPONSE_PREFIX//string(2:)
   else
      newstring=string
   endif
end function change_leading_underscore_to_prefix
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_usage(3f) - [ARGUMENTS:M_CLI2] allow setting a short description
!!    of keywords for the --usage switch
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     subroutine set_usage(keyword,description)
!!
!!      character(len=*),intent(in)     ::  keyword
!!      character(len=*),intent(in)     ::  description
!!
!!##DESCRIPTION
!!
!!##OPTIONS
!!     KEYWORD      the name of a command keyword
!!     DESCRIPTION  a brief one-line description of the keyword
!!
!!
!!##EXAMPLES
!!
!! sample program:
!!
!!    program demo_set_usage
!!    use M_CLI2,  only : set_args, igets, rgets, specified, sget, lget
!!    implicit none
!!
!!    integer,allocatable  :: ints(:)
!!    logical              :: flag
!!       call set_args(' --flag:f F --ints:i 1,10,11 ')
!!       call set_usage('flag','This is my flag')
!!       call set_usage('ints','These are my whole numbers')
!!       flag=lget('flag')
!!       ints=igets('ints')
!!       write(*,*)'flag=',flag
!!       write(*,*)'ints=',ints
!!    end program demo_set_usage
!!
!!    Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine set_usage(keyword,description,value)
character(len=*),intent(in) :: keyword
character(len=*),intent(in) :: description
character(len=*),intent(in) :: value
write(*,*)keyword
write(*,*)description
write(*,*)value
! store the descriptions in an array and then apply them when set_args(3f) is called.
! alternatively, could allow for a value as well in lieu of the prototype
end subroutine set_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_to_dictionary(3f) - [ARGUMENTS:M_CLI2] parse user command
!!    and store tokens into dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     recursive subroutine prototype_to_dictionary(string)
!!
!!      character(len=*),intent(in)     ::  string
!!
!!##DESCRIPTION
!!      given a string of form
!!
!!        -var value -var value
!!
!!      define dictionary of form
!!
!!        keyword(i), value(i)
!!
!!      o  string values
!!
!!          o must be delimited with double quotes.
!!          o adjacent double quotes put one double quote into value
!!          o must not be null. A blank is specified as " ", not "".
!!
!!      o  logical values
!!
!!          o logical values must have a value. Use F.
!!
!!      o  leading and trailing blanks are removed from unquoted values
!!
!!
!!##OPTIONS
!!      STRING   string is character input string to define command
!!
!!##RETURNS
!!
!!##EXAMPLES
!!
!! sample program:
!!
!!     call prototype_to_dictionary(' -l F --ignorecase F --title "my title string" -x 10.20')
!!     call prototype_to_dictionary(' --ints 1,2,3,4')
!!
!! Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
recursive subroutine prototype_to_dictionary(string)

! ident_3="@(#) M_CLI2 prototype_to_dictionary(3f) parse user command and store tokens into dictionary"

character(len=*),intent(in)   :: string  ! string is character input string of options and values

character(len=:),allocatable  :: dummy   ! working copy of string
character(len=:),allocatable  :: value
character(len=:),allocatable  :: keyword
character(len=3)              :: delmt   ! flag if in a delimited string or not
character(len=1)              :: currnt  ! current character being processed
character(len=1)              :: prev    ! character to left of CURRNT
character(len=1)              :: forwrd  ! character to right of CURRNT
integer,dimension(2)          :: ipnt
integer                       :: islen   ! number of characters in input string
integer                       :: ipoint
integer                       :: itype
integer,parameter             :: VAL=1, KEYW=2
integer                       :: ifwd
integer                       :: ibegin
integer                       :: iend
integer                       :: place

   islen=len_trim(string)                               ! find number of characters in input string
   if(islen  ==  0)then                                 ! if input string is blank, even default variable will not be changed
      return
   endif
   dummy=adjustl(string)//'  '

   keyword=""          ! initial variable name
   value=""            ! initial value of a string
   ipoint=0            ! ipoint is the current character pointer for (dummy)
   ipnt(2)=2           ! pointer to position in keyword
   ipnt(1)=1           ! pointer to position in value
   itype=VAL           ! itype=1 for value, itype=2 for variable

   delmt="off"
   prev=" "

   G_keyword_single_letter=.true.
   do
      ipoint=ipoint+1               ! move current character pointer forward
      currnt=dummy(ipoint:ipoint)   ! store current character into currnt
      ifwd=min(ipoint+1,islen)      ! ensure not past end of string
      forwrd=dummy(ifwd:ifwd)       ! next character (or duplicate if last)

      if((currnt=="-" .and. prev==" " .and. delmt == "off" .and. index("0123456789.",forwrd) == 0).or.ipoint > islen)then
         ! beginning of a keyword
         if(forwrd == '-')then                      ! change --var to -var so "long" syntax is supported
            !x!dummy(ifwd:ifwd)='_'
            ipoint=ipoint+1                         ! ignore second - instead (was changing it to _)
            G_keyword_single_letter=.false.         ! flag this is a long keyword
         else
            G_keyword_single_letter=.true.          ! flag this is a short (single letter) keyword
         endif
         if(ipnt(1)-1 >= 1)then                     ! position in value
            ibegin=1
            iend=len_trim(value(:ipnt(1)-1))
            TESTIT: do
               if(iend  ==  0)then                  ! len_trim returned 0, value is blank
                  iend=ibegin
                  exit TESTIT
               elseif(value(ibegin:ibegin) == " ")then
                  ibegin=ibegin+1
               else
                  exit TESTIT
               endif
            enddo TESTIT
            if(keyword /= ' ')then
               if(value=='[]')value=','
               call update(keyword,value)            ! store name and its value
            elseif( G_remaining_option_allowed)then  ! meaning "--" has been encountered
               if(value=='[]')value=','
               call update('_args_',trim(value))
            else
               !x!write(warn,'(*(g0))')'*prototype_to_dictionary* warning: ignoring string [',trim(value),'] for ',trim(keyword)
               G_RESPONSE_IGNORED=TRIM(VALUE)
               if(G_DEBUG)write(*,gen)'<DEBUG>PROTOTYPE_TO_DICTIONARY:G_RESPONSE_IGNORED:',G_RESPONSE_IGNORED
            endif
         else
            call locate_key(keyword,place)
            if(keyword /= ' '.and.place < 0)then
               call update(keyword,'F')           ! store name and null value (first pass)
            elseif(keyword /= ' ')then
               call update(keyword,' ')           ! store name and null value (second pass)
            elseif(.not.G_keyword_single_letter.and.ipoint-2 == islen) then ! -- at end of line
               G_remaining_option_allowed=.true.  ! meaning for "--" is that everything on commandline goes into G_remaining
            endif
         endif
         itype=KEYW                            ! change to expecting a keyword
         value=""                              ! clear value for this variable
         keyword=""                            ! clear variable name
         ipnt(1)=1                             ! restart variable value
         ipnt(2)=1                             ! restart variable name

      else       ! currnt is not one of the special characters
         ! the space after a keyword before the value
         if(currnt == " " .and. itype  ==  KEYW)then
            ! switch from building a keyword string to building a value string
            itype=VAL
            ! beginning of a delimited value
         elseif(currnt  ==  """".and.itype  ==  VAL)then
            ! second of a double quote, put quote in
            if(prev  ==  """")then
               if(itype == VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
               delmt="on"
            elseif(delmt  ==  "on")then     ! first quote of a delimited string
               delmt="off"
            else
               delmt="on"
            endif
            if(prev /= """")then  ! leave quotes where found them
               if(itype == VAL)then
                  value=value//currnt
               else
                  keyword=keyword//currnt
               endif
               ipnt(itype)=ipnt(itype)+1
            endif
         else     ! add character to current keyword or value
            if(itype == VAL)then
               value=value//currnt
            else
               keyword=keyword//currnt
            endif
            ipnt(itype)=ipnt(itype)+1
         endif

      endif

      prev=currnt
      if(ipoint <= islen)then
         cycle
      else
         exit
      endif
   enddo

end subroutine prototype_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    specified(3f) - [ARGUMENTS:M_CLI2] return true if keyword was present
!!    on command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental impure function specified(name)
!!
!!     character(len=*),intent(in) :: name
!!     logical :: specified
!!
!!##DESCRIPTION
!!
!!    specified(3f) returns .true. if the specified keyword was present on
!!    the command line.
!!
!!    M_CLI2 intentionally does not have validators except for SPECIFIED(3f)
!!    and of course a check whether the input conforms to the type when
!!    requesting a value (with get_args(3f) or the convenience functions
!!    like inum(3f)).
!!
!!    Fortran already has powerful validation capabilities. Logical
!!    expressions ANY(3f) and ALL(3f) are standard Fortran features which
!!    easily allow performing the common validations for command line
!!    arguments without having to learn any additional syntax or methods.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to query the presence of. Long
!!           names should always be used.
!!
!!##RETURNS
!!    SPECIFIED  returns .TRUE. if specified NAME was present on the command
!!               line when the program was invoked.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!    program demo_specified
!!    use, intrinsic :: iso_fortran_env, only : &
!!    & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
!!    use M_CLI2,  only : set_args, igets, rgets, specified, sget, lget
!!    implicit none
!!
!!    ! Define args
!!    integer,allocatable  :: ints(:)
!!    real,allocatable     :: floats(:)
!!    logical              :: flag
!!    character(len=:),allocatable :: color
!!    character(len=:),allocatable :: list(:)
!!    integer :: i
!!
!!     call set_args('&
!!        & --color:c "red"       &
!!        & --flag:f F            &
!!        & --ints:i 1,10,11      &
!!        & --floats:T 12.3, 4.56 &
!!        & ')
!!     ints=igets('ints')
!!     floats=rgets('floats')
!!     flag=lget('flag')
!!     color=sget('color')
!!
!!     write(*,*)'color=',color
!!     write(*,*)'flag=',flag
!!     write(*,*)'ints=',ints
!!     write(*,*)'floats=',floats
!!
!!     write(*,*)'was -flag specified?',specified('flag')
!!
!!     ! elemental
!!     write(*,*)specified(['floats','ints  '])
!!
!!     ! If you want to know if groups of parameters were specified use
!!     ! ANY(3f) and ALL(3f)
!!     write(*,*)'ANY:',any(specified(['floats','ints  ']))
!!     write(*,*)'ALL:',all(specified(['floats','ints  ']))
!!
!!     ! For mutually exclusive
!!     if (all(specified(['floats','ints  '])))then
!!         write(*,*)'You specified both names --ints and --floats'
!!     endif
!!
!!     ! For required parameter
!!     if (.not.any(specified(['floats','ints  '])))then
!!         write(*,*)'You must specify --ints or --floats'
!!     endif
!!
!!    ! check if all values are in range from 10 to 30 and even
!!    write(*,*)'are all numbers good?',all([ints>=10,ints<= 30,(ints/2)*2==ints])
!!
!!    ! perhaps you want to check one value at a time
!!    do i=1,size(ints)
!!       write(*,*)ints(i),[ints(i) >= 10,ints(i) <= 30,(ints(i)/2)*2 == ints(i)]
!!       if(all([ints(i) >= 10,ints(i) <= 30,(ints(i)/2)*2 == ints(i)]) )then
!!          write(*,*)ints(i),'is an even number from 10 to 30 inclusive'
!!       else
!!          write(*,*)ints(i),'is not an even number from 10 to 30 inclusive'
!!       endif
!!    enddo
!!
!!    list = [character(len=10) :: 'red','white','blue']
!!    if( any(color == list) )then
!!       write(*,*)color,'matches a value in the list'
!!    else
!!       write(*,*)color,'not in the list'
!!    endif
!!
!!    if(size(ints).eq.3)then
!!       write(*,*)'ints(:) has expected number of values'
!!    else
!!       write(*,*)'ints(:) does not have expected number of values'
!!    endif
!!
!!    end program demo_specified
!!
!! Default output
!!
!!  > color=red
!!  > flag= F
!!  > ints=           1          10          11
!!  > floats=   12.3000002       4.55999994
!!  > was -flag specified? F
!!  > F F
!!  > ANY: F
!!  > ALL: F
!!  > You must specify --ints or --floats
!!  >           1 F T F
!!  >           1  is not an even number from 10 to 30 inclusive
!!  >          10 T T T
!!  >          10  is an even number from 10 to 30 inclusive
!!  >          11 T T F
!!  >          11  is not an even number from 10 to 30 inclusive
!!  > red matches a value in the list
!!  > ints(:) has expected number of values
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
elemental impure function specified(key)
character(len=*),intent(in) :: key
logical                     :: specified
integer                     :: place
   call locate_key(key,place)                   ! find where string is or should be
   if(place < 1)then
      specified=.false.
   else
      specified=present_in(place)
   endif
end function specified
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    update(3f) - [ARGUMENTS:M_CLI2] update internal dictionary given
!!    keyword and value
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine update(key,val)
!!
!!      character(len=*),intent(in)           :: key
!!      character(len=*),intent(in),optional  :: val
!!##DESCRIPTION
!!      Update internal dictionary in M_CLI2(3fm) module.
!!##OPTIONS
!!      key  name of keyword to add, replace, or delete from dictionary
!!      val  if present add or replace value associated with keyword. If not
!!           present remove keyword entry from dictionary.
!!
!!           If "present" is true, a value will be appended
!!##EXAMPLES
!!
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine update(key,val)
character(len=*),intent(in)           :: key
character(len=*),intent(in),optional  :: val
integer                               :: place, ii
integer                               :: iilen
character(len=:),allocatable          :: val_local
character(len=:),allocatable          :: short
character(len=:),allocatable          :: long
character(len=:),allocatable          :: long_short(:)
integer                               :: isize
logical                               :: set_mandatory
   set_mandatory=.false.
   if(G_IGNOREALLCASE) then
      call split(lower(trim(key)),long_short,':',nulls='return') ! split long:short keyword or long:short:: or long:: or short::
   else
      call split(trim(key),long_short,':',nulls='return') ! split long:short keyword or long:short:: or long:: or short::
   endif
   ! check for :: on end
   isize=size(long_short)

   if(isize > 0)then                     ! very special-purpose syntax where if ends in :: next field is a value even
      if(long_short(isize) == '')then    ! if it starts with a dash, for --flags option on fpm(1).
         set_mandatory=.true.
         long_short=long_short(:isize-1)
      endif
   endif

   select case(size(long_short))
   case(0)
      long=''
      short=''
   case(1)
      long=trim(long_short(1))
      if(len_trim(long) == 1)then
         !x!ii= findloc (shorts, long, dim=1) ! if parsing arguments on line and a short keyword look up long value
         ii=maxloc([0,merge(1, 0, shorts == long)],dim=1)
         if(ii > 1)then
            long=keywords(ii-1)
         endif
         short=long
      else
         short=''
      endif
   case(2)
      long=trim(long_short(1))
      short=trim(long_short(2))
   case default
      write(warn,*)'WARNING: incorrect syntax for key: ',trim(key)
      long=trim(long_short(1))
      short=trim(long_short(2))
   end select
   if(G_UNDERDASH) long=replace_str(long,'-','_')
   if(G_NODASHUNDER)then
      long=replace_str(long,'-','')
      long=replace_str(long,'_','')
   endif
   if(G_IGNORELONGCASE.and.len_trim(long) > 1)long=lower(long)
   if(present(val))then
      val_local=val
      iilen=len_trim(val_local)
      call locate_key(long,place)                  ! find where string is or should be
      if(place < 1)then                                ! if string was not found insert it
         call insert_(keywords,long,iabs(place))
         call insert_(values,val_local,iabs(place))
         call insert_(counts,iilen,iabs(place))
         call insert_(shorts,short,iabs(place))
         call insert_(present_in,.true.,iabs(place))
         call insert_(mandatory,set_mandatory,iabs(place))
      else
         if(present_in(place))then                      ! if multiple keywords append values with space between them
            if(G_append)then
               if(values(place)(1:1) == '"')then
               ! UNDESIRABLE: will ignore previous blank entries
                  val_local='"'//trim(unquote(values(place)))//' '//trim(unquote(val_local))//'"'
               else
                  val_local=clipends(values(place))//' '//val_local
               endif
            endif
            iilen=len_trim(val_local)
         endif
         call replace_(values,val_local,place)
         call replace_(counts,iilen,place)
         call replace_(present_in,.true.,place)
      endif
   else                                                 ! if no value is present remove the keyword and related values
      call locate_key(long,place)                       ! check name as long and short
      if(place > 0)then
         call remove_(keywords,place)
         call remove_(values,place)
         call remove_(counts,place)
         call remove_(shorts,place)
         call remove_(present_in,place)
         call remove_(mandatory,place)
      endif
   endif
end subroutine update
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    wipe_dictionary(3fp) - [ARGUMENTS:M_CLI2] reset private M_CLI2(3fm)
!!    dictionary to empty
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!      subroutine wipe_dictionary()
!!##DESCRIPTION
!!      reset private M_CLI2(3fm) dictionary to empty
!!##EXAMPLES
!!
!! Sample program:
!!
!!      program demo_wipe_dictionary
!!      use M_CLI2, only : dictionary
!!         call wipe_dictionary()
!!      end program demo_wipe_dictionary
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine wipe_dictionary()
   if(allocated(keywords))deallocate(keywords)
   allocate(character(len=0) :: keywords(0))
   if(allocated(values))deallocate(values)
   allocate(character(len=0) :: values(0))
   if(allocated(counts))deallocate(counts)
   allocate(counts(0))
   if(allocated(shorts))deallocate(shorts)
   allocate(character(len=0) :: shorts(0))
   if(allocated(present_in))deallocate(present_in)
   allocate(present_in(0))
   if(allocated(mandatory))deallocate(mandatory)
   allocate(mandatory(0))
end subroutine wipe_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get(3f) - [ARGUMENTS:M_CLI2] get dictionary value associated with
!!    key name in private M_CLI2(3fm) dictionary
!!##SYNOPSIS
!!
!!
!!##DESCRIPTION
!!    Get dictionary value associated with key name in private M_CLI2(3fm)
!!    dictionary.
!!##OPTIONS
!!##RETURNS
!!##EXAMPLES
!!
!===================================================================================================================================
function get(key) result(valout)
character(len=*),intent(in)   :: key
character(len=:),allocatable  :: valout
integer                       :: place
   ! find where string is or should be
   call locate_key(key,place)
   if(place < 1)then
      valout=''
   else
      valout=values(place)(:counts(place))
   endif
end function get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    prototype_and_cmd_args_to_nlist(3f) - [ARGUMENTS:M_CLI2] convert
!!    Unix-like command arguments to table
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine prototype_and_cmd_args_to_nlist(prototype)
!!
!!      character(len=*) :: prototype
!!##DESCRIPTION
!!    create dictionary with character keywords, values, and value lengths
!!    using the routines for maintaining a list from command line arguments.
!!##OPTIONS
!!      prototype
!!##EXAMPLES
!!
!! Sample program
!!
!!      program demo_prototype_and_cmd_args_to_nlist
!!      use M_CLI2,  only : prototype_and_cmd_args_to_nlist, unnamed
!!      implicit none
!!      character(len=:),allocatable :: readme
!!      character(len=256)           :: message
!!      integer                      :: ios
!!      integer                      :: i
!!      doubleprecision              :: something
!!
!!      ! define arguments
!!      logical            :: l,h,v
!!      real               :: p(2)
!!      complex            :: c
!!      doubleprecision    :: x,y,z
!!
!!      ! uppercase keywords get an underscore to make it easier to remember
!!      logical            :: l_,h_,v_
!!      ! character variables must be long enough to hold returned value
!!      character(len=256) :: a_,b_
!!      integer            :: c_(3)
!!
!!         ! give command template with default values
!!         ! all values except logicals get a value.
!!         ! strings must be delimited with double quotes
!!         ! A string has to have at least one character as for -A
!!         ! lists of numbers should be comma-delimited.
!!         ! No spaces are allowed in lists of numbers
!!         call prototype_and_cmd_args_to_nlist('&
!!         & -l -v -h -LVH -x 0 -y 0.0 -z 0.0d0 -p 0,0 &
!!         & -A " " -B "Value B" -C 10,20,30 -c (-123,-456)',readme)
!!
!!         call get_args('x',x,'y',y,'z',z)
!!            something=sqrt(x**2+y**2+z**2)
!!            write (*,*)something,x,y,z
!!            if(size(unnamed) > 0)then
!!               write (*,'(a)')'files:'
!!               write (*,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
!!            endif
!!      end program demo_prototype_and_cmd_args_to_nlist
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine prototype_and_cmd_args_to_nlist(prototype,string)

! ident_4="@(#) M_CLI2 prototype_and_cmd_args_to_nlist create dictionary from prototype if not null and update from command line"

character(len=*),intent(in)           :: prototype
character(len=*),intent(in),optional  :: string
integer                               :: ibig
integer                               :: itrim
integer                               :: iused

   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:START'
   G_passed_in=prototype                            ! make global copy for printing
   ibig=longest_command_argument()                  ! bug in gfortran. len=0 should be fine
   ibig=max(ibig,1)
   IF(ALLOCATED(UNNAMED))DEALLOCATE(UNNAMED)
   ALLOCATE(CHARACTER(LEN=IBIG) :: UNNAMED(0))
   if(allocated(args))deallocate(args)
   allocate(character(len=ibig) :: args(0))

   G_remaining_option_allowed=.false.
   G_remaining_on=.false.
   G_remaining=''
   if(prototype /= '')then
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype

      ! if short keywords not used by user allow them for standard options

      call locate_key('h',iused)
      if(iused <= 0)then
         call update('help')
         call update('help:h','F')
      endif

      call locate_key('v',iused)
      if(iused <= 0)then
         call update('version')
         call update('version:v','F')
      endif

      call locate_key('V',iused)
      if(iused <= 0)then
         call update('verbose')
         call update('verbose:V','F')
      endif

      call locate_key('u',iused)
      if(iused <= 0)then
         call update('usage')
         call update('usage:u','F')
      endif

      present_in=.false.                            ! reset all values to false so everything gets written
   endif

   if(present(string))then                          ! instead of command line arguments use another prototype string
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL PROTOTYPE_TO_DICTIONARY:STRING=',STRING
      call prototype_to_dictionary(string)          ! build dictionary from prototype
   else
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:CALL CMD_ARGS_TO_DICTIONARY:CHECK=',.true.
      call cmd_args_to_dictionary()
   endif

   if( len(G_remaining) > 1)then                    ! if -- was in prototype then after -- on input return rest in this string
      itrim=len(G_remaining)
      if(G_remaining(itrim:itrim) == ' ')then       ! was adding a space at end as building it, but do not want to remove blanks
         G_remaining=G_remaining(:itrim-1)
      endif
      remaining=G_remaining
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_NLIST:NORMAL END'
end subroutine prototype_and_cmd_args_to_nlist
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine expand_response(name)
character(len=*),intent(in)  :: name
character(len=:),allocatable :: prototype
logical                      :: hold

   if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:START:NAME=',name

   call get_prototype(name,prototype)

   if(prototype /= '')then
      hold=G_append
      G_append=.false.
      if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:CALL PROTOTYPE_TO_DICTIONARY:PROTOTYPE=',prototype
      call prototype_to_dictionary(prototype)       ! build dictionary from prototype
      G_append=hold
   endif

   if(G_DEBUG)write(*,gen)'<DEBUG>EXPAND_RESPONSE:END'

end subroutine expand_response
!===================================================================================================================================
subroutine get_prototype(name,prototype) ! process @name abbreviations
character(len=*),intent(in) :: name
character(len=:),allocatable,intent(out) :: prototype
character(len=:),allocatable             :: filename
character(len=:),allocatable             :: os
character(len=:),allocatable             :: plain_name
character(len=:),allocatable             :: search_for
integer                                  :: lun
integer                                  :: ios
integer                                  :: itrim
character(len=4096)                      :: line !x! assuming input never this long
character(len=256)                       :: message
character(len=:),allocatable             :: array(:) ! output array of tokens
integer                                  :: lines_processed

   G_RESPONSE_PREFIX=get_env('CLI_RESPONSE_PREFIX','@')
   lines_processed=0
   plain_name=name//'  '
   plain_name=trim(name(len(G_RESPONSE_PREFIX)+1:))
   os= G_RESPONSE_PREFIX // get_env('OSTYPE',get_env('OS'))
   if(G_DEBUG)write(*,gen)'<DEBUG>GET_PROTOTYPE:OS=',OS

   search_for=''
   ! look for NAME.rsp and see if there is an @OS  section in it and position to it and read
   if(os /= G_RESPONSE_PREFIX)then
      search_for=os
      call find_and_read_response_file(plain_name)
      if(lines_processed /= 0)return
   endif

   ! look for NAME.rsp and see if there is anything before an OS-specific section
   search_for=''
   call find_and_read_response_file(plain_name)
   if(lines_processed /= 0)return

   ! look for ARG0.rsp  with @OS@NAME  section in it and position to it
   if(os /= G_RESPONSE_PREFIX)then
      search_for=os//name
      call find_and_read_response_file(basename(get_name(),keep_suffix=.false.))
      if(lines_processed /= 0)return
   endif

   ! look for ARG0.rsp  with a section called @NAME in it and position to it
   search_for=name
   call find_and_read_response_file(basename(get_name(),keep_suffix=.false.))
   if(lines_processed /= 0)return

   if(.not.CLI_AUTO_QUIET)then
      write(*,gen)'<ERROR> response name ['//trim(name)//'] not found'
      stop 1
   endif
contains
!===================================================================================================================================
subroutine find_and_read_response_file(rname)
! search for a simple file named the same as the @NAME field with one entry assumed in it
character(len=*),intent(in)  :: rname
character(len=:),allocatable :: paths(:)
character(len=:),allocatable :: testpath
character(len=256)           :: message
integer                      :: i
integer                      :: ios
   prototype=''
   ! look for NAME.rsp
   ! assume if have / or \ a full filename was supplied to support ifort(1)
   if((index(rname,'/') /= 0.or.index(rname,'\') /= 0) .and. len(rname) > 1 )then
      filename=rname
      lun=fileopen(filename,message)
      if(lun /= -1)then
         call process_response()
         close(unit=lun,iostat=ios)
      endif
      return
   else
      filename=rname//'.rsp'
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:FILENAME=',filename

   ! look for name.rsp in directories from environment variable assumed to be a colon-separated list of directories
   call split(get_env('CLI_RESPONSE_PATH',join_path(get_env('HOME'),'/.local/share/rsp')),paths)
   paths=[character(len=len(paths)) :: ' ',paths]
   if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:PATHS=',paths

   do i=1,size(paths)
      testpath=join_path(paths(i),filename)
      lun=fileopen(testpath,message)
      if(lun /= -1)then
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:SEARCH_FOR=',search_for
         if(search_for /= '') call position_response() ! set to end of file or where string was found
         call process_response()
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:LINES_PROCESSED=',LINES_PROCESSED
         close(unit=lun,iostat=ios)
         if(G_DEBUG)write(*,gen)'<DEBUG>FIND_AND_READ_RESPONSE_FILE:CLOSE:LUN=',LUN,' IOSTAT=',IOS
         if(lines_processed /= 0)exit
      endif
   enddo

end subroutine find_and_read_response_file
!===================================================================================================================================
subroutine position_response()
integer :: ios
   line=''
   INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         if(G_DEBUG)write(*,gen)'<DEBUG>POSITION_RESPONSE:EOF'
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios /= 0)then
         write(*,gen)'<ERROR>*position_response*:'//trim(message)
         exit INFINITE
      endif
      line=adjustl(line)
      if(line == search_for)return
   enddo INFINITE
end subroutine position_response
!===================================================================================================================================
subroutine process_response()
character(len=:),allocatable :: padded
character(len=:),allocatable :: temp
   G_RESPONSE_PREFIX=get_env('CLI_RESPONSE_PREFIX','@')
   line=''
   lines_processed=0
   INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios /= 0)then
         write(*,gen)'<ERROR>*process_response*:'//trim(message)
         exit INFINITE
      endif
      line=clipends(line)
      temp=line
      if(index(temp//' ','#') == 1)cycle
      if(temp /= '')then

         if(index(temp,G_RESPONSE_PREFIX) == 1.and.lines_processed /= 0)exit INFINITE

         call split(temp,array) ! get first word
         itrim=len_trim(array(1))+2
         temp=temp(itrim:)

         PROCESS: select case(lower(array(1)))
         case('comment','#','')
         case('system','!','$')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            call execute_command_line(temp)
         case('options','option','-')
            lines_processed= lines_processed+1
            prototype=prototype//' '//trim(temp)
         case('print','>','echo')
            if(G_options_only)exit PROCESS
            lines_processed= lines_processed+1
            write(*,'(a)')trim(temp)
         case('stop')
            if(G_options_only)exit PROCESS
            write(*,'(a)')trim(temp)
            stop
         case default
            if(array(1)(1:1) == '-')then
               ! assume these are simply options to support ifort(1)
               ! if starts with a single dash must assume a single argument
               ! and rest is value to support -Dname and -Ifile option
               ! which currently is not supported, so multiple short keywords
               ! does not work. Just a ifort(1) test at this point, so do not document
               if(G_options_only)exit PROCESS
               padded=trim(line)//'  '
               if(padded(2:2) == '-')then
                  prototype=prototype//' '//trim(line)
               else
                  prototype=prototype//' '//padded(1:2)//' '//trim(padded(3:))
               endif
               lines_processed= lines_processed+1
            else
               if(array(1)(1:len(G_RESPONSE_PREFIX)) == G_RESPONSE_PREFIX)cycle INFINITE !skip adjacent @ lines from first
               lines_processed= lines_processed+1
               write(*,'(*(g0))')'unknown response keyword [',array(1),'] with options of [',trim(temp),']'
            endif
         end select PROCESS

      endif
   enddo INFINITE
end subroutine process_response
!===================================================================================================================================
subroutine show_response_file(quiet)  ! copy response file to stdout
logical,intent(in),optional :: quiet
logical                     :: quiet_local
   if(present(quiet))then
      quiet_local=quiet
   else
      quiet_local=.false.
   endif
   G_RESPONSE_PREFIX=get_env('CLI_RESPONSE_PREFIX','@')
   line=''
   INFINITE: do
      read(unit=lun,fmt='(a)',iostat=ios,iomsg=message)line
      if(is_iostat_end(ios))then
         backspace(lun,iostat=ios)
         exit INFINITE
      elseif(ios /= 0)then
         if(quiet_local)then
            write(*,gen)'<ERROR>*show_response_file*:'//trim(message)
         endif
         exit INFINITE
      endif
      line=clipends(line)
      if(index(line//' ','#') == 1)cycle
      if(line == '' )cycle
      if(index(line,G_RESPONSE_PREFIX) == 1)then
         PROCESS: select case(lower(array(1)))
         case('comment','#','')
         case('system','!','$')
         case('options','option','-')
         case('print','>','echo')
         case('stop')
         case default
         end select PROCESS
         write(*,*)trim(line)
      endif
   enddo INFINITE
end subroutine show_response_file
!===================================================================================================================================
end subroutine get_prototype
!===================================================================================================================================
function fileopen(filename,message) result(lun)
character(len=*),intent(in)              :: filename
character(len=*),intent(out),optional    :: message
integer                                  :: lun
integer                                  :: ios
character(len=256)                       :: message_local

   ios=0
   message_local=''
   open(file=filename,newunit=lun,&
    & form='formatted',access='sequential',action='read',&
    & position='rewind',status='old',iostat=ios,iomsg=message_local)

   if(ios /= 0)then
      lun=-1
      if(present(message))then
         message=trim(message_local)
      else
         write(*,gen)trim(message_local)
      endif
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>FILEOPEN:FILENAME=',filename,' LUN=',lun,' IOS=',IOS,' MESSAGE=',trim(message_local)

end function fileopen
!===================================================================================================================================
function get_env(NAME,DEFAULT) result(VALUE)
character(len=*),intent(in)          :: NAME
character(len=*),intent(in),optional :: DEFAULT
character(len=:),allocatable         :: VALUE
integer                              :: howbig
integer                              :: stat
integer                              :: length
   ! get length required to hold value
   length=0
   if(NAME /= '')then
      call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
          !x!print *, NAME, " is not defined in the environment. Strange..."
          VALUE=''
      case (2)
          !x!print *, "This processor doesn't support environment variables. Boooh!"
          VALUE=''
      case default
          ! make string to hold value of sufficient size
          if(allocated(value))deallocate(value)
          allocate(character(len=max(howbig,1)) :: VALUE)
          ! get value
         call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)
          if(stat /= 0)VALUE=''
      end select
   else
      VALUE=''
   endif
   if(VALUE == ''.and.present(DEFAULT))VALUE=DEFAULT
end function get_env
!===================================================================================================================================
function join_path(a1,a2,a3,a4,a5) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1 /= '')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   path=adjustl(path//'   ')
   ! clean up duplicate adjacent separators
   path=path(1:2)//replace_str(path(3:),filesep//filesep,filesep) ! some systems allow filepath starting with // or \\
   path=trim(path)
end function join_path
!===================================================================================================================================
function get_name() result(name)
! get the pathname of arg0
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: istat
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=istat)
   if(istat == 0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=istat)
      if(istat == 0)then
         inquire(file=arg0,iostat=istat,name=long_name)
         name=trim(long_name)
      else
         name=arg0
      endif
   endif
end function get_name
!===================================================================================================================================
function basename(path,keep_suffix) result (base)
    ! Extract filename from path with/without keep_suffix
    !
character(*), intent(In) :: path
logical, intent(in), optional :: keep_suffix
character(:), allocatable :: base

character(:), allocatable :: file_parts(:)
logical :: return_with_suffix
integer :: iend

   if (.not.present(keep_suffix)) then
      return_with_suffix = .true.
   else
      return_with_suffix = keep_suffix
   endif

   call split(path,file_parts,delimiters='\/')
   if(size(file_parts) > 0)then
      base = trim(file_parts(size(file_parts)))
   else
      base = ''
   endif
   if(.not.return_with_suffix)then
      iend=index(base,'.',back=.true.)
      if(iend.gt.1)then
         base=base(:iend-1)
      endif
   endif
end function basename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!! !>
!!##NAME
!!     separator(3f) - [M_io:ENVIRONMENT] try to determine pathname directory
!!     separator character
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!     function separator() result(sep)
!!
!!      character(len=1) :: sep
!!
!!##DESCRIPTION
!!    First testing for the existence of "/.",  then if that fails a list
!!    of variable names assumed to contain directory paths {PATH|HOME} are
!!    examined first for a backslash, then a slash. Assuming basically the
!!    choice is a ULS or MSWindows system, and users can do weird things like
!!    put a backslash in a ULS path and break it.
!!
!!    Therefore can be very system dependent. If the queries fail the
!!    default returned is "/".
!!
!!##EXAMPLES
!!
!!
!!    sample usage
!!
!!     program demo_separator
!!     use M_io, only : separator
!!     implicit none
!!        write(*,*)'separator=',separator()
!!     end program demo_separator
!===================================================================================================================================
function separator() result(sep)
! use the pathname returned as arg0 to determine pathname separator
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!x!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !x!FORT BUG:if(sep_cache /= ' ')then  ! use cached value.
    !x!FORT BUG:    sep=sep_cache
    !x!FORT BUG:    return
    !x!FORT BUG:endif
    if(isep /= -1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios == 0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\') /= 0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/') /= 0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !x!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine cmd_args_to_dictionary()
! convert command line arguments to dictionary entries
!x!logical                      :: guess_if_value
integer                      :: pointer
character(len=:),allocatable :: lastkeyword
integer                      :: i, jj, kk
integer                      :: ilength, istatus, imax
character(len=1)             :: letter
character(len=:),allocatable :: current_argument
character(len=:),allocatable :: current_argument_padded
character(len=:),allocatable :: dummy
character(len=:),allocatable :: oldvalue
logical                      :: nomore
logical                      :: next_mandatory
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START'
   G_RESPONSE_PREFIX=get_env('CLI_RESPONSE_PREFIX','@')
   next_mandatory=.false.
   nomore=.false.
   pointer=0
   lastkeyword=' '
   G_keyword_single_letter=.true.
   if(CLI_AUTO_RESPONSE_FILE)then
      i=0  ! cause get_next_argument to return a response macro name
   else
      i=1
   endif
   current_argument=''
   GET_ARGS: do while (get_next_argument()) ! insert and replace entries
      if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:WHILE:CURRENT_ARGUMENT=',current_argument

      if( current_argument  ==  '-' .and. nomore .eqv. .true. )then   ! sort of
      elseif( current_argument  ==  '-')then                          ! sort of
         current_argument='"stdin"'
      endif
      if( current_argument  ==  '--' .and. nomore .eqv. .true. )then  ! -- was already encountered
      elseif( current_argument  ==  '--' )then                        ! everything after this goes into the unnamed array
         nomore=.true.
         pointer=0
         if(G_remaining_option_allowed)then
            G_remaining_on=.true.
         endif
         cycle GET_ARGS
      endif

      dummy=current_argument//'   '
      current_argument_padded=current_argument//'   '

      if(.not.next_mandatory.and..not.nomore.and.current_argument_padded(1:2) == '--')then    ! beginning of long word
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START_LONG:'
         G_keyword_single_letter=.false.
         if(lastkeyword /= '')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(3:),pointer)
         if(pointer <= 0)then
            if(G_QUIET)then
               lastkeyword="UNKNOWN"
               pointer=0
               cycle GET_ARGS
            endif
            call print_dictionary('UNKNOWN LONG KEYWORD: '//current_argument)
            call mystop(1)
            return
         endif
         lastkeyword=trim(current_argument_padded(3:))
         next_mandatory=mandatory(pointer)
      elseif(.not.next_mandatory &
      & .and..not.nomore &
      & .and.current_argument_padded(1:1) == '-' &
      & .and.index("0123456789.",dummy(2:2)) == 0)then
      ! short word
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:START_SHORT'
         G_keyword_single_letter=.true.
         if(lastkeyword /= '')then
            call ifnull()
         endif
         call locate_key(current_argument_padded(2:),pointer)
         jj=len(current_argument)
         if( (pointer <= 0.or.jj.ge.3).and.(G_STRICT) )then  ! name not found
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT NOT FOUND:',current_argument_padded(2:)
            ! in strict mode this might be multiple single-character values
            do kk=2,jj
               letter=current_argument_padded(kk:kk)
               call locate_key(letter,pointer)
               if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:LETTER:',letter,pointer
               if(pointer > 0)then
                  call update(keywords(pointer),'T')
               else
                  if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNKNOWN SHORT:',letter
                  call print_dictionary('UNKNOWN SHORT KEYWORD:'//letter) ! //' in '//current_argument)
                  if(G_QUIET)then
                     lastkeyword="UNKNOWN"
                     pointer=0
                     cycle GET_ARGS
                  endif
                  call mystop(2)
                  return
               endif
               current_argument='-'//current_argument_padded(jj:jj)
            enddo
            !--------------
            lastkeyword=""
            pointer=0
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT_END:2:'
            cycle GET_ARGS
            !--------------
         elseif(pointer<0)then
            if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNKNOWN SHORT_CONFIRMED:',letter
            call print_dictionary('UNKNOWN SHORT KEYWORD:'//current_argument_padded(2:))
            if(G_QUIET)then
               lastkeyword="UNKNOWN"
               pointer=0
               cycle GET_ARGS
            endif
            call mystop(2)
            return
         endif
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:SHORT_END:1:'
         lastkeyword=trim(current_argument_padded(2:))
         next_mandatory=mandatory(pointer)
      elseif(pointer == 0)then                                       ! unnamed arguments
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:UNNAMED ARGUMENT:',current_argument
         if(G_remaining_on)then
            if(len(current_argument) < 1)then
               G_remaining=G_remaining//'"" '
            elseif(current_argument(1:1) == '-')then
               !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
               G_remaining=G_remaining//'"'//current_argument//'" '
            else
               G_remaining=G_remaining//'"'//current_argument//'" '
            endif
            imax=max(len(args),len(current_argument))
            args=[character(len=imax) :: args,current_argument]
         else
            imax=max(len(unnamed),len(current_argument))
            if(scan(current_argument//' ',G_RESPONSE_PREFIX) == 1.and.G_response)then
               if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:1:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
               call expand_response(current_argument)
            else
               unnamed=[character(len=imax) :: unnamed,current_argument]
            endif
         endif
      else
         if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:FOUND:',current_argument
         oldvalue=get(keywords(pointer))//' '
         if(oldvalue(1:1) == '"')then
            current_argument=quote(current_argument(:ilength))
         endif
         if(upper(oldvalue) == 'F'.or.upper(oldvalue) == 'T')then  ! assume boolean parameter
            if(current_argument /= ' ')then
               if(G_remaining_on)then
                  if(len(current_argument) < 1)then
                        G_remaining=G_remaining//'"" '
                  elseif(current_argument(1:1) == '-')then
                       !get fancier to handle spaces and =!G_remaining=G_remaining//current_argument//' '
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  else
                        G_remaining=G_remaining//'"'//current_argument//'" '
                  endif
                  imax=max(len(args),len(current_argument))
                  args=[character(len=imax) :: args,current_argument]
               else
                  imax=max(len(unnamed),len(current_argument))
                  if(scan(current_argument//' ',G_RESPONSE_PREFIX) == 1.and.G_response)then
                    if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:2:CALL EXPAND_RESPONSE:CURRENT_ARGUMENT=',current_argument
                    call expand_response(current_argument)
                  else
                    unnamed=[character(len=imax) :: unnamed,current_argument]
                  endif
               endif
            endif
            current_argument='T'
         endif
         call update(keywords(pointer),current_argument)
         pointer=0
         lastkeyword=''
         next_mandatory=.false.
      endif
      if(CLI_AUTO_QUIET)CLI_AUTO_QUIET=.false.
   enddo GET_ARGS
   if(lastkeyword /= '')then
      call ifnull()
   endif
   if(G_DEBUG)write(*,gen)'<DEBUG>CMD_ARGS_TO_DICTIONARY:NORMAL END'

contains

subroutine ifnull()

   oldvalue=clipends(get(lastkeyword))//' '

   if(upper(oldvalue(1:1)) == 'F'.or.upper(oldvalue(1:1)) == 'T')then
      call update(lastkeyword,'T')
      !call update(lastkeyword,upper(oldvalue(1:1)))
   elseif(oldvalue(1:1) == '"')then
      call update(lastkeyword,'" "')
   else
      call update(lastkeyword,' ')
   endif

end subroutine ifnull

function get_next_argument()
!
! get next argument from command line into allocated variable current_argument
!
logical,save :: hadequal=.false.
character(len=:),allocatable,save :: right_hand_side
logical :: get_next_argument
integer :: iright
integer :: iequal

   if(hadequal)then  ! use left-over value from previous -NAME=VALUE syntax
      current_argument=right_hand_side
      right_hand_side=''
      hadequal=.false.
      get_next_argument=.true.
      ilength=len(current_argument)
      return
   endif

   if(i == 0)then ! auto_response_file is true and first call to here
      get_next_argument=.true.
      current_argument=G_RESPONSE_PREFIX//basename(get_name(),keep_suffix=.false.)
      i=i+1
      return
   endif

   if(i>command_argument_count())then
      get_next_argument=.false.
      return
   else
      get_next_argument=.true.
   endif

   call get_command_argument(number=i,length=ilength,status=istatus)                              ! get next argument
   if(istatus /= 0) then                                                                          ! on error
      write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
         &'status=',istatus,&
         &'length=',ilength
      get_next_argument=.false.
   else
      ilength=max(ilength,1)
      if(allocated(current_argument))deallocate(current_argument)
      allocate(character(len=ilength) :: current_argument)
      call get_command_argument(number=i,value=current_argument,length=ilength,status=istatus)    ! get next argument
      if(istatus /= 0) then                                                                       ! on error
         write(warn,*)'*prototype_and_cmd_args_to_nlist* error obtaining argument ',i,&
            &'status=',istatus,&
            &'length=',ilength,&
            &'target length=',len(current_argument)
         get_next_argument=.false.
       endif

       ! if an argument keyword and an equal before a space split on equal and save right hand side for next call
       if(nomore)then
       elseif( len(current_argument) == 0)then
       else
          iright=index(current_argument,' ')
          if(iright == 0)iright=len(current_argument)
          iequal=index(current_argument(:iright),'=')
          if(next_mandatory)then
          elseif(iequal /= 0.and.current_argument(1:1) == '-')then
             if(iequal /= len(current_argument))then
                right_hand_side=current_argument(iequal+1:)
             else
                right_hand_side=''
             endif
             hadequal=.true.
             current_argument=current_argument(:iequal-1)
          endif
       endif
   endif
   i=i+1
end function get_next_argument

end subroutine cmd_args_to_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    print_dictionary(3f) - [ARGUMENTS:M_CLI2] print internal dictionary
!!    created by calls to set_args(3f)
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!     subroutine print_dictionary(header,stop)
!!
!!      character(len=*),intent(in),optional :: header
!!      logical,intent(in),optional          :: stop
!!##DESCRIPTION
!!    Print the internal dictionary created by calls to set_args(3f).
!!    This routine is intended to print the state of the argument list
!!    if an error occurs in using the set_args(3f) procedure.
!!##OPTIONS
!!     HEADER  label to print before printing the state of the command
!!             argument list.
!!     STOP    logical value that if true stops the program after displaying
!!             the dictionary.
!!##EXAMPLES
!!
!!
!!
!! Typical usage:
!!
!!       program demo_print_dictionary
!!       use M_CLI2,  only : set_args, get_args
!!       implicit none
!!       real :: x, y, z
!!          call set_args('-x 10 -y 20 -z 30')
!!          call get_args('x',x,'y',y,'z',z)
!!          ! all done cracking the command line; use the values in your program.
!!          write(*,*)x,y,z
!!       end program demo_print_dictionary
!!
!!      Sample output
!!
!!      Calling the sample program with an unknown parameter or the --usage
!!      switch produces the following:
!!
!!         $ ./demo_print_dictionary -A
!!         UNKNOWN SHORT KEYWORD: -A
!!         KEYWORD             PRESENT  VALUE
!!         z                   F        [3]
!!         y                   F        [2]
!!         x                   F        [1]
!!         help                F        [F]
!!         version             F        [F]
!!         usage               F        [F]
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine print_dictionary(header,stop)
character(len=*),intent(in),optional :: header
logical,intent(in),optional          :: stop
integer          :: i
   if(G_QUIET)return
   if(present(header))then
      if(header /= '')then
         write(warn,'(a)')header
      endif
   endif
   if(allocated(keywords))then
      if(size(keywords) > 0)then
         write(warn,'(a,1x,a,1x,a,1x,a)')atleast('KEYWORD',max(len(keywords),8)),'SHORT','PRESENT','VALUE'
         write(warn,'(*(a,1x,a5,1x,l1,8x,"[",a,"]",/))') &
         & (atleast(keywords(i),max(len(keywords),8)),shorts(i),present_in(i),values(i)(:counts(i)),i=size(keywords),1,-1)
      endif
   endif
   if(allocated(unnamed))then
      if(size(unnamed) > 0)then
         write(warn,'(a)')'UNNAMED'
         write(warn,'(i6.6,3a)')(i,'[',unnamed(i),']',i=1,size(unnamed))
      endif
   endif
   if(allocated(args))then
      if(size(args) > 0)then
         write(warn,'(a)')'ARGS'
         write(warn,'(i6.6,3a)')(i,'[',args(i),']',i=1,size(args))
      endif
   endif
   if(G_remaining /= '')then
      write(warn,'(a)')'REMAINING'
      write(warn,'(a)')G_remaining
   endif
   if(present(stop))then
      if(stop) call mystop(5)
   endif
end subroutine print_dictionary
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    get_args(3f) - [ARGUMENTS:M_CLI2] return keyword values when parsing
!!    command line arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   get_args(3f) and its convenience functions:
!!
!!     use M_CLI2, only : get_args
!!     ! convenience functions
!!     use M_CLI2, only : dget, iget, lget, rget, sget, cget
!!     use M_CLI2, only : dgets, igets, lgets, rgets, sgets, cgets
!!
!!     subroutine get_args(name,value,delimiters)
!!
!!      character(len=*),intent(in) :: name
!!
!!      type(${TYPE}),allocatable,intent(out) :: value(:)
!!      ! or
!!      type(${TYPE}),allocatable,intent(out) :: value
!!
!!      character(len=*),intent(in),optional :: delimiters
!!
!!      where ${TYPE} may be from the set
!!              {real,doubleprecision,integer,logical,complex,character(len=:)}
!!##DESCRIPTION
!!
!!    GET_ARGS(3f) returns the value of keywords after SET_ARGS(3f) has
!!    been called to parse the command line. For fixed-length CHARACTER
!!    variables see GET_ARGS_FIXED_LENGTH(3f). For fixed-size arrays see
!!    GET_ARGS_FIXED_SIZE(3f).
!!
!!    As a convenience multiple pairs of keywords and variables may be
!!    specified if and only if all the values are scalars and the CHARACTER
!!    variables are fixed-length or pre-allocated.
!!
!!##OPTIONS
!!
!!     NAME        name of commandline argument to obtain the value of
!!     VALUE       variable to hold returned value. The kind of the value
!!                 is used to determine the type of returned value. May
!!                 be a scalar or allocatable array. If type is CHARACTER
!!                 the scalar must have an allocatable length.
!!     DELIMITERS  By default the delimiter for array values are comma,
!!                 colon, and whitespace. A string containing an alternate
!!                 list of delimiter characters may be supplied.
!!
!!##CONVENIENCE FUNCTIONS
!!    There are convenience functions that are replacements for calls to
!!    get_args(3f) for each supported default intrinsic type
!!
!!      o scalars -- dget(3f), iget(3f), lget(3f), rget(3f), sget(3f),
!!                   cget(3f)
!!      o vectors -- dgets(3f), igets(3f), lgets(3f), rgets(3f),
!!                   sgets(3f), cgets(3f)
!!
!!    D is for DOUBLEPRECISION, I for INTEGER, L for LOGICAL, R for REAL,
!!    S for string (CHARACTER), and C for COMPLEX.
!!
!!    If the functions are called with no argument they will return the
!!    UNNAMED array converted to the specified type.
!!
!!##EXAMPLES
!!
!!
!! Sample program:
!!
!!     program demo_get_args
!!     use M_CLI2,  only : filenames=>unnamed, set_args, get_args
!!     implicit none
!!     integer                      :: i
!!      ! Define ARGS
!!     real                         :: x, y, z
!!     real,allocatable             :: p(:)
!!     character(len=:),allocatable :: title
!!     logical                      :: l, lbig
!!      ! Define and parse (to set initial values) command line
!!      !   o only quote strings and use double-quotes
!!      !   o set all logical values to F or T.
!!     call set_args('         &
!!        & -x 1 -y 2 -z 3     &
!!        & -p -1,-2,-3        &
!!        & --title "my title" &
!!        & -l F -L F          &
!!        & --label " "        &
!!        & ')
!!      ! Assign values to elements
!!      ! Scalars
!!     call get_args( 'x',x, 'y',y, 'z',z, 'l',l, 'L',lbig )
!!      ! Allocatable string
!!     call get_args('title',title)
!!      ! Allocatable arrays
!!     call get_args('p',p)
!!      ! Use values
!!     write(*,'(1x,g0,"=",g0)')'x',x, 'y',y, 'z',z
!!     write(*,*)'p=',p
!!     write(*,*)'title=',title
!!     write(*,*)'l=',l
!!     write(*,*)'L=',lbig
!!     if(size(filenames) > 0)then
!!        write(*,'(i6.6,3a)')(i,'[',filenames(i),']',i=1,size(filenames))
!!     endif
!!     end program demo_get_args
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_length(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-length string when parsing command line
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_length(name,value)
!!
!!     character(len=*),intent(in)  :: name
!!     character(len=:),allocatable :: value
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    get_args_fixed_length(3f) returns the value of a string
!!    keyword when the string value is a fixed-length CHARACTER
!!    variable.
!!
!!##OPTIONS
!!
!!    NAME   name of commandline argument to obtain the value of
!!
!!    VALUE  variable to hold returned value.
!!           Must be a fixed-length CHARACTER variable.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_length
!!     use M_CLI2,  only : set_args, get_args_fixed_length
!!     implicit none
!!
!!      ! Define args
!!     character(len=80)   :: title
!!      ! Parse command line
!!     call set_args(' --title "my title" ')
!!      ! Assign values to variables
!!     call get_args_fixed_length('title',title)
!!      ! Use values
!!     write(*,*)'title=',title
!!
!!     end program demo_get_args_fixed_length
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
!>
!!##NAME
!!    get_args_fixed_size(3f) - [ARGUMENTS:M_CLI2] return keyword values
!!    for fixed-size array when parsing command line arguments
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine get_args_fixed_size(name,value)
!!
!!     character(len=*),intent(in) :: name
!!     [real|doubleprecision|integer|logical|complex] :: value(NNN)
!!        or
!!     character(len=MMM) :: value(NNN)
!!
!!     character(len=*),intent(in),optional :: delimiters
!!
!!##DESCRIPTION
!!
!!    get_args_fixed_size(3f) returns the value of keywords for fixed-size
!!    arrays after set_args(3f) has been called. On input on the command
!!    line all values of the array must be specified.
!!
!!##OPTIONS
!!    NAME        name of commandline argument to obtain the value of
!!
!!    VALUE       variable to hold returned values. The kind of the value
!!                is used to determine the type of returned value. Must be
!!                a fixed-size array. If type is CHARACTER the length must
!!                also be fixed.
!!
!!    DELIMITERS  By default the delimiter for array values are comma,
!!                colon, and whitespace. A string containing an alternate
!!                list of delimiter characters may be supplied.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_get_args_fixed_size
!!     use M_CLI2,  only : set_args, get_args_fixed_size
!!     implicit none
!!     integer,parameter   :: dp=kind(0.0d0)
!!     ! DEFINE ARGS
!!     real                :: x(2)
!!     real(kind=dp)       :: y(2)
!!     integer             :: p(3)
!!     character(len=80)   :: title(1)
!!     logical             :: l(4), lbig(4)
!!     complex             :: cmp(2)
!!     ! DEFINE AND PARSE (TO SET INITIAL VALUES) COMMAND LINE
!!     !   o only quote strings
!!     !   o set all logical values to F or T.
!!     call set_args(' &
!!        & -x 10.0,20.0 &
!!        & -y 11.0,22.0 &
!!        & -p -1,-2,-3 &
!!        & --title "my title" &
!!        & -l F,T,F,T -L T,F,T,F  &
!!        & --cmp 111,222.0,333.0e0,4444 &
!!        & ')
!!     ! ASSIGN VALUES TO ELEMENTS
!!        call get_args_fixed_size('x',x)
!!        call get_args_fixed_size('y',y)
!!        call get_args_fixed_size('p',p)
!!        call get_args_fixed_size('title',title)
!!        call get_args_fixed_size('l',l)
!!        call get_args_fixed_size('L',lbig)
!!        call get_args_fixed_size('cmp',cmp)
!!     ! USE VALUES
!!        write(*,*)'x=',x
!!        write(*,*)'p=',p
!!        write(*,*)'title=',title
!!        write(*,*)'l=',l
!!        write(*,*)'L=',lbig
!!        write(*,*)'cmp=',cmp
!!     end program demo_get_args_fixed_size
!!   Results:
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
subroutine get_fixedarray_class(keyword,generic,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
class(*)                             :: generic(:)
character(len=*),intent(in),optional :: delimiters
   select type(generic)
    type is (character(len=*));  call get_fixedarray_fixed_length_c(keyword,generic,delimiters)
    type is (integer);           call get_fixedarray_i(keyword,generic,delimiters)
    type is (real);              call get_fixedarray_r(keyword,generic,delimiters)
    type is (complex);           call get_fixed_size_complex(keyword,generic,delimiters)
    type is (real(kind=dp));     call get_fixedarray_d(keyword,generic,delimiters)
    type is (logical);           call get_fixedarray_l(keyword,generic,delimiters)
    class default
      call mystop(-7,'*get_fixedarray_class* crud -- procedure does not know about this type')
   end select
end subroutine get_fixedarray_class
!===================================================================================================================================
! return allocatable arrays
!===================================================================================================================================
subroutine get_anyarray_l(keyword,larray,delimiters)

! ident_5="@(#) M_CLI2 get_anyarray_l(3f) given keyword fetch logical array from string in dictionary(F on err)"

character(len=*),intent(in)  :: keyword                    ! the dictionary keyword (in form VERB_KEYWORD) to retrieve
logical,allocatable          :: larray(:)                  ! convert value to an array
character(len=*),intent(in),optional   :: delimiters
character(len=:),allocatable :: carray(:)                  ! convert value to an array
character(len=:),allocatable :: val
integer                      :: i
integer                      :: place
integer                      :: iichar                     ! point to first character of word unless first character is "."
   call locate_key(keyword,place)                          ! find where string is or should be
   if(place > 0)then                                      ! if string was found
      val=values(place)(:counts(place))
      call split(adjustl(upper(val)),carray,delimiters=delimiters)  ! convert value to uppercase, trimmed; then parse into array
   else
      call journal('*get_anyarray_l* unknown keyword',keyword)
      call mystop(8 ,'*get_anyarray_l* unknown keyword '//keyword)
      if(allocated(larray))deallocate(larray)
      allocate(larray(0))
      return
   endif
   if(size(carray) > 0)then                                  ! if not a null string
      if(allocated(larray))deallocate(larray)
      allocate(larray(size(carray)))                          ! allocate output array
      do i=1,size(carray)
         larray(i)=.false.                                    ! initialize return value to .false.
         if(carray(i)(1:1) == '.')then                        ! looking for fortran logical syntax .STRING.
            iichar=2
         else
            iichar=1
         endif
         select case(carray(i)(iichar:iichar))             ! check word to see if true or false
         case('T','Y',' '); larray(i)=.true.               ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
         case('F','N');     larray(i)=.false.              ! assume this is false or no
         case default
            call journal("*get_anyarray_l* bad logical expression for ",(keyword),'=',carray(i))
         end select
      enddo
   else                                                       ! for a blank string return one T
      if(allocated(larray))deallocate(larray)
      allocate(larray(1))                                     ! allocate output array
      larray(1)=.true.
   endif
end subroutine get_anyarray_l
!===================================================================================================================================
subroutine get_anyarray_d(keyword,darray,delimiters)

! ident_6="@(#) M_CLI2 get_anyarray_d(3f) given keyword fetch dble value array from Language Dictionary (0 on err)"

character(len=*),intent(in)           :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp),allocatable,intent(out) :: darray(:)    ! function type
character(len=*),intent(in),optional  :: delimiters

character(len=:),allocatable          :: carray(:)    ! convert value to an array using split(3f)
integer                               :: i
integer                               :: place
integer                               :: ierr
character(len=:),allocatable          :: val
!-----------------------------------------------------------------------------------------------------------------------------------
   call locate_key(keyword,place)                    ! find where string is or should be
   if(place > 0)then                                 ! if string was found
      val=values(place)(:counts(place))
      val=replace_str(val,'(','')
      val=replace_str(val,')','')
      call split(val,carray,delimiters=delimiters)    ! find value associated with keyword and split it into an array
   else
      call journal('*get_anyarray_d* unknown keyword '//keyword)
      call mystop(9 ,'*get_anyarray_d* unknown keyword '//keyword)
      if(allocated(darray))deallocate(darray)
      allocate(darray(0))
      return
   endif
   if(allocated(darray))deallocate(darray)
   allocate(darray(size(carray)))                     ! create the output array
   do i=1,size(carray)
      call a2d(carray(i), darray(i),ierr) ! convert the string to a numeric value
      if(ierr /= 0)then
         call mystop(10 ,'*get_anyarray_d* unreadable value '//carray(i)//' for keyword '//keyword)
      endif
   enddo
end subroutine get_anyarray_d
!===================================================================================================================================
subroutine get_anyarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer,allocatable                  :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   iarray=nint(darray)
end subroutine get_anyarray_i
!===================================================================================================================================
subroutine get_anyarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real,allocatable                     :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
   call get_anyarray_d(keyword,darray,delimiters)
   rarray=real(darray)
end subroutine get_anyarray_r
!===================================================================================================================================
subroutine get_anyarray_x(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex(kind=sp),allocatable         :: xarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: half,sz,i
   call get_anyarray_d(keyword,darray,delimiters)
   sz=size(darray)
   half=sz/2
   if(sz /= half+half)then
      call journal('*get_anyarray_x* uneven number of values defining complex value '//keyword)
      call mystop(11,'*get_anyarray_x* uneven number of values defining complex value '//keyword)
      if(allocated(xarray))deallocate(xarray)
      allocate(xarray(0))
   endif

   !x!================================================================================================
   !x!IFORT,GFORTRAN OK, NVIDIA RETURNS NULL ARRAY: xarray=cmplx(real(darray(1::2)),real(darray(2::2)))
   if(allocated(xarray))deallocate(xarray)
   allocate(xarray(half))
   do i=1,sz,2
      xarray((i+1)/2)=cmplx( darray(i),darray(i+1),kind=sp )
   enddo
   !x!================================================================================================

end subroutine get_anyarray_x
!===================================================================================================================================
subroutine get_anyarray_c(keyword,strings,delimiters)

! ident_7="@(#) M_CLI2 get_anyarray_c(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=:),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
integer                              :: place
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings,delimiters=delimiters)   ! find value associated with keyword and split it into an array
   else
      call journal('*get_anyarray_c* unknown keyword '//keyword)
      call mystop(12,'*get_anyarray_c* unknown keyword '//keyword)
      if(allocated(strings))deallocate(strings)
      allocate(character(len=0)::strings(0))
   endif
end subroutine get_anyarray_c
!===================================================================================================================================
subroutine get_args_fixed_length_a_array(keyword,strings,delimiters)

! ident_8="@(#) M_CLI2 get_args_fixed_length_a_array(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)          :: keyword       ! name to look up in dictionary
character(len=*),allocatable         :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: strings_a(:)
integer                              :: place
character(len=:),allocatable         :: val
integer                              :: ibug
   call locate_key(keyword,place)                     ! find where string is or should be
   if(place > 0)then                                  ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,strings_a,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      if( len(strings_a) <= len(strings) )then
         strings=strings_a
      else
         ibug=len(strings)
         call journal('*get_args_fixed_length_a_array* values too long. Longest is',len(strings_a),'allowed is',ibug)
         write(*,'("strings=",3x,*(a,1x))')strings
         call journal('*get_args_fixed_length_a_array* keyword='//keyword)
         call mystop(13,'*get_args_fixed_length_a_array* keyword='//keyword)
         strings=[character(len=len(strings)) ::]
      endif
   else
      call journal('*get_args_fixed_length_a_array* unknown keyword '//keyword)
      call mystop(14,'*get_args_fixed_length_a_array* unknown keyword '//keyword)
      strings=[character(len=len(strings)) ::]
   endif
end subroutine get_args_fixed_length_a_array
!===================================================================================================================================
! return non-allocatable arrays
!===================================================================================================================================
subroutine get_fixedarray_i(keyword,iarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
integer                              :: iarray(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(iarray,dim=1) == dsize)then
      iarray=nint(darray)
   else
      ibug=size(iarray)
      call journal('*get_fixedarray_i* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(33)
      iarray=0
   endif
end subroutine get_fixedarray_i
!===================================================================================================================================
subroutine get_fixedarray_r(keyword,rarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real                                 :: rarray(:)
character(len=*),intent(in),optional :: delimiters
real,allocatable                     :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_r(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(rarray,dim=1) == dsize)then
      rarray=darray
   else
      ibug=size(rarray)
      call journal('*get_fixedarray_r* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(33)
      rarray=0.0
   endif
end subroutine get_fixedarray_r
!===================================================================================================================================
subroutine get_fixed_size_complex(keyword,xarray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
complex                              :: xarray(:)
character(len=*),intent(in),optional :: delimiters
complex,allocatable                  :: darray(:)    ! function type
integer                              :: half, sz
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_x(keyword,darray,delimiters)
   dsize=size(darray)
   sz=dsize*2
   half=sz/2
   if(sz /= half+half)then
      call journal('*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      call mystop(15,'*get_fixed_size_complex* uneven number of values defining complex value '//keyword)
      xarray=0
      return
   endif
   if(ubound(xarray,dim=1) == dsize)then
      xarray=darray
   else
      ibug=size(xarray)
      call journal('*get_fixed_size_complex* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(34)
      xarray=cmplx(0.0,0.0)
   endif
end subroutine get_fixed_size_complex
!===================================================================================================================================
subroutine get_fixedarray_d(keyword,darr,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                        :: darr(:)
character(len=*),intent(in),optional :: delimiters
real(kind=dp),allocatable            :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_d(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(darr,dim=1) == dsize)then
      darr=darray
   else
      ibug=size(darr)
      call journal('*get_fixedarray_d* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(35)
      darr=0.0d0
   endif
end subroutine get_fixedarray_d
!===================================================================================================================================
subroutine get_fixedarray_l(keyword,larray,delimiters)
character(len=*),intent(in)          :: keyword      ! keyword to retrieve value from dictionary
logical                              :: larray(:)
character(len=*),intent(in),optional :: delimiters
logical,allocatable                  :: darray(:)    ! function type
integer                              :: dsize
integer                              :: ibug
   call get_anyarray_l(keyword,darray,delimiters)
   dsize=size(darray)
   if(ubound(larray,dim=1) == dsize)then
      larray=darray
   else
      ibug=size(larray)
      call journal('*get_fixedarray_l* wrong number of values for keyword',keyword,'got',dsize,'expected',ibug)
      call print_dictionary_usage()
      call mystop(36)
      larray=.false.
   endif
end subroutine get_fixedarray_l
!===================================================================================================================================
subroutine get_fixedarray_fixed_length_c(keyword,strings,delimiters)

! ident_9="@(#) M_CLI2 get_fixedarray_fixed_length_c(3f) Fetch strings value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*)                     :: strings(:)
character(len=*),intent(in),optional :: delimiters
character(len=:),allocatable         :: str(:)
character(len=*),intent(in)          :: keyword   ! name to look up in dictionary
integer                              :: place
integer                              :: ssize
integer                              :: ibug
character(len=:),allocatable         :: val
   call locate_key(keyword,place)                 ! find where string is or should be
   if(place > 0)then                              ! if index is valid return strings
      val=unquote(values(place)(:counts(place)))
      call split(val,str,delimiters=delimiters)   ! find value associated with keyword and split it into an array
      ssize=size(str)
      if(ssize==size(strings))then
         strings(:ssize)=str
      else
         ibug=size(strings)
         call journal('*get_fixedarray_fixed_length_c* wrong number of values for keyword',&
            & keyword,'got',ssize,'expected ',ibug) !,ubound(strings,dim=1)
         call print_dictionary_usage()
         call mystop(30,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
         strings=''
      endif
   else
      call journal('*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      call mystop(16,'*get_fixedarray_fixed_length_c* unknown keyword '//keyword)
      strings=''
   endif
end subroutine get_fixedarray_fixed_length_c
!===================================================================================================================================
! return scalars
!===================================================================================================================================
subroutine get_scalar_d(keyword,d)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real(kind=dp)                 :: d
real(kind=dp),allocatable     :: darray(:)    ! function type
integer                       :: ibug
   call get_anyarray_d(keyword,darray)
   if(size(darray) == 1)then
      d=darray(1)
   else
      ibug=size(darray)
      call journal('*get_anyarray_d* incorrect number of values for keyword "',keyword,'" expected one found',ibug)
      call print_dictionary_usage()
      call mystop(31,'*get_anyarray_d* incorrect number of values for keyword "'//keyword//'" expected one')
   endif
end subroutine get_scalar_d
!===================================================================================================================================
subroutine get_scalar_real(keyword,r)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
real,intent(out)              :: r
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   r=real(d)
end subroutine get_scalar_real
!===================================================================================================================================
subroutine get_scalar_i(keyword,i)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
integer,intent(out)           :: i
real(kind=dp)                 :: d
   call get_scalar_d(keyword,d)
   i=nint(d)
end subroutine get_scalar_i
!===================================================================================================================================
subroutine get_scalar_anylength_c(keyword,string)

! ident_10="@(#) M_CLI2 get_scalar_anylength_c(3f) Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=:),allocatable,intent(out)  :: string
integer                       :: place
   call locate_key(keyword, place)                     ! find where string is or should be
   if (place > 0) then                                  ! if index is valid return string
      string = unquote(values(place) (:counts(place)))
   else
      call journal('*get_anyarray_c* unknown keyword '//keyword)
      call mystop(17, '*get_anyarray_c* unknown keyword '//keyword)
      string = ''
   endif
end subroutine get_scalar_anylength_c
!===================================================================================================================================
elemental impure subroutine get_args_fixed_length_scalar_c(keyword,string)

! ident_11="@(#) M_CLI2 get_args_fixed_length_scalar_c(3f) Fetch string value for specified KEYWORD from the lang. dictionary"

! This routine trusts that the desired keyword exists. A blank is returned if the keyword is not in the dictionary
character(len=*),intent(in)   :: keyword              ! name to look up in dictionary
character(len=*),intent(out)  :: string
integer                       :: place
integer                       :: unlen
integer                       :: ibug
   call locate_key(keyword, place)                     ! find where string is or should be

   if (place > 0) then                                  ! if index is valid return string
      string = unquote(values(place) (:counts(place)))
   else
      call mystop(18, '*get_args_fixed_length_scalar_c* unknown keyword '//keyword)
      string = ''
   endif

   unlen = len_trim(unquote(values(place) (:counts(place))))
   if (unlen > len(string)) then
      ibug = len(string)
      call journal('*get_args_fixed_length_scalar_c* value too long for', keyword, 'allowed is', ibug,&
      & 'input string [', values(place), '] is', unlen)
      call mystop(19, '*get_args_fixed_length_scalar_c* value too long')
      string = ''
   endif

end subroutine get_args_fixed_length_scalar_c
!===================================================================================================================================
subroutine get_scalar_complex(keyword,x)
character(len=*),intent(in) :: keyword      ! keyword to retrieve value from dictionary
complex,intent(out)         :: x
real(kind=dp)               :: d(2)

   call get_fixedarray_d(keyword,d)
   x=cmplx(d(1),d(2),kind=sp)

end subroutine get_scalar_complex
!===================================================================================================================================
subroutine get_scalar_logical(keyword,l)
character(len=*),intent(in)   :: keyword      ! keyword to retrieve value from dictionary
logical                       :: l
logical,allocatable           :: larray(:)    ! function type
integer                       :: ibug

   l = .false.

   call get_anyarray_l(keyword, larray)

   if (.not. allocated(larray)) then
      call journal('*get_scalar_logical* expected one value found not allocated')
      call mystop(37, '*get_scalar_logical* incorrect number of values for keyword "'//keyword//'"')
   elseif (size(larray) == 1) then
      l = larray(1)
   else
      ibug = size(larray)
      call journal('*get_scalar_logical* expected one value found', ibug)
      call mystop(21, '*get_scalar_logical* incorrect number of values for keyword "'//keyword//'"')
   endif

end subroutine get_scalar_logical
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! THE REMAINDER SHOULD BE ROUTINES EXTRACTED FROM OTHER MODULES TO MAKE THIS MODULE STANDALONE BY POPULAR REQUEST
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!use M_strings,                     only : UPPER, LOWER, QUOTE, REPLACE_STR=>REPLACE, UNQUOTE, SPLIT, STRING_TO_VALUE
!use M_list,                        only : insert, locate, remove, replace
!use M_journal,                     only : JOURNAL

!use M_args,                        only : LONGEST_COMMAND_ARGUMENT
! routines extracted from other modules
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    longest_command_argument(3f) - [ARGUMENTS:M_args] length of longest
!!    argument on command line
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function longest_command_argument() result(ilongest)
!!
!!     integer :: ilongest
!!
!!##DESCRIPTION
!!    length of longest argument on command line. Useful when allocating
!!    storage for holding arguments.
!!##RETURNS
!!    longest_command_argument  length of longest command argument
!!##EXAMPLES
!!
!! Sample program
!!
!!      program demo_longest_command_argument
!!      use M_args, only : longest_command_argument
!!         write(*,*)'longest argument is ',longest_command_argument()
!!      end program demo_longest_command_argument
!!##AUTHOR
!!    John S. Urban, 2019
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function longest_command_argument() result(ilongest)
integer :: i
integer :: ilength
integer :: istatus
integer :: ilongest

   ilength = 0
   ilongest = 0

   GET_LONGEST: do i = 1, command_argument_count()                          ! loop throughout command line arguments to find longest

      call get_command_argument(number=i, length=ilength, status=istatus)   ! get next argument

      if (istatus /= 0) then                                                ! on error
         write (warn, *) '*prototype_and_cmd_args_to_nlist* error obtaining length for argument ', i
         exit GET_LONGEST
      elseif (ilength > 0) then
         ilongest = max(ilongest, ilength)
      endif

   end do GET_LONGEST

end function longest_command_argument
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    journal(3f) - [M_CLI2] converts a list of standard scalar types to a string and writes message
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine journal(g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep,line)
!!
!!     class(*),intent(in),optional  :: g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     character(len=*),intent(in),optional :: sep
!!     character(len=:),intent(out),allocatable,optional :: line
!!
!!##DESCRIPTION
!!    journal(3f) builds and prints a space-separated string from up to twenty scalar values.
!!
!!##OPTIONS
!!    g[0-9a-j]   optional value to print the value of after the message. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!
!!    sep         separator to place between values. Defaults to a space.
!!    line        if present, the output is placed in the variable instead of
!!                being written
!!##RETURNS
!!    journal     description to print
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_journal
!!     use M_CLI2, only : journal
!!     implicit none
!!     character(len=:),allocatable :: frmt
!!     integer                      :: biggest
!!
!!     call journal('HUGE(3f) integers',huge(0),'and real',&
!!               & huge(0.0),'and double',huge(0.0d0))
!!     call journal('real            :',huge(0.0),0.0,12345.6789,tiny(0.0) )
!!     call journal('doubleprecision :',huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!     call journal('complex         :',cmplx(huge(0.0),tiny(0.0)) )
!!
!!     end program demo_journal
!!
!!  Output
!!
!!     HUGE(3f) integers 2147483647 and real 3.40282347E+38 and
!!     double 1.7976931348623157E+308
!!     real            : 3.40282347E+38 0.00000000 12345.6787 1.17549435E-38
!!     doubleprecision : 1.7976931348623157E+308 0.0000000000000000
!!     12345.678900000001 2.2250738585072014E-308
!!     complex         : (3.40282347E+38,1.17549435E-38)
!!      format=(*(i9:,1x))
!!      program will now stop
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine journal(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep,line)

! ident_12="@(#) M_CLI2 journal(3fp) writes a message to stdout or a string composed of any standard scalar types"

class(*),intent(in),optional         :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character(len=*),intent(in),optional :: sep
character(len=:),intent(out),allocatable,optional :: line
character(len=:),allocatable         :: sep_local
character(len=4096)                  :: local_line
integer                              :: istart
integer                              :: increment
   if(present(sep))then
      sep_local=sep
      increment=len(sep_local)+1
   else
      sep_local=' '
      increment=2
   endif

   istart=1
   local_line=''
   if(present(g0))call print_generic(g0)
   if(present(g1))call print_generic(g1)
   if(present(g2))call print_generic(g2)
   if(present(g3))call print_generic(g3)
   if(present(g4))call print_generic(g4)
   if(present(g5))call print_generic(g5)
   if(present(g6))call print_generic(g6)
   if(present(g7))call print_generic(g7)
   if(present(g8))call print_generic(g8)
   if(present(g9))call print_generic(g9)
   if(present(ga))call print_generic(ga)
   if(present(gb))call print_generic(gb)
   if(present(gc))call print_generic(gc)
   if(present(gd))call print_generic(gd)
   if(present(ge))call print_generic(ge)
   if(present(gf))call print_generic(gf)
   if(present(gg))call print_generic(gg)
   if(present(gh))call print_generic(gh)
   if(present(gi))call print_generic(gi)
   if(present(gj))call print_generic(gj)
   if(present(line))then
      line=trim(local_line)
   else
      write(*,'(a)')trim(local_line)
   endif
contains
!===================================================================================================================================
subroutine print_generic(generic)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(local_line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(local_line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(local_line(istart:),'(1pg0)') generic
      type is (real(kind=real64))
         write(local_line(istart:),'(1pg0)') generic
      !x! DOES NOT WORK WITH NVFORTRAN: type is (real(kind=real128));     write(local_line(istart:),'(1pg0)') generic
      type is (logical)
         write(local_line(istart:),'(l1)') generic
      type is (character(len=*))
         write(local_line(istart:),'(a)') trim(generic)
      type is (complex);                write(local_line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(local_line)+increment
   local_line=trim(local_line)//sep_local
end subroutine print_generic
!===================================================================================================================================
end subroutine journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep) result(line)

! ident_13="@(#) M_CLI2 str(3fp) writes a message to a string composed of any standard scalar types"

class(*),intent(in),optional         :: g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable         :: line
call journal(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep,line)

end function str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function upper(str) result (string)

! ident_14="@(#) M_CLI2 upper(3f) Changes a string to uppercase"

character(*), intent(in)      :: str
character(:),allocatable      :: string
integer                       :: i
   string = str
   do i = 1, len_trim(str)
       select case (str(i:i))
       case ('a':'z')
          string(i:i) = char(iachar(str(i:i))-32)
       end select
   end do
end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lower(str) result (string)

! ident_15="@(#) M_CLI2 lower(3f) Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(:),allocatable     :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

! ident_16="@(#) M_CLI2 a2i(3fp) subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
integer,parameter           :: ihuge=huge(0)

   valu8 = 0.0d0
   call a2d(chars, valu8, ierr, onerr=0.0d0)

   if (valu8 <= huge(valu)) then

      if (valu8 <= huge(valu)) then
         valu = int(valu8)
      else
         call journal('*a2i*', '- value too large', valu8, '>', ihuge)
         valu = huge(valu)
         ierr = -1
      endif

   endif

end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

! ident_17="@(#) M_CLI2 a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=unquote(chars)
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   local_chars=replace_str(local_chars,',','')                  ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         write(frmt,"('(Z',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         write(frmt,"('(B',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         write(frmt,"('(O',i0,')')")len(local_chars)
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(f3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         call journal('*a2d* - cannot produce number from string ['//trim(chars)//']')
         if(msg /= '')then
            call journal('*a2d* - ['//trim(msg)//']')
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_CLI2:TOKENS] parse string into an array using specified
!!    delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!##DESCRIPTION
!!    SPLIT(3f) parses a string using specified delimiter characters and
!!    store tokens into an allocatable array
!!
!!##OPTIONS
!!
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!
!!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_split
!!     use M_CLI2, only: split
!!     character(len=*),parameter     :: &
!!     & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!     character(len=:),allocatable :: array(:) ! output array of tokens
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,'(80("="))')
!!        write(*,*)'typical call:'
!!        CALL split(line,array)
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'custom list of delimiters (colon and vertical line):'
!!        CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)&
!!      &'custom list of delimiters, reverse array order and count null fields:'
!!        CALL split(line,array,delimiters=':|',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!        write(*,'(80("-"))')
!!        write(*,*)'INPUT LINE:['//LINE//']'
!!        write(*,*)&
!!        &'default delimiters and reverse array order and return null fields:'
!!        CALL split(line,array,delimiters='',order='reverse',nulls='return')
!!        write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!        write(*,*)'SIZE:',SIZE(array)
!!     end program demo_split
!!
!!   Output
!!
!!    > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    > ===========================================================================
!!    >  typical call:
!!    > 1 ==> aBcdef
!!    > 2 ==> ghijklmnop
!!    > 3 ==> qrstuvwxyz
!!    > 4 ==> 1:|:2
!!    > 5 ==> 333|333
!!    > 6 ==> a
!!    > 7 ==> B
!!    > 8 ==> cc
!!    >  SIZE:           8
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters (colon and vertical line):
!!    > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    > 2 ==> 2     333
!!    > 3 ==> 333 a B cc
!!    >  SIZE:           3
!!    > --------------------------------------------------------------------------
!!    >  custom list of delimiters, reverse array order and return null fields:
!!    > 1 ==> 333 a B cc
!!    > 2 ==> 2     333
!!    > 3 ==>
!!    > 4 ==>
!!    > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!    >  SIZE:           5
!!    > --------------------------------------------------------------------------
!!    >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!    >  default delimiters and reverse array order and count null fields:
!!    > 1 ==>
!!    > 2 ==>
!!    > 3 ==>
!!    > 4 ==> cc
!!    > 5 ==> B
!!    > 6 ==> a
!!    > 7 ==> 333|333
!!    > 8 ==>
!!    > 9 ==>
!!    > 10 ==>
!!    > 11 ==>
!!    > 12 ==> 1:|:2
!!    > 13 ==>
!!    > 14 ==> qrstuvwxyz
!!    > 15 ==> ghijklmnop
!!    > 16 ==>
!!    > 17 ==>
!!    > 18 ==> aBcdef
!!    > 19 ==>
!!    > 20 ==>
!!    >  SIZE:          20
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)

! ident_18="@(#) M_CLI2 split(3f) parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
intrinsic index, min, present, len
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: iilen                  ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:' ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)//',:'    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   if(allocated(ibegin))deallocate(ibegin)    !x! intel compiler says allocated already ???
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   if(allocated(iterm))deallocate(iterm)      !x! intel compiler says allocated already ???
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   iilen=len(input_line)                                          ! IILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
   if(iilen > 0)then                                              ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,iilen,1                                  ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iterm(i30)=iilen                                      ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):iilen),dlim(i10:i10))
               IF(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > iilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (clipends(nlls))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   if(allocated(array))deallocate(array)
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                      ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (clipends(ordr))                                   ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20) < ibegin(i20))then
         select case (clipends(nlls))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    replace_str(3f) - [M_CLI2:EDITING] function globally replaces one
!!    substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function replace_str(targetline,old,new,range,ierr) result (newline)
!!
!!     character(len=*)               :: targetline
!!     character(len=*),intent(in)    :: old
!!     character(len=*),intent(in)    :: new
!!     integer,intent(in),optional    :: range(2)
!!     integer,intent(out),optional   :: ierr
!!     logical,intent(in),optional    :: clip
!!     character(len=:),allocatable   :: newline
!!##DESCRIPTION
!!    Globally replace one substring for another in string.
!!    Either CMD or OLD and NEW must be specified.
!!
!!##OPTIONS
!!     targetline  input line to be changed
!!     old         old substring to replace
!!     new         new substring
!!     range       if present, only change range(1) to range(2) of
!!                 occurrences of old string
!!     ierr        error code. If ier = -1 bad directive, >= 0 then
!!                 count of changes made
!!     clip        whether to return trailing spaces or not. Defaults to .false.
!!##RETURNS
!!     newline     allocatable string returned
!!
!!##EXAMPLES
!!
!! Sample Program:
!!
!!       program demo_replace_str
!!       use M_CLI2, only : replace_str
!!       implicit none
!!       character(len=:),allocatable :: targetline
!!
!!       targetline='this is the input string'
!!
!!       call testit('th','TH','THis is THe input string')
!!
!!       ! a null old substring means "at beginning of line"
!!       call testit('','BEFORE:', 'BEFORE:THis is THe input string')
!!
!!       ! a null new string deletes occurrences of the old substring
!!       call testit('i','', 'BEFORE:THs s THe nput strng')
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A')
!!       write(*,*)'replace a with A ['//targetline//']'
!!
!!       write(*,*)'Examples of the use of RANGE='
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','A',range=[3,5])
!!       write(*,*)'replace a with A instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa','a','',range=[3,5])
!!       write(*,*)'replace a with null instances 3 to 5 ['//targetline//']'
!!
!!       targetline=replace_str('a b ab baaa aaaa aa aa a a a aa aaaaaa',&
!!        & 'aa','CCCC',range=[3,5])
!!       write(*,*)'replace aa with CCCC instances 3 to 5 ['//targetline//']'
!!
!!       contains
!!       subroutine testit(old,new,expected)
!!       character(len=*),intent(in) :: old,new,expected
!!       write(*,*)repeat('=',79)
!!       write(*,*)':STARTED ['//targetline//']'
!!       write(*,*)':OLD['//old//']', ' NEW['//new//']'
!!       targetline=replace_str(targetline,old,new)
!!       write(*,*)':GOT     ['//targetline//']'
!!       write(*,*)':EXPECTED['//expected//']'
!!       write(*,*)':TEST    [',targetline == expected,']'
!!       end subroutine testit
!!
!!       end program demo_replace_str
!!
!!   Expected output
!!
!!     ===============================================================================
!!     STARTED [this is the input string]
!!     OLD[th] NEW[TH]
!!     GOT     [THis is THe input string]
!!     EXPECTED[THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [THis is THe input string]
!!     OLD[] NEW[BEFORE:]
!!     GOT     [BEFORE:THis is THe input string]
!!     EXPECTED[BEFORE:THis is THe input string]
!!     TEST    [ T ]
!!     ===============================================================================
!!     STARTED [BEFORE:THis is THe input string]
!!     OLD[i] NEW[]
!!     GOT     [BEFORE:THs s THe nput strng]
!!     EXPECTED[BEFORE:THs s THe nput strng]
!!     TEST    [ T ]
!!     replace a with A [A b Ab bAAA AAAA]
!!     Examples of the use of RANGE=
!!     replace a with A instances 3 to 5 [a b ab bAAA aaaa]
!!     replace a with null instances 3 to 5 [a b ab b aaaa]
!!     replace aa with CCCC instances 3 to 5 [a b ab baaa aaCCCC CCCC CCCC
!!     a a a aa aaaaaa]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function replace_str(targetline,old,new,ierr,range) result (newline)

! ident_19="@(#) M_CLI2 replace_str(3f) Globally replace one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
! parameters
character(len=*),intent(in)            :: targetline   ! input line to be changed
character(len=*),intent(in)            :: old          ! old substring to replace
character(len=*),intent(in)            :: new          ! new substring
integer,intent(out),optional           :: ierr         ! error code. If ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional            :: range(2)     ! start and end of which changes to make
!-----------------------------------------------------------------------------------------------------------------------------------
! returns
character(len=:),allocatable  :: newline               ! output string buffer
!-----------------------------------------------------------------------------------------------------------------------------------
! local
integer  :: icount,ichange
integer  :: original_input_length
integer  :: len_old, len_new
integer  :: ladd
integer  :: left_margin, right_margin
integer  :: ind
integer  :: ic
integer  :: iichar
integer  :: range_local(2)
!-----------------------------------------------------------------------------------------------------------------------------------
   icount=0                                            ! initialize error flag/change count
   ichange=0                                           ! initialize error flag/change count
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   left_margin=1                                       ! left_margin is left margin of window to change
   right_margin=len(targetline)                        ! right_margin is right margin of window to change
   newline=''                                          ! begin with a blank line as output string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(range))then
      range_local=range
   else
      range_local=[1,original_input_length]
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      iichar=len_new + original_input_length
      if(len_new > 0)then
         newline=new(:len_new)//targetline(left_margin:original_input_length)
      else
         newline=targetline(left_margin:original_input_length)
      endif
      ichange=1                                        ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ichange
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   iichar=left_margin                                  ! place to put characters into output string
   ic=left_margin                                      ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1 ! try finding start of OLD in remaining part of input in change window
      if(ind == ic-1.or.ind > right_margin)then           ! did not find old string or found old string past edit window
         exit loop                                        ! no more changes left to make
      endif
      icount=icount+1                                  ! found an old string to change, so increment count of change candidates
      if(ind > ic)then                                 ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         newline=newline(:iichar-1)//targetline(ic:ind-1)
         iichar=iichar+ladd
      endif
      if(icount >= range_local(1).and.icount <= range_local(2))then    ! check if this is an instance to change or keep
         ichange=ichange+1
         if(len_new /= 0)then                                          ! put in new string
            newline=newline(:iichar-1)//new(:len_new)
            iichar=iichar+len_new
         endif
      else
         if(len_old /= 0)then                                          ! put in copy of old string
            newline=newline(:iichar-1)//old(:len_old)
            iichar=iichar+len_old
         endif
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ichange)
   case (0)                                            ! there were no changes made to the window
      newline=targetline                               ! if no changes made output should be input
   case default
      if(ic <= len(targetline))then                    ! if there is more after last change on original line add it
         newline=newline(:iichar-1)//targetline(ic:max(ic,original_input_length))
      endif
   end select
   if(present(ierr))ierr=ichange
!-----------------------------------------------------------------------------------------------------------------------------------
end function replace_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    quote(3f) - [M_CLI2:QUOTES] add quotes to string as if written with
!!    list-directed input
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   function quote(str,mode,clip) result (quoted_str)
!!
!!    character(len=*),intent(in)          :: str
!!    character(len=*),optional,intent(in) :: mode
!!    logical,optional,intent(in)          :: clip
!!    character(len=:),allocatable         :: quoted_str
!!##DESCRIPTION
!!    Add quotes to a CHARACTER variable as if it was written using
!!    list-directed input. This is particularly useful for processing
!!    strings to add to CSV files.
!!
!!##OPTIONS
!!    str         input string to add quotes to, using the rules of
!!                list-directed input (single quotes are replaced by two
!!                adjacent quotes)
!!    mode        alternate quoting methods are supported:
!!
!!                   DOUBLE   default. replace quote with double quotes
!!                   ESCAPE   replace quotes with backslash-quote instead
!!                            of double quotes
!!
!!    clip        default is to trim leading and trailing spaces from the
!!                string. If CLIP
!!                is .FALSE. spaces are not trimmed
!!
!!##RETURNS
!!    quoted_str  The output string, which is based on adding quotes to STR.
!!##EXAMPLES
!!
!! Sample program:
!!
!!     program demo_quote
!!     use M_CLI2, only : quote
!!     implicit none
!!     character(len=:),allocatable :: str
!!     character(len=1024)          :: msg
!!     integer                      :: ios
!!     character(len=80)            :: inline
!!        do
!!           write(*,'(a)',advance='no')'Enter test string:'
!!           read(*,'(a)',iostat=ios,iomsg=msg)inline
!!           if(ios /= 0)then
!!              write(*,*)trim(inline)
!!              exit
!!           endif
!!
!!           ! the original string
!!           write(*,'(a)')'ORIGINAL     ['//trim(inline)//']'
!!
!!           ! the string processed by quote(3f)
!!           str=quote(inline)
!!           write(*,'(a)')'QUOTED     ['//str//']'
!!
!!           ! write the string list-directed to compare the results
!!           write(*,'(a)',iostat=ios,iomsg=msg) 'LIST DIRECTED:'
!!           write(*,*,iostat=ios,iomsg=msg,delim='none') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='quote') inline
!!           write(*,*,iostat=ios,iomsg=msg,delim='apostrophe') inline
!!        enddo
!!     end program demo_quote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
function quote(str,mode,clip) result (quoted_str)
character(len=*),intent(in)          :: str                ! the string to be quoted
character(len=*),optional,intent(in) :: mode
logical,optional,intent(in)          :: clip
logical                              :: clip_local
character(len=:),allocatable         :: quoted_str

character(len=1),parameter           :: double_quote = '"'
character(len=20)                    :: local_mode

   if(present(mode))then
      local_mode=mode
   else
      local_mode='DOUBLE'
   endif

   if(present(clip))then
      clip_local=clip
   else
      clip_local=.false.
   endif

   if(clip_local)then
      quoted_str=adjustl(str)
   else
      quoted_str=str
   endif

   select case(lower(local_mode))
   case('double')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','""'))//double_quote
   case('escape')
      quoted_str=double_quote//trim(replace_str(quoted_str,'"','\"'))//double_quote
   case default
      call journal('*quote* ERROR: unknown quote mode ',local_mode)
      quoted_str=str
   end select

end function quote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    unquote(3f) - [M_CLI2:QUOTES] remove quotes from string as if read
!!    with list-directed input
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   pure function unquote(quoted_str,esc) result (unquoted_str)
!!
!!    character(len=*),intent(in)          :: quoted_str
!!    character(len=1),optional,intent(in) :: esc
!!    character(len=:),allocatable         :: unquoted_str
!!##DESCRIPTION
!!    Remove quotes from a CHARACTER variable as if it was read using
!!    list-directed input. This is particularly useful for processing
!!    tokens read from input such as CSV files.
!!
!!    Fortran can now read using list-directed input from an internal file,
!!    which should handle quoted strings, but list-directed input does not
!!    support escape characters, which UNQUOTE(3f) does.
!!##OPTIONS
!!    quoted_str  input string to remove quotes from, using the rules of
!!                list-directed input (two adjacent quotes inside a quoted
!!                region are replaced by a single quote, a single quote or
!!                double quote is selected as the delimiter based on which
!!                is encountered first going from left to right, ...)
!!    esc         optional character used to protect the next quote
!!                character from being processed as a quote, but simply as
!!                a plain character.
!!##RETURNS
!!    unquoted_str  The output string, which is based on removing quotes
!!                  from quoted_str.
!!##EXAMPLES
!!
!! Sample program:
!!
!!       program demo_unquote
!!       use M_CLI2, only : unquote
!!       implicit none
!!       character(len=128)           :: quoted_str
!!       character(len=:),allocatable :: unquoted_str
!!       character(len=1),parameter   :: esc='\'
!!       character(len=1024)          :: msg
!!       integer                      :: ios
!!       character(len=1024)          :: dummy
!!       do
!!          write(*,'(a)',advance='no')'Enter test string:'
!!          read(*,'(a)',iostat=ios,iomsg=msg)quoted_str
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!             exit
!!          endif
!!
!!          ! the original string
!!          write(*,'(a)')'QUOTED       ['//trim(quoted_str)//']'
!!
!!          ! the string processed by unquote(3f)
!!          unquoted_str=unquote(trim(quoted_str),esc)
!!          write(*,'(a)')'UNQUOTED     ['//unquoted_str//']'
!!
!!          ! read the string list-directed to compare the results
!!          read(quoted_str,*,iostat=ios,iomsg=msg)dummy
!!          if(ios /= 0)then
!!             write(*,*)trim(msg)
!!          else
!!             write(*,'(a)')'LIST DIRECTED['//trim(dummy)//']'
!!          endif
!!       enddo
!!       end program demo_unquote
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
pure function unquote(quoted_str,esc) result (unquoted_str)
character(len=*),intent(in)          :: quoted_str              ! the string to be unquoted
character(len=1),optional,intent(in) :: esc                     ! escape character
character(len=:),allocatable         :: unquoted_str
integer                              :: inlen
character(len=1),parameter           :: single_quote = "'"
character(len=1),parameter           :: double_quote = '"'
integer                              :: quote                   ! whichever quote is to be used
integer                              :: before
integer                              :: current
integer                              :: iesc
integer                              :: iput
integer                              :: i
logical                              :: inside
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(esc))then                           ! select escape character as specified character or special value meaning not set
      iesc=ichar(esc)                             ! allow for an escape character
   else
      iesc=-1                                     ! set to value that matches no character
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   inlen=len(quoted_str)                          ! find length of input string
   if(allocated(unquoted_str))deallocate(unquoted_str)
   allocate(character(len=inlen) :: unquoted_str) ! initially make output string length of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(inlen >= 1)then                             ! double_quote is the default quote unless the first character is single_quote
      if(quoted_str(1:1) == single_quote)then
         quote=ichar(single_quote)
      else
         quote=ichar(double_quote)
      endif
   else
      quote=ichar(double_quote)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   before=-2                                      ! initially set previous character to impossible value
   unquoted_str(:)=''                             ! initialize output string to null string
   iput=1
   inside=.false.
   STEPTHROUGH: do i=1,inlen
      current=ichar(quoted_str(i:i))
      if(before == iesc)then                      ! if previous character was escape use current character unconditionally
           iput=iput-1                            ! backup
           unquoted_str(iput:iput)=char(current)
           iput=iput+1
           before=-2                              ! this could be second esc or quote
      elseif(current == quote)then                ! if current is a quote it depends on whether previous character was a quote
         if(before == quote)then
           unquoted_str(iput:iput)=char(quote)    ! this is second quote so retain it
           iput=iput+1
           before=-2
         elseif(.not.inside.and.before /= iesc)then
            inside=.true.
         else                                     ! this is first quote so ignore it except remember it in case next is a quote
            before=current
         endif
      else
         unquoted_str(iput:iput)=char(current)
         iput=iput+1
         before=current
      endif
   enddo STEPTHROUGH
!-----------------------------------------------------------------------------------------------------------------------------------
   unquoted_str=unquoted_str(:iput-1)
!-----------------------------------------------------------------------------------------------------------------------------------
end function unquote
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!    decodebase(3f) - [M_CLI2:BASE] convert whole number string in base
!!                     [2-36] to base 10 number
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   logical function decodebase(string,basein,out10)
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in)           :: basein
!!    integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!    Convert a numeric string representing a whole number in base BASEIN
!!    to base 10. The function returns FALSE if BASEIN is not in the range
!!    [2..36] or if string STRING contains invalid characters in base BASEIN
!!    or if result OUT10 is too big
!!
!!    The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!      program demo_decodebase
!!      use M_CLI2, only : codebase, decodebase
!!      implicit none
!!      integer           :: ba,bd
!!      character(len=40) :: x,y
!!      integer           :: r
!!
!!      print *,' BASE CONVERSION'
!!      write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!      write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!      INFINITE: do
!!         print *,''
!!         write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!         if(x == '0') exit INFINITE
!!         if(decodebase(x,bd,r)) then
!!            if(codebase(r,ba,y)) then
!!              write(*,'("In base ",I2,": ",A20)')  ba, y
!!            else
!!              print *,'Error in coding number.'
!!            endif
!!         else
!!            print *,'Error in decoding number.'
!!         endif
!!      enddo INFINITE
!!
!!      end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
logical function decodebase(string,basein,out_baseten)

! ident_20="@(#) M_CLI2 decodebase(3f) convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(clipends(string))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call a2i(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        IF(CH == '-'.AND.K == 1)THEN
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    locate_(3f) - [M_CLI2] finds the index where a string is found or
!!                  should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate_(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE_(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update_dic(arr,'b')
!!     call update_dic(arr,'[')
!!     call update_dic(arr,'c')
!!     call update_dic(arr,'ZZ')
!!     call update_dic(arr,'ZZZZ')
!!     call update_dic(arr,'z')
!!
!!     contains
!!     subroutine update_dic(arr,string)
!!     character(len=:),intent(in),allocatable :: arr(:)
!!     character(len=*),intent(in)  :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate_(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end == 0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus == 1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus == end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update_dic
!!     end program demo_locate
!!
!!   Results:
!!
!!     for "b" index is            2           5
!!     for "[" index is           -4           5
!!    SIZE=5 xxx,b,aaa,[,ZZZ,
!!     for "c" index is           -2           6
!!    SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!     for "ZZ" index is           -7           7
!!    SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     for "ZZZZ" index is           -6           8
!!    SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!     for "z" index is           -1           9
!!    SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

! ident_21="@(#) M_CLI2 locate_c(3f) find PLACE in sorted character array LIST where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)

   error=0
   if(arraysize == 0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value == list(PLACE))then
         exit LOOP
      elseif(value > list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin > imax)then
         place=-imin
         if(iabs(place) > arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place > arraysize.or.place <= 0)then
         message='*locate_* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate_* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   elseif(error /= 0)then
      write(warn,*)message//' VALUE=',trim(value)//' PLACE=',place
      call mystop(-24,'(*locate_c* '//message)
   endif
   if(present(errmsg))then
      errmsg=message
   endif
end subroutine locate_c
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove_(3f) - [M_CLI2] remove entry from an allocatable array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove_(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!
!! Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_, remove_
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'Z', 'aaa', 'b', 'b', 'ab', 'bb', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove_(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove_(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results:
!!
!!    Expected output
!!
!!     SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!     SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

! ident_22="@(#) M_CLI2 remove_c(3fp) remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
end subroutine remove_c
subroutine remove_l(list,place)

! ident_23="@(#) M_CLI2 remove_l(3fp) remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_l
subroutine remove_i(list,place)

! ident_24="@(#) M_CLI2 remove_i(3fp) remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place <= 0.or.place > end)then                       ! index out of bounds of array
   elseif(place == end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace_(3f) - [M_CLI2] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace_(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out) :: place
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless the
!!    array needs the string length to increase this is merely an assign of a value
!!    to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER>
!!    It is assumed to be sorted in descending order without duplicate values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_CLI2, only  : insert_, locate_, replace_
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update_dic('b','value of b')
!!     call update_dic('a','value of a')
!!     call update_dic('c','value of c')
!!     call update_dic('c','value of c again')
!!     call update_dic('d','value of d')
!!     call update_dic('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate_key('a',place)
!!     if(place > 0)then
!!        write(*,*)'The value of "a" is',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update_dic(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate_key(key,place)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        call insert_(keywords,key,abs(place))
!!        call insert_(values,val,abs(place))
!!     else ! replace
!!        call replace_(values,val,place)
!!     endif
!!
!!     end subroutine update_dic
!!    end program demo_replace
!!
!!   Expected output
!!
!!    d==>value of d
!!    c==>value of c again
!!    b==>value of b
!!    a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

! ident_25="@(#) M_CLI2 replace_c(3fp) replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place < 0.or.place > end)then
           write(warn,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value) <= len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
end subroutine replace_c
subroutine replace_l(list,value,place)

! ident_26="@(#) M_CLI2 replace_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place > 0.and.place <= end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_l
subroutine replace_i(list,value,place)

! ident_27="@(#) M_CLI2 replace_i(3fp) place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place > 0.and.place <= end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(warn,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert_(3f) - [M_CLI2] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert_(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!
!! Find if a string is in a sorted array, and insert the string into
!! the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_CLI2, only : locate_, insert_
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update_dic(arr,'b')
!!     call update_dic(arr,'[')
!!     call update_dic(arr,'c')
!!     call update_dic(arr,'ZZ')
!!     call update_dic(arr,'ZZZ')
!!     call update_dic(arr,'ZZZZ')
!!     call update_dic(arr,'')
!!     call update_dic(arr,'z')
!!
!!     contains
!!     subroutine update_dic(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate_(arr,string,place)
!!     ! if string was not found insert it
!!     if(place < 1)then
!!        call insert_(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update_dic
!!     end program demo_insert
!!
!!   Results:
!!
!!     array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!     array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!     array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!     array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!     array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!     array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

! ident_28="@(#) M_CLI2 insert_c(3fp) place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)

   if(end == 0)then                                        ! empty array
      list=[character(len=ii) :: value ]
   elseif(place == 1)then                                  ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place > end)then                                 ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place >= 2.and.place <= end)then                 ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(warn,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_c
subroutine insert_l(list,value,place)

! ident_29="@(#) M_CLI2 insert_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place == 1)then                                    ! put in front of array
      list=[value, list]
   elseif(place > end)then                                   ! put at end of array
      list=[list, value ]
   elseif(place >= 2.and.place <= end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_l
subroutine insert_i(list,value,place)

! ident_30="@(#) M_CLI2 insert_i(3fp) place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(end == 0)then                                          ! empty array
      list=[value]
   elseif(place == 1)then                                    ! put in front of array
      list=[value, list]
   elseif(place > end)then                                   ! put at end of array
      list=[list, value ]
   elseif(place >= 2.and.place <= end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(warn,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine many_args(n0,g0, n1,g1, n2,g2, n3,g3, n4,g4, n5,g5, n6,g6, n7,g7, n8,g8, n9,g9, &
                   & na,ga, nb,gb, nc,gc, nd,gd, ne,ge, nf,gf, ng,gg, nh,gh, ni,gi, nj,gj )

! ident_31="@(#) M_CLI2 many_args(3fp) allow for multiple calls to get_args(3f)"

character(len=*),intent(in)          :: n0, n1
character(len=*),intent(in),optional :: n2, n3, n4, n5, n6, n7, n8, n9, na, nb, nc, nd, ne, nf, ng, nh, ni, nj
class(*),intent(out)           :: g0, g1
class(*),intent(out),optional  :: g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
   call get_generic(n0,g0)
   call get_generic(n1,g1)
   if( present(n2) .and. present(g2) )call get_generic(n2,g2)
   if( present(n3) .and. present(g3) )call get_generic(n3,g3)
   if( present(n4) .and. present(g4) )call get_generic(n4,g4)
   if( present(n5) .and. present(g5) )call get_generic(n5,g5)
   if( present(n6) .and. present(g6) )call get_generic(n6,g6)
   if( present(n7) .and. present(g7) )call get_generic(n7,g7)
   if( present(n8) .and. present(g8) )call get_generic(n8,g8)
   if( present(n9) .and. present(g9) )call get_generic(n9,g9)
   if( present(na) .and. present(ga) )call get_generic(na,ga)
   if( present(nb) .and. present(gb) )call get_generic(nb,gb)
   if( present(nc) .and. present(gc) )call get_generic(nc,gc)
   if( present(nd) .and. present(gd) )call get_generic(nd,gd)
   if( present(ne) .and. present(ge) )call get_generic(ne,ge)
   if( present(nf) .and. present(gf) )call get_generic(nf,gf)
   if( present(ng) .and. present(gg) )call get_generic(ng,gg)
   if( present(nh) .and. present(gh) )call get_generic(nh,gh)
   if( present(ni) .and. present(gi) )call get_generic(ni,gi)
   if( present(nj) .and. present(gj) )call get_generic(nj,gj)
contains
!===================================================================================================================================
function c(generic)
class(*),intent(in) :: generic
character(len=:),allocatable :: c
   select type(generic)
      type is (character(len=*)); c=trim(generic)
      class default
         c='unknown'
         stop 'get_many:: parameter name is not character'
   end select
end function c
!===================================================================================================================================
subroutine get_generic(name,generic)
use,intrinsic :: iso_fortran_env, only : real64
character(len=*),intent(in)  :: name
class(*),intent(out)         :: generic
   select type(generic)
      type is (integer);                        call get_args(name,generic)
      type is (real);                           call get_args(name,generic)
      type is (real(kind=real64));              call get_args(name,generic)
      type is (logical);                        call get_args(name,generic)
      !x!type is (character(len=:),allocatable ::);   call get_args(name,generic)
      type is (character(len=*));
      call get_args_fixed_length(name,generic)
      type is (complex);                        call get_args(name,generic)
      class default
         stop 'unknown type in *get_generic*'
   end select
end subroutine get_generic
!===================================================================================================================================
end subroutine many_args
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function iget(n); integer                      :: iget; character(len=*),intent(in) :: n; call get_args(n,iget); end function iget
function rget(n); real                         :: rget; character(len=*),intent(in) :: n; call get_args(n,rget); end function rget
function dget(n); real(kind=dp)                :: dget; character(len=*),intent(in) :: n; call get_args(n,dget); end function dget
function sget(n); character(len=:),allocatable :: sget; character(len=*),intent(in) :: n; call get_args(n,sget); end function sget
function cget(n); complex                      :: cget; character(len=*),intent(in) :: n; call get_args(n,cget); end function cget
function lget(n); logical                      :: lget; character(len=*),intent(in) :: n; call get_args(n,lget); end function lget

function igs(n); integer,allocatable          :: igs(:); character(len=*),intent(in) :: n; call get_args(n,igs); end function igs
function rgs(n); real,allocatable             :: rgs(:); character(len=*),intent(in) :: n; call get_args(n,rgs); end function rgs
function dgs(n); real(kind=dp),allocatable    :: dgs(:); character(len=*),intent(in) :: n; call get_args(n,dgs); end function dgs
function sgs(n,delims)
character(len=:),allocatable         :: sgs(:)
character(len=*),optional,intent(in) :: delims
character(len=*),intent(in)          :: n
   call get_args(n,sgs,delims)
end function sgs
function cgs(n); complex,allocatable          :: cgs(:); character(len=*),intent(in) :: n; call get_args(n,cgs); end function cgs
function lgs(n); logical,allocatable          :: lgs(:); character(len=*),intent(in) :: n; call get_args(n,lgs); end function lgs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function ig()
integer,allocatable :: ig(:)
integer             :: i, ierr
   if(allocated(ig))deallocate(ig)
   allocate(ig(size(unnamed)))
   do i=1,size(ig)
      call a2i(unnamed(i),ig(i),ierr)
   enddo
end function ig
!===================================================================================================================================
function rg()
real,allocatable :: rg(:)
   rg=real(dg())
end function rg
!===================================================================================================================================
function dg()
real(kind=dp),allocatable :: dg(:)
integer                   :: i
integer                   :: ierr
   if(allocated(dg))deallocate(dg)
   allocate(dg(size(unnamed)))
   do i=1,size(dg)
      call a2d(unnamed(i),dg(i),ierr)
   enddo
end function dg
!===================================================================================================================================
function lg()
logical,allocatable   :: lg(:)
integer               :: i
integer               :: iichar
character,allocatable :: hold
   if(allocated(lg))deallocate(lg)
   allocate(lg(size(unnamed)))
   do i=1,size(lg)
      hold=upper(clipends(unnamed(i)))
      if(hold(1:1) == '.')then                 ! looking for fortran logical syntax .STRING.
         iichar=2
      else
         iichar=1
      endif
      select case(hold(iichar:iichar))         ! check word to see if true or false
      case('T','Y',' '); lg(i)=.true.          ! anything starting with "T" or "Y" or a blank is TRUE (true,yes,...)
      case('F','N');     lg(i)=.false.         ! assume this is false or no
      case default
         call journal("*lg* bad logical expression for element",i,'=',hold)
      end select
   enddo
end function lg
!===================================================================================================================================
function cg()
complex,allocatable :: cg(:)
integer             :: i, ierr
real(kind=dp)       :: rc, ic
   if(allocated(cg))deallocate(cg)
   allocate(cg(size(unnamed)))
   do i=1,size(cg),2
      call a2d(unnamed(i),rc,ierr)
      call a2d(unnamed(i+1),ic,ierr)
      cg(i)=cmplx(rc,ic,kind=sp)
   enddo
end function cg
!===================================================================================================================================
! Does not work with gcc 5.3
!function sg()
!character(len=:),allocatable :: sg(:)
!   sg=unnamed
!end function sg

!===================================================================================================================================
function sg()
character(len=:),allocatable :: sg(:)
   if(allocated(sg))deallocate(sg)
   allocate(sg,source=unnamed)
end function sg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine mystop(sig,msg)
! negative signal means always stop program
! else do not stop and set G_STOP_MESSAGE if G_QUIET is true
! or
! print message and stop if G_QUIET is false
! the MSG is NOT for displaying except for internal errors when the program will be stopped.
! It is for returning a value when the stop is being ignored
!
integer,intent(in) :: sig
character(len=*),intent(in),optional :: msg
   if(sig < 0)then
      if(present(msg))call journal(msg)
      stop 1
   elseif(.not.G_QUIET)then
      stop
   else
      if(present(msg)) then
         G_STOP_MESSAGE=msg
      else
         G_STOP_MESSAGE=''
      endif
      G_STOP=sig
   endif
end subroutine mystop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function atleast(line,length,pattern) result(strout)

! ident_32="@(#) M_strings atleast(3f) return string padded to at least specified length"

character(len=*),intent(in)                :: line
integer,intent(in)                         :: length
character(len=*),intent(in),optional       :: pattern
character(len=max(length,len(trim(line)))) :: strout
if(present(pattern))then
   strout=line//repeat(pattern,len(strout)/len(pattern)+1)
else
   strout=line
endif
end function atleast
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function clipends(string) result(lopped)
! trim leading and trailings spaces from resulting string
character(len=*),intent(in)  :: string
character(len=:),allocatable :: lopped
integer                      :: ends(2)
   ends=verify( string, " ", [.false.,.true.] )
   if(ends(1) == 0)then
      lopped=""
   else
      lopped=string(ends(1):ends(2))
   endif
end function clipends
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine locate_key(keyname,place)

! ident_33="@(#) M_CLI2 locate_key(3f) find PLACE in sorted character array where KEYNAME can be found or should be placed"

character(len=*),intent(in)             :: keyname
integer,intent(out)                     :: place
integer                                 :: ii
character(len=:),allocatable            :: keyword_local

   if(G_UNDERDASH)then
      keyword_local=trim(replace_str(keyname,'-','_'))
   else
      keyword_local=trim(keyname)
   endif

   if(G_NODASHUNDER)then
      keyword_local=replace_str(keyword_local,'-','')
      keyword_local=replace_str(keyword_local,'_','')
   endif

   if(G_IGNORELONGCASE.and.len_trim(keyword_local) > 1)keyword_local=lower(keyword_local)
   if(G_IGNOREALLCASE)keyword_local=lower(keyword_local)

   if(len(keyword_local) == 1)then
      !x!ii=findloc(shorts,keyword_local,dim=1)
      ii=maxloc([0,merge(1, 0, shorts == keyword_local)],dim=1)
      if(ii > 1)then
         place=ii-1
      else
         call locate_(keywords,keyword_local,place)
      endif
   else
      call locate_(keywords,keyword_local,place)
   endif

   if(G_DEBUG) write(*,gen)'<DEBUG>LOCATE_KEY:KEYNAME:',trim(keyname),':KEYWORD:',keyword_local

end subroutine locate_key
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    set_mode(3f) - [ARGUMENTS:M_CLI2] turn on optional modes+
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine set_mode(key,mode)
!!
!!     character(len=*),intent(in) :: key
!!     logical,intent(in),optional :: mode
!!
!!##DESCRIPTION
!!     Allow optional behaviors.
!!
!!##OPTIONS
!!    KEY    name of option
!!
!!    The following values are allowed:
!!
!!    o  response_file - enable use of response file
!!
!!    o  auto_response_file - enable use of response file
!!       but also act as if @$0 was entered on the command line
!!       where $0 is the basename of the file being executed
!!
!!    o  ignorelongcase - ignore case in long key names. So the user
!!       does not have to remember if the option is --CurtMode or --curtmode
!!       or --curtMode .
!!
!!    o  ignoreallcase - ignore case in long and short key names.
!!       This is similar to Powershell, which is case-insensitive.
!!
!!    o  dashunder  - treat dash in keyword as an underscore.
!!       So the user should not have to remember if the option is
!!       --ignore_case or --ignore-case.
!!
!!    o  nodashunder  - ignore dash and underscore in keywords.
!!
!!    o  strict - allow Boolean keys to be bundled, but requires
!!       a single dash prefix be used for short key names and long names
!!       must be prefixed with two dashes.
!!
!!    o  lastonly  - when multiple keywords occur keep the rightmost
!!       value specified instead of appending the values together.
!!
!!    MODE   set to .true. to activate the optional mode.
!!           Set to .false. to deactivate the mode.
!!           It is .true. by default.
!!
!!##EXAMPLES
!!
!! Sample program:
!!
!!    program demo_set_mode
!!    use M_CLI2,  only : set_args, lget, set_mode
!!    implicit none
!!    character(len=*),parameter :: all='(*(g0))'
!!       !
!!       ! enable use of response files
!!       call set_mode('response_file')
!!       !
!!       ! Any dash in a keyword is treated as an underscore
!!       call set_mode('underdash')
!!       !
!!       ! The case of long keywords are ignored.
!!       ! Values and short names remain case-sensitive
!!       call set_mode('ignorelongcase')
!!       ! The case of short and long keywords are ignored
!!       call set_mode('ignoreallcase')
!!       !
!!       ! short single-character boolean keys may be bundled
!!       ! but it is required that a single dash is used for
!!       ! short keys and a double dash for long keywords.
!!       call set_mode('strict')
!!       !
!!       call set_args(' --switch_X:X F --switch-Y:Y F --ox:O F -t F -x F -o F')
!!       !
!!       ! show the results
!!       print all,'--switch_X or -X ... ',lget('switch_X')
!!       print all,'--switch_Y or -Y ... ',lget('switch_Y')
!!       print all,'--ox or -O       ... ',lget('ox')
!!       print all,'-o               ... ',lget('o')
!!       print all,'-x               ... ',lget('x')
!!       print all,'-t               ... ',lget('t')
!!    end program demo_set_mode
!!
!!##AUTHOR
!!      John S. Urban, 2019
!!##LICENSE
!!      Public Domain
!===================================================================================================================================
elemental impure subroutine set_mode(key,mode)
character(len=*),intent(in)   :: key
logical,intent(in),optional   :: mode
logical                       :: local_mode
character(len=:),allocatable  :: debug_mode

   debug_mode= upper(get_env('CLI_DEBUG_MODE','FALSE'))//' '
   select case(debug_mode(1:1))
   case('Y','T')
      G_DEBUG=.true.
   end select

   if(present(mode))then
      local_mode=mode
   else
      local_mode=.true.
   endif

   select case(lower(key))
   case('response_file','response file'); CLI_RESPONSE_FILE=local_mode
   case('auto_response_file','auto response file'); CLI_AUTO_RESPONSE_FILE=local_mode
   case('debug');                         G_DEBUG=local_mode
   case('ignorecase','ignorelongcase');   G_IGNORELONGCASE=local_mode
   case('ignoreallcase');   G_IGNOREALLCASE=local_mode
   case('underdash','dashunder');         G_UNDERDASH=local_mode
   case('nodashunder','nounderdash');     G_NODASHUNDER=local_mode
   case('strict');                        G_STRICT=local_mode
   case('lastonly');                      G_APPEND=.not.local_mode
   case default
      call journal('*set_mode* unknown key name ',key)
   end select

   if(G_DEBUG)write(*,gen)'<DEBUG>SET_MODE:END'

end subroutine set_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine print_dictionary_usage()
   if(G_DEBUG)then
      call print_dictionary( str('response_file=', CLI_RESPONSE_FILE, &
                                &'ignorelongcase=', G_IGNORELONGCASE,&
                                &'ignoreallcase=', G_IGNOREALLCASE,&
                                &'underdash=', G_UNDERDASH,&
                                &'strict=', G_STRICT,&
                                &'lastonly=', G_APPEND,&
                                &'NODASHUNDER=', G_NODASHUNDER,&
                                &'debug=', G_DEBUG) )
   else
      call print_dictionary('USAGE:')
   endif
end subroutine print_dictionary_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_CLI2
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================

!>>>>> build/dependencies/M_list/src/M_list.f90
!>
!!##NAME
!!    M_list(3f) - [M_list::INTRO] maintain simple lists
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    use M_list, only : insert, replace, remove, locate
!!    use M_list, only : dictionary
!!
!!##DESCRIPTION
!!
!!    The M_list(3fm) module allows for maintaining an allocatable array of
!!    intrinsic type (REAL, INTEGER, CHARACTER) as a sorted list. An example
!!    is given that creates a keyword-value dictionary using the lists.
!!
!!    The lists are maintained as simple allocatable arrays. Each time an
!!    entry is added or deleted the array is re-allocated. Because of the
!!    expense of reallocating the data these routines are best suited for
!!    maintaining small lists that do not change size frequently.
!!
!!    The advantage of this simplistic approach is that the dictionary
!!    components are simple arrays of intrinsic types which can be easily
!!    accessed with standard routines. It is easy to understand, as it
!!    works with simple arrays. For more demanding applications this would
!!    be implemented as a linked list, which there are a number of freely
!!    available examples of; several are listed on the Fortran Wiki.
!!
!!    BASIC LIST
!!
!!    subroutine locate(list,value,place,ier,errmsg)  finds the index where a
!!                                                    value is found or should
!!                                                    be in a sorted array and
!!                                                    flag if the value exists
!!                                                    already
!!    subroutine insert(list,value,place)     insert entry into an allocatable
!!                                            array at specified position
!!    subroutine replace(list,value,place)    replace entry in an allocatable
!!                                            array at specified position
!!    subroutine remove(list,place)           remove entry from an allocatable
!!                                            array at specified position
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_M_list
!!    use M_list, only : insert, locate, replace, remove
!!    ! create a dictionary with character keywords, values, and value lengths
!!    ! using the routines for maintaining a list
!!
!!     use M_list, only : locate, insert, replace
!!     implicit none
!!     character(len=:),allocatable   :: keywords(:)
!!     character(len=:),allocatable   :: values(:)
!!     integer,allocatable            :: counts(:)
!!     integer                        :: i
!!     ! insert and replace entries
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>","[",a,"]",/))')&
!!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! remove some entries
!!     call update('a')
!!     call update('c')
!!     write(*,'(*(a,"==>","[",a,"]",/))')&
!!      & (trim(keywords(i)),values(i)(:counts(i)),i=1,size(keywords))
!!     ! get some values
!!     write(*,*)'get b=>',get('b')
!!     write(*,*)'get d=>',get('d')
!!     write(*,*)'get notthere=>',get('notthere')
!!     !
!!     contains
!!     subroutine update(key,valin)
!!     character(len=*),intent(in)           :: key
!!     character(len=*),intent(in),optional  :: valin
!!     integer                               :: place
!!     integer                               :: ilen
!!     character(len=:),allocatable          :: val
!!     if(present(valin))then
!!        val=valin
!!        ilen=len_trim(val)
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        ! if string was not found insert it
!!        if(place.lt.1)then
!!           call insert(keywords,key,iabs(place))
!!           call insert(values,val,iabs(place))
!!           call insert(counts,ilen,iabs(place))
!!        else
!!           call replace(values,val,place)
!!           call replace(counts,ilen,place)
!!        endif
!!     else
!!        call locate(keywords,key,place)
!!        if(place.gt.0)then
!!           call remove(keywords,place)
!!           call remove(values,place)
!!           call remove(counts,place)
!!        endif
!!     endif
!!     end subroutine update
!!     function get(key) result(valout)
!!     character(len=*),intent(in)   :: key
!!     character(len=:),allocatable  :: valout
!!     integer                       :: place
!!        ! find where string is or should be
!!        call locate(keywords,key,place)
!!        if(place.lt.1)then
!!           valout=''
!!        else
!!           valout=values(place)(:counts(place))
!!        endif
!!     end function get
!!     end program demo_M_list
!!
!!   Results
!!
!!       >  d==>[value of d]
!!       >  c==>[value of c again]
!!       >  b==>[value of b]
!!       >  a==>[value of a again]
!!       >
!!       > d==>[value of d]
!!       > b==>[value of b]
!!       >
!!       >  get b=>value of b
!!       >  get d=>value of d
!!       >  get notthere=>
!!
!!
!!    BASIC DICTIONARY
!!
!!    A basic dictionary that uses the basic M_list functions.
!!
!!    Consider using generic linked-list based dictionaries when heavy
!!    usage is required, now that that is available in more recent versions
!!    of Fortran.
!!
!!    Note: this does not work with gfortran(1) up to at least 7.4.0 but
!!    works from at least 10.3.0 and onward.
!!
!!    Dictionary type definition:
!!
!!       type dictionary
!!          character(len=:),allocatable :: key(:)
!!          character(len=:),allocatable :: value(:)
!!          integer,allocatable          :: count(:)
!!          contains
!!             procedure,public :: get => dict_get
!!             procedure,public :: set => dict_add
!!             procedure,public :: del => dict_delete
!!             procedure,public :: clr => dict_clear
!!       end type dictionary
!!
!!       %get      get value from type(dictionary) given an existing key
!!       %set      set or replace value for type(dictionary) given a key
!!       %del      delete an existing key from type(dictionary)
!!       %clr      empty a type(dictionary)
!!       %ifdef    test if name is defined
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!       program test_dictionary
!!       use M_list, only : dictionary
!!       implicit none
!!       type(dictionary)             :: table
!!         !
!!         ! create a character string dictionary
!!         !
!!         call table%set('A','aye')
!!         call table%set('B','bee')
!!         call table%set('C','see')
!!         call table%set('D','dee')
!!         !
!!         write(*,*)'A=',table%get('A')
!!         write(*,*)'C=',table%get('C')
!!         write(*,*)'notthere=',table%get('notthere')
!!         !
!!         call print_dict()
!!         !
!!         ! delete dictionary entries
!!         !
!!         call  table%del('A')
!!         call  table%del('C')
!!         call  table%del('z') ! a noop as there is no key of 'z'
!!         !
!!         call print_dict()
!!         !
!!         ! clear dictionary
!!         !
!!         call  table%clr()
!!         !
!!         call print_dict()
!!       !
!!       contains
!!       !
!!       subroutine print_dict()
!!       integer :: i
!!          ! the dictionary is just three arrays
!!          write(*,'("DICTIONARY:")')
!!          write(*,'(*(a,"==>","[",a,"]",/))') &
!!          & (trim(table%key(i)),               &
!!          & table%value(i)(:table%count(i)),    &
!!          & i=1,size(table%key))
!!          !
!!       end subroutine print_dict
!!       !
!!       end program test_dictionary
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module M_list
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,stdout=>OUTPUT_UNIT    ! access computing environment
implicit none
private

public locate        ! [M_list] find PLACE in sorted character array where value can be found or should be placed
   private locate_c
   private locate_d
   private locate_r
   private locate_i
public insert        ! [M_list] insert entry into a sorted allocatable array at specified position
   private insert_c
   private insert_d
   private insert_r
   private insert_i
   private insert_l
public replace       ! [M_list] replace entry by index from a sorted allocatable array if it is present
   private replace_c
   private replace_d
   private replace_r
   private replace_i
   private replace_l
public remove        ! [M_list] delete entry by index from a sorted allocatable array if it is present
   private remove_c
   private remove_d
   private remove_r
   private remove_i
   private remove_l

! ident_1="@(#) M_list locate(3f) Generic subroutine locates where element is or should be in sorted allocatable array"
interface locate
   module procedure locate_c, locate_d, locate_r, locate_i
end interface

! ident_2="@(#) M_list insert(3f) Generic subroutine inserts element into allocatable array at specified position"
interface insert
   module procedure insert_c, insert_d, insert_r, insert_i, insert_l
end interface

! ident_3="@(#) M_list replace(3f) Generic subroutine replaces element from allocatable array at specified position"
interface replace
   module procedure replace_c, replace_d, replace_r, replace_i, replace_l
end interface

! ident_4="@(#) M_list remove(3f) Generic subroutine deletes element from allocatable array at specified position"
interface remove
   module procedure remove_c, remove_d, remove_r, remove_i, remove_l
end interface

!-----------------------------------------------------------------------------------------------------------------------------------
public dictionary

type dictionary
   character(len=:),allocatable :: key(:)
   character(len=:),allocatable :: value(:)
   integer,allocatable          :: count(:)
   contains
      procedure,public :: get   => dict_get    ! get value associated with a key in a dictionary or return blank
      procedure,public :: set   => dict_add    ! insert or replace entry by name into a dictionary
      procedure,public :: del   => dict_delete ! delete entry by name from a dictionary if entry is present
      procedure,public :: clr   => dict_clear  ! clear dictionary
      procedure,public :: ifdef => dict_ifdef  ! return if defined or not
end type dictionary

logical,save :: debug=.false.
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    locate(3f) - [M_list] finds the index where a string is found or
!!                 should be in a sorted array
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine locate(list,value,place,ier,errmsg)
!!
!!    character(len=:)|doubleprecision|real|integer,allocatable :: list(:)
!!    character(len=*)|doubleprecision|real|integer,intent(in)  :: value
!!    integer, intent(out)                  :: PLACE
!!
!!    integer, intent(out),optional         :: IER
!!    character(len=*),intent(out),optional :: ERRMSG
!!
!!##DESCRIPTION
!!
!!    LOCATE(3f) finds the index where the VALUE is found or should
!!    be found in an array. The array must be sorted in descending
!!    order (highest at top). If VALUE is not found it returns the index
!!    where the name should be placed at with a negative sign.
!!
!!    The array and list must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL,INTEGER)
!!
!!##OPTIONS
!!
!!    VALUE         the value to locate in the list.
!!    LIST          is the list array.
!!
!!##RETURNS
!!    PLACE         is the subscript that the entry was found at if it is
!!                  greater than zero(0).
!!
!!                  If PLACE is negative, the absolute value of
!!                  PLACE indicates the subscript value where the
!!                  new entry should be placed in order to keep the
!!                  list alphabetized.
!!
!!    IER           is zero(0) if no error occurs.
!!                  If an error occurs and IER is not
!!                  present, the program is stopped.
!!
!!    ERRMSG        description of any error
!!
!!##EXAMPLES
!!
!!   Find if a string is in a sorted array, and insert the string into
!!   the list if it is not present ...
!!
!!     program demo_locate
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate
!!     implicit none
!!     character(len=:),allocatable  :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, plus, ii, end
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     write(*,*)'for "'//string//'" index is ',place, size(arr)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        plus=abs(place)
!!        ii=len(arr)
!!        end=size(arr)
!!        ! empty array
!!        if(end.eq.0)then
!!           arr=[character(len=ii) :: string ]
!!        ! put in front of array
!!        elseif(plus.eq.1)then
!!           arr=[character(len=ii) :: string, arr]
!!        ! put at end of array
!!        elseif(plus.eq.end)then
!!           arr=[character(len=ii) :: arr, string ]
!!        ! put in middle of array
!!        else
!!           arr=[character(len=ii) :: arr(:plus-1), string,arr(plus:) ]
!!        endif
!!        ! show array
!!        write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     endif
!!     end subroutine update
!!     end program demo_locate
!!
!!   Results
!!
!!       >  for "b" index is            2           5
!!       >  for "[" index is           -4           5
!!       > SIZE=5 xxx,b,aaa,[,ZZZ,
!!       >  for "c" index is           -2           6
!!       > SIZE=6 xxx,c,b,aaa,[,ZZZ,
!!       >  for "ZZ" index is           -7           7
!!       > SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!       >  for "ZZZZ" index is           -6           8
!!       > SIZE=8 xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!       >  for "z" index is           -1           9
!!       > SIZE=9 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine locate_c(list,value,place,ier,errmsg)

! ident_5="@(#) M_list locate_c(3f) find PLACE in sorted character array where VALUE can be found or should be placed"

character(len=*),intent(in)             :: value
integer,intent(out)                     :: place
character(len=:),allocatable            :: list(:)
integer,intent(out),optional            :: ier
character(len=*),intent(out),optional   :: errmsg
integer                                 :: i
character(len=:),allocatable            :: message
integer                                 :: arraysize
integer                                 :: maxtry
integer                                 :: imin, imax
integer                                 :: error
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_c* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',trim(value)//' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_c* END PLACE=',place,' ARRAYSIZE=',size(list),' LENGTH=',len(list)
end subroutine locate_c
subroutine locate_d(list,value,place,ier,errmsg)

! ident_6="@(#) M_list locate_d(3f) find PLACE in sorted doubleprecision array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

doubleprecision,allocatable            :: list(:)
doubleprecision,intent(in)             :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   message=''
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_d* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_d* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_d
subroutine locate_r(list,value,place,ier,errmsg)

! ident_7="@(#) M_list locate_r(3f) find PLACE in sorted real array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

real,allocatable                       :: list(:)
real,intent(in)                        :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[real :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_r* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_r* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_r
subroutine locate_i(list,value,place,ier,errmsg)

! ident_8="@(#) M_list locate_i(3f) find PLACE in sorted integer array where VALUE can be found or should be placed"

! Assuming an array sorted in descending order
!
!  1. If it is not found report where it should be placed as a NEGATIVE index number.

integer,allocatable                    :: list(:)
integer,intent(in)                     :: value
integer,intent(out)                    :: place
integer,intent(out),optional           :: ier
character(len=*),intent(out),optional  :: errmsg

integer                                :: i
character(len=:),allocatable           :: message
integer                                :: arraysize
integer                                :: maxtry
integer                                :: imin, imax
integer                                :: error

   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   arraysize=size(list)
   if(debug)write(stderr,*)'*locate_i* START ARRAYSIZE=',size(list)

   error=0
   if(arraysize.eq.0)then
      maxtry=0
      place=-1
   else
      maxtry=nint(log(float(arraysize))/log(2.0)+1.0)
      place=(arraysize+1)/2
   endif
   imin=1
   imax=arraysize
   message=''

   LOOP: block
   do i=1,maxtry

      if(value.eq.list(PLACE))then
         exit LOOP
      else if(value.gt.list(place))then
         imax=place-1
      else
         imin=place+1
      endif

      if(imin.gt.imax)then
         place=-imin
         if(iabs(place).gt.arraysize)then ! ran off end of list. Where new value should go or an unsorted input array'
            exit LOOP
         endif
         exit LOOP
      endif

      place=(imax+imin)/2

      if(place.gt.arraysize.or.place.le.0)then
         message='*locate* error: search is out of bounds of list. Probably an unsorted input array'
         error=-1
         exit LOOP
      endif

   enddo
   message='*locate* exceeded allowed tries. Probably an unsorted input array'
   endblock LOOP
   if(present(ier))then
      ier=error
   else if(error.ne.0)then
      write(stderr,*)message//' VALUE=',value,' PLACE=',place
      stop 1
   endif
   if(present(errmsg))then
      errmsg=message
   endif
   if(debug)write(stderr,*)'*locate_i* END PLACE=',place,' ARRAYSIZE=',size(list)
end subroutine locate_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    remove(3f) - [M_list] remove entry from an allocatable array at
!!                 specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine remove(list,place)
!!
!!    character(len=:)|doubleprecision|real|integer,intent(inout) :: list(:)
!!    integer, intent(out) :: PLACE
!!
!!##DESCRIPTION
!!
!!    Remove a value from an allocatable array at the specified index.
!!    The array is assumed to be sorted in descending order. It may be of
!!    type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!
!!##OPTIONS
!!
!!    list    is the list array.
!!    PLACE   is the subscript for the entry that should be removed
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     program demo_remove
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate, remove
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!     integer                       :: end
!!
!!     arr=[character(len=20) :: '','ZZZ','Z','aaa','b','b','ab','bb','xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,1)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!     call remove(arr,4)
!!     end=size(arr)
!!     write(*,'("SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end program demo_remove
!!
!!   Results
!!
!!       > SIZE=9 xxx,bb,b,b,ab,aaa,ZZZ,Z,,
!!       > SIZE=8 bb,b,b,ab,aaa,ZZZ,Z,,
!!       > SIZE=7 bb,b,b,aaa,ZZZ,Z,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine remove_c(list,place)

! ident_9="@(#) M_list remove_c(3fp) remove string from allocatable string array at specified position"

character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii, end
   if(debug) write(stderr,*)'*remove_c* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=2) :: ]
   endif
   ii=len(list)
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[character(len=ii) :: list(:place-1) ]
   else
      list=[character(len=ii) :: list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_c* END PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine remove_c
subroutine remove_d(list,place)

! ident_10="@(#) M_list remove_d(3fp) remove doubleprecision value from allocatable array at specified position"

doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*remove_d* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_d* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_d
subroutine remove_r(list,place)

! ident_11="@(#) M_list remove_r(3fp) remove value from allocatable array at specified position"

real,allocatable    :: list(:)
integer,intent(in)  :: place
integer             :: end
   if(debug) write(stderr,*)'*remove_r* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_r* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_r
subroutine remove_l(list,place)

! ident_12="@(#) M_list remove_l(3fp) remove value from allocatable array at specified position"

logical,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_l* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_l* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_l
subroutine remove_i(list,place)

! ident_13="@(#) M_list remove_i(3fp) remove value from allocatable array at specified position"
integer,allocatable    :: list(:)
integer,intent(in)     :: place
integer                :: end

   if(debug) write(stderr,*)'*remove_i* START PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(place.le.0.or.place.gt.end)then                       ! index out of bounds of array
   elseif(place.eq.end)then                                 ! remove from array
      list=[ list(:place-1)]
   else
      list=[ list(:place-1), list(place+1:) ]
   endif
   if(debug)write(stderr,*)'*remove_i* END PLACE=',place,' NEWSIZE=',size(list)

end subroutine remove_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    replace(3f) - [M_list] replace entry in a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine replace(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer, intent(out)          :: PLACE
!!
!!##DESCRIPTION
!!
!!    replace a value in an allocatable array at the specified index. Unless
!!    the array needs the string length to increase this is merely an assign
!!    of a value to an array element.
!!
!!    The array may be of type CHARACTER, DOUBLEPRECISION, REAL, or INTEGER.
!!    It is assumed to be sorted in descending order without duplicate
!!    values.
!!
!!    The value and list must be of the same type.
!!
!!##OPTIONS
!!
!!    VALUE         the value to place in the array
!!    LIST          is the array.
!!    PLACE         is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!   Replace key-value pairs in a dictionary
!!
!!     program demo_replace
!!     use M_list, only  : insert, locate, replace
!!     ! Find if a key is in a list and insert it
!!     ! into the key list and value list if it is not present
!!     ! or replace the associated value if the key existed
!!     implicit none
!!     character(len=20)            :: key
!!     character(len=100)           :: val
!!     character(len=:),allocatable :: keywords(:)
!!     character(len=:),allocatable :: values(:)
!!     integer                      :: i
!!     integer                      :: place
!!     call update('b','value of b')
!!     call update('a','value of a')
!!     call update('c','value of c')
!!     call update('c','value of c again')
!!     call update('d','value of d')
!!     call update('a','value of a again')
!!     ! show array
!!     write(*,'(*(a,"==>",a,/))')&
!!            &(trim(keywords(i)),trim(values(i)),i=1,size(keywords))
!!
!!     call locate(keywords,'a',place)
!!     if(place.gt.0)then
!!        write(*,*)'The value of "a" is ',trim(values(place))
!!     else
!!        write(*,*)'"a" not found'
!!     endif
!!
!!     contains
!!     subroutine update(key,val)
!!     character(len=*),intent(in)  :: key
!!     character(len=*),intent(in)  :: val
!!     integer                      :: place
!!
!!     ! find where string is or should be
!!     call locate(keywords,key,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(keywords,key,abs(place))
!!        call insert(values,val,abs(place))
!!     else ! replace
!!        call replace(values,val,place)
!!     endif
!!
!!     end subroutine update
!!    end program demo_replace
!!
!!   Results
!!
!!    > d==>value of d
!!    > c==>value of c again
!!    > b==>value of b
!!    > a==>value of a again
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine replace_c(list,value,place)

! ident_14="@(#) M_list replace_c(3fp) replace string in allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
character(len=:),allocatable :: kludge(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: tlen
integer                      :: end
   if(debug) write(stderr,*)'*replace_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif
   tlen=len_trim(value)
   end=size(list)
   if(place.lt.0.or.place.gt.end)then
           write(stderr,*)'*replace_c* error: index out of range. end=',end,' index=',place
   elseif(len_trim(value).le.len(list))then
      list(place)=value
   else  ! increase length of variable
      ii=max(tlen,len(list))
      kludge=[character(len=ii) :: list ]
      list=kludge
      list(place)=value
   endif
   if(debug)write(stderr,*)'*replace_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list),' LENGTH=',len(list)
end subroutine replace_c
subroutine replace_d(list,value,place)

! ident_15="@(#) M_list replace_d(3fp) place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)   :: value
doubleprecision,allocatable  :: list(:)
integer,intent(in)           :: place
integer                      :: end
   if(debug) write(stderr,*)'*replace_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
           list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_d* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_d
subroutine replace_r(list,value,place)

! ident_16="@(#) M_list replace_r(3fp) place value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(debug) write(stderr,*)'*replace_r* START REPLACE_R VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_r* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_r* END REPLACE_R VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_r
subroutine replace_l(list,value,place)

! ident_17="@(#) M_list replace_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_l* START REPLACE_L VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_l* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_l* END REPLACE_L VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_l
subroutine replace_i(list,value,place)

! ident_18="@(#) M_list replace_i(3fp) place value into allocatable array at specified position"

integer,intent(in)    :: value
integer,allocatable   :: list(:)
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*replace_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.gt.0.and.place.le.end)then
      list(place)=value
   else                                                      ! put in middle of array
      write(stderr,*)'*replace_i* error: index out of range. end=',end,' index=',place
   endif
   if(debug)write(stderr,*)'*replace_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine replace_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    insert(3f) - [M_list] insert entry into a string array at specified position
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine insert(list,value,place)
!!
!!    character(len=*)|doubleprecision|real|integer,intent(in) :: value
!!    character(len=:)|doubleprecision|real|integer,intent(in) :: list(:)
!!    integer,intent(in)    :: place
!!
!!##DESCRIPTION
!!
!!    Insert a value into an allocatable array at the specified index.
!!    The list and value must be of the same type (CHARACTER, DOUBLEPRECISION,
!!    REAL, or INTEGER)
!!
!!##OPTIONS
!!
!!    list    is the list array. Must be sorted in descending order.
!!    value   the value to place in the array
!!    PLACE   is the subscript that the entry should be placed at
!!
!!##EXAMPLES
!!
!!   Find if a string is in a sorted array, and insert the string into
!!   the list if it is not present ...
!!
!!     program demo_insert
!!     use M_sort, only : sort_shell
!!     use M_list, only : locate, insert
!!     implicit none
!!     character(len=:),allocatable :: arr(:)
!!     integer                       :: i
!!
!!     arr=[character(len=20) :: '', 'ZZZ', 'aaa', 'b', 'xxx' ]
!!     ! make sure sorted in descending order
!!     call sort_shell(arr,order='d')
!!     ! add or replace values
!!     call update(arr,'b')
!!     call update(arr,'[')
!!     call update(arr,'c')
!!     call update(arr,'ZZ')
!!     call update(arr,'ZZZ')
!!     call update(arr,'ZZZZ')
!!     call update(arr,'')
!!     call update(arr,'z')
!!
!!     contains
!!     subroutine update(arr,string)
!!     character(len=:),allocatable :: arr(:)
!!     character(len=*)             :: string
!!     integer                      :: place, end
!!
!!     end=size(arr)
!!     ! find where string is or should be
!!     call locate(arr,string,place)
!!     ! if string was not found insert it
!!     if(place.lt.1)then
!!        call insert(arr,string,abs(place))
!!     endif
!!     ! show array
!!     end=size(arr)
!!     write(*,'("array is now SIZE=",i0,1x,*(a,","))')end,(trim(arr(i)),i=1,end)
!!
!!     end subroutine update
!!     end program demo_insert
!!
!!   Results
!!
!!        > array is now SIZE=5 xxx,b,aaa,ZZZ,,
!!        > array is now SIZE=6 xxx,b,aaa,[,ZZZ,,
!!        > array is now SIZE=7 xxx,c,b,aaa,[,ZZZ,,
!!        > array is now SIZE=8 xxx,c,b,aaa,[,ZZZ,ZZ,,
!!        > array is now SIZE=9 xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!        > array is now SIZE=10 z,xxx,c,b,aaa,[,ZZZZ,ZZZ,ZZ,,
!!
!!##AUTHOR
!!    1989,2017 John S. Urban
!!##LICENSE
!!    Public Domain
subroutine insert_c(list,value,place)

! ident_19="@(#) M_list insert_c(3fp) place string into allocatable string array at specified position"

character(len=*),intent(in)  :: value
character(len=:),allocatable :: list(:)
integer,intent(in)           :: place
integer                      :: ii
integer                      :: end
   if(debug) write(stderr,*)'*insert_c* START VALUE=',trim(value),' PLACE=',place,' ORIGINALSIZE=',size(list)

   if(.not.allocated(list))then
      list=[character(len=max(len_trim(value),2)) :: ]
   endif

   ii=max(len_trim(value),len(list),2)
   end=size(list)
   !call slower()
   call faster(ii)
   if(debug)write(stderr,*)'*insert_c* END VALUE=',trim(value),' PLACE=',place,' NEWSIZE=',size(list)
contains

subroutine slower()
character(len=:),allocatable :: kludge(:)
   if(end.eq.0)then                                          ! empty array
      list=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      kludge=[character(len=ii) :: value, list]
      list=kludge
   elseif(place.gt.end)then                                  ! put at end of array
      kludge=[character(len=ii) :: list, value ]
      list=kludge
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      kludge=[character(len=ii) :: list(:place-1), value,list(place:) ]
      list=kludge
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif
end subroutine slower

subroutine faster(ilen)
integer,intent(in) :: ilen
character(len=:),allocatable :: temp(:)
   allocate(character(len=ilen) :: temp(size(list)+1))
   if(end.eq.0)then                                          ! empty array
      temp(:)=[character(len=ii) :: value ]
   elseif(place.eq.1)then                                    ! put in front of array
      temp(1)=value
      temp(2:)=list
   elseif(place.gt.end)then                                  ! put at end of array
      temp(1:end)=list
      temp(end+1)=value
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      temp(:place-1)=list(:place-1)
      temp(place)=value
      temp(place+1:)=list(place:)
   else                                                      ! index out of range
      write(stderr,*)'*insert_c* error: index out of range. end=',end,' index=',place,' value=',value
   endif
   call move_alloc (from=temp, to=list)
end subroutine faster

end subroutine insert_c
subroutine insert_r(list,value,place)

! ident_20="@(#) M_list insert_r(3fp) place real value into allocatable array at specified position"

real,intent(in)       :: value
real,allocatable      :: list(:)
integer,intent(in)    :: place
integer               :: end

   if(debug) write(stderr,*)'*insert_r* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[real :: ]
   endif

   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                   ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_r* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_r* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_r
subroutine insert_d(list,value,place)

! ident_21="@(#) M_list insert_d(3fp) place doubleprecision value into allocatable array at specified position"

doubleprecision,intent(in)       :: value
doubleprecision,allocatable      :: list(:)
integer,intent(in)               :: place
integer                          :: end
   if(debug) write(stderr,*)'*insert_d* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(.not.allocated(list))then
      list=[doubleprecision :: ]
   endif
   end=size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_d* error: index out of range. end=',end,' index=',place,' value=',value
   endif
   if(debug)write(stderr,*)'*insert_d* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_d
subroutine insert_l(list,value,place)

! ident_22="@(#) M_list insert_l(3fp) place value into allocatable array at specified position"

logical,allocatable   :: list(:)
logical,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[logical :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_l* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_l* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_l* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_l
subroutine insert_i(list,value,place)

! ident_23="@(#) M_list insert_i(3fp) place value into allocatable array at specified position"

integer,allocatable   :: list(:)
integer,intent(in)    :: value
integer,intent(in)    :: place
integer               :: end
   if(.not.allocated(list))then
      list=[integer :: ]
   endif
   end=size(list)
   if(debug)write(stderr,*)'*insert_i* START VALUE=',value,' PLACE=',place,' ORIGINALSIZE=',size(list)
   if(end.eq.0)then                                          ! empty array
      list=[value]
   elseif(place.eq.1)then                                    ! put in front of array
      list=[value, list]
   elseif(place.gt.end)then                                  ! put at end of array
      list=[list, value ]
   elseif(place.ge.2.and.place.le.end)then                 ! put in middle of array
      list=[list(:place-1), value,list(place:) ]
   else                                                      ! index out of range
      write(stderr,*)'*insert_i* error: index out of range. end=',end,' index=',place,' value=',value
   endif

   if(debug)write(stderr,*)'*insert_i* END VALUE=',value,' PLACE=',place,' NEWSIZE=',size(list)
end subroutine insert_i
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    del(3f) - [M_list::dictionary::OOPS] delete entry by key name from
!!              a basic dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!
!!    dict%del(key)
!!
!!##DESCRIPTION
!!
!!    Delete an entry from a basic dictionary if it is present.
!!
!!##OPTIONS
!!
!!    DICT   the dictionary.
!!    KEY    the key name to find and delete from the dictionary.
!!
!!##EXAMPLES
!!
!!   Delete an entry from a dictionary by key name.
!!
!!     program demo_del
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: caps
!!     integer                       :: i
!!        ! create a character string dictionary
!!        call caps%set('A','aye')
!!        call caps%set('B','bee')
!!        call caps%set('C','see')
!!        call caps%set('D','dee')
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!        ! delete dictionary entries
!!        call  caps%del('A')
!!        call  caps%del('C')
!!        call  caps%del('z') ! a noop as there is no key of 'z'
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!
!!     101 format (1x,*(a,"='",a,"'",:,","))
!!     end program demo_del
!!
!!   Results
!!
!!        > D='dee',C='see',B='bee',A='aye'
!!        > D='dee',B='bee'
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_delete(self,key)

! ident_24="@(#) M_list dict_delete(3f) remove string from sorted allocatable string array if present"

class(dictionary),intent(in) :: self
character(len=*),intent(in)  :: key
integer                      :: place

   call locate(self%key,key,place)
   if(place.ge.1)then
      call remove(self%key,place)
      call remove(self%value,place)
      call remove(self%count,place)
   endif

end subroutine dict_delete
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    get(3f) - [M_list::dictionary::OOPS] get value of key-value pair in
!!              a dictionary given key
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!    value=dict%get(key)
!!
!!
!!##DESCRIPTION
!!
!!    get a value given a key from a key-value dictionary
!!
!!    If key is not found in dictionary , return a blank
!!
!!##OPTIONS
!!
!!    DICT     is the dictionary.
!!    KEY      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_get
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary)             :: table
!!     character(len=:),allocatable :: val
!!     integer                      :: i
!!
!!        call table%set('A','value for A')
!!        call table%set('B','value for B')
!!        call table%set('C','value for C')
!!        call table%set('D','value for D')
!!        call table%set('E','value for E')
!!        call table%set('F','value for F')
!!        call table%set('G','value for G')
!!
!!        write(*,*)'A=',table%get('A')
!!        write(*,*)'B=',table%get('B')
!!        write(*,*)'C=',table%get('C')
!!        write(*,*)'D=',table%get('D')
!!        write(*,*)'E=',table%get('E')
!!        write(*,*)'F=',table%get('F')
!!        write(*,*)'G=',table%get('G')
!!        write(*,*)'H=',table%get('H')
!!
!!      end program demo_get
!!
!!   Results
!!
!!       >  A=value for A
!!       >  B=value for B
!!       >  C=value for C
!!       >  D=value for D
!!       >  E=value for E
!!       >  F=value for F
!!       >  G=value for G
!!       >  H=
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function dict_get(self,key) result(value)

! ident_25="@(#) M_list dict_get(3f) get value of key-value pair in dictionary given key"

class(dictionary),intent(in)    :: self
character(len=*),intent(in)     :: key
character(len=:),allocatable    :: value
integer                         :: place
   call locate(self%key,key,place)
   if(place.lt.1)then
      value=''
   else
      value=self%value(place)(:self%count(place))
   endif
end function dict_get
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    set(3f) - [M_list::dictionary::OOPS] add or replace a key-value pair
!!              in a dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    character(len=*),intent(in) :: VALUE
!!
!!    call dict%rep(key,value)
!!
!!##DESCRIPTION
!!    Add or replace a key-value pair in a dictionary.
!!
!!##OPTIONS
!!    DICT     is the dictionary.
!!    key      key name
!!    VALUE    value associated with key
!!
!!##EXAMPLES
!!
!!   Add or replace a key and value pair in a dictionary
!!
!!     program demo_set
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: dict
!!     integer          :: i
!!
!!         call dict%set('A','b')
!!         call dict%set('B','^')
!!         call dict%set('C',' ')
!!         call dict%set('D','c')
!!         call dict%set('E','ZZ')
!!         call dict%set('F','ZZZZ')
!!         call dict%set('G','z')
!!         call dict%set('A','new value for A')
!!
!!         write(*,'(*(a,"==>","[",a,"]",/))') &
!!          & (trim(dict%key(i)),              &
!!          & dict%value(i)(:dict%count(i)),   &
!!          & i=1,size(dict%key))
!!
!!      end program demo_set
!!
!!   Results
!!
!!       > G==>[z]
!!       > F==>[ZZZZ]
!!       > E==>[ZZ]
!!       > D==>[c]
!!       > C==>[]
!!       > B==>[^]
!!       > A==>[new value for A]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_add(self,key,value)

! ident_26="@(#) M_list dict_add(3f) place key-value pair into dictionary adding the key if required"

class(dictionary),intent(inout) :: self
character(len=*),intent(in)     :: key
character(len=*),intent(in)     :: value
integer                         :: place
integer                         :: place2
   call locate(self%key,key,place)
   if(place.le.0)then
      place2=iabs(place)
      call insert( self%key,   key,             place2 )
      call insert( self%value, value,           place2 )
      call insert( self%count, len_trim(value), place2 )
   elseif(place.gt.0)then  ! replace instead of insert
      call replace( self%value, value,           place )
      call replace( self%count, len_trim(value), place )
   endif
end subroutine dict_add
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    clr(3f) - [M_list::dictionary::OOPS] clear basic dictionary
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    call dict%clr()
!!
!!##DESCRIPTION
!!
!!    clear a basic dictionary.
!!
!!##OPTIONS
!!
!!    DICT   the dictionary.
!!
!!##EXAMPLES
!!
!!   create and clear a basic dictionary
!!
!!     program demo_clr
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary) :: caps
!!     integer                       :: i
!!        ! create a character string dictionary
!!        call caps%set('A','aye')
!!        call caps%set('B','bee')
!!        call caps%set('C','see')
!!        call caps%set('D','dee')
!!        ! show current dictionary
!!        write(*,'("DICTIONARY BEFORE CLEARED")')
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!        call  caps%clr()
!!        write(*,'("DICTIONARY AFTER CLEARED")')
!!        ! show current dictionary
!!        write(*,101)(trim(caps%key(i)),trim(caps%value(i)),i=1,size(caps%key))
!!
!!     101 format (1x,*(a,"='",a,"'",:,","))
!!     end program demo_clr
!!
!!   Results
!!
!!       > DICTIONARY BEFORE CLEARED
!!       >  D='dee',C='see',B='bee',A='aye'
!!       > DICTIONARY AFTER CLEARED
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine dict_clear(self)

! ident_27="@(#) M_list dict_clear(3f) clear basic dictionary"

class(dictionary),intent(inout) :: self
integer                         :: i

   do i=size(self%key),1,-1
      call self%del(self%key(i))
   enddo

end subroutine dict_clear
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!>
!!##NAME
!!    ifdef(3f) - [M_list::dictionary::OOPS] return whether name is present
!!                in dictionary or not
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   type(dictionary) :: dict
!!
!!    character(len=*),intent(in) :: key
!!    logical :: value
!!
!!    value=dict%ifdef(key)
!!
!!
!!##DESCRIPTION
!!
!!    determine if name is already defined in dictionary or not
!!
!!##OPTIONS
!!
!!    DICT     is the dictionary.
!!    KEY      key name
!!
!!##RETURNS
!!    VALUE    .FALSE. if name not defined, .TRUE if name is defined.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_ifdef
!!     use M_list, only : dictionary
!!     implicit none
!!     type(dictionary)             :: table
!!     character(len=:),allocatable :: val
!!     integer                      :: i
!!
!!        call table%set('A','value for A')
!!        call table%set('B','value for B')
!!        call table%set('C','value for C')
!!        call table%set('D','value for D')
!!        call table%set('E','value for E')
!!        call table%set('F','value for F')
!!        call table%set('G','value for G')
!!        call table%del('F')
!!        call table%del('D')
!!
!!        write(*,*)'A=',table%ifdef('A')
!!        write(*,*)'B=',table%ifdef('B')
!!        write(*,*)'C=',table%ifdef('C')
!!        write(*,*)'D=',table%ifdef('D')
!!        write(*,*)'E=',table%ifdef('E')
!!        write(*,*)'F=',table%ifdef('F')
!!        write(*,*)'G=',table%ifdef('G')
!!        write(*,*)'H=',table%ifdef('H')
!!
!!      end program demo_ifdef
!!
!!   Results:
!!
!!     > A= T
!!     > B= T
!!     > C= T
!!     > D= F
!!     > E= T
!!     > F= F
!!     > G= T
!!     > H= F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function dict_ifdef(self,key) result(value)

! ident_28="@(#) M_list dict_ifdef(3f) return whether name is defined or not"

class(dictionary),intent(in)    :: self
character(len=*),intent(in)     :: key
logical                         :: value
integer                         :: place
   call locate(self%key,key,place)
   if(place.lt.1)then
      value=.false.
   else
      value=.true.
   endif
end function dict_ifdef
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_list
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================

!>>>>> build/dependencies/M_io/src/M_io.F90
!===================================================================================================================================
MODULE M_io
use, intrinsic :: iso_fortran_env, only : stdin=>input_unit, stdout=>output_unit, stderr=>error_unit

#ifdef __NVCOMPILER
#define NOREAL128
#else
#undef NOREAL128
#endif
implicit none
private
integer,parameter,private:: sp=kind(1.0), dp=kind(1.0d0)
public uniq
public print_inquire
public notopen
public filename_generator
public number_of_lines
public get_next_char
public dirname
public basename
public splitpath
public joinpath
public fileopen
public filebyte, slurp
public fileread, gulp, swallow
public filewrite
public fileclose
public filedelete
public get_tmp
public read_line
public getline
public read_table
public rd
public separator
public lookfor
public which
public get_env
public is_hidden_file
public getname

! ident_1="@(#) M_io rd(3f) ask for string or number from standard input with user-definable prompt"
interface rd
   module procedure rd_character
   module procedure rd_integer
   module procedure rd_real
   module procedure rd_doubleprecision
   module procedure rd_logical
end interface

! ident_2="@(#) M_io read_table(3f) read file containing a table of numeric values"
interface read_table
   module procedure read_table_i
   module procedure read_table_r
   module procedure read_table_d
end interface

interface filedelete
   module procedure filedelete_filename
   module procedure filedelete_lun
end interface

integer,save,private       :: my_stdout=stdout
logical,save               :: debug=.false.
integer,save               :: last_int=0

interface string_to_value
   module procedure a2d, a2i
end interface

interface v2s
   module procedure i2s
end interface

interface journal
   !!module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   !!module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

interface str
   module procedure msg_scalar, msg_one
end interface str
character(len=*),parameter,private :: gen='(*(g0,1x))'

interface get_env
   module procedure get_env_integer
   module procedure get_env_real
   module procedure get_env_double
   module procedure get_env_character
   module procedure get_env_logical
end interface get_env

type :: force_keywd_hack  ! force keywords, using @awvwgk method
end type force_keywd_hack
! so then any argument that comes afer "force_keywd" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_keywd_hack), optional, intent(in) :: force_keywd
!-----------------------------------
! old names
interface swallow;  module procedure fileread;  end interface
interface gulp;     module procedure fileread;  end interface
interface slurp;    module procedure filebyte;  end interface
interface readenv
   module procedure get_env_integer
   module procedure get_env_real
   module procedure get_env_double
   module procedure get_env_character
   module procedure get_env_logical
end interface readenv
public readenv
!-----------------------------------

CONTAINS
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      uniq(3f) - [M_io:QUERY] append a number to the end of filename to make
!!                 a unique name if name exists
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!      Usage
!!
!!       character(len=:),allocatable function uniq(name,istart,verbose,create)
!!       character(len=*),intent(in) :: name
!!       integer,intent(in),optional :: istart
!!       logical,intent(in),optional :: verbose
!!       logical,intent(in),optional :: create
!!
!!##DESCRIPTION
!!    Given a filename test if it is in use or exists. If it is, or if it
!!    ends in a period add a number to the end of the name and
!!    test if the new name exists. If necessary, increment the number and
!!    try again up to the value 9999999. By default an empty file is created
!!    if an unused name is found.
!!
!!
!!##OPTIONS
!!    name     base input name used to create output filename
!!             If name ends in "." a numeric suffix is always added.
!!    istart   number to start with as a suffix. Default is 1. Must be a
!!             positive integer less than 9999999.
!!    verbose  writes extra messages to stdout. Defaults to .false.
!!    create   create file if a new unused name is successfully
!!             found. Defaults to .true. .
!!
!!##RETURNS
!!    uniq     A unique filename that is the same as the NAME input parameter
!!             except with a number appended at the end if needed. If could
!!             not find a unique name a blank is returned.
!!
!!##EXAMPLE
!!
!!    Sample program
!!
!!       program demo_uniq
!!       use M_io, only : uniq
!!       implicit none
!!       character(len=4096) :: myname
!!       integer             :: i
!!          myname=uniq('does_not_exist')
!!          write(*,*)'name stays the same   :',trim(myname)
!!          open(unit=10,file='does_exist')
!!          myname=uniq('does_exist')
!!          write(*,*)'name has suffix added :',trim(myname)
!!          do i=1,10
!!             myname=uniq('does_exist')
!!             write(*,*) 'FILENAME:',trim(myname)
!!             open(unit=20+i,file=myname)
!!          enddo
!!       end program demo_uniq
!!
!!    Expected output
!!
!!     name stays the same does_not_exist
!!     name has suffix added does_exist0001
!!     FILENAME:does_exist0002
!!     FILENAME:does_exist0003
!!     FILENAME:does_exist0004
!!     FILENAME:does_exist0005
!!     FILENAME:does_exist0006
!!     FILENAME:does_exist0007
!!     FILENAME:does_exist0008
!!     FILENAME:does_exist0009
!!     FILENAME:does_exist0010
!!     FILENAME:does_exist0011
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!! Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
function uniq(name,istart,verbose,create)
implicit none

! ident_3="@(#) M_io uniq(3f) append a number to the end of filename to make a unique name if name exists"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: name
character(len=:),allocatable :: uniq
integer,intent(in),optional  :: istart
logical,intent(in),optional  :: verbose
logical,intent(in),optional  :: create
!-----------------------------------------------------------------------------------------------------------------------------------
logical                     :: around
integer,save                :: icount=1           ! counter to generate suffix from
character(len=4096),save    :: lastname=' '       ! name called with last time the routine was called
integer                     :: ilen
integer                     :: itimes
integer                     :: iscr
integer                     :: ios
logical                     :: verbose_local
logical                     :: create_local
!-----------------------------------------------------------------------------------------------------------------------------------
   uniq=trim(name)                                   ! the input name will be returned if it passes all the tests
!-----------------------------------------------------------------------------------------------------------------------------------
   if(lastname /= name)then                          ! if a different input name than last time called reset icount
      lastname=name                                  ! a new name to keep for subsequent calls
      icount=1                                       ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(create))then
      create_local=create
   else
      create_local=.true.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(istart))then
      icount=istart                                  ! icount is used to make a suffix to add to make the file unique
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len_trim(name)                               ! find last non-blank character in file name
!-----------------------------------------------------------------------------------------------------------------------------------
   if(ilen /= 0)then                                 ! a blank input name so name will just be a suffix
      if(name(ilen:ilen) /= '.')then                 ! always append a number to a file ending in .
         inquire(file=name(:ilen),exist=around)      ! check filename as-is
         if(.not.around)then                         ! file name does not exist, can use it as-is
            uniq=trim(name)
            if(create_local)then
               open(newunit=iscr,file=uniq,iostat=ios,status='new')
               close(unit=iscr,iostat=ios)
            endif
            return
         endif
      endif
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   itimes=0                                           ! count number of times tried to get a uniq name
   deallocate(uniq)
   allocate(character(len=ilen+8) :: uniq)            ! make it useable with an internal WRITE(3f) with room for a numeric suffix
   uniq(:)=name
   INFINITE: do                                       ! top of loop trying for a unique name
      if(itimes >= 9999999)then                       ! if too many tries to be reasonable give up
         call journal('sc','*uniq* unable to find a unique filename. Too many tries')
         uniq=''
         return
      endif
      if(icount > 9999999) icount=1                  ! reset ICOUNT when it hits arbitrary maximum value
      if(icount <= 9999)then
         write(uniq(ilen+1:),'(i4.4)')icount          ! create name by adding a numeric string to end
      else
         write(uniq(ilen+1:),'(i7.7)')icount          ! create name by adding a numeric string to end
      endif
      icount=icount+1                                 ! increment counter used to come up with suffix
      inquire(file=uniq,exist=around)                 ! see if this filename already exists
      if(.not.around)then                             ! found an unused name
         if(verbose_local)then
            call journal('c','*uniq* name='//trim(uniq)) ! write out message reporting name used
         endif
         if(create_local)then
            open(newunit=iscr,file=uniq,iostat=ios,status='new')
            close(unit=iscr,iostat=ios)
         endif
         uniq=trim(uniq)
         return                                       ! return successfully
      endif
      itimes=itimes+1                                 ! haven't found a unique name, try again
   enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
end function uniq
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    print_inquire(3f) - [M_io:QUERY] Do INQUIRE on file by name/number and
!!                        print results
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   Definition:
!!
!!    subroutine print_inquire(lun)
!!      or
!!    subroutine print_inquire(name)
!!    integer,intent(in),optional          :: lun
!!    character(len=*),intent(in),optional :: name
!!
!!##DESCRIPTION
!!    Given either a Fortran file-unit-number or filename, call the
!!    INQUIRE(3f) intrinsic and print typical status information.
!!
!!##OPTIONS
!!    lun    if lun is not equal to -1 then query by number and ignore
!!           filename even if present
!!    name   if lun = -1  or is not present then query by this filename
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_print_inquire
!!    use M_io, only : print_inquire, fileopen
!!    implicit none
!!    character(len=4096)  :: filename
!!    character(len=20)    :: mode
!!    integer              :: ios
!!    character(len=256)   :: message
!!    integer              :: lun
!!       do
!!          write(*,'(a)',advance='no')'enter filename>'
!!          read(*,'(a)',iostat=ios)filename
!!          if(ios /= 0)exit
!!          write(*,'(a)',advance='no')'enter mode ([rwa][bt][+]>'
!!          read(*,'(a)',iostat=ios)mode
!!          if(ios /= 0)exit
!!          lun=fileopen(filename,mode,ios)
!!          if(ios == 0)then
!!             write(*,*)'OPENED'
!!          else
!!             write(*,*)'ERROR: IOS=',ios
!!          endif
!!          if(lun /= -1)then
!!             call print_inquire(lun,'')
!!             close(lun,iostat=ios,iomsg=message)
!!             if(ios /= 0)then
!!                write(*,'(a)')trim(message)
!!             endif
!!          endif
!!       enddo
!!    end program demo_print_inquire
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine print_inquire(lun_in,namein_in) ! Version: JSU-1997-12-31, 2020-01-11

! ident_4="@(#) M_io print_inquire(3f) Do INQUIRE on file by name/number and print results"

integer,intent(in),optional             :: lun_in        ! if unit >= 0 then query by unit number, else by name
character(len=*),intent(in),optional    :: namein_in
integer                        :: ios
character(len=256)             :: message
character(len=:),allocatable   :: namein
integer                        :: lun
!==============================================================================================
!  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
!  ACTION    =  READ        | WRITE         |  READWRITE
!  FORM      =  FORMATTED   |  UNFORMATTED
!  POSITION  =  ASIS        |  REWIND       |  APPEND
!  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
character(len=20)             :: access         ; namelist/inquire/access
character(len=20)             :: asynchronous   ; namelist/inquire/asynchronous
character(len=20)             :: blank          ; namelist/inquire/blank
character(len=20)             :: decimal        ; namelist/inquire/decimal
character(len=20)             :: delim          ; namelist/inquire/delim
character(len=20)             :: direct         ; namelist/inquire/direct
character(len=20)             :: encoding       ; namelist/inquire/encoding
logical                       :: exist          ; namelist/inquire/exist

character(len=20)             :: form           ; namelist/inquire/form
character(len=20)             :: formatted      ; namelist/inquire/formatted
character(len=20)             :: unformatted    ; namelist/inquire/unformatted

integer                       :: id             ; namelist/inquire/id
character(len=20)             :: name           ; namelist/inquire/name
logical                       :: named          ; namelist/inquire/named
integer                       :: nextrec        ; namelist/inquire/nextrec
integer                       :: number         ; namelist/inquire/number
logical                       :: opened         ; namelist/inquire/opened
character(len=20)             :: pad            ; namelist/inquire/pad
logical                       :: pending        ; namelist/inquire/pending
integer                       :: pos            ; namelist/inquire/pos
character(len=20)             :: position       ; namelist/inquire/position

character(len=20)             :: action         ; namelist/inquire/action
character(len=20)             :: read           ; namelist/inquire/read
character(len=20)             :: readwrite      ; namelist/inquire/readwrite
character(len=20)             :: write          ; namelist/inquire/write

integer                       :: recl           ; namelist/inquire/recl
character(len=20)             :: round          ; namelist/inquire/round
character(len=20)             :: sequential     ; namelist/inquire/sequential
character(len=20)             :: sign           ; namelist/inquire/sign
integer                       :: size           ; namelist/inquire/size
character(len=20)             :: stream         ; namelist/inquire/stream
!==============================================================================================
   namein=merge_str(namein_in,'',present(namein_in))
   lun=merge(lun_in,-1,present(lun_in))
   ! exist, opened, and named always become defined unless an error condition occurs.
   !!write(*,*)'LUN=',lun,' FILENAME=',namein
   !-----------------------------------------------------------------------------------------------------------------------------------
   name=''
   if(namein == ''.and.lun /= -1)then
         call journal('sc','*print_inquire* checking unit',lun)
         inquire(unit=lun,                                                                               &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
    elseif(namein /= '')then
         call journal('sc','*print_inquire* checking file:'//namein)
         inquire(file=namein,                                                                            &
     &   recl=recl,nextrec=nextrec,pos=pos,size=size,                                                    &
     &   position=position,                                                                              &
     &   name=name,                                                                                      &
     &   form=form,formatted=formatted,unformatted=unformatted,                                          &
     &   access=access,sequential=sequential,direct=direct,stream=stream,                                &
     &   action=action,read=read,write=write,readwrite=readwrite,                                        &
     &   sign=sign,                                                                                      &
     &   round=round,                                                                                    &
     &   blank=blank,decimal=decimal,delim=delim,encoding=encoding,pad=pad,                              &
     &   named=named,opened=opened,exist=exist,number=number,pending=pending,asynchronous=asynchronous,  &
     &   iostat=ios,err=999,iomsg=message)
     if(name == '')name=namein
    else
       call journal('sc','*print_inquire* must specify either filename or unit number')
    endif
!-----------------------------------------------------------------------------------------------------------------------------------
   write(*,nml=inquire,delim='none')
   return
!-----------------------------------------------------------------------------------------------------------------------------------
999   continue
   call journal('sc','*print_inquire* bad inquire')
!  If an error condition occurs during execution of an INQUIRE  statement,
!  all of the inquiry identifiers except ios become undefined.
   call journal('sc','*print_inquire* inquire call failed,iostat=',ios,'message=',message)
end subroutine print_inquire
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    separator(3f) - [M_io:QUERY] try to determine pathname directory
!!                    separator character
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function separator() result(sep)
!!
!!     character(len=1) :: sep
!!
!!##DESCRIPTION
!!
!!    Try to determine the separator character used to separate directory
!!    names from file basenames. It is assumed it is either a backslash or
!!    a slash character.
!!
!!    First, the environment variables PATH, HOME, PWD, and  SHELL  are
!!    examined for a backslash, then a slash.
!!
!!    Then, using the name the program was invoked with, then an INQUIRE(3f)
!!    of that name, then ".\NAME" and "./NAME" try to find an expected
!!    separator character.
!!
!!    Can be very system dependent. If the queries fail the default returned
!!    is "/".
!!
!!    The value is cached as a return value for subsequent calls.
!!
!!##EXAMPLE
!!
!!   sample usage
!!
!!    program demo_separator
!!    use M_io, only : separator
!!    implicit none
!!       write(*,*)'separator=',separator()
!!    end program demo_separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function separator() result(sep)

! use the pathname returned as arg0 to determine pathname separator
implicit none
integer                      :: ios
integer                      :: i
logical                      :: existing=.false.
character(len=1)             :: sep
!*!IFORT BUG:character(len=1),save        :: sep_cache=' '
integer,save                 :: isep=-1
character(len=4096)          :: name
character(len=:),allocatable :: envnames(:)

    ! NOTE:  A parallel code might theoretically use multiple OS
    !*!FORT BUG:if(sep_cache /= ' ')then  ! use cached value.
    !*!FORT BUG:    sep=sep_cache
    !*!FORT BUG:    return
    !*!FORT BUG:endif
    if(isep /= -1)then  ! use cached value.
        sep=char(isep)
        return
    endif
    FOUND: block
    ! simple, but does not work with ifort
    ! most MSWindows environments see to work with backslash even when
    ! using POSIX filenames to do not rely on '\.'.
    inquire(file='/.',exist=existing,iostat=ios,name=name)
    if(existing.and.ios == 0)then
        sep='/'
        exit FOUND
    endif
    ! check variables names common to many platforms that usually have a
    ! directory path in them although a ULS file can contain a backslash
    ! and vice-versa (eg. "touch A\\B\\C"). Removed HOMEPATH because it
    ! returned a name with backslash on CygWin, Mingw, WLS even when using
    ! POSIX filenames in the environment.
    envnames=[character(len=10) :: 'PATH', 'HOME']
    do i=1,size(envnames)
       if(index(get_env(envnames(i)),'\') /= 0)then
          sep='\'
          exit FOUND
       elseif(index(get_env(envnames(i)),'/') /= 0)then
          sep='/'
          exit FOUND
       endif
    enddo

    write(*,*)'<WARNING>unknown system directory path separator'
    sep='\'
    endblock FOUND
    !*!IFORT BUG:sep_cache=sep
    isep=ichar(sep)
end function separator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    read_table(3f) - [M_io:READ] read file containing a table of numeric values
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine read_table(filename,array,ierr,comment)
!!
!!    character(len=*),intent(in)          :: filename
!!    TYPE,allocatable,intent(out)         :: array(:,:)
!!    integer,intent(out)                  :: ierr
!!    character(len=1,intent(in),optional  :: comment
!!
!!   where TYPE may be REAL, INTEGER, or DOUBLEPRECISION
!!
!!##DESCRIPTION
!!    Read a table from a file that is assumed to be columns of numbers,
!!    ignoring characters not in the set [0-9edED+-.] and requiring each
!!    row contain the same number of values.
!!
!!    The input file is assumed to be of a small enough size that it can
!!    be copied into memory.
!!
!!##OPTIONS
!!    filename   filename to read
!!    array      array to create. May be INTEGER, REAL, or DOUBLEPRECISION
!!    ierr       zero if no error occurred.
!!    comment    ignore lines which contain this as the first non-blank
!!               character. Ignore it and subsequent characters on any line.
!!##EXAMPLES
!!
!!    Sample program, assuming the input file "inputfile" exists:
!!
!!     program demo_read_table
!!     use M_io, only : read_table
!!     implicit none
!!     doubleprecision,allocatable :: array(:,:)
!!     integer :: i, ierr
!!
!!     ! create test file
!!     open(file='inputfile',unit=10,action='write')
!!     write(10,'(a)') [character(len=80):: &
!!      ' ___.___.___                           ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '|---+---+---|                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      ' -----------                           ', &
!!      '    #-----#-----#------#               ', &
!!      '|   | 1   | 3e2 | 4    |               ', &
!!      '|   #-----#-----#------#               ', &
!!      '|   | 2.0 | -5  | +2.2 |               ', &
!!      '    #-----#-----#------#               ', &
!!      '                                       ', &
!!      '#___#___#___#                          ', &
!!      '| 1 | 5 | 3 |                          ', &
!!      '#---#---#---#                          ', &
!!      '| 4 | 2 | 6 |                          ', &
!!      '#---#---#---#                          ', &
!!      '                                       ', &
!!      '1;10;45                                ', &
!!      '10, ,, ,,20    45                      ', &
!!      '  2 20  15                             ', &
!!      ' big=20.345 medium=20  small=15        ', &
!!      '                                       ', &
!!      '30 30e3   0                            ', &
!!      '  4 300.444e-1 -10                     ', &
!!      '40 30.5555d0 -10                       ', &
!!      '  4 300.444E-1 -10                     ', &
!!      '40 30.5555D0 -10                       ', &
!!      '                                       ']
!!     close(unit=10)
!!
!!     ! read file as a table
!!     call read_table('inputfile',array,ierr)
!!
!!     ! print values
!!     write(*,*)'size=       ',size(array)
!!     write(*,*)'size(dim=1)=',size(array,dim=1)
!!     write(*,*)'size=(dim=2)',size(array,dim=2)
!!     do i=1,size(array,dim=1)
!!        write(*,*)array(i,:)
!!     enddo
!!
!!     ! remove sample file
!!     open(file='inputfile',unit=10)
!!     close(unit=10,status='delete')
!!
!!     end program demo_read_table
!!
!!   Results:
!!
!!     size=                 45
!!     size(dim=1)=          15
!!     size=(dim=2)           3
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      300.0000000000000      4.000000000000000
!!       2.000000000000000     -5.000000000000000      2.200000000000000
!!       1.000000000000000      5.000000000000000      3.000000000000000
!!       4.000000000000000      2.000000000000000      6.000000000000000
!!       1.000000000000000      10.00000000000000      45.00000000000000
!!       10.00000000000000      20.00000000000000      45.00000000000000
!!       2.000000000000000      20.00000000000000      15.00000000000000
!!       20.34499999999999      20.00000000000000      15.00000000000000
!!       30.00000000000000      30000.00000000000      0.000000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!       4.000000000000000      30.04440000000000     -10.00000000000000
!!       40.00000000000000      30.55549999999999     -10.00000000000000
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine read_table_d(filename,darray,ierr,comment)
! note the array is allocated as text, and then doubleprecision, and then placed in the output array.
! for large files it would be worth it to just determine the file size and allocate and fill the output
! array

character(len=*),intent(in)             :: FILENAME
doubleprecision,allocatable,intent(out) :: darray(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
character(len=:),allocatable :: page(:) ! array to hold file in memory
integer                      :: irows,irowsmax
integer                      :: icols
integer                      :: i
doubleprecision,allocatable  :: dline(:)
   ierr=0
   ! allocate character array and copy file into it
   call fileread(FILENAME,page)
   if(.not.allocated(page))then
      write(*,*)'*demo_read_table* failed to load file '//FILENAME
      if(allocated(darray))deallocate(darray)
      allocate(darray(0,0))
      ierr=-1
   else
      call cleanse()
      if(allocated(darray))deallocate(darray)
      if(size(page,dim=1) == 0)then
         allocate(darray(0,0))
      else
         irowsmax=size(page,dim=1)
         icols=size(s2vs(page(1)))
         allocate(darray(irowsmax,icols))
         darray=0.0d0
         irows=0
         do i=1,irowsmax
            dline=s2vs(page(i))
            irows=irows+1
            if(size(dline) /= icols)then
               write(*,gen)page(i),'does not contain',icols,'values'
               ierr=ierr+1
               darray(irows,:min(size(dline),icols))=dline(min(size(dline),icols))
            else
               darray(irows,:)=dline
            endif
         enddo
         if(irows /= irowsmax)then
            darray=darray(:irows,:icols)
         endif
         deallocate(page)  ! release memory
      endif
   endif
contains
    subroutine cleanse()
    integer :: i,j,k
    integer :: ios
    integer :: ikeep
    character(len=:),allocatable :: words(:), line
    doubleprecision :: value
    ikeep=0
    do i=1,size(page,dim=1)
       ! do this more rigourously
       ! [+-]NNNNNN[.NNNN][ED][+-]NN
       line=''
       ! get rid of all characters not in a number and
       ! then split the remaining line and keep only
       ! tokens that can be read as a number
       do j=1,len(page)
          if(present(comment))then
             if(page(i)(j:j) == comment)then
                page(i)(j:)=' '
                exit
             endif
          endif
          select case(page(i)(j:j))
          case('e','E','d','D','+','-','.','0':'9')
          case default
             page(i)(j:j)=' '
          end select
       enddo
       call split(page(i),words)
       do k=1,size(words)
          read(words(k),*,iostat=ios)value
          if(ios == 0)then
             line=line//crop(words(k))//' '
          endif
       enddo
       if(line /= '')then
          ikeep=ikeep+1
          page(ikeep)(:)=line
       endif
    enddo
    page=page(:ikeep)
    end subroutine cleanse
end subroutine read_table_d
!===================================================================================================================================
subroutine read_table_i(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
integer,allocatable,intent(out)         :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=nint(darray)
end subroutine read_table_i
!===================================================================================================================================
subroutine read_table_r(filename,array,ierr,comment)
implicit none
character(len=*),intent(in)             :: FILENAME
real,allocatable,intent(out)            :: array(:,:)
integer,intent(out)                     :: ierr
character(len=1),intent(in),optional    :: comment
doubleprecision,allocatable             :: darray(:,:)
call read_table_d(filename,darray,ierr,comment)
array=real(darray)
end subroutine read_table_r
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileread(3f) - [M_io:READ] read (ie. slurp) a file into a string array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine fileread(filename,pageout)
!!
!!    character(len=*),intent(in) :: filename
!!      or
!!    integer,intent(in)          :: io
!!
!!    character(len=:),allocatable,intent(out) :: pageout(:)
!!##DESCRIPTION
!!    Read an entire file into memory as a character array, one character
!!    variable per line.
!!
!!    NOTE:
!!
!!    Do not casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!    filename   filename to read into memory, or LUN (Fortran Logical
!!               Unit Number). If filename is a LUN, file must be opened
!!               with
!!
!!                  form='unformatted',access='stream'
!!
!!               as in
!!
!!                 open(unit=igetunit, file=filename,     &
!!                 & action="read", iomsg=message,        &
!!                 & form="unformatted", access="stream", &
!!                 & status='old',iostat=ios)
!!
!!               An exception is that although stdin cannot currently
!!               generally be treated as a stream file file the data
!!               will be read from stdin if the filename is '-'.
!!
!!    pageout    array of characters to hold file
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_fileread
!!    use M_io,      only : fileread
!!    implicit none
!!    character(len=4096)          :: FILENAME   ! file to read
!!    character(len=:),allocatable :: pageout(:) ! array to hold file in memory
!!    integer                      :: longest, lines, i
!!    character(len=*),parameter   :: gen='(*(g0,1x))'
!!       ! get a filename
!!       call get_command_argument(1, FILENAME)
!!       ! allocate character array and copy file into it
!!       call fileread(FILENAME,pageout)
!!       if(.not.allocated(pageout))then
!!          write(*,gen)'*demo_fileread* failed to load file',FILENAME
!!       else
!!          ! write file from last line to first line
!!          longest=len(pageout)
!!          lines=size(pageout)
!!          write(*,gen)'number of lines is',lines
!!          write(*,gen)'and length of lines is',longest
!!          write(*,'(a)')repeat('%',longest+2)
!!          write(*,'("%",a,"%")')(trim(pageout(i)),i=lines,1,-1)
!!          write(*,'(a)')repeat('%',longest+2)
!!          deallocate(pageout)  ! release memory
!!       endif
!!    end program demo_fileread
!!
!!   Given
!!
!!    first line
!!    second line
!!    third line
!!
!!   Expected output
!!
!!    >  number of lines is 3
!!    >  and length of lines is 11
!!    > %%%%%%%%%%%%%
!!    > %third line %
!!    > %second line%
!!    > %first line %
!!    > %%%%%%%%%%%%%
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine fileread(FILENAME,pageout)
implicit none
class(*),intent(in)                      :: FILENAME   ! file to read
character(len=:),allocatable,intent(out) :: pageout(:) ! page to hold file in memory
character(len=1),allocatable             :: text(:)    ! array to hold file in memory

   call filebyte(FILENAME,text) ! allocate character array and copy file into it

   if(.not.allocated(text))then
      select type(FILENAME)
       type is (character(len=*)); write(*,*)'*fileread* failed to load file '//FILENAME
       type is (integer);          write(*,'(a,i0)')'*fileread* failed to load file unit ',FILENAME
      end select
   else  ! convert array of characters to array of lines
      pageout=page(text)
      deallocate(text)     ! release memory
   endif

contains
function page(array)  result (table)

! ident_5="@(#) page(3fp) function to copy char array to page of text"

character(len=1),intent(in)  :: array(:)
character(len=:),allocatable :: table(:)
integer                      :: i
integer                      :: linelength
integer                      :: length
integer                      :: lines
integer                      :: linecount
integer                      :: position
integer                      :: sz
!!character(len=1),parameter   :: nl=new_line('A')
character(len=1),parameter   :: nl = char(10)
character(len=1),parameter   :: cr = char(13)
   lines = 0
   linelength = 0
   length = 0
   sz=size(array)
   do i = 1,sz
      if( array(i) == nl )then
         linelength = max(linelength,length)
         lines = lines + 1
         length = 0
      else
         length = length + 1
      endif
   enddo
   if( sz > 0 )then
      if( array(sz) /= nl )then
         lines = lines+1
      endif
   endif

   if(allocated(table))deallocate(table)
   allocate(character(len=linelength) :: table(lines))
   table(:) = ' '

   linecount = 1
   position = 1
   do i = 1,sz
      if( array(i) == nl )then
         linecount=linecount+1
         position=1
      elseif( array(i) == cr )then
      elseif( linelength /= 0 )then
         table(linecount)(position:position) = array(i)
         position = position+1
      endif
   enddo
end function page
end subroutine fileread
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filebyte(3f) - [M_io:READ] read (ie. slurp) a file into a character array
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine filebyte(filename,text,length.lines)
!!
!!    character(len=*),intent(in) :: filename
!!     or
!!    integer,intent(in)          :: filenumber
!!
!!    character(len=1),allocatable,intent(out) :: text(:)
!!    integer,intent(out),optional :: length
!!    integer,intent(out),optional :: lines
!!##DESCRIPTION
!!    Read an entire file as a stream into memory as an array of single
!!    characters, retaining line end terminators.
!!
!!    NOTE:
!!
!!    Never casually read an entire file into memory if you can process it
!!    per line or in smaller units; as large files can consume unreasonable
!!    amounts of memory.
!!
!!##OPTIONS
!!       filename   filename to read into memory or LUN (Fortran Logical
!!                  Unit Number) If a LUN, file must be opened with
!!
!!                     form='unformatted',access='stream'
!!
!!                  as in
!!
!!                    open(unit=igetunit, file=filename,     &
!!                    & action="read", iomsg=message,        &
!!                    & form="unformatted", access="stream", &
!!                    & status='old',iostat=ios)
!!
!!                  An exception is that although stdin cannot currently
!!                  generally be treated as a stream file file the data
!!                  will be read from stdin if the filename is '-'.
!!
!!       text       array of characters to hold file
!!       length     returns length of longest line read(Optional).
!!       lines      returns number of lines read(Optional).
!!
!!##EXAMPLES
!!
!!    Sample program, which  creates test input file "inputfile":
!!
!!     program demo_filebyte
!!     use M_io, only      : filebyte
!!     implicit none
!!     character(len=1),allocatable :: text(:) ! array to hold file in memory
!!     character(len=*),parameter :: FILENAME='inputfile' ! file to read
!!
!!     ! create test file
!!     open(file=FILENAME,unit=10,action='write')
!!     write(10,'(a)') new_line('A')//'esrever lliw'
!!     write(10,'(a)') 'margorp elpmas eht taht'
!!     write(10,'(a)') 'elif elpmas a si sihT'
!!     close(unit=10)
!!
!!     call filebyte(FILENAME,text) ! allocate character array and copy file into it
!!
!!     if(.not.allocated(text))then
!!        write(*,*)'*rever* failed to load file '//FILENAME
!!     else
!!        ! write file reversed to stdout
!!        write(*,'(*(a:))',advance='no')text(size(text):1:-1)
!!        deallocate(text)  ! release memory
!!     endif
!!
!!     end program demo_filebyte
!!
!!    Expected output:
!!
!!     >This is a sample file
!!     >that the sample program
!!     >will reverse
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine filebyte(filename,text,length,lines)
implicit none

! ident_6="@(#) M_io filebyte(3f) allocate text array and read file filename into it"

class(*),intent(in)                      :: filename    ! filename to shlep
character(len=1),allocatable,intent(out) :: text(:)     ! array to hold file
integer,intent(out),optional             :: length      ! length of longest line
integer,intent(out),optional             :: lines       ! number of lines
integer :: nchars=0             ! holds size of file
integer :: igetunit             ! use newunit=igetunit in f08
integer :: ios=0                ! used for I/O error status
integer :: length_local
integer :: lines_local
integer :: i
integer :: icount
character(len=256)  :: message
character(len=4096) :: label
character(len=:),allocatable :: line
   length_local=0
   lines_local=0
   message=''
   select type(FILENAME)
    type is (character(len=*))
       if(filename /= '-') then
          open(newunit=igetunit, file=trim(filename), action="read", iomsg=message,&
           &form="unformatted", access="stream",status='old',iostat=ios)
          label=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
    type is (integer)
       if(filename /= stdin) then
          rewind(unit=filename,iostat=ios,iomsg=message)
          igetunit=filename
       else ! copy stdin to a scratch file
          call copystdin()
       endif
       write(label,'("unit ",i0)')filename
   end select
   if(ios == 0)then  ! if file was successfully opened
      inquire(unit=igetunit, size=nchars)
      if(nchars <= 0)then
         call stderr_local( '*filebyte* empty file '//trim(label) )
         return
      endif
      ! read file into text array
      if(allocated(text))deallocate(text) ! make sure text array not allocated
      allocate ( text(nchars) )           ! make enough storage to hold file
      read(igetunit,iostat=ios,iomsg=message) text      ! load input file -> text array
      if(ios /= 0)then
         call stderr_local( '*filebyte* bad read of '//trim(label)//':'//trim(message) )
      endif
   else
      call stderr_local('*filebyte* '//message)
      allocate ( text(0) )           ! make enough storage to hold file
   endif

   close(iostat=ios,unit=igetunit)            ! close if opened successfully or not

   if(present(lines).or.present(length))then  ! get length of longest line and number of lines
      icount=0
      do i=1,nchars
         if(text(i) == NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
            icount=0
         endif
         icount=icount+1
      enddo
      if(nchars /= 0)then
         if(text(nchars) /= NEW_LINE('A'))then
            lines_local=lines_local+1
            length_local=max(length_local,icount)
         endif
      endif
      if(present(lines))lines=lines_local
      if(present(length))length=length_local
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
contains
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine copystdin()
integer :: iostat
   open(newunit=igetunit, iomsg=message,&
   &form="unformatted", access="stream",status='scratch',iostat=iostat)
   open(unit=stdin,pad='yes')
   INFINITE: do while (getline(line,iostat=iostat)==0)
      write(igetunit)line//new_line('a')
   enddo INFINITE
   rewind(igetunit,iostat=iostat,iomsg=message)
end subroutine copystdin
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine stderr_local(message)
character(len=*) :: message
   write(stderr,'(a)')trim(message)    ! write message to standard error
end subroutine stderr_local
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine filebyte
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    number_of_lines(3f) - [M_io:QUERY] read an open sequential file to get
!!                          number of lines
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function number_of_lines(lun) result(nlines)
!!
!!    integer,intent(in)          :: lun
!!    integer                     :: nlines
!!
!!##DESCRIPTION
!!    Rewind an open sequential file and read through it to count the number
!!    of lines. The file is rewound on exit. If it is not readable -1 is returned.
!!
!!##OPTIONS
!!    lun       logical unit number of open sequential file to count lines in.
!!
!!##RETURNS
!!    nlines    number of lines read. If it is not readable -1 is returned.
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_number_of_lines
!!    use M_io,      only : number_of_lines, fileopen
!!    implicit none
!!    integer :: ios
!!    integer :: lun
!!       lun=fileopen('test.txt','r',ios)
!!       if(ios == 0)then
!!          write(*,*) number_of_lines(lun)
!!       else
!!          write(*,*)'ERROR: IOS=',ios
!!       endif
!!    end program demo_number_of_lines
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function number_of_lines(lun) result(nlines)
!@(#) determine number or lines in file given a LUN to the open file
integer,intent(in) :: lun

integer            :: ios
integer            :: nlines
character(len=256) :: iomsg

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)
   nlines = 0

   do
   read(lun, '(A)', end=99, iostat=ios,iomsg=iomsg)
      if (ios /= 0) then
         write(stderr,gen)'*number_of_lines*:',trim(iomsg)
         nlines=-1
         exit
      endif
      nlines = nlines + 1
   enddo

99 continue

   if(lun /= stdin)rewind(lun,iostat=ios,iomsg=iomsg)

end function number_of_lines
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:QUERY] Find a FUN/LUN (Fortran-unit-number) that is not in use
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       integer function notopen(start,end,err)
!!       integer,optional,intent(in)  :: start
!!       integer,optional,intent(in)  :: end
!!       integer,optional,intent(out) :: err
!!##DESCRIPTION
!!    A free FORTRAN unit number is needed to OPEN a file. NOTOPEN() returns
!!    a FORTRAN unit number from START to END not currently associated with
!!    an I/O unit. START and END are expected to be positive integers where
!!    END  >=  START.
!!
!!    If NOTOPEN() returns -1, then no free FORTRAN unit could be found in
!!    the specified range.
!!
!!    Otherwise, NOTOPEN() returns an integer representing a free FORTRAN
!!    logical unit number. Note that NOTOPEN() assumes the following unit
!!    numbers defined by the Fortran 2008 ISO_FORTRAN_ENV module
!!
!!       ERROR_UNIT,INPUT_UNIT,OUTPUT_UNIT
!!
!!    are special, and will never return those values.
!!
!!##OPTIONS
!!       start  optional logical unit number to start scan at, defaults to 10.
!!       end    optional logical unit number to stop scan at, defaults to 99.
!!       err    optional error flag returned. ERR will be non-zero if
!!              no errors. If not present and an error occurs the program
!!              will stop instead of returning.
!!
!!##NOTES
!!
!!    Why are the default START and END limits from 10 to 99? the Fortran 77
!!    standard did not specify a specific limit on the upper range limit, but
!!    the LUN range of 1 to 99 was almost always supported in conventional
!!    programming environments. Additionally, units in the range 0-10 have
!!    often been the units used for pre-assigned files. Occasionally 100,
!!    101 and 102 are reserved (for files such as standard input, standard
!!    output, standard error, ...). Therefore, the defaults for START and
!!    END were selected to be 10 and 99. And most programs do not need
!!    more than 90 files simultaneously open, so the defaults work well in
!!    practice with many versions/vintages of Fortran.
!!
!!    Note that an environment may impose a limit on the number of
!!    simultaneously open files (which some compilers work around).
!!
!!    Beginning with f2008, you can probably use OPEN(NEWUNIT=...) instead
!!    of an open unit locator.
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!     program demo_notopen ! test the NOTOPEN(3f) function
!!     use m_io, only: notopen
!!     implicit none
!!     integer :: ii, ierr, igot
!!
!!     write(*,*)'check for preassigned files from unit 0 to unit 1000'
!!     write(*,*)'(5 and 6 always return -1)'
!!
!!     do ii=0,1000
!!        if(notopen(ii,ii,ierr)  /=  ii)then
!!           write(*,*)'INUSE:',ii, notopen(ii,ii,ierr)
!!        endif
!!     enddo
!!
!!     ! open all files from UNIT=10 to UNIT=30 so have used units
!!     do ii=10,30,1
!!       open(unit=ii,status="scratch")
!!     enddo
!!     ! close UNIT=25
!!     close(25)
!!
!!     ! find open file in range 10 to 30
!!     write(*,*)'Should get 25 for this ..',notopen(10,30,ierr)
!!
!!     close(18)
!!     do ii=10,32
!!       igot=notopen(ii,ii,ierr)
!!       write(*,*)'For unit ',ii,' I got ',igot,' with ERR=',ierr
!!     enddo
!!
!!     end program demo_notopen
!!
!!    Expected output(can vary with each programming environment):
!!
!!       check for preassigned files from unit 0 to unit 1000
!!       (5 and 6 always return -1)
!!       INUSE:    0    -1
!!       INUSE:    5    -1
!!       INUSE:    6    -1
!!       Should get 25 for this .. 25
!!       For  unit  10  I  got  -1  with  ERR=  -1
!!       For  unit  11  I  got  -1  with  ERR=  -1
!!       For  unit  12  I  got  -1  with  ERR=  -1
!!       For  unit  13  I  got  -1  with  ERR=  -1
!!       For  unit  14  I  got  -1  with  ERR=  -1
!!       For  unit  15  I  got  -1  with  ERR=  -1
!!       For  unit  16  I  got  -1  with  ERR=  -1
!!       For  unit  17  I  got  -1  with  ERR=  -1
!!       For  unit  18  I  got  18  with  ERR=   0
!!       For  unit  19  I  got  -1  with  ERR=  -1
!!       For  unit  20  I  got  -1  with  ERR=  -1
!!       For  unit  21  I  got  -1  with  ERR=  -1
!!       For  unit  22  I  got  -1  with  ERR=  -1
!!       For  unit  23  I  got  -1  with  ERR=  -1
!!       For  unit  24  I  got  -1  with  ERR=  -1
!!       For  unit  25  I  got  25  with  ERR=   0
!!       For  unit  26  I  got  -1  with  ERR=  -1
!!       For  unit  27  I  got  -1  with  ERR=  -1
!!       For  unit  28  I  got  -1  with  ERR=  -1
!!       For  unit  29  I  got  -1  with  ERR=  -1
!!       For  unit  30  I  got  -1  with  ERR=  -1
!!       For  unit  31  I  got  31  with  ERR=   0
!!       For  unit  32  I  got  32  with  ERR=   0
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
integer function notopen(start,end,err)
implicit none

! ident_7="@(#) M_io notopen(3f) find free FORTRAN unit number to OPEN() a file"

integer,optional,intent(in)    :: start                           ! unit number to start looking at
integer,optional,intent(in)    :: end                             ! last unit number to look at
integer,optional,intent(out)   :: err                             ! error flag returned
integer                        :: istart
integer                        :: iend
integer                        :: ierr

integer         :: i10                                            ! counter from start to end
integer         :: ios                                            ! iostatus from INQUIRE
logical         :: lopen                                          ! returned from INQUIRE
logical         :: lexist                                         ! returned from INQUIRE
!-----------------------------------------------------------------------------------------------------------------------------------
   !! IEND=MERGE( END, 99, PRESENT(END)) do not use merge, as TSOURCE must be evaluated before the call
   if(present(start))then; istart=start; else; istart=10; endif
   if(present(end  ))then; iend  =end  ; else; iend  =99; endif
   ierr=0
   notopen=(-1)                                                   ! result if no units are available
!-----------------------------------------------------------------------------------------------------------------------------------
   do i10=istart,iend                                             ! check units over selected range
      select case (i10)                                           ! always skip these predefined units
      case(stderr,stdin,stdout)
          cycle
      end select
      inquire( unit=i10, opened=lopen, exist=lexist, iostat=ios )
      if( ios == 0 )then                                          ! no error on inquire
         if(.not. lopen .and. lexist)then                         ! if unit number not in use, return it
            notopen = i10
            exit                                                  ! only need to find one, so return
         endif
      else
         write(stderr,*)'*notopen*:error on unit ',i10,'=',ios
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   if (notopen  <  0 )then                                       ! no valid unit was found in given range
      ierr=-1
   else                                                           ! valid value being returned
      ierr=0
   endif
   if(present(err))then                                           ! if error flag is present set it
      err=ierr
   elseif(ierr /= 0)then                                          ! if error occurred and error flag not present stop program
      stop 1
   endif
end function notopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dirname(3f) - [M_io:PATHNAMES] strip last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function dirname(FILENAME) result (DIRECTORY)
!!
!!      character(len=*),intent(in)  :: FILENAME
!!      character(len=:),allocatable :: DIRECTORY
!!
!!##DESCRIPTION
!!    Output FILENAME with its last non-slash component and trailing slashes
!!    removed. If FILENAME contains no slash or backslash character, output
!!    '.' (meaning the current directory).
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that FILENAME does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to remove the last leaf from
!!
!!##RETURNS
!!      DIRECTORY  directory name for pathname
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_dirname
!!    use M_io, only : dirname
!!    implicit none
!!    character(len=:),allocatable :: filename
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1 , command_argument_count()
!!       call get_command_argument (i , length=filename_length)
!!       if(allocated(filename))deallocate(filename)
!!       allocate(character(len=filename_length) :: filename)
!!       call get_command_argument (i , value=filename)
!!       write(*,'(a)')dirname(filename)
!!    enddo
!!    end program demo_dirname
!!
!!   Sample program executions:
!!
!!      demo_dirname /usr/bin/          -> "/usr"
!!      demo_dirname dir1/str dir2/str  -> "dir1" followed by "dir2"
!!      demo_dirname stdio.h            -> "."
!!
!!##SEE ALSO
!!    dirname(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        dirname(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function dirname(filename) result (directory)
implicit none

! ident_8="@(#) M_io dirname(3f) strip last component from filename"

character(len=*),intent(in)      :: filename
character(len=:),allocatable     :: directory
integer                          :: iend
character(len=1)                 :: sep
!-----------------------------------------------------------------------------------------------------------------------------------
   sep=separator()
   directory=trim(filename)
   call removetail()                         ! trim trailing slashes even if duplicates
   iend=index(directory,sep,back=.true.)     ! find last slash if any
   if(iend == 0)then                         ! filename is a leaf
      directory='.'                          ! special case
   else
      directory=directory(:iend-1)           ! remove leaf
      call removetail()                      ! trim off trailing slashes in case duplicates
   endif
   directory=trim(directory)                 ! clean up return value
contains
   subroutine removetail()              ! replace trailing slashes with spaces even if duplicates
   integer :: right
   do right=len(directory),1,-1
      if(directory(right:right) == sep.or.directory(right:right) == ' ')then
         directory(right:right)=' '
      else
         exit
      endif
   enddo
   end subroutine removetail

end function dirname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    basename(3f) - [M_io:PATHNAMES] return last component from filename
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function basename(FILENAME,SUFFIX) result (LEAF)
!!
!!      character(len=:),allocatable :: FILENAME
!!      character(len=*),intent(in),optional :: SUFFIX
!!      character(len=*),intent(in) :: LEAF
!!
!!##DESCRIPTION
!!    Output LEAF of filename with directory paths removed.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!      FILENAME   pathname to extract the last leaf from
!!      SUFFIX     suffix to remove. If not present
!!                 the rightmost ".string" string is removed.
!!                 If present the LEAF is returned with any matching
!!                 suffix removed.
!!
!!##RETURNS
!!      LEAF  returned leaf name
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_basename
!!    use M_io, only : basename
!!    implicit none
!!    character(len=:),allocatable :: fn
!!    integer                      :: filename_length
!!    integer                      :: i
!!    ! get pathname from command line arguments
!!    do i = 1, command_argument_count()
!!       call get_command_argument (i, length=filename_length)
!!       if(allocated(fn))deallocate(fn)
!!       allocate(character(len=filename_length) :: fn)
!!       call get_command_argument (i, value=fn)
!!       ! leaf with any suffix removed
!!       ! leaf with suffix retained
!!       ! with suffix unless it is ".f90"
!!       write(*,'(*(a,1x))') basename(fn), basename(fn,''), basename(fn,'.f90')
!!    enddo
!!    end program demo_basename
!!
!!   Sample program executions:
!!
!!     $demo_basename /usr/bin/
!!     bin bin bin
!!     $demo_basename dir1/fred.x dir2/.y
!!     fred fred.x fred.x
!!     .y .y .y
!!     $demo_basename stdio.h
!!     stdio stdio.h stdio.h
!!     $demo_basename /name.f90
!!     name name.f90 name
!!
!!##SEE ALSO
!!    basename(3c), basename(3c), readlink(3c), realpath(3c)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
!>
!! PRODUCT:        CLI library utilities and examples
!! PROGRAM:        basename(3f)
!! DESCRIPTION:    strip last component from filename
!!##VERSION:        1.0.0
!!##DATE:           2015-06-26
!! AUTHOR:         John S. Urban
!! REPORTING BUGS: http://www.urbanjost.altervista.org/
!! HOME PAGE:      http://www.urbanjost.altervista.org/index.html
function basename(filename,suffix) result (leaf)
implicit none

! ident_9="@(#) M_io basename(3f) strip last component from filename"

character(len=*),intent(in)          :: filename
character(len=*),intent(in),optional :: suffix
character(len=:),allocatable         :: leaf
integer                              :: iend
integer                              :: i
integer,parameter                    :: maxlen=4096
character(len=maxlen)                :: name
character(len=maxlen)                :: bname
character(len=maxlen)                :: extension
character(len=1)                 :: sep
   sep=separator()
   ! trim trailing separators
   iend=len_trim(filename)
   do i=iend,1,-1
      if(filename(i:i) /= sep)exit
      iend=iend-1
   enddo
   !
   call splitpath(filename(:iend),name=name,basename=bname,ext=extension)
   if(present(suffix))then
      leaf=merge(bname,name,suffix == extension)
   else
      leaf=bname
   endif
   if(leaf == '')leaf=name
   leaf=trim(leaf)
end function basename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileopen(3f) - [M_io] A simple open of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   function fileopen(filename,mode,ios) result(lun)
!!
!!    character(len=*),intent(in)           :: filename
!!    character(len=*),intent(in),optional  :: mode
!!    integer,intent(out),optional          :: ios
!!    integer                               :: lun
!!
!!##DESCRIPTION
!!    fileopen(3f) is a convenience routine that allows you to open a file
!!    for sequential reading and writing as a text file in a form commonly
!!    found in C and interpreted languages such as shells. See the OPEN(3f)
!!    statement for more demanding I/O specifications (asynchronous, direct,
!!    unformatted, ... ). The documentation for the flexible and powerful
!!    OPEN(3f) statement can be a bit overwhelming; this routine cuts it
!!    down to the just the simple basic functions typically available in
!!    a scripting language such as bash, tcsh, sh, ...
!!
!!    Specify the file's name as the string FILENAME with a shell-like prefix
!!    specifying the access mode, or alternatively specify a plain FILENAME
!!    and the kind of access you need to the file with the string MODE.
!!
!!    Three fundamental kinds of access are available: read, write,
!!    and append.
!!
!!##OPTION
!!   FILENAME  The filename to open. If the beginning of the filename is
!!
!!             <   open for read. File must exist
!!             >   open for write. Will overwrite current file
!!             >>  open for append. Will append to current file
!!
!!             If no prefix exists to specify a file access mode, it
!!             will depend on the values of the MODE argument (meaning
!!             the default will be "readwrite").
!!
!!             A blank filename causes a unit number for a scratch file
!!             to be returned.
!!
!!   MODE     [rwa][tb][+]
!!            An alternate way to specify the file access mode is to specify
!!            a MODE value. It should begin with one of the three characters
!!            "r", "w", or "a". It defaults to 'rw'. It is case-insensitive.
!!
!!
!!        READING PREFIX
!!        r,<   Open the file for reading; the operation will fail if the
!!              file does not exist, or if the host system does not permit
!!              you to read it.
!!
!!        WRITING PREFIXES
!!        w,>   Open a file for writing from the beginning of the file.
!!              If the file whose name you specified already existed,
!!              the call fails.
!!
!!        o     Open the file for writing from the beginning of the file:
!!              effectively, this always creates a new file. If the file
!!              whose name you specified already existed, its old contents
!!              are discarded.
!!
!!        a,<<  Initially open the file for appending data (ie. writing
!!              at the end of file).
!!
!!        SUFFIX
!!
!!        b   Append a "b" to any of the three modes above to specify that
!!            you are opening the file as a "binary file" (the default is
!!            to open the file as a sequential formatted text file. This
!!            switch changes to to an unformatted stream).
!!
!!                   open( ... access='stream';form='unformatted')
!!
!!        t   Append a "t" to any of the three modes (rwa) to specify a
!!            formatted stream
!!
!!                   open( ... access='stream';form='formatted')
!!
!!        +   Finally, you might need to both read and write from the same
!!            file. You can specify "rw" or you can append a `+' to any of
!!            the three primary modes ("rwa") to permit "readwrite" access
!!
!!        v   Additionally, "v" selects verbose mode, which prints the
!!            OPEN(3f) options explicitly selected
!!
!!        NOTES
!!
!!            If you want to append both `b' and `+', you can do it in
!!            either order: for example, "rb+" means the same thing as
!!            "r+b" when used as a mode string.)
!!
!!    IOS    The error code returned by the OPEN(3f) statement ultimately
!!           executed by this function. If not present the program stops on
!!           an error.
!!##RETURNS
!!        FILEOPEN(3f) returns a Fortran unit number which you can use
!!        for other file operations, unless the file you requested could
!!        not be opened; in that situation, the result is -1 (a reserved
!!        value that cannot be returned as a NEWUNIT value on an OPEN(3f))
!!        and IOS will be non-zero.
!!
!!##EXAMPLE
!!
!!  Common usage
!!
!!   READ
!!     R=fileopen('<in.txt')
!!     or
!!     R=fileopen('in.txt','r')
!!
!!   WRITE
!!     W=fileopen('>out.txt')
!!     or
!!     W=fileopen('out.txt','W')
!!
!!   READWRITE
!!     RW=fileopen('inout.txt')
!!
!!   APPEND
!!     A=fileopen('>>inout.txt')
!!     or
!!     A=fileopen('inout.txt','a')
!!
!!   Sample program
!!
!!       program demo_fileopen
!!       use M_io, only : fileopen, fileclose, print_inquire
!!       implicit none
!!       integer :: lun
!!       lun=fileopen('fred.txt')
!!       call print_inquire(lun)
!!       end program demo_fileopen
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileopen(filename,mode,ios) result(lun)
character(len=*),intent(in)           :: filename
character(len=*),intent(in),optional  :: mode
integer,intent(out),optional          :: ios
integer                               :: lun, i, ios_local,ifound,gts
character(len=:),allocatable          :: local_mode
character(len=256)                    :: message
character(len=:),allocatable          :: action, position, access, form, status, file
logical                               :: verbose
   local_mode=lower(merge_str(mode,'',present(mode)))
   file=trim(adjustl(filename))//'   '
   ifound=index(file,'>>')
   if(ifound /= 0)then
      file(ifound:ifound+1)='  '
      local_mode=local_mode//'a'
   endif
   ifound=index(file,'>')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'w'
   endif
   ifound=index(file,'<')
   if(ifound /= 0)then
      file(ifound:ifound)=' '
      local_mode=local_mode//'r'
   endif
   file=adjustl(file)
   local_mode=merge_str('rw',local_mode,local_mode == '')
   file=trim(file)

   gts=0
   action=''
   position='asis'
   form='formatted'
   access='sequential'
   status='unknown'
   verbose=.false.
   do i=1,len(local_mode) ! create order independence
      select case(local_mode(i:i))
       case('r','<'); if(action /= 'readwrite'.and.action /= 'read')action='read'//action
                      if(status == 'unknown')status='old'
       case('w','>'); if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')status='new'
                      if(gts > 0)then
                         position='append'
                      endif
                      gts=gts+1
       case('o');     if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status=='unknown')then
                         status='replace'
                      endif
       case('a');     position='append'
                      if(action /= 'readwrite'.and.action /= 'write')action=action//'write'
                      if(status == 'old')status='unknown'
       case('b');     access='stream';form='unformatted'
       case('t');     access='stream';form='formatted'
       case('+');     action='readwrite'
                      status='unknown'
       case('v');     verbose=.true.
       case default
         write(*,'(*(g0))',advance='no')'*fileopen* unknown mode key ',local_mode(i:i)
         write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & ' INPUTNAME=',trim(file), &
         & ' MODE=',trim(local_mode)
      end select
   enddo
   if(action == '')action='readwrite'

   if(verbose)then
      write(*,'(*(:,"[",g0,"=",g0,"]"))',advance='no') &
         & 'INPUTNAME=',trim(file), &
         & 'MODE=',trim(local_mode)
      write(*,'(a)',advance='no')'==>'
      write(*,'(*(:,"[",g0,"=",g0,"]"))') &
         & 'FILE=',trim(file), &
         & 'FORM=',trim(form), &
         & 'ACCESS=',trim(access), &
         & 'ACTION=',trim(action), &
         & 'POSITION=',trim(position), &
         & 'STATUS=',trim(status)
   endif
   if(file /= ' ')then
    open(file=file,newunit=lun,form=form,access=access,action=action,position=position,status=status,iostat=ios_local,iomsg=message)
   else
    open(newunit=lun,form=form,access=access,action=action,status='scratch',iostat=ios_local,iomsg=message)
   endif
   !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
   !  ACTION    =  READ|WRITE  |  READWRITE
   !  FORM      =  FORMATTED   |  UNFORMATTED
   !  POSITION  =  ASIS        |  REWIND       |  APPEND
   !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
   if(ios_local /= 0)then
      call journal('sc','*fileopen* ',message)
      lun=-1
   endif
   if(present(ios))then        ! caller has asked for status so let caller process any error
      ios=ios_local
   elseif(ios_local /= 0)then  ! caller did not ask for status so stop program on error
      stop 1
   endif
end function fileopen
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fileclose(3f) - [M_io] A simple close of a sequential file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function fileclose(lun) result(ios)
!!
!!      integer,intent(in)       :: lun
!!      integer                  :: ios
!!##DESCRIPTION
!!   A convenience command for closing a file that leaves an
!!   error message in the current journal file if active.
!!##OPTION
!!   LUN unit number to close
!!##RETURNS
!!   IOS status value from CLOSE
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_fileclose
!!     use M_io, only : fileclose, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios, ierr
!!        lun=fileopen('<input.txt',ios=ierr)
!!        if(ierr /= 0)then
!!           write(*,*)'<ERROR> opening file'
!!        endif
!!        ios=fileclose(lun)
!!     end program demo_fileclose
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function fileclose(lun) result(ios)
integer,intent(in)       :: lun
integer                  :: ios
character(len=256)       :: message
   close(unit=lun,iostat=ios,iomsg=message)
   if(ios /= 0)then
      call journal('sc','*fileclose* ',message)
      stop
   endif
end function fileclose
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filewrite(3f) - [M_io:WRITE] A simple write of a CHARACTER array to a file
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     function filewrite(filename,data,status,position) result(ierr)
!!
!!      character(len=*),intent(in) :: filename
!!      character(len=*),intent(in) :: data(:)
!!      character(len=*),intent(in),optional :: status
!!      character(len=*),intent(in),optional :: position
!!      integer                     :: ierr
!!##DESCRIPTION
!!   A convenience procedure for writing a CHARACTER array as
!!   a new file.
!!##OPTION
!!   FILENAME   file to create or write. If the name ends
!!              in ">" the default for STATUS changes to
!!              "REPLACE". If it ends in ">>" STATUS changes to
!!              "UNKNOWN" and the default POSITION changes to "APPEND".
!!   DATA       CHARACTER array to write to file
!!   STATUS     STATUS to use on OPEN(7f). Defaults to "NEW".
!!              Allowed values are  NEW|REPLACE|OLD|SCRATCH|UNKNOWN
!!   POSITION   POSITION to use on OPEN(7f). Defaults to "REWIND".
!!              Allowed values are  ASIS|REWIND|APPEND
!!##RETURNS
!!   IERR       status value. Zero indicates no error occurred
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filewrite
!!     use M_io, only : filewrite
!!     implicit none
!!     integer :: ierr
!!     character(len=:),allocatable :: data(:)
!!        data=[ character(len=80) :: &
!!             &'This is the text to write  ', &
!!             &'into the file. It will be  ', &
!!             &'trimmed on the right side. ', &
!!             &' ', &
!!             &'     That is all Folks!    ', &
!!             &'']
!!        ierr=filewrite('_scratch.txt',data)
!!     end program demo_filewrite
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filewrite(filename,filedata,status,position) result (ierr)
! write filedata to file filename
character(len=*),intent(in)           :: filename
character(len=*),intent(in)           :: filedata(:)
character(len=*),intent(in),optional  :: status
character(len=*),intent(in),optional  :: position
integer                               :: ierr
integer                               :: lun, i, ios, ilen
character(len=256)                    :: message
character(len=:),allocatable          :: file
character(len=:),allocatable          :: local_status
character(len=:),allocatable          :: local_position
character(len=:),allocatable          :: default_status
character(len=:),allocatable          :: default_position
   ierr=0
   default_status='NEW'
   default_position='REWIND'
   file=trim(adjustl(filename))//'  '
   ilen=max(len_trim(file),2)
   if(file(ilen-1:ilen) == '>>')then
      ilen=ilen-2
      file=file(:ilen)
      default_status='UNKNOWN'
      default_position='APPEND'
   elseif(file(ilen:ilen) == '>')then
      ilen=ilen-1
      file=file(:ilen)
      default_status='REPLACE'
   else
      file=trim(file)
   endif
   if(present(position))then; local_position=position; else; local_position=default_position; endif
   if(present(status))then;   local_status=status;     else; local_status=default_status;     endif
   if(file /= ' ')then
      open(file=file, &
      & newunit=lun, &
      & form='formatted', &         !  FORM      =  FORMATTED   |  UNFORMATTED
      & access='sequential', &      !  ACCESS    =  SEQUENTIAL  |  DIRECT       |  STREAM
      & action='write', &           !  ACTION    =  READ|WRITE  |  READWRITE
      & position=local_position, &  !  POSITION  =  ASIS        |  REWIND       |  APPEND
      & status=local_status, &      !  STATUS    =  NEW         |  REPLACE      |  OLD     |  SCRATCH   | UNKNOWN
      & iostat=ios, &
      & iomsg=message)
   else
      lun=stdout
      ios=0
   endif
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
      ierr=ios
   else
      do i=1,size(filedata)                                                    ! write file
         write(lun,'(a)',iostat=ios,iomsg=message)trim(filedata(i))
         if(ios /= 0)then
            write(stderr,'(*(a,1x))')'*filewrite* error:',file,trim(message)
            ierr=ios
            exit
         endif
      enddo
   endif
   close(unit=lun,iostat=ios,iomsg=message)                                 ! close file
   if(ios /= 0)then
      write(stderr,'(*(a,1x))')'*filewrite* error:',trim(message)
      ierr=ios
   endif
end function filewrite
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    filedelete(3f) - [M_io] A simple close of an open file with STATUS='DELETE'
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function filedelete(lun) result(ios)
!!
!!     integer,intent(in)          :: lun
!!       or
!!     character(len=*),intent(in) :: filename
!!     integer                     :: ios
!!
!!##DESCRIPTION
!!   A convenience command for deleting an OPEN(3f) file that leaves an
!!   error message in the current journal file if active
!!##OPTION
!!   LUN  unit number of open file to delete or filename.
!!##RETURNS
!!   IOS  status returned by CLOSE().
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_filedelete
!!     use M_io, only : filedelete, fileopen
!!     implicit none
!!     integer :: lun
!!     integer :: ios
!!        lun=fileopen('<input.txt')
!!        ios=filedelete(lun)
!!     end program demo_filedelete
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function filedelete_lun(lun) result(iostat)
integer,intent(in)    :: lun
integer               :: iostat
character(len=256)    :: message
   close(unit=lun,iostat=iostat,status='delete',iomsg=message)
   if(iostat /= 0)then
      call journal('sc','*filedelete* ',message)
   endif
end function filedelete_lun
function filedelete_filename(filename) result(iostat)
character(len=*),intent(in) :: filename
integer                     :: number
integer                     :: iostat
character(len=256)          :: message
logical                     :: opened
logical                     :: exist
   inquire(file=filename,opened=opened,iostat=iostat,exist=exist,number=number)
   if(exist)then
      if(.not.opened)then
         open(newunit=number,iostat=iostat,file=filename)
      endif
      close(unit=number,iostat=iostat,status='delete',iomsg=message)
      if(iostat /= 0)then
         call journal('sc','*filedelete* ',message)
      endif
   endif
end function filedelete_filename
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    joinpath(3f) - [M_io:PATHNAMES] join parts of a pathname together
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9)  result(path)
!!
!!     character(len=*), intent(in)           :: a1, a2
!!     character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
!!     character(len=:), allocatable          :: path
!!##DESCRIPTION
!!##OPTIONS
!!     a1,a2  the first two pathname sections to join. Required
!!     a3-a9  additional optional sections to join
!!##RETURNS
!!     pathname sections joined together with trailing spaces removed from
!!     the ends of sections and a separator (as returned by separator(3f)
!!     ) placed between them, and duplicate adjacent separators removed
!!     accept for one beginning the joined pathname.
!!##EXAMPLE
!!
!!   Sample program
!!
!!      program demo_joinpath
!!      use M_io, only : joinpath
!!      implicit none
!!         write(*,*)joinpath(&
!!         &'/share/user','/man/','man3','joinpath.3m_io'//'.gz' &
!!         &)
!!      end program demo_joinpath
!!
!! Results:
!!
!!      >  /share/user/man/man3/joinpath.3m_io.gz
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function joinpath(a1,a2,a3,a4,a5,a6,a7,a8,a9) result(path)
   ! Construct path by joining strings with os file separator
   !
   character(len=*), intent(in)           :: a1, a2
   character(len=*), intent(in), optional :: a3, a4, a5, a6, a7, a8, a9
   character(len=:), allocatable          :: path
   character(len=1)                       :: filesep

   filesep = separator()
   if(a1 /= '')then
      path = trim(a1) // filesep // trim(a2)
   else
      path = trim(a2)
   endif
   if (present(a3)) path = path // filesep // trim(a3)
   if (present(a4)) path = path // filesep // trim(a4)
   if (present(a5)) path = path // filesep // trim(a5)
   if (present(a6)) path = path // filesep // trim(a6)
   if (present(a7)) path = path // filesep // trim(a7)
   if (present(a8)) path = path // filesep // trim(a8)
   if (present(a9)) path = path // filesep // trim(a9)
   path=adjustl(path//'  ')
   call substitute(path,filesep//filesep,filesep,start=2) ! some systems allow names starting with '//' or '\\'
   path=trim(path)
end function joinpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     splitpath(3f) - [M_io:PATHNAMES] split a Unix pathname into components
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   subroutine splitpath(path,dir,name,basename,ext)
!!
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),intent(in)  :: path
!!    character(len=maxlen),intent(out),optional :: dir
!!    character(len=maxlen),intent(out),optional :: name
!!    character(len=maxlen),intent(out),optional :: basename
!!    character(len=maxlen),intent(out),optional :: ext
!!
!!##DESCRIPTION
!!    splitpath(3f) splits given pathname assuming a forward slash separates
!!    filename components and that the right-most period in the last leaf
!!    of the pathname is considered the beginning of an extension. If
!!    an extension is found it is left present in NAME but removed from
!!    BASENAME.
!!
!!    This routine does not check the system for the existence or type of
!!    the filename components; it merely parses a string.
!!
!!    Assumes leaf separator is a slash or backslash as determined by
!!    separator(3f) and that filename does not contain trailing spaces.
!!
!!##OPTIONS
!!    path      Path to be broken into components. It is assumed
!!
!!              o Forward slashes (/) separate pathname components.
!!              o the name '.' means "current directory"
!!              o the name '..' means "up one directory"
!!              o a pathname ending in a slash is a directory name
!!              o a slash starting the pathname represents the root
!!                directory.
!!              o trailing spaces are insignificant.
!!
!!    Using these rules helps to reduce incorrect parsing, but the
!!    routine is only intended for simple parsing of names of the form
!!    "[dir/]name[.extension].
!!
!!##RESULTS
!!    dir       Path of directories, including the trailing slash.
!!    name      Name of file leaf or, if no file is specified in path,
!!              name of the lowest directory.
!!    basename  NAME with any extension removed
!!    ext       File name extension, if any, including the leading period (.).
!!
!!    The path parameter can be a complete or partial file specification. The
!!    special name "." is assumed to mean the current directory, and the
!!    special name ".." is assumed to mean one directory above the current
!!    directory.
!!
!!##EXAMPLE
!!
!!   program demo_splitpath
!!
!!    use m_io, only : splitpath
!!    implicit none
!!    integer,parameter :: maxlen=4096
!!    character(len=maxlen),parameter   :: file(*)=[&
!!       & 'dirs/name.ext  ', &
!!       & 'xx/IO/zz/NN.FF ', &
!!       & 'xx/IO/zz/NN    ', &
!!       & '/xx/IO/zz/NN   ', &
!!       & '/xx/IO/zz/     ', &
!!       & '/xx/IO/zz.A/   ', &
!!       & '/xx/IO/zz/.    ', &
!!       & '               ', &
!!       & './             ', &
!!       & '/              ', &
!!       & '/..            ', &
!!       & './..           ', &
!!       & 'name.          ', &
!!       & '.name          ', &
!!       & '.name.         ', &
!!       & '.              ', &
!!       & '..             ', &
!!       & '...            ']
!!
!!    character(len=maxlen)  :: dir
!!    character(len=maxlen)  :: name
!!    character(len=maxlen)  :: basename
!!    character(len=maxlen)  :: ext
!!    integer                :: i
!!    integer                :: longest
!!    longest=maxval(len_trim(file)) ! find longest filename
!!
!!    do i=1,size(file)
!!       call splitpath(file(i), dir, name, basename, ext)
!!       write(*,'(*("| ",a:))')  &
!!       & file(i)(:longest),     &
!!       & dir(:longest),         &
!!       & name(:longest),        &
!!       & basename(:longest),    &
!!       & ext(:longest)
!!    enddo
!!   end program demo_splitpath
!!
!!   Output
!!
!!    | dirs/name.ext | dirs          | name.ext      | name          | .ext
!!    | xx/IO/zz/NN.FF| xx/IO/zz      | NN.FF         | NN            | .FF
!!    | xx/IO/zz/NN   | xx/IO/zz      | NN            | NN            |
!!    | /xx/IO/zz/NN  | /xx/IO/zz     | NN            | NN            |
!!    | /xx/IO/zz/    | /xx/IO/zz     |               |               |
!!    | /xx/IO/zz.A/  | /xx/IO/zz.A   |               |               |
!!    | /xx/IO/zz/.   | /xx/IO/zz/.   |               |               |
!!    |               | .             |               |               |
!!    | ./            | .             |               |               |
!!    | /             | /             |               |               |
!!    | /..           | /             |               |               |
!!    | ./..          | ./..          |               |               |
!!    | name.         |               | name.         | name          | .
!!    | .name         |               | .name         | .name         |
!!    | .name.        |               | .name.        | .name         | .
!!    | .             | .             |               |               |
!!    | ..            |               |               |               |
!!    | ...           |               | ...           | ..            | .
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine splitpath(path,dir,name,basename,ext)
implicit none

! ident_10="@(#) M_io splitpath(3f) split Unix pathname into components (dir name basename extension)"

!===================================================================================================================================
character(len=*),intent(in)           :: path
character(len=*),intent(out),optional :: dir
character(len=*),intent(out),optional :: name
character(len=*),intent(out),optional :: basename
character(len=*),intent(out),optional :: ext
integer,parameter                     :: maxlen=4096
character(len=maxlen)                 :: dir_local
character(len=maxlen)                 :: name_local
character(len=maxlen)                 :: basename_local
character(len=maxlen)                 :: ext_local
character(len=len(path)+1)            :: path_local
integer                               :: where
integer                               :: i
integer                               :: iend
character(len=1)                 :: sep
   sep=separator()
!===================================================================================================================================
   path_local=path                           ! initialize variables
   dir_local=''
   name_local=''
   basename_local=''
   ext_local=''
   iend=len_trim(path_local)
   LOCAL : block
!===================================================================================================================================
   if(iend == 0)then                         ! blank input path
      dir_local='.'
      exit LOCAL
   endif
!===================================================================================================================================
   if(path_local(iend:iend) == sep)then      ! assume entire name is a directory if it ends in a slash
      if(iend > 1)then
         dir_local=path_local(:iend-1)
      else                                   ! if just a slash it means root directory so leave it as slash
         dir_local=path_local
      endif
      exit LOCAL
   endif
!===================================================================================================================================
   TRIMSLASHES: do i=iend,1,-1               ! trim off trailing slashes even if duplicates
      if(path_local(i:i) == sep)then
         path_local(i:i)=' '
         iend=i-1
      else
         iend=i
         exit TRIMSLASHES
      endif
   enddo TRIMSLASHES

   if(iend == 0)then                         ! path composed entirely of slashes.
      dir_local=sep
      exit LOCAL
   endif
!===================================================================================================================================
   where=INDEX(path_local,sep,BACK=.true.)   ! find any right-most slash in remaining non-null name_local after trimming trailing slashes
   if(where <= 0)then                        ! no slash in path so everything left is name_local
      name_local=path_local(:iend)                 ! this is name_local unless '.' or '..'
   else                                      ! last slash found
      dir_local=path_local(:where-1)               ! split into directory
      name_local=path_local(where+1:iend)          ! this is name_local unless '.' or '..'
   endif
!===================================================================================================================================
   select case (name_local(1:3))                   ! special cases where name_local is a relative directory name_local '.' or '..'
   case('.  ')
      dir_local=path_local
      name_local=''
   case('.. ')
      if(dir_local == '')then
         if(path_local(1:1) == sep)then
            dir_local=sep
         endif
      else
         dir_local=path_local
      endif
      name_local=''
   case default
   end select
!===================================================================================================================================
   if(name_local == '.')then
      name_local=''
   endif
!===================================================================================================================================
   iend=len_trim(name_local)
   where=INDEX(name_local,'.',BACK=.true.)         ! find any extension
   if(where > 0.and.where /= 1)then         ! only consider a non-blank extension name_local
      ext_local=name_local(where:)
      basename_local=name_local(:where-1)
   else
      basename_local=name_local
   endif
!===================================================================================================================================
   endblock LOCAL
   if(present(dir))dir=dir_local
   if(present(name))name=name_local
   if(present(basename))basename=basename_local
   if(present(ext))ext=ext_local
end subroutine splitpath
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getline(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                  string up to line length limit
!!    (LICENSE:PD)
!!
!!##SYNTAX
!!   function getline(line,lun,iostat) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,intent(out),optional             :: iostat
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!    Read a line of any length up to programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function
!!    to work properly, which is typically true.
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a
!!    time could (depending on the programming environment used) be
!!    inefficient, as it could reallocate and allocate memory used for
!!    the output string with each buffer read.
!!
!!##OPTIONS
!!    LINE    line read
!!    LUN     optional LUN (Fortran logical I/O unit) number. Defaults
!!            to stdin.
!!    IOSTAT  status returned by READ(IOSTAT=IOS). If not zero, an error
!!            occurred or an end-of-file or end-of-record was encountered.
!!            This is the same value as returned by the function. See the
!!            example program for a usage case.
!!##RETURNS
!!    IER     zero unless an error occurred. If not zero, LINE returns the
!!            I/O error message.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_getline
!!    use,intrinsic :: iso_fortran_env, only : stdin=>input_unit
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : getline
!!    implicit none
!!    integer :: iostat
!!    character(len=:),allocatable :: line
!!       open(unit=stdin,pad='yes')
!!       INFINITE: do while (getline(line,iostat=iostat)==0)
!!          write(*,'(a)')'['//line//']'
!!       enddo INFINITE
!!       if(iostat /= iostat_end)then
!!          write(*,*)'error reading input:',trim(line)
!!       endif
!!    end program demo_getline
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function getline(line,lun,iostat) result(ier)
implicit none

! ident_11="@(#) M_io getline(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,intent(out),optional             :: iostat
integer                                  :: ier
character(len=4096)                      :: message

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=buflen)                    :: buffer
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   if(present(lun))then
      lun_local=lun
   else
      lun_local=stdin
   endif

   INFINITE: do                                                   ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no', &
      & size=isize,iomsg=message) buffer                          ! read next buffer (might use stream I/O for files
                                                                  ! other than stdin so system line limit is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)          ! append what was read to result
      if(is_iostat_eor(ier))then                                  ! if hit EOR reading is complete unless backslash ends the line
         ier=0                                                    ! hitting end of record is not an error for this routine
         exit INFINITE                                            ! end of reading line
     elseif(ier /= 0)then                                         ! end of file or error
        line=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   line=line_local                                                ! trim line
   if(present(iostat))iostat=ier
end function getline
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     read_line(3f) - [M_io:READ] read a line from specified LUN into allocatable
!!                     string up to line length limit cleaning up input line
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function read_line(line,lun,ios) result(ier)
!!
!!    character(len=:),allocatable,intent(out) :: line
!!    integer,intent(in),optional              :: lun
!!    integer,optional                         :: ios
!!    integer                                  :: ier
!!
!!##DESCRIPTION
!!
!!    Read a line of any length up to the programming environment maximum
!!    line length. Requires Fortran 2003+.
!!
!!    It is primarily expected to be used when reading input which will
!!    then be parsed.
!!
!!    The input file must have a PAD attribute of YES for the function to
!!    work properly, which is typically true but can be set on an open file.
!!
!!    o Append lines that end in a backslash with next line
!!    o Expand tabs
!!    o Replace unprintable characters with spaces
!!    o Remove trailing carriage return characters and white space
!!
!!    The simple use of a loop that repeatedly re-allocates a character
!!    variable in addition to reading the input file one buffer at a time
!!    could (depending on the programming environment used) be inefficient,
!!    as it could reallocate and allocate memory used for the output string
!!    with each buffer read.
!!
!!##OPTIONS
!!    LINE   the line read from the file.
!!    LUN    The LUN (logical unit) to read from. Defaults to stdin.
!!    IOS    status returned by READ(IOSTAT=IOS). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!           This is the same value as returned by the function. See the
!!           example program for a usage case.
!!##RETURNS
!!    IER    status returned by READ(IOSTAT=IER). If not zero, an error
!!           occurred or an end-of-file or end-of-record was encountered.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!   Checking the error message and counting lines:
!!
!!     program demo_read_line
!!     use,intrinsic :: iso_fortran_env, only : stdin  => input_unit
!!     use,intrinsic :: iso_fortran_env, only : stderr => error_unit
!!     use,intrinsic :: iso_fortran_env, only : iostat_end, iostat_eor
!!     use M_io, only : read_line
!!     implicit none
!!     character (len =: ), allocatable :: line
!!     integer                          :: stat
!!     integer                          :: icount=0
!!        open(unit=stdin,pad='yes')
!!        INFINITE: do while (read_line(line,ios=stat) == 0)
!!           icount=icount
!!           write (*, '(*(g0))') icount,' [',line,']'
!!        enddo INFINITE
!!        if ( .not.is_iostat_end(stat) ) then
!!           write (stderr, '(*(g0))') &
!!           & 'error: line ',icount,'==>',trim (line)
!!        endif
!!     end program demo_read_line
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function read_line(line,lun,ios) result(ier)
implicit none

! ident_12="@(#) M_io read_line(3f) read a line from specified LUN into allocatable string up to line length limit"

character(len=:),allocatable,intent(out) :: line
integer,intent(in),optional              :: lun
integer,optional                         :: ios
integer                                  :: ier

integer,parameter                        :: buflen=1024
character(len=:),allocatable             :: line_local
character(len=256)                       :: message
integer                                  :: biggest
character(len=buflen)                    :: buffer
integer                                  :: last
integer                                  :: isize
integer                                  :: lun_local

   line_local=''
   ier=0
   lun_local=merge(lun,stdin,present(lun))
   INFINITE: do                                                           ! read characters from line and append to result
      read(lun_local,pad='yes',iostat=ier,fmt='(a)',advance='no',size=isize,iomsg=message) buffer ! read next buffer (might use stream I/O for
                                                                          ! files other than stdin so system line limit
                                                                          ! is not limiting
      if(isize > 0)line_local=line_local//buffer(:isize)   ! append what was read to result
      if(is_iostat_eor(ier))then                            ! if hit EOR reading is complete unless backslash ends the line
         last=len(line_local)
         if(last /= 0)then
            if(line_local(last:last) == '\')then            ! if line ends in backslash it is assumed a continued line
               line_local=line_local(:last-1)               ! remove backslash
               cycle INFINITE                               ! continue on and read next line and append to result
            endif
         endif
         ier=0                                              ! hitting end of record is not an error for this routine
         exit INFINITE                                      ! end of reading line
     elseif(ier /= 0)then                                   ! end of file or error
        line_local=trim(message)
        exit INFINITE
     endif
   enddo INFINITE
   biggest=8*len(line_local)                                ! worst case is raw line is all tab characters
   if(allocated(line))deallocate(line)
   allocate(character(len=biggest) :: line)
   call notabs(line_local,line,last)                        ! expand tabs, trim carriage returns, remove unprintable characters
   line=noesc(line)
   line=trim(line(:last))                                   ! trim line
   if(present(ios))then
      ios=ier
   endif
end function read_line
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      get_tmp(3f) - [M_io:QUERY] Return the name of the scratch directory
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!     function get_tmp() result(tname)
!!
!!      character(len=:),allocatable :: tname
!!##DESCRIPTION
!!
!!    Return the name of the scratch directory set by the most common
!!    environment variables used to designate a scratch directory.
!!    $TMPDIR is the canonical environment variable in Unix and POSIX[1]
!!    to use to specify a temporary directory for scratch space. If $TMPDIR
!!    is not set, $TEMP, $TEMPDIR, and $TMP are examined in that order. If
!!    nothing is set "/tmp/" is returned. The returned value always ends in
!!    "/". No test is made that the directory exists or is writable.
!!
!!##EXAMPLE
!!
!!
!!   Sample:
!!
!!     program demo_get_tmp
!!     use M_io, only : get_tmp, uniq
!!     implicit none
!!     character(len=:),allocatable :: answer
!!        answer=get_tmp()
!!        write(*,*)'result is ',answer
!!        answer=get_tmp()//uniq('_scratch',create=.false.)
!!        write(*,*)'the file ',answer, &
!!        & ' was a good scratch file name, at least a moment ago'
!!     end program demo_get_tmp
!!
!!   Sample Results:
!!
!!     > result is /cygdrive/c/Users/JSU/AppData/Local/Temp/
!!     >
!!     > the file /cygdrive/c/Users/JSU/AppData/Local/Temp/_scratch
!!     > was a good scratch file name, at least a moment ago
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function get_tmp() result(tname)

! ident_13="@(#) M_io get_tmp(3f) Return the name of the scratch directory"

character(len=:),allocatable :: tname
integer                      :: lngth
character(len=10),parameter  :: names(*)=["TMPDIR    ","TEMP      ","TEMPDIR   ","TMP       "]
integer                      :: i
character(len=1)             :: sep
   sep=separator()
   tname=''
   do i=1,size(names)
      call get_environment_variable(name=names(i), length=lngth)
      if(lngth /= 0)then
         if(allocated(tname))deallocate(tname)
         allocate(character(len=lngth) :: tname)
         call get_environment_variable(name=names(i), value=tname)
         exit
      endif
   enddo
   if(lngth == 0)then
      tname='/tmp'
      lngth=len_trim(tname)
   endif
   if(scan(tname(lngth:lngth),'/\') == 0)then
      tname=tname//sep
   endif
end function get_tmp
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! rd(3f) - [M_io:READ] ask for string from standard input with user-definable prompt
!! (LICENSE:PD)
!!
!!   function rd(prompt,default) result(out)
!!
!!    character(len=*),intent(in)              :: prompt
!!
!!   One of
!!
!!    character(len=*),intent(in)              :: default
!!    character(len=:),allocatable,intent(out) :: out
!!
!!    integer,intent(in)                       :: default
!!    integer,intent(out)                      :: out
!!
!!    real,intent(in)                          :: default
!!    real,intent(out)                         :: out
!!
!!    doubleprecision,intent(in)               :: default
!!    doubleprecision,intent(out)              :: out
!!
!!    logical,intent(in)                       :: default
!!    logical,intent(out)                      :: out
!!
!!
!!##DESCRIPTION
!!    Ask for string or value from standard input with user-definable prompt
!!    up to 20 times.
!!
!!    Do not use the function in an I/O statement as not all versions of
!!    Fortran support this form of recursion. Numeric values may be input
!!    in standard INTEGER, REAL, and DOUBLEPRECISION formats or as whole
!!    numbers in base 2 to 36 in the format BASE#VALUE.
!!
!!##OPTIONS
!!    prompt    Prompt string; displayed on same line as input is read from
!!    default   default answer on carriage-return. The type of the default
!!              determines the type of the output.
!!##RETURNS
!!    out       returned string or value. If an end-of-file or system error
!!              is encountered the string "EOF" is returned, or a "Nan"
!!              REAL numeric value, or huge(0), or .false. .
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_rd
!!    use M_io, only : rd
!!    implicit none
!!    character(len=:),allocatable :: mystring
!!    doubleprecision              :: d
!!    real                         :: r
!!    integer                      :: i
!!    logical                      :: l
!!
!!    INFINITE: do
!!       mystring=rd('Enter string or "STOP":',default='Today')
!!       if(mystring == 'STOP')stop
!!       i=rd('Enter integer:',default=huge(0))
!!       r=rd('Enter real:',default=huge(0.0))
!!       d=rd('Enter double:',default=huge(0.0d0))
!!       l=rd('Enter logical:',default=.false.)
!!
!!       write(*,*)'I=', i, 'R=', r, 'D=',d,  'MYSTRING=', mystring
!!       write(*,*)'L=', l
!!    enddo INFINITE
!!
!!    end program demo_rd
!!
!!##AUTHOR
!!    John S. Urban, 1993
!!##LICENSE
!!    Public Domain
function rd_logical(prompt,default) result(out)
! 1995 John S. Urban
!
implicit none

! ident_14="@(#) M_io rd_logical(3fp) ask for logical value from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
logical,intent(in)           :: default
logical                      :: out

integer                      :: prompt_len
integer                      :: igot
integer                      :: ierr
integer                      :: icount
integer                      :: ios
character(:),allocatable     :: response
character(len=256)           :: iomsg
   out=.false.
   response=''
   prompt_len=len(prompt)
   do icount=1,20                                                 ! prevent infinite loop on error or end-of-file
      if(prompt_len > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(response,stdin)                                ! get back string
      igot=len(response)
      if(ierr /= 0)then
         cycle
      elseif(igot == 0.and.prompt_len > 0)then
         out=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         response=response//' '
         select case(response(1:1))
         case('y','Y')
            out=.true.
         case('n','N')
            out=.false.
         case default
            read(response,*,iostat=ios,iomsg=iomsg)out
            if(ios /= 0)then
               write(*,*)trim(iomsg)
               cycle
            endif
         end select
         exit
      endif
   enddo
end function rd_logical
!===================================================================================================================================
function rd_character(prompt,default) result(strout)
! 1995 John S. Urban
!
implicit none

! ident_15="@(#) M_io rd_character(3fp) ask for string from standard input with user-definable prompt"

character(len=*),intent(in)  :: prompt
character(len=*),intent(in)  :: default
character(len=:),allocatable :: strout

integer                      :: len_default
integer                      :: igot
integer                      :: ierr
integer                      :: icount
!===================================================================================================================================
   len_default=len(prompt)
!===================================================================================================================================
   do icount=1,20                                                  ! prevent infinite loop on error or end-of-file
      if(len_default > 0)write(*,'(a,'' '')',advance='no')prompt  ! write prompt
      ierr=getline(strout,stdin)                                  ! get back string
      igot=len(strout)
      if(ierr /= 0)then
         strout='EOF'
         cycle
      elseif(igot == 0.and.len_default > 0)then
         strout=default
         exit
      elseif(igot <= 0)then
         call journal('*rd* blank string not allowed')
         cycle
      else
         exit
      endif
   enddo
end function rd_character
!===================================================================================================================================
function rd_doubleprecision(prompt,default,iostat) result(dvalue)
implicit none

! ident_16="@(#) M_io rd_doubleprecision(3fp) ask for number from standard input with user-definable prompt"

doubleprecision              :: dvalue
integer                      :: ivalue
character(len=*),intent(in)  :: prompt
doubleprecision,intent(in)   :: default
integer,intent(out),optional :: iostat
character(len=:),allocatable :: strout
character(len=:),allocatable :: message
integer                      :: itest

   iostat=0
   dvalue=default
   strout=adjustl(rd_character(prompt,'NaN'))

   ! 1 for an integer [-+]NNNNN
   ! 2 for a whole number [-+]NNNNN.
   ! 3 for a real value [-+]NNNNN.MMMM
   ! 4 for a exponential value [-+]NNNNN.MMMM[-+]LLLL [-+]NNNNN.MMMM[ed][-+]LLLL
   ! values less than 1 represent an error
   if(strout == 'NaN')then
      dvalue=default
   elseif(index(strout,'#') /= 0)then
      if( decodebase(strout,0,ivalue))then
         dvalue=ivalue
      else
         iostat=-1
         write(*,*)'ERROR> could not convert ',strout
      endif
   else
      itest=isnumber(strout,message)
      if(itest > 0)then
         dvalue=s2v(strout,ierr=iostat)
      else
         iostat=-2
         write(*,*)' ERROR> for ',strout,' ',itest,':',trim(message)
      endif
   endif
end function rd_doubleprecision
!===================================================================================================================================
function rd_real(prompt,default,iostat) result(rvalue)
implicit none

! ident_17="@(#) M_io rd_real(3fp) ask for number from standard input with user-definable prompt"

real                         :: rvalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
real,intent(in)              :: default
integer,intent(out),optional :: iostat
   !*! what about Nan, Inf, -Inf? Likely place for compiler bugs
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      rvalue=huge(0.0)
   else
      rvalue=real(dvalue)
   endif
end function rd_real
!===================================================================================================================================
function rd_integer(prompt,default,iostat) result(ivalue)
implicit none

! ident_18="@(#) M_io rd_integer(3fp) ask for number from standard input with user-definable prompt"

integer                      :: ivalue
real(kind=dp)                :: dvalue
character(len=*),intent(in)  :: prompt
integer,intent(in)           :: default
integer,intent(out),optional :: iostat
   dvalue=rd_doubleprecision(prompt,dble(default),iostat)
   !*! what about Nan, Inf, -Inf?
   if(dvalue /= dvalue)then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] is indefinite'
      ivalue=huge(0)
   elseif(dvalue > huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] greater than ', huge(0)
      ivalue=huge(0)
   elseif(dvalue < 1-huge(0))then
      write(stderr,'(*(g0))') &
      & '<ERROR>*input* value [',dvalue,'] less than ', 1-huge(0)
      ivalue=1-huge(0)
   else
      ivalue=nint(dvalue)
   endif
end function rd_integer
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getname(3f) - [M_io:QUERY] get name of the current executable
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getname() result(name)
!!
!!     character(len=:),allocatable         :: getname
!!
!!##DESCRIPTION
!!    getname(3f) returns the name of the current executable using
!!    get_command_argument(3f) and inquire(3f).
!!
!!##EXAMPLE
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getname
!!      use M_io, only : getname
!!      implicit none
!!         write(*,'(*(a))')'Running ',getname()
!!      end program demo_getname
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getname() result(name)
! get the pathname of arg0
implicit none
character(len=:),allocatable :: arg0
integer                      :: arg0_length
integer                      :: ios
character(len=4096)          :: long_name
character(len=:),allocatable :: name
   arg0_length=0
   name=''
   long_name=''
   call get_command_argument(0,length=arg0_length,status=ios)
   if(ios == 0)then
      if(allocated(arg0))deallocate(arg0)
      allocate(character(len=arg0_length) :: arg0)
      call get_command_argument(0,arg0,status=ios)
      if(ios == 0)then
         inquire(file=arg0,iostat=ios,name=long_name)
         if(ios == 0)then
            name=trim(long_name)
         else
            name=arg0
         endif
      else
         arg0=''
      endif
   else
      arg0=''
   endif
end function getname
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     which(3f) - [M_io:SCANNAMES] given a command name find the pathname
!!                 by searching the directories in the environment variable
!!                 $PATH
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function which(command) result(pathname)
!!
!!    character(len=*),intent(in)  :: command
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a command name find the first file with that name in the directories
!!    specified by the environment variable $PATH.
!!
!!##OPTIONS
!!    COMMAND   the command to search for
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the command is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_which
!!     use M_io, only : which
!!     implicit none
!!        write(*,*)'ls is ',which('ls')
!!        write(*,*)'dir is ',which('dir')
!!        write(*,*)'install is ',which('install')
!!     end program demo_which
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function which(command) result(pathname)
character(len=*),intent(in)     :: command
character(len=:),allocatable    :: pathname, checkon, paths(:), exts(:)
integer                         :: i, j
   pathname=''
   call split(get_env('PATH'),paths,delimiters=merge(';',':',separator() == '\'))
   SEARCH: do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),command))
      select case(separator())
      case('/')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
      case('\')
         if(exists(checkon))then
            pathname=checkon
            exit SEARCH
         endif
         if(exists(checkon//'.bat'))then
            pathname=checkon//'.bat'
            exit SEARCH
         endif
         if(exists(checkon//'.exe'))then
            pathname=checkon//'.exe'
            exit SEARCH
         endif
         call split(get_env('PATHEXT'),exts,delimiters=';')
         do j=1,size(exts)
            if(exists(checkon//'.'//trim(exts(j))))then
               pathname=checkon//'.'//trim(exts(j))
               exit SEARCH
            endif
         enddo
      end select
   enddo SEARCH
contains
logical function exists(filename) result(r)
character(len=*), intent(in) :: filename
    inquire(file=filename, exist=r)
end function exists
end function which
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     lookfor(3f) - [M_io:SCANNAMES] look for a filename in a number
!!                   of directories specified by an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!   function lookfor(basename,env) result(pathname)
!!
!!    character(len=:),intent(in)  :: basename
!!    character(len=:),intent(in)  :: env
!!    character(len=:),allocatable :: pathname
!!
!!##DESCRIPTION
!!    Given a base filename find the first file with that name in the directories
!!    specified by the environment variable ENV
!!
!!##OPTIONS
!!    BASENAME   the file to search for
!!    ENV        environment variable name. Separator between directory names is
!!               assumed to be a colon on ULS (Unix-Like Systems) and semi-colon on
!!               MS-Windows machines.
!!
!!##RETURNS
!!    PATHNAME  the first pathname found in the current user path. Returns blank
!!              if the file is not found.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!     program demo_lookfor
!!     use M_io, only : lookfor
!!     implicit none
!!     character(len=:),allocatable :: returned
!!        returned=lookfor('ls','PATH')
!!        write(*,*)'ls is ',returned
!!        returned=lookfor('dir.exe','PATH')
!!        write(*,*)'dir is ',returned
!!     end program demo_lookfor
!!
!!##SEE ALSO
!!    M_system:system_dir(3f)
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function lookfor(basename,env) result(pathname)
character(len=*),intent(in)     :: basename
character(len=*),intent(in)     :: env
character(len=:),allocatable    :: pathname, checkon, paths(:)
integer                         :: i
logical                         :: r
   pathname=''
   call split(get_env(env),paths,delimiters=merge(';',':',separator() == '\'))
   if(size(paths) == 0)then
      paths=['']
   endif
   do i=1,size(paths)
      checkon=trim(joinpath(trim(paths(i)),basename))
      inquire(file=checkon, exist=r)
      if(r)then
         pathname=checkon
         exit
      endif
   enddo
end function lookfor
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_env(3f) - [M_io:QUERY] a function returning the value of
!!                   an environment variable
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    function get_env(NAME,DEFAULT,IERR=IERR) result(VALUE)
!!
!!     character(len=*),intent(in)            :: NAME
!!
!!     ! ONE OF ...
!!     o character(len=*),intent(in),optional :: DEFAULT
!!     o real,intent(in),optional             :: DEFAULT
!!     o integer,intent(in),optional          :: DEFAULT
!!     o doubleprecision,intent(in),optional  :: DEFAULT
!!     o logical,intent(in),optional          :: DEFAULT
!!
!!     integer,intent(out),optional           :: IERR
!!
!!     ! ONE OF THE FOLLOWING, MATCHING TYPE OF DEFAULT
!!     o character(len=:),allocatable         :: VALUE
!!     o integer                              :: VALUE
!!     o real                                 :: VALUE
!!     o doubleprecision                      :: VALUE
!!     o logical                              :: VALUE
!!
!!##DESCRIPTION
!!     Get the value of an environment variable or optionally return a
!!     default value when the environment variable is not set or is set
!!     to a blank string.
!!
!!     The type returned is the same as the type of the default value.
!!
!!
!!##OPTIONS
!!    NAME     name of environment variable
!!    DEFAULT  value to return if environment variable is not set or set
!!             to an empty string. May be CHARACTER, REAL, INTEGER,
!!             LOGICAL or DOUBLEPRECISION. Defaults to a null CHARACTER value.
!!##RETURNS
!!    VALUE    the value of the environment variable or the default.
!!             The type is the same as DEFAULT. If an error occurs and it
!!             is numeric, huge(0|0.0|0.0d0) is returned.
!!
!!             For a LOGICAL type, Any environment variable value starting
!!             with F,f,N or n is .FALSE. and any value starting with
!!             Y,y,T or t is true. A leading period (".") is ignored.
!!             Anything else returns .false. .
!!
!!    IERR     return error code. Must be specified with a keyword.
!!             It is zero if no error occurred.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_env
!!    use M_io, only : get_env, getname
!!    character(len=*),parameter :: g='(*(g0))'
!!    integer :: ierr
!!    character(len=:),allocatable :: HOME
!!      !Basics
!!       HOME=get_env('HOME','UNKNOWN')
!!       write(*,'(a)')HOME
!!       write(*,'(a)')Get_env('PATH')
!!
!!      !call this program setting STOP=RUN unless STOP=RUN
!!      !otherwise print various environment variable values
!!      !converted to various types
!!       if(get_env('STOP').eq.'RUN')then
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER','string')
!!          write(*,g)get_env('INTEGER',100)
!!          write(*,g)get_env('REAL',200.0)
!!          write(*,g)get_env('DOUBLE',300.0d0)
!!          write(*,g)get_env('LOGICAL',.true.)
!!
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER','string',ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('INTEGER',100,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('REAL',200.0,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('DOUBLE',300.0d0,ierr=ierr)
!!          write(*,*)'ierr=',ierr
!!          write(*,g)get_env('LOGICAL',.true.)
!!          write(*,*)'ierr=',ierr
!!
!!          write(*,g)repeat('-',80)
!!          write(*,g)get_env('CHARACTER')
!!          write(*,g)get_env('HOME')
!!        else
!!          write(*,g)repeat('-',80)
!!          call execute_command_line('env STOP=RUN '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=aaaa &
!!          & INTEGER=1 REAL=2.3 DOUBLE=444444444444 '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=bbbb &
!!          & INTEGER=1 REAL=2.3 DOUBLE=44.555 '//getname())
!!          call execute_command_line('env STOP=RUN CHARACTER=cccc &
!!          & INTEGER=asdf REAL=asdf DOUBLE=adsf '//getname())
!!          write(*,g)repeat('-',80)
!!          stop
!!       endif
!!
!!    end program demo_get_env
!!
!!##SEE ALSO
!!    This duplicates system_getenv(3m_system) in most respects but avoids
!!    some interdependencies as M_system(3) currently requires a POSIX
!!    programming environment.
!!
!!    get_environment_variable(3fortran), system_getenv(3m_system),
!!    set_environment_variable(3m_system), system_putenv(3m_system),
!!    system_clearenv(3m_system), system_initenv(3m_system),
!!    system_getenv(3m_system), system_unsetenv(3m_system)
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
function get_env_character(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
implicit none
character(len=*),intent(in)                :: NAME
character(len=*),intent(in),optional       :: DEFAULT
type(force_keywd_hack),optional,intent(in) :: force_keywd
integer,intent(out),optional               :: ierr
character(len=:),allocatable               :: VALUE
character(len=255)                         :: errmsg
integer                                    :: howbig
integer                                    :: stat
integer                                    :: length
   ! get length required to hold value
   length=0
   errmsg=''
   stat=0
   if(NAME.ne.'')then
      call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
         !*!print *, NAME, " is not defined in the environment. Strange..."
         VALUE=''
         stat=0
      case (2)
         !*!print *, "This processor doesn't support environment variables. Boooh!"
         VALUE=''
      case default
         ! make string to hold value of sufficient size
         allocate(character(len=max(howbig,1)) :: VALUE)
         ! get value
         call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)
         if(stat.ne.0)VALUE=''
      end select
   else
      VALUE=''
   endif
   if(VALUE.eq.''.and.present(DEFAULT))VALUE=DEFAULT
   if(present(ierr))then
      ierr=stat
   elseif(stat.ne.0)then
      !write(stderr,'(a)')trim(errmsg)
   endif
end function get_env_character

function get_env_real(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
real,intent(in)               :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
real                          :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
   else
      write(fmt,'(*(g0))')'(g',max(1,len(string)),'.0)'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0.0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_real

function get_env_double(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
doubleprecision,intent(in)    :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
doubleprecision               :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
   else
      write(fmt,'(*(g0))')'(g',max(1,len(string)),'.0)'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0.0d0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_double

function get_env_integer(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
integer,intent(in)            :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
integer                       :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
   STRING=get_env_character(NAME,'')
   iostat=0
   iomsg=''
   if(STRING.eq.'')then
      VALUE=DEFAULT
      iostat=0
   else
      write(fmt,'(*(g0))')'(i',max(1,len(string)),')'
      string=string//' '
      read(STRING,fmt,iostat=iostat,iomsg=iomsg)value
      if(iostat.ne.0)then
         value=-huge(0)
      endif
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_integer

function get_env_logical(NAME,DEFAULT,force_keywd,ierr) result(VALUE)
character(len=*),intent(in)   :: NAME
logical,intent(in)            :: DEFAULT
type(force_keywd_hack), optional, intent(in) :: force_keywd
integer,intent(out),optional :: ierr
logical                       :: VALUE
character(len=:),allocatable  :: STRING
integer                       :: iostat
character(len=255)            :: iomsg, fmt
character(len=1)              :: ch
   STRING=get_env_character(NAME,'',ierr=iostat)
   if(iostat.ne.0)then
      VALUE=.false.
   elseif(STRING.eq.'')then
      VALUE=DEFAULT
      iostat=0
   else
      string=string//'  '
      ch=string(1:1)
      if(ch.eq.'.')ch=string(2:2)
      select case(ch)
      case('t','T','y','Y')
         value=.true.
      case('f','F','n','N')
         value=.false.
       case default
         value=.false.
      end select
   endif
   if(present(ierr))then
      ierr=iostat
   elseif(iostat.ne.0)then
      write(stderr,'(a)')'<ERROR>*get_env* NAME='//NAME//' STRING='//STRING//':'//trim(iomsg)
   endif
end function get_env_logical

!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   is_hidden_file(3f) - [M_io:QUERY]  determine if a pathname points to a
!!   hidden file, which is defined as a file basename starting with a period.
!!   (LICENSE:PD)
!!
!!##SYNTAX
!!     impure elemental function is_hidden_file(PATH) result(YESNO)
!!
!!      character(len=*),intent(in) :: PATH
!!      logical                     :: YESNO
!!
!!##DESCRIPTION
!!    Given a pathname determine if it is a hidden file. This is simply
!!    assumed to be a basename that does not begin with a period and is not
!!    a single or double period, assumed to represent the current directory
!!    and parent directory.
!!
!!##LIMITATIONS
!!    Pathnames are not expanded to a canonical form, so if the basename is
!!    '.' or '..' and those point to a hidden directory name the return
!!    value will still be .FALSE. . Filenames are assumed to not contain
!!    leading or trailing spaces.
!!
!!##OPTIONS
!!    PATH     pathname to classify. It need not exist.
!!
!!##RETURNS
!!    YESNO    true if pathname points to a hidden file, otherwise it
!!             is false.
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!       program demo_is_hidden_file
!!       use M_io, only : is_hidden_file, basename
!!          call showit('.abc')
!!          call showit('./.')
!!          call showit('..')
!!          call showit('...')
!!          call showit('/abc/def/notes.txt')
!!          call showit('/abc/def/.hide')
!!       contains
!!       subroutine showit(path)
!!       character(len=*),intent(in) :: path
!!          write(*,*)is_hidden_file(path), &
!!           & ' ,path=',path
!!       end subroutine showit
!!       end program demo_is_hidden_file
!!
!!    Results:
!!
!!     >  T  ,path=.abc
!!     >  F  ,path=./.
!!     >  F  ,path=..
!!     >  T  ,path=...
!!     >  F  ,path=/abc/def/notes.txt
!!     >  T  ,path=/abc/def/.hide
!!
!!##SEE ALSO
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
impure elemental function is_hidden_file(path) result(yesno)
character(*), intent(in) :: path
logical :: yesno
character(len=:), allocatable :: base

   base = basename(path,suffix=char(0))//'  '
   select case (base)
   case ('.', '..');  yesno = .false.
   case default;      yesno = merge(.true., .false., base(1:1) == '.')
   end select

end function is_hidden_file
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     get_next_char(3f) - [M_io:READ] read from a file one character at a time
!!     (LICENSE:PD)
!!
!!##SYNTAX
!!    subroutine get_next_char(fd,c,ios)
!!
!!     integer,intent(in)    :: fd
!!     character,intent(out) :: c
!!     integer,intent(out)   :: ios
!!
!!
!!##DESCRIPTION
!!    This reads a file opened with stream access one character at a
!!    time, much like ""read(fd,iostat=ios) c" but with buffering, which
!!    I have found to be up to sixty times faster than such a plain read,
!!    although this varies depending on how or if the programming environment
!!    implements I/O buffering itself.
!!
!!    IT USES SAVED VARIABLES AND CAN ONLY BE USED ON ONE FILE AT A TIME
!!    IN THE CURRENT FORM. A user type including the saved values and the
!!    LUN could easily resolve this.
!!
!!##OPTIONS
!!    FD    A Fortran unit number of a file opened for stream access
!!    C     The next returned character if IOS=0
!!    IOS   The error status returned by the last read. It is zero (0) if
!!          no error occurred
!!
!!##EXAMPLE
!!
!!   Sample program:
!!
!!    program demo_get_next_char
!!    use,intrinsic :: iso_fortran_env, only : iostat_end
!!    use M_io, only : get_next_char
!!    implicit none
!!    character(len=4096) :: filename ! filename to read
!!    character(len=256)  :: message  ! returned error messages
!!    integer             :: fd       ! file descriptor for input file
!!    integer             :: ios,ios1 ! hold I/O error flag
!!    character           :: c1       ! current character read
!!       filename='test.in'
!!       open(unit=fd,file=trim(filename),access='stream',status='old',&
!!       & iostat=ios,action='read',form='unformatted',iomsg=message)
!!       if(ios /= 0)then
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: could not open '//&
!!          trim(filename)
!!          write(*,*)&
!!          '*demo_get_next_char* ERROR: '//trim(message)
!!          stop 5
!!       endif
!!       ! loop through read of file one character at a time
!!       ONE_CHAR_AT_A_TIME: do
!!          ! get next character from buffered read from file
!!          call get_next_char(fd,c1,ios1)
!!          if(ios1 == iostat_end)then
!!             ! reached end of file so stop
!!             stop
!!          elseif(ios1 /= 0 )then
!!             ! error on file read
!!             write(*,*)&
!!          '*demo_get_next_char* ERROR: before end of '//&
!!          trim(filename)
!!             stop 1
!!          endif
!!          ! do something with the characters
!!          write(*,'(a)',advance='no')c1
!!       enddo ONE_CHAR_AT_A_TIME
!!    end program demo_get_next_char
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine get_next_char(fd,c,ios)
! replace "read(fd,iostat=ios) c" because gfortran on CygWin sixty times slower with plain read (no system buffering?)
! quick buffering read
implicit none
integer,intent(in)          :: fd
character,intent(out)       :: c
integer,intent(out)         :: ios
integer,parameter           :: bufsize=1048576
character(len=1),save       :: buff(bufsize)
integer,save                :: point=0
integer,save                :: filepoint=1
integer,save                :: sz=bufsize

ios=0

do
select case(point)
case(0)                                            ! read a buffer
   read(fd,iostat=ios,pos=filepoint) buff(1:sz)
   if(is_iostat_end(ios))then                      ! this is the last buffer
      if(sz /= 1)then                              ! try again with a smaller buffer
         sz=sz/2
         sz=max(1,sz)
         cycle
      endif
   elseif(ios == 0)then                            ! no error occurred so successfully read a buffer
      c=buff(1)
      filepoint=filepoint+sz
      point=sz-1
   endif
case(1:)                                           ! getting a character from a previous buffer
   point=point-1
   c=buff(sz-point)
case default
   write(*,*)'*get_next_char* internal error '
   read(fd,iostat=ios) c
end select
! assume if IOS is not zero, not called again until new file is started
   if(ios /= 0)then
      filepoint=1
      point=0
      sz=bufsize
   endif
   exit
enddo
end subroutine get_next_char
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    notopen(3f) - [M_io:FILENAME] generate a filename containing a number
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    Usage
!!
!!       function filename_generator(head,tail,num,lenlimit) result(filename)
!!       character(len=*),intent(in)  :: head
!!       character(len=*),intent(in)  :: tail
!!       integer,intent(in) :: num
!!       integer,intent(in) :: lenlimit
!!       character(len=:),allocatable :: filename
!!
!!##DESCRIPTION
!!
!!    Generate a filename containing a representation of the specified
!!    whole number. This is useful for generating a series of filenames
!!    differing by a number such as "file1.txt", "file2.txt",
!!    ... .
!!
!!##OPTIONS
!!
!!    head      filename prefix.
!!    tail      filename suffix.
!!    num       number to represent as a string between HEAD and TAIL.
!!    lenlimit  number of digits up to which to zero-pad the string
!!              representing NUM.
!!
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!       program demo_filename_generator
!!       use,intrinsic::iso_fortran_env,only:int8,int16,int32,int64
!!       use M_io, only : filename_generator
!!       implicit none
!!
!!           ! no zero-fill
!!           write(*,*) filename_generator("file_",".dat",11)
!!           ! zero-fill till 3 digits
!!           write(*,*) filename_generator("file_",".dat",11,3)
!!           ! zero-fill till 9 digits
!!           write(*,*) filename_generator("file_",".dat",11,9)
!!           ! same as default (no zero-fill)
!!           write(*,*) filename_generator("file_",".dat",11,0)
!!
!!       end program demo_filename_generator
!!
!!    Results
!!
!!       > file_11.dat
!!       > file_011.dat
!!       > file_000000011.dat
!!       > file_11.dat
!!
!!##AUTHOR
!!    Zh, Niu; with modifications by John S. Urban
!!##LICENSE
!!    Public Domain

function filename_generator(head, tail, num, lenlimit) result(filename)
character(*),intent(in)      :: head
character(*),intent(in)      :: tail
integer,intent(in)           :: num
integer,intent(in),optional  :: lenlimit
character(len=:),allocatable :: filename

character(30)                :: fmt
integer                      :: local_lenlimit

   if ( present(lenlimit) ) then
      local_lenlimit = lenlimit
   else
      local_lenlimit = 0
   endif

   fmt = ""
   write(fmt, '("(a,i0.",i2.2,",a)")' ) local_lenlimit
   filename=repeat(' ', len(head) + len(tail) + max(19,local_lenlimit) )
   write(filename(:),fmt) trim(adjustl(head)), num, trim(adjustl(tail))
   filename=trim(filename)
end function filename_generator
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! routines from other modules to make this one stand-alone
!     XX                    XX       X
!      X                     X                              X
!      X                     X                              X
!  XXXXX  XX  XX  XXXXXX     X     XXX     XXXXX   XXXX    XXXX    XXXXX   XXXXX
! X    X   X   X   X    X    X       X    X     X      X    X     X     X X     X
! X    X   X   X   X    X    X       X    X        XXXXX    X     XXXXXXX  XXX
! X    X   X   X   X    X    X       X    X       X    X    X     X           XX
! X    X   X  XX   X    X    X       X    X     X X    X    X  X  X     X X     X
!  XXXXXX   XX XX  XXXXX   XXXXX   XXXXX   XXXXX   XXXX X    XX    XXXXX   XXXXX
!                  X
!                 XXX
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function lenset(line,length) result(strout)

!character(len=*),parameter::ident_36="@(#)M_strings::lenset(3f): return string trimmed or padded to specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=length)        ::  strout
   strout=line
end function lenset
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine a2i(chars,valu,ierr)

!character(len=*),parameter::ident_41="@(#)M_strings::a2i(3fp): subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8 <= huge(valu))then
      if(valu8 <= huge(valu))then
         valu=int(valu8)
      else
         write(*,*)'sc','*a2i*','- value too large',valu8,'>',huge(valu)
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)

!character(len=*),parameter::ident_42="@(#)M_strings::a2d(3fp): subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd /= 0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr /= 0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars /= 'eod')then                           ! print warning message except for special value "eod"
         write(*,*)'sc','*a2d* - cannot produce number from string ['//trim(chars)//']'
         if(msg /= '')then
            write(*,*)'*a2d* - ['//trim(msg)//']'
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

!character(len=*),parameter::ident_43="@(#)M_strings::s2v(3f): returns doubleprecision number from string"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local /= 0)then
      write(*,*)'*s2v* stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
! calls to s2v(3f) for extending intrinsics int(3f), real(3f), dble(3f)
!===================================================================================================================================
doubleprecision function dble_s2v(chars)
character(len=*),intent(in) :: chars
   dble_s2v=s2v(chars)
end function dble_s2v
!===================================================================================================================================
real function real_s2v(chars)
character(len=*),intent(in) :: chars
   real_s2v=real(s2v(chars))
end function real_s2v
!===================================================================================================================================
integer function int_s2v(chars)
character(len=*),intent(in) :: chars
   int_s2v=int(s2v(chars))
end function int_s2v
!===================================================================================================================================
function ints_s2v(chars)
integer,allocatable         :: ints_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(ints_s2v(isize))
   do i=1,isize
      ints_s2v(i)=int(s2v(chars(i)))
   enddo
end function ints_s2v
!===================================================================================================================================
function reals_s2v(chars)
real,allocatable            :: reals_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(reals_s2v(isize))
   do i=1,isize
      reals_s2v(i)=real(s2v(chars(i)))
   enddo
end function reals_s2v
!===================================================================================================================================
function dbles_s2v(chars)
doubleprecision,allocatable :: dbles_s2v(:)
character(len=*),intent(in) :: chars(:)
integer                     :: i,isize
   isize=size(chars)
   allocate(dbles_s2v(isize))
   do i=1,isize
      dbles_s2v(i)=s2v(chars(i))
   enddo
end function dbles_s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())()()()()()()()()()()()()!
!===================================================================================================================================
function s2vs(string,delim) result(darray)

!character(len=*),parameter::ident_55="@(#)M_strings::s2vs(3f): function returns array of values from a string"

character(len=*),intent(in)        :: string                       ! keyword to retrieve value for from dictionary
character(len=*),optional          :: delim                        ! delimiter characters
character(len=:),allocatable       :: delim_local
doubleprecision,allocatable        :: darray(:)                    ! function type

character(len=:),allocatable       :: carray(:)                    ! convert value to an array using split(3f)
integer                            :: i
integer                            :: ier
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(delim))then
      delim_local=delim
   else
      delim_local=' ;,'
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(string,carray,delimiters=delim_local)         ! split string into an array
   allocate(darray(size(carray)))                           ! create the output array
   do i=1,size(carray)
      call string_to_value(carray(i), darray(i), ier)       ! convert the string to a numeric value
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end function s2vs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
logical function decodebase(string,basein,out_baseten)
implicit none

!character(len=*),parameter::ident_72="@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein == 0.and.ipound > 1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local >= 0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print *,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch == '-'.and.k == 1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(*,*)'*decodebase* ERROR: invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine trimzeros(string)

!character(len=*),parameter::ident_50="@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.') == 0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i <= 1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine substitute(targetline,old,new,ierr,start,end)

!character(len=*),parameter::ident_11="@(#)M_strings::substitute(3f): Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichar
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option !! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id <= 0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old == 0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichar=len_new + original_input_length
      if(ichar > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new > 0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichar=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind == ic-1.or.ind > ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind > ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichar-1+ladd > maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichar:)=targetline(ic:ind-1)
         ichar=ichar+ladd
      endif
      if(ichar-1+len_new > maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new /= 0)then
         dum1(ichar:)=new(:len_new)
         ichar=ichar+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      write(*,*)'*substitute* new line will be too long'
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichar+ladd > maxlengthout)then
         write(*,*)'*substitute* new line will be too long'
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic < len(targetline))then
         dum1(ichar:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    isnumber(3f) - [M_strings:NUMERIC] determine if a string represents a number
!    (LICENSE:PD)
!
! SYNOPSIS
!    function isnumber(str,msg)
!
!     character(len=*),intent(in)  :: str
!     character(len=:),intent(out),allocatable,optional  :: msg
!
! DESCRIPTION
!     ISNUMBER(3f) returns a value greater than zero if the string represents
!     a number, and a number less than or equal to zero if it is a bad number.
!     Blank characters are ignored.
!
! OPTIONS
!     str  the string to evaluate as to whether it represents a numeric value
!          or not
!     msg  An optional message describing the string
!
! RETURNS
!     isnumber  the following values are returned
!
!                1 for an integer             [-+]NNNNN
!                2 for a whole number         [-+]NNNNN.
!                3 for a real value           [-+]NNNNN.MMMM
!                4 for a exponential value    [-+]NNNNN.MMMM[-+]LLLL
!                                             [-+]NNNNN.MMMM[ed][-+]LLLL
!
!               values less than 1 represent an error
!
! EXAMPLES
!   As the example shows, you can use an internal READ(3f) along with the
!   IOSTAT= parameter to check (and read) a string as well.
!
!     program demo_isnumber
!     use M_strings, only : isnumber
!     implicit none
!     character(len=256) :: line
!     real               :: value
!     integer            :: ios
!     integer            :: answer
!     character(len=256) :: message
!     character(len=:),allocatable :: description
!        write(*,*)'Begin entering values, one per line'
!        do
!           read(*,'(a)',iostat=ios)line
!           !
!           ! try string as number using list-directed input
!           line=''
!           read(line,*,iostat=ios,iomsg=message) value
!           if(ios == 0)then
!              write(*,*)'VALUE=',value
!           elseif( is_iostat_end(ios) ) then
!              stop 'end of file'
!           else
!              write(*,*)'ERROR:',ios,trim(message)
!           endif
!           !
!           ! try string using isnumber(3f)
!           answer=isnumber(line,msg=description)
!           if(answer > 0)then
!              write(*,*) &
!              & ' for ',trim(line),' ',answer,':',description
!           else
!              write(*,*) &
!              & ' ERROR for ',trim(line),' ',answer,':',description
!           endif
!           !
!        enddo
!     end program demo_isnumber
!
!  Example run
!
!    > Begin entering values
!    > ERROR:          -1 End of file
!    >  ERROR for            -1 :null string
!    >10
!    > VALUE=   10.0000000
!    >  for 10            1 :integer
!    >20
!    > VALUE=   20.0000000
!    >  for 20            1 :integer
!    >20.
!    > VALUE=   20.0000000
!    >  for 20.            2 :whole number
!    >30.1
!    > VALUE=   30.1000004
!    >  for 30.1            3 :real number
!    >3e1
!    > VALUE=   30.0000000
!    >  for 3e1            4 :value with exponent
!    >1-2
!    > VALUE=   9.99999978E-03
!    >  for 1-2            4 :value with exponent
!    >100.22d-4
!    > VALUE=   1.00220004E-02
!    >  for 100.22d-4            4 :value with exponent
!    >1--2
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1--2           -5 :bad number
!    >e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e           -6 :missing leading value before exponent
!    >e1
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for e1           -6 :missing leading value before exponent
!    >1e
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e           -3 :missing exponent
!    >1e+
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+           -4 :missing exponent after sign
!    >1e+2.0
!    > ERROR:        5010 Bad real number in item 1 of list input
!    >  ERROR for 1e+2.0           -5 :bad number
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function isNumber(string,msg,verbose)
implicit none

! ident_1="@(#)M_strings::isnumber(3f): Determines if a string is a number of not."

character(len=*),intent(in)    :: string
character(len=:),intent(out),allocatable,optional :: msg
logical,intent(in),optional                      :: verbose
integer                      :: isnumber

integer             :: i,iend
character(len=1),allocatable :: z(:)
character(len=:),allocatable :: message
logical                      :: founddigit
logical                      :: verbose_local

   i=1
   founddigit=.false.
   isnumber=0
   z=s2a(trim(nospace(string)))
   iend=size(z)
   message='not a number'
   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif
   DONE : block
      if(iend == 0)then
         isnumber=-1                   ! string is null
         message='null string'
         exit DONE
      endif

      if(index('+-',z(i)) /= 0) i=i+1  ! skip optional leading sign
      if(i > iend)then
         isnumber=-2                   ! string was just a sign
         message='just a sign'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1

      if(i > iend)then
         isnumber=1                    ! [+-]NNNNNN
         message='integer'
         exit DONE
      endif
      if(z(i) == '.')then              ! a period would be OK at this point
         i=i+1
      endif

      if(i > iend)then                ! [+-]NNNNNN.
         isnumber=2
         message='whole number'
         exit DONE
      endif

      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=3                    ! [+-]NNNNNN.MMMM
         message='real number'
         exit DONE
      endif

      if(index('eEdD',z(i)) /= 0)then
         i=i+1
         if(i == 2)then
            isnumber=-6                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
            message='missing leading value before exponent'
            exit DONE
         endif
      endif
      if(i > iend)then
         isnumber=-3                   ! [+-]NNNNNN[.[MMMM]]e but a value must follow
         message='missing exponent'
         exit DONE
      endif
      if(.not.founddigit)then
         isnumber=-7
         message='missing value before exponent'
         exit DONE
      endif
      if(index('+-',z(i)) /= 0) i=i+1
      if(i > iend)then
         isnumber=-4                   ! [+-]NNNNNN[.[MMMM]]e[+-] but a value must follow
         message='missing exponent after sign'
         exit DONE
      endif
      call next()                      ! position I to next non-digit or end of string+1
      if(i > iend)then
         isnumber=4                    ! [+-]NNNNNN.MMMMe[+-]LL
         message='value with exponent'
         exit DONE
      endif
      isnumber=-5
      message='bad number'
   endblock DONE
   if(verbose_local)then
      write(*,*)trim(string)//' is '//message
   endif
   if(present(msg))then
      msg=message
   endif

contains
   subroutine next() ! move to next non-digit or end of string+1
      integer :: j
      do j=i,iend
         if(.not.isdigit(z(j)))then
            exit
         endif
         founddigit=.true.
         if(verbose_local) write(*,*)'I=',i,' J=',j,' Z(j)=',z(j)
      enddo
      i=j
      if(verbose_local)then
         write(*,*)'I and J=',i
         if(i <= iend) then
            write(*,*)'Z(I)=',z(i)
         else
            write(*,*)'====>'
         endif
      endif
   end subroutine next
end function isNumber
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function isdigit(ch) result(res)

! ident_2="@(#)M_strings::isdigit(3f): Returns .true. if ch is a digit (0-9) and .false. otherwise"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case('0':'9')
     res=.true.
   case default
     res=.false.
   end select
end function isdigit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! NAME
!    nospace(3f) - [M_strings:WHITESPACE] remove all whitespace from
!    input string
!    (LICENSE:PD)
!
! SYNOPSIS
!    function nospace(str) - remove all whitespace from input string
!
!     character(len=*),intent(in)          :: str
!     character(len=:),allocatable         :: nospace
!
! DESCRIPTION
!    nospace(3f) removes space, tab, carriage return, new line, vertical
!    tab, formfeed and null characters (called "whitespace"). The output
!    is returned trimmed.
!
! EXAMPLES
!   Sample program:
!
!     program demo_nospace
!     use M_strings, only: nospace
!     implicit none
!     character(len=:),allocatable  :: s
!        s='  This     is      a     test  '
!        write(*,*) 'original input string is ....',s
!        write(*,*) 'processed output string is ...',nospace(s)
!        if(nospace(s) == 'Thisisatest')then
!           write(*,*)'nospace test passed'
!        else
!           write(*,*)'nospace test error'
!        endif
!     end program demo_nospace
!
!   Expected output
!
!     original input string is ....  This     is      a     test
!     processed output string is ...Thisisatest
!     nospace test passed
!
! AUTHOR
!    John S. Urban
!
! LICENSE
!    Public Domain
function nospace(line)

! ident_3="@(#)M_strings::nospace(3f): remove all whitespace from input string"

character(len=*),intent(in)    ::  line             ! remove whitespace from this string and return it
character(len=:),allocatable   ::  nospace          ! returned string
integer                        ::  ipos             ! position to place next output character at
integer                        ::  i                ! counter to increment from beginning to end of input string
!-----------------------------------------------------------------------------------------------------------------------------------
   allocate(nospace,mold=line)                      ! initially make output line length of input line
   nospace(:len_trim(nospace))=' '
   ipos=0
   do i=1,len_trim(line)                            ! increment from first to last character of the input line
      if ( isspace( line(i:i) ) ) cycle             ! if a blank is encountered skip it
      ipos=ipos+1                                   ! increment count of non-blank characters found
      nospace(ipos:ipos)=line(i:i)                  ! store non-blank character in output
   enddo
   nospace=trim(nospace)                            ! blank out unpacked part of line
end function nospace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     isspace(3f) - [M_strings:COMPARE] returns .true. if character is a
!!     null, space, tab, carriage return, new line, vertical tab, or formfeed
!!     (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!
!!    elemental function isspace(onechar)
!!
!!     character,intent(in) :: onechar
!!     logical              :: isspace
!!
!!##DESCRIPTION
!!     isspace(3f) returns .true. if character is a null, space, tab,
!!     carriage return, new line, vertical tab, or formfeed
!!
!!##OPTIONS
!!    onechar  character to test
!!
!!##RETURNS
!!    isspace  returns true if character is ASCII white space
!!
!!##EXAMPLE
!!
!!  Sample program:
!!
!!     program demo_isspace
!!     use M_strings, only : isspace
!!     implicit none
!!     integer                    :: i
!!     character(len=1),parameter :: string(*)=[(char(i),i=0,127)]
!!        write(*,'(20(g0,1x))')'ISSPACE: ', &
!!        & ichar(pack( string, isspace(string) ))
!!     end program demo_isspace
!!
!!   Results:
!!
!!    ISSPACE:  0 9 10 11 12 13 32
!!
!!##AUTHOR
!!     John S. Urban
!!
!!##LICENSE
!!     Public Domain
elemental function isspace(ch) result(res)

! ident_63="@(#)M_strings::isspace(3f): true if null,space,tab,return,new line,vertical tab, or formfeed"

character,intent(in) :: ch
logical              :: res
   select case(ch)
   case(' ')                 ! space(32)
     res=.true.
   case(char(0))             ! null(0)
     res=.true.
   case(char(9):char(13))    ! tab(9), new line(10), vertical tab(11), formfeed(12), carriage return(13),
     res=.true.
   case default
     res=.false.
   end select
end function isspace
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

!character(len=*),parameter::ident_7="&
!&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: ilen                   ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters /= '')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len(input_line)                                           ! ILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ilen)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (:0)                                                      ! command was totally blank
!-----------------------------------------------------------------------------------------------------------------------------------
   case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,ilen,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol)) == 0)then  ! if current character is not a delimiter
            iterm(i30)=ilen                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))
               IF(ifound > 0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol > ilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20) < ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function upper(str,begin,end) result (string)

!character(len=*),parameter::ident_21="@(#)M_strings::upper(3f): Changes a string to uppercase"

character(*), intent(In)      :: str                 ! inpout string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
   string = str                                      ! initialize output string to input string

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = char(iachar(str(i:i))-32)    ! change miniscule letter to uppercase
       end select
   end do

end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental pure function lower(str,begin,end) result (string)

!character(len=*),parameter::ident_22="@(#)M_strings::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
   string = str

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32)     ! change letter to miniscule
      case default
      end select
   end do

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure function s2a(string)  RESULT (array)

!character(len=*),parameter::ident_24="@(#)M_strings::s2a(3fp): function to copy string(1:Clen(string)) to char array"

character(len=*),intent(in) :: string
character(len=1)            :: array(len(string))
integer                     :: i
! ----------------------------------------------------------------------------------------------------------------------------------
   forall(i=1:len(string)) array(i) = string(i:i)
! ----------------------------------------------------------------------------------------------------------------------------------
end function s2a
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

!character(len=*),parameter::ident_47="@(#)M_strings::i2s(3fp): private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

!character(len=*),parameter::ident_40="@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt /= '') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         write(*,*)'*value_to_string* UNKNOWN TYPE'
         chars=' '
      end select
      if(fmt == '') then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.') /= 0) call trimzeros(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local /= 0)then
      !! cannot currently do I/O from a function being called from I/O
      !!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function merge_str(str1,str2,expr) result(strout)
! for some reason the MERGE(3f) intrinsic requires the strings it compares to be of equal length
! make an alias for MERGE(3f) that makes the lengths the same before doing the comparison by padding the shorter one with spaces

!character(len=*),parameter::ident_37="@(#)M_strings::merge_str(3f): pads first and second arguments to MERGE(3f) to same length"

character(len=*),intent(in)     :: str1
character(len=*),intent(in)     :: str2
logical,intent(in)              :: expr
character(len=:),allocatable    :: strout
integer                         :: big
   big=max(len(str1),len(str2))
   strout=trim(merge(lenset(str1,big),lenset(str2,big),expr))
end function merge_str
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine notabs(INSTR,OUTSTR,ILEN)

!character(len=*),parameter::ident_31="&
!&@(#)M_strings::notabs(3f): convert tabs to spaces while maintaining columns, remove CRLF chars"

CHARACTER(LEN=*),INTENT(IN)   :: instr        ! input line to scan for tab characters
CHARACTER(LEN=*),INTENT(OUT)  :: outstr       ! tab-expanded version of INSTR produced
INTEGER,INTENT(OUT)           :: ilen         ! column position of last character put into output string
                                              ! that is, ILEN holds the position of the last non-blank character in OUTSTR
!===================================================================================================================================
INTEGER,PARAMETER             :: tabsize=8    ! assume a tab stop is set every 8th column
INTEGER                       :: ipos         ! position in OUTSTR to put next character of INSTR
INTEGER                       :: lenin        ! length of input string trimmed of trailing spaces
INTEGER                       :: lenout       ! number of characters output string can hold
INTEGER                       :: istep        ! counter that advances thru input string INSTR one character at a time
CHARACTER(LEN=1)              :: c            ! character in input line being processed
INTEGER                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested
!===================================================================================================================================
   IPOS=1                                     ! where to put next character in output string OUTSTR
   lenin=LEN(instr)                           ! length of character variable INSTR
   lenin=LEN_TRIM(instr(1:lenin))             ! length of INSTR trimmed of trailing spaces
   lenout=LEN(outstr)                         ! number of characters output string OUTSTR can hold
   OUTSTR=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters
!===================================================================================================================================
      SCAN_LINE: DO istep=1,lenin             ! look through input string one character at a time
         c=instr(istep:istep)                 ! get next character
         iade=ICHAR(c)                        ! get ADE of the character
         expand_tabs : SELECT CASE (iade)     ! take different actions depending on which character was found
         CASE(9)                              ! test if character is a tab and move pointer out to appropriate column
            ipos = ipos + (tabsize - (MOD(ipos-1,tabsize)))
         CASE(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files
            ipos=ipos+1
         CASE DEFAULT                         ! c is anything else other than a tab,newline,or return  insert it in output string
            IF(ipos > lenout)THEN
               write(*,*)"*notabs* output string overflow"
               EXIT
            ELSE
               outstr(ipos:ipos)=c
               ipos=ipos+1
            ENDIF
         END SELECT expand_tabs
      enddo SCAN_LINE
!===================================================================================================================================
      ipos=MIN(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far
      ilen=LEN_TRIM(outstr(:ipos))            ! trim trailing spaces
!===================================================================================================================================
END SUBROUTINE notabs
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
elemental function noesc(INSTR)
! ident_48="@(#) M_strings noesc(3f) convert non-printable characters to a space"
character(len=*),intent(in) :: INSTR      ! string that might contain nonprintable characters
character(len=len(instr))   :: noesc
integer                     :: ic,i10
   noesc=''                               ! initialize output string
   do i10=1,len_trim(INSTR(1:len(INSTR)))
      ic=iachar(INSTR(i10:i10))
      if(ic <= 31.or.ic == 127)then       ! find characters with ADE of 0-31, 127
         noesc(I10:I10)=' '               ! replace non-printable characters with a space
      else
         noesc(I10:I10)=INSTR(i10:i10)    ! copy other characters as-is from input string to output string
      endif
   enddo
end function noesc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)
! ident_2="@(#)M_journal::where_write_message(3fp): basic message routine used for journal files"
character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to my_stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O
character(len=4096)                :: mssge
   adv='yes'
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)trim(msg)
         endif
      case('S','s')
         write(my_stdout,'(a)',advance=adv)trim(msg)
         times=times+1
      case('E','e')
         write(stderr,'(a)',advance=adv)trim(msg)
         times=times+1
      case('+'); adv='no'
      case('>'); debug=.true.
      case('<'); debug=.false.
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
end subroutine where_write_message

subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep)
implicit none
! ident_5="@(#)M_journal::where_write_message_all(3f): writes a message to a string composed of any standard scalar types"
character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
character(len=*),intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,sep))
end subroutine where_write_message_all

subroutine write_message_only(message)
! ident_6="@(#)M_journal::write_message_only(3fp): calls JOURNAL('sc',message)"
character(len=*),intent(in)          :: message
   call where_write_message('sc',trim(message))
end subroutine write_message_only

function msg_scalar(generic0, generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9, &
                  & generica, genericb, genericc, genericd, generice, genericf, genericg, generich, generici, genericj, &
                  & sep)
! ident_2="@(#)M_io::msg_scalar(3fp): writes a message to a string composed of any standard scalar types"
class(*),intent(in),optional  :: generic0, generic1, generic2, generic3, generic4
class(*),intent(in),optional  :: generic5, generic6, generic7, generic8, generic9
class(*),intent(in),optional  :: generica, genericb, genericc, genericd, generice
class(*),intent(in),optional  :: genericf, genericg, generich, generici, genericj
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:), allocatable :: msg_scalar
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
         increment=len(sep)+1
         sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=''
   if(present(generic0))call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   if(present(generica))call print_generic(generica)
   if(present(genericb))call print_generic(genericb)
   if(present(genericc))call print_generic(genericc)
   if(present(genericd))call print_generic(genericd)
   if(present(generice))call print_generic(generice)
   if(present(genericf))call print_generic(genericf)
   if(present(genericg))call print_generic(genericg)
   if(present(generich))call print_generic(generich)
   if(present(generici))call print_generic(generici)
   if(present(genericj))call print_generic(genericj)
   msg_scalar=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in) :: generic
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'(i0)') generic
      type is (integer(kind=int16));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int32));    write(line(istart:),'(i0)') generic
      type is (integer(kind=int64));    write(line(istart:),'(i0)') generic
      type is (real(kind=real32));      write(line(istart:),'(1pg0)') generic
      type is (real(kind=real64));      write(line(istart:),'(1pg0)') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'(1pg0)') generic
#endif
      type is (logical);                write(line(istart:),'(l1)') generic
      type is (character(len=*));       write(line(istart:),'(a)') trim(generic)
      type is (complex);                write(line(istart:),'("(",1pg0,",",1pg0,")")') generic
   end select
   istart=len_trim(line)+increment
   line=trim(line)//sep_local
end subroutine print_generic

end function msg_scalar

function msg_one(generic0,generic1, generic2, generic3, generic4, generic5, generic6, generic7, generic8, generic9,sep)
implicit none
! ident_3="@(#)M_io::msg_one(3fp): writes a message to a string composed of any standard one dimensional types"
class(*),intent(in)           :: generic0(:)
class(*),intent(in),optional  :: generic1(:), generic2(:), generic3(:), generic4(:), generic5(:)
class(*),intent(in),optional  :: generic6(:), generic7(:), generic8(:), generic9(:)
character(len=*),intent(in),optional :: sep
character(len=:),allocatable  :: sep_local
character(len=:),allocatable  :: msg_one
character(len=4096)           :: line
integer                       :: istart
integer                       :: increment
   if(present(sep))then
      increment=len(sep)+1
      sep_local=sep
   else
      sep_local=' '
      increment=2
   endif
   istart=1
   line=' '
   call print_generic(generic0)
   if(present(generic1))call print_generic(generic1)
   if(present(generic2))call print_generic(generic2)
   if(present(generic3))call print_generic(generic3)
   if(present(generic4))call print_generic(generic4)
   if(present(generic5))call print_generic(generic5)
   if(present(generic6))call print_generic(generic6)
   if(present(generic7))call print_generic(generic7)
   if(present(generic8))call print_generic(generic8)
   if(present(generic9))call print_generic(generic9)
   msg_one=trim(line)
contains

subroutine print_generic(generic)
!use, intrinsic :: iso_fortran_env, only : int8, int16, int32, biggest=>int64, real32, real64, dp=>real128
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
class(*),intent(in),optional :: generic(:)
integer :: i
   select type(generic)
      type is (integer(kind=int8));     write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int16));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int32));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (integer(kind=int64));    write(line(istart:),'("[",*(i0,1x))') generic
      type is (real(kind=real32));      write(line(istart:),'("[",*(1pg0,1x))') generic
      type is (real(kind=real64));      write(line(istart:),'("[",*(1pg0,1x))') generic
#ifdef __NVCOMPILER
#else
      type is (real(kind=real128));     write(line(istart:),'("[",*(1pg0,1x))') generic
#endif
      !type is (real(kind=real256));     write(error_unit,'(1pg0)',advance='no') generic
      type is (logical);                write(line(istart:),'("[",*(l1,1x))') generic
      type is (character(len=*));       write(line(istart:),'("[",:*("""",a,"""",1x))') (trim(generic(i)),i=1,size(generic))
      type is (complex);                write(line(istart:),'("[",*("(",1pg0,",",1pg0,")",1x))') generic
      class default
         stop 'unknown type in *print_generic*'
   end select
   istart=len_trim(line)+increment
   line=trim(line)//"]"//sep_local
end subroutine print_generic

end function msg_one
!===================================================================================================================================
function crop(strin) result (strout)

! ident_19="@(#) M_strings crop(3f) trim leading and trailings spaces from resulting string"

character(len=*),intent(in)  :: strin
character(len=:),allocatable :: strout
   strout=trim(adjustl(strin))
end function crop
!===================================================================================================================================
end module m_io
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_LA/src/M_LA.f90
module m_la
use,intrinsic :: iso_fortran_env, only : stderr=>error_unit, stdin=>input_unit, stdout=>output_unit
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128
implicit none
private

public mat_wlog
public mat_wdiv
public mat_watan

public :: mat_inverse_hilbert
public :: mat_magic
public :: mat_pythag
public :: mat_rref

! for other routines
public mat_flop
public mat_wasum
public mat_wdotcr
public mat_wdotci

public mat_wdotur
public mat_wcopy
public mat_wset
public mat_wswap
public mat_wsqrt
public mat_wpow
public mat_rswap
public mat_wrscal
public mat_wscal
public mat_wmul
public mat_rrot
public mat_rset
public mat_rat
public mat_urand
public mat_wnrm2
public mat_wdotui
public mat_iwamax
public mat_round
public mat_wpofa
public mat_rrotg
public mat_wsign

!public :: matx_waxpy
!public :: ml_comqr3
!public :: ml_corth
!public :: ml_htribk
!public :: ml_htridi
!public :: ml_imtql2
!public :: ml_wgeco
!public :: ml_wgedi
!public :: ml_wgefa
!public :: ml_wgesl
!public :: ml_wqrdc
!public :: ml_wqrsl
!public :: ml_wsvdc

public :: linspace
public :: elementcopy

integer,parameter,private:: sp=kind(1.0),dp=kind(1.0d0)

integer,save             :: la_flop_counter(2)=[0,0]

interface linspace
   module procedure  &
   & linspace_real128, linspace_real64, linspace_real32, &
   & linspace_int64,   linspace_int32,  linspace_int16,  linspace_int8
end interface linspace

interface elementcopy
   module procedure  &
   & elementcopy_real128, elementcopy_real64, elementcopy_real32, &
   & elementcopy_int64,   elementcopy_int32,  elementcopy_int16,  elementcopy_int8
end interface elementcopy

interface
   subroutine matx_waxpy(n, sr, si, xr, xi, incx, yr, yi, incy)
      import  int32, real64
      integer(kind=int32), intent(in) :: n
      real(kind=real64), intent(in) :: sr
      real(kind=real64), intent(in) :: si
      real(kind=real64), intent(in) :: xr(*)
      real(kind=real64), intent(in) :: xi(*)
      integer(kind=int32), intent(in) :: incx
      real(kind=real64) :: yr(*)
      real(kind=real64) :: yi(*)
      integer(kind=int32), intent(in) :: incy
   end subroutine matx_waxpy
end interface

interface
   subroutine ml_comqr3(nm, n, low, igh, ortr, orti, hr, hi, wr, wi, zr, zi, ierr, job)
      import  int32, real64
      integer(kind=int32) :: igh
      integer(kind=int32) :: n
      integer(kind=int32) :: nm
      integer(kind=int32) :: low
      real(kind=real64) :: ortr(igh)
      real(kind=real64) :: orti(igh)
      real(kind=real64) :: hr(nm, n)
      real(kind=real64) :: hi(nm, n)
      real(kind=real64) :: wr(n)
      real(kind=real64) :: wi(n)
      real(kind=real64) :: zr(nm, n)
      real(kind=real64) :: zi(nm, n)
      integer(kind=int32) :: ierr
      integer(kind=int32) :: job
   end subroutine ml_comqr3
end interface

interface
   subroutine ml_corth(nm, n, low, igh, ar, ai, ortr, orti)
      import  int32, real64
      integer(kind=int32) :: igh
      integer(kind=int32) :: n
      integer(kind=int32) :: nm
      integer(kind=int32) :: low
      real(kind=real64) :: ar(nm, n)
      real(kind=real64) :: ai(nm, n)
      real(kind=real64) :: ortr(igh)
      real(kind=real64) :: orti(igh)
   end subroutine ml_corth
end interface

interface
   subroutine ml_htribk(nm, n, ar, ai, tau, m, zr, zi)
      import  int32, real64
      integer(kind=int32) :: m
      integer(kind=int32) :: n
      integer(kind=int32) :: nm
      real(kind=real64) :: ar(nm, n)
      real(kind=real64) :: ai(nm, n)
      real(kind=real64) :: tau(2, n)
      real(kind=real64) :: zr(nm, m)
      real(kind=real64) :: zi(nm, m)
   end subroutine ml_htribk
end interface

interface
   subroutine ml_htridi(nm, n, ar, ai, d, e, e2, tau)
      import  int32, real64
      integer(kind=int32) :: n
      integer(kind=int32) :: nm
      real(kind=real64) :: ar(nm, n)
      real(kind=real64) :: ai(nm, n)
      real(kind=real64) :: d(n)
      real(kind=real64) :: e(n)
      real(kind=real64) :: e2(n)
      real(kind=real64) :: tau(2, n)
   end subroutine ml_htridi
end interface

interface
   subroutine ml_imtql2(nm, n, d, e, z, ierr, job)
      import  int32, real64
      integer(kind=int32) :: n
      integer(kind=int32) :: nm
      real(kind=real64) :: d(n)
      real(kind=real64) :: e(n)
      real(kind=real64) :: z(nm, n)
      integer(kind=int32) :: ierr
      integer(kind=int32) :: job
   end subroutine ml_imtql2
end interface

interface
   subroutine ml_wgeco(ar, ai, lda, n, ipvt, rcond, zr, zi)
      import  int32, real64
      integer(kind=int32) :: lda
      real(kind=real64) :: ar(lda, *)
      real(kind=real64) :: ai(lda, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: ipvt(*)
      real(kind=real64) :: rcond
      real(kind=real64) :: zr(*)
      real(kind=real64) :: zi(*)
   end subroutine ml_wgeco
end interface

interface
   subroutine ml_wgedi(ar, ai, lda, n, ipvt, detr, deti, workr, worki, job)
      import  int32, real64
      integer(kind=int32) :: lda
      real(kind=real64) :: ar(lda, *)
      real(kind=real64) :: ai(lda, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: ipvt(*)
      real(kind=real64) :: detr(2)
      real(kind=real64) :: deti(2)
      real(kind=real64) :: workr(*)
      real(kind=real64) :: worki(*)
      integer(kind=int32) :: job
   end subroutine ml_wgedi
end interface

interface
   subroutine ml_wgefa(ar, ai, lda, n, ipvt, info)
      import  int32, real64
      integer(kind=int32) :: lda
      real(kind=real64) :: ar(lda, *)
      real(kind=real64) :: ai(lda, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: ipvt(*)
      integer(kind=int32) :: info
   end subroutine ml_wgefa
end interface

interface
   subroutine ml_wgesl(ar, ai, lda, n, ipvt, br, bi, job)
      import  int32, real64
      integer(kind=int32) :: lda
      real(kind=real64) :: ar(lda, *)
      real(kind=real64) :: ai(lda, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: ipvt(*)
      real(kind=real64) :: br(*)
      real(kind=real64) :: bi(*)
      integer(kind=int32) :: job
   end subroutine ml_wgesl
end interface

interface
   subroutine ml_wqrdc(xr, xi, ldx, n, p, qrauxr, qrauxi, jpvt, workr, worki, job)
      import  int32, real64
      integer(kind=int32) :: ldx
      real(kind=real64) :: xr(ldx, *)
      real(kind=real64) :: xi(ldx, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: p
      real(kind=real64) :: qrauxr(*)
      real(kind=real64) :: qrauxi(*)
      integer(kind=int32) :: jpvt(*)
      real(kind=real64) :: workr(*)
      real(kind=real64) :: worki(*)
      integer(kind=int32) :: job
   end subroutine ml_wqrdc
end interface

interface
   subroutine ml_wqrsl(xr, xi, ldx, n, k, qrauxr, qrauxi, yr, yi, qyr, qyi, qtyr, qtyi, br, bi, rsdr, rsdi, xbr, xbi, job, info)
      import  int32, real64
      integer(kind=int32) :: ldx
      real(kind=real64) :: xr(ldx, *)
      real(kind=real64) :: xi(ldx, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: k
      real(kind=real64) :: qrauxr(*)
      real(kind=real64) :: qrauxi(*)
      real(kind=real64) :: yr(*)
      real(kind=real64) :: yi(*)
      real(kind=real64) :: qyr(*)
      real(kind=real64) :: qyi(*)
      real(kind=real64) :: qtyr(*)
      real(kind=real64) :: qtyi(*)
      real(kind=real64) :: br(*)
      real(kind=real64) :: bi(*)
      real(kind=real64) :: rsdr(*)
      real(kind=real64) :: rsdi(*)
      real(kind=real64) :: xbr(*)
      real(kind=real64) :: xbi(*)
      integer(kind=int32) :: job
      integer(kind=int32) :: info
   end subroutine ml_wqrsl
end interface

interface
   subroutine ml_wsvdc(xr, xi, ldx, n, p, sr, si, er, ei, ur, ui, ldu, vr, vi, ldv, workr, worki, job, info)
      import  int32, real64
      integer(kind=int32) :: ldv
      integer(kind=int32) :: ldu
      integer(kind=int32) :: ldx
      real(kind=real64) :: xr(ldx, *)
      real(kind=real64) :: xi(ldx, *)
      integer(kind=int32) :: n
      integer(kind=int32) :: p
      real(kind=real64) :: sr(*)
      real(kind=real64) :: si(*)
      real(kind=real64) :: er(*)
      real(kind=real64) :: ei(*)
      real(kind=real64) :: ur(ldu, *)
      real(kind=real64) :: ui(ldu, *)
      real(kind=real64) :: vr(ldv, *)
      real(kind=real64) :: vi(ldv, *)
      real(kind=real64) :: workr(*)
      real(kind=real64) :: worki(*)
      integer(kind=int32) :: job
      integer(kind=int32) :: info
   end subroutine ml_wsvdc
end interface

contains
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    elementcopy(3f) - [M_LA] copy elements from IN to OUT regardless
!!    of rank until hit end of one of them
!!
!!##SYNOPSIS
!!
!!     Subroutine elementcopy (IN, OUT)
!!
!!      ${TYPE} (kind=${KIND}), Intent (In) :: IN(..)
!!      ${TYPE} (kind=${KIND})              :: OUT(..)
!!
!!    Where ${TYPE}(kind=${KIND}) may be
!!
!!       o Real(kind=real32)
!!       o Real(kind=real64)
!!       o Real(kind=real128)
!!       o Integer(kind=int8)
!!       o Integer(kind=int16)
!!       o Integer(kind=int32)
!!       o Integer(kind=int64)
!!
!!##DESCRIPTION
!!
!!    Copy the elements from scalar or array IN to array or scalar OUT
!!    until either the end of IN or OUT is reached, regardless of rank
!!    of the arguments.
!!
!!##OPTIONS
!!     IN          input array or scalar
!!     OUT         output array or scalar
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_elementcopy
!!    use m_la, only : elementcopy
!!    implicit none
!!    character(len=*),parameter :: g='(*(g0:,","))'
!!    real :: b, b1(3), b2(2,3), b3(2,2,2)
!!    real :: c8(8), c6(6), c3(3), c
!!    integer :: ib, ib1(3), ib2(2,3), ib3(2,2,2)
!!    integer :: ic8(8), ic6(6), ic3(3), ic
!!       ! default real
!!       call elementcopy(100.0,b)
!!       write(*,g)'b',b
!!       call elementcopy([1.0,2.0,3.0],b1)
!!       write(*,g)'b1',b1
!!       call elementcopy(reshape([1.0,2.0,3.0,4.0,5.0,6.0],[2,3]),b2)
!!       write(*,g)'b2',b2
!!       call elementcopy(reshape([1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0],[2,2,2]),b3)
!!       write(*,g)'b3',b3
!!       call elementcopy(b3,c8) ! pack
!!       write(*,g)'c8',c8
!!       call elementcopy(b3*10,c3) ! smaller
!!       write(*,g)'c3',c3
!!       call elementcopy(pack(b3*111.0,.true.),b) ! to scalar
!!       write(*,g)'b',b
!!       c6=-999.0
!!       call elementcopy(b1*10,c6) ! bigger
!!       write(*,g)'c6',c6
!!       call elementcopy(b3(2:,2,2),c) !  to scalar from vector
!!       write(*,g)'c',c
!!       call elementcopy(b3(2,1,1),c) !  to scalar from element
!!       write(*,g)'c',c
!!       call elementcopy(b3,c) !  to scalar
!!       write(*,g)'c',c
!!       ! default integer
!!       call elementcopy(100,ib)
!!       write(*,g)'ib',ib
!!       call elementcopy([1,2,3],ib1)
!!       write(*,g)'ib1',ib1
!!       call elementcopy(reshape([1,2,3,4,5,6],[2,3]),ib2)
!!       write(*,g)'ib2',ib2
!!       call elementcopy(reshape([1,2,3,4,5,6,7,8],[2,2,2]),ib3)
!!       write(*,g)'ib3',ib3
!!       call elementcopy(ib3,ic8) ! pack
!!       write(*,g)'ic8',ic8
!!       call elementcopy(ib3*10,ic3) ! smaller
!!       write(*,g)'ic3',ic3
!!       call elementcopy(pack(ib3*111,.true.),ib) ! to scalar
!!       write(*,g)'ib',ib
!!       ic6=-999
!!       call elementcopy(ib1*10,ic6) ! bigger
!!       write(*,g)'ic6',ic6
!!       call elementcopy(ib3(2:,2,2),ic) !  to scalar from vector
!!       write(*,g)'ic',ic
!!       call elementcopy(ib3(2,1,1),ic) !  to scalar from element
!!       write(*,g)'ic',ic
!!       call elementcopy(ib3,ic) !  to scalar
!!       write(*,g)'ic',ic
!!       !
!!       tesseract: block
!!       integer :: box(2,3,4,5)
!!       integer :: i
!!          call elementcopy([(i,i=1,size(box))],box)
!!          write(*,g)'box',box
!!       endblock tesseract
!!    end program demo_elementcopy
!!
!!   Results:
!!
!!    b,100.0000
!!    b1,1.00000,2.00000,3.00000
!!    b2,1.00000,2.00000,3.00000,4.00000,5.00000,6.00000
!!    b3,1.00000,2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000
!!    c8,1.00000,2.00000,3.00000,4.00000,5.00000,6.00000,7.00000,8.00000
!!    c3,10.0000,20.0000,30.0000
!!    b,111.0000
!!    c6,10.00000,20.00000,30.00000,-999.0000,-999.0000,-999.0000
!!    c,8.000000
!!    c,2.000000
!!    c,1.000000
!!    ib,100
!!    ib1,1,2,3
!!    ib2,1,2,3,4,5,6
!!    ib3,1,2,3,4,5,6,7,8
!!    ic8,1,2,3,4,5,6,7,8
!!    ic3,10,20,30
!!    ib,111
!!    ic6,10,20,30,-999,-999,-999
!!    ic,8
!!    ic,2
!!    ic,1
!!    box,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,
!!    19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,
!!    36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,
!!    53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,
!!    70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,
!!    87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,
!!    103,104,105,106,107,108,109,110,111,112,113,114,115,116,
!!    117,118,119,120
!!
!!##AUTHOR
!!    John S. Urban, 2022.05.07
!!##LICENSE
!!    CC0-1.0
subroutine elementcopy_real32(a1,a2) ! using assumed rank
real(kind=real32),intent(in) :: a1(..)
real(kind=real32)            :: a2(..)
real(kind=real32)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
real(kind=real32),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
real(kind=real32),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
real(kind=real32)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_real32

subroutine elementcopy_real64(a1,a2) ! using assumed rank
real(kind=real64),intent(in) :: a1(..)
real(kind=real64)            :: a2(..)
real(kind=real64)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
real(kind=real64),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
real(kind=real64),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
real(kind=real64)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_real64

subroutine elementcopy_real128(a1,a2) ! using assumed rank
real(kind=real128),intent(in) :: a1(..)
real(kind=real128)            :: a2(..)
real(kind=real128)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
real(kind=real128),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
real(kind=real128),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
real(kind=real128)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_real128

subroutine elementcopy_int8(a1,a2) ! using assumed rank
integer(kind=int8),intent(in) :: a1(..)
integer(kind=int8)            :: a2(..)
integer(kind=int8)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
integer(kind=int8),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
integer(kind=int8),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
integer(kind=int8)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_int8

subroutine elementcopy_int16(a1,a2) ! using assumed rank
integer(kind=int16),intent(in) :: a1(..)
integer(kind=int16)            :: a2(..)
integer(kind=int16)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
integer(kind=int16),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
integer(kind=int16),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
integer(kind=int16)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_int16

subroutine elementcopy_int32(a1,a2) ! using assumed rank
integer(kind=int32),intent(in) :: a1(..)
integer(kind=int32)            :: a2(..)
integer(kind=int32)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
integer(kind=int32),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
integer(kind=int32),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
integer(kind=int32)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_int32

subroutine elementcopy_int64(a1,a2) ! using assumed rank
integer(kind=int64),intent(in) :: a1(..)
integer(kind=int64)            :: a2(..)
integer(kind=int64)            :: one(1), two(1)
   SELECT RANK(a1)
   RANK(0)
      one=a1
      SELECT RANK(a2)
      RANK(0); call step2(one,1)
      RANK(1); call step2(one,1)
      RANK(2); call step2(one,1)
      RANK(3); call step2(one,1)
      RANK(4); call step2(one,1)
      RANK(5); call step2(one,1)
      RANK(6); call step2(one,1)
      RANK(7); call step2(one,1)
      RANK(8); call step2(one,1)
      RANK(9); call step2(one,1)
      RANK(10); call step2(one,1)
      RANK(11); call step2(one,1)
      RANK(12); call step2(one,1)
      RANK(13); call step2(one,1)
      RANK(14); call step2(one,1)
      RANK(15); call step2(one,1)
      END SELECT
   RANK(1)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(2)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   RANK(3)
      SELECT RANK(a2)
      RANK(0); call step2(a1,size(a1))
      RANK(1); call step2(a1,size(a1))
      RANK(2); call step2(a1,size(a1))
      RANK(3); call step2(a1,size(a1))
      RANK(4); call step2(a1,size(a1))
      RANK(5); call step2(a1,size(a1))
      RANK(6); call step2(a1,size(a1))
      RANK(7); call step2(a1,size(a1))
      RANK(8); call step2(a1,size(a1))
      RANK(9); call step2(a1,size(a1))
      RANK(10); call step2(a1,size(a1))
      RANK(11); call step2(a1,size(a1))
      RANK(12); call step2(a1,size(a1))
      RANK(13); call step2(a1,size(a1))
      RANK(14); call step2(a1,size(a1))
      RANK(15); call step2(a1,size(a1))
      END SELECT
   END SELECT
contains
subroutine step2(a3,isz)
integer :: isz
integer(kind=int64),intent(in) :: a3(isz)
   SELECT RANK(a2)
   RANK(0); call ecopy(a3,1,two,1);a2=two(1)
   RANK(1); call ecopy(a3,size(a3),a2,size(a2))
   RANK(2); call ecopy(a3,size(a3),a2,size(a2))
   RANK(3); call ecopy(a3,size(a3),a2,size(a2))
   RANK(4); call ecopy(a3,size(a3),a2,size(a2))
   RANK(5); call ecopy(a3,size(a3),a2,size(a2))
   RANK(6); call ecopy(a3,size(a3),a2,size(a2))
   RANK(7); call ecopy(a3,size(a3),a2,size(a2))
   RANK(8); call ecopy(a3,size(a3),a2,size(a2))
   RANK(9); call ecopy(a3,size(a3),a2,size(a2))
   RANK(10); call ecopy(a3,size(a3),a2,size(a2))
   RANK(11); call ecopy(a3,size(a3),a2,size(a2))
   RANK(12); call ecopy(a3,size(a3),a2,size(a2))
   RANK(13); call ecopy(a3,size(a3),a2,size(a2))
   RANK(14); call ecopy(a3,size(a3),a2,size(a2))
   RANK(15); call ecopy(a3,size(a3),a2,size(a2))
   END SELECT
end subroutine step2

subroutine ecopy(a1,n,a2,m)
integer,intent(in) :: n,m
integer(kind=int64),intent(in) :: a1(n) ! dimensioned with n, there is no rank/shape check
integer(kind=int64)            :: a2(m) ! dimensioned with m, there is no rank/shape check
integer :: ismall
   ismall=min(n,m)       ! should warn as well
   a2(:ismall)=a1(:ismall)
end subroutine ecopy

end subroutine elementcopy_int64

!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!     linspace(3f) - [M_LA] return a vector of linearly spaced values
!!##SYNOPSIS
!!
!!    function linspace(x1,x2,n)
!!
!!     integer,intent(in)               :: n
!!     ${TYPE}(kind=${KIND}),intent(in) :: x1,x2
!!     ${TYPE}(kind=${KIND})            :: linspace
!!
!!    Where ${TYPE} may be real or integer and ${KIND} may be any
!!    supported kind for the corresponding type.
!!##USAGE
!!    Common usage:
!!
!!     y = linspace(x1,x2)
!!     y = linspace(x1,x2,n)
!!##DESCRIPTION
!!    linspace returns a vector of linearly spaced values from x1 to
!!    x2 inclusive. It gives direct control over the number of points
!!    and always includes the endpoints, the results being the same as
!!    [(x1+i*(x2-x1)/(n-1),i=0,n-1)] if n>1 and [x1,x2] if n<=1.
!!##OPTIONS
!!    X1,X2     X1 and X2 are the upper and lower bound of the values
!!              returned. The options can be of type REAL or INTEGER,
!!              but must be of the same type.
!!
!!    N         number of values to return
!!##RETURNS
!!    LINSPACE  The returned row vector starts with X1 and ends with X2,
!!              returning N evenly spaced values.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_linspace
!!    use M_LA,  only : linspace
!!    implicit none
!!    character(len=*), parameter :: gen='(*(g0, 1x))'
!!       write( *, gen ) linspace(  0,      9,    10 )
!!       write( *, gen ) linspace( 10.0,   20.0,  11 )
!!       write( *, gen ) linspace( 11.1d0, 12.1d0, 5 )
!!       write( *, gen ) linspace( 11.1,   12.1,   5 )
!!    end program demo_linspace
!!   Results:
!!    0 1 2 3 4 5 6 7 8 9
!!    10.00 11.00 12.00 13.00 14.00 15.00 16.00 17.00 18.00 19.00 20.00
!!    11.1000000000 11.3500000000 11.6000000000 11.8500000000 12.100000000
!!    11.1000004 11.3500004 11.6000004 11.8500004 12.1000004
!!
!!   Results:
function linspace_real128(x1,x2,n)
integer,intent(in)               :: n
real(kind=real128),intent(in) :: x1,x2
real(kind=real128)            :: linspace_real128(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_real128=[x1,x2]
   else
      linspace_real128=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_real128
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_real64(x1,x2,n)
integer,intent(in)               :: n
real(kind=real64),intent(in) :: x1,x2
real(kind=real64)            :: linspace_real64(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_real64=[x1,x2]
   else
      linspace_real64=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_real64
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_real32(x1,x2,n)
integer,intent(in)               :: n
real(kind=real32),intent(in) :: x1,x2
real(kind=real32)            :: linspace_real32(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_real32=[x1,x2]
   else
      linspace_real32=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_real32
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_int64(x1,x2,n)
integer,intent(in)               :: n
integer(kind=int64),intent(in) :: x1,x2
integer(kind=int64)            :: linspace_int64(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_int64=[x1,x2]
   else
      linspace_int64=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_int64
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_int32(x1,x2,n)
integer,intent(in)               :: n
integer(kind=int32),intent(in) :: x1,x2
integer(kind=int32)            :: linspace_int32(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_int32=[x1,x2]
   else
      linspace_int32=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_int32
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_int16(x1,x2,n)
integer,intent(in)               :: n
integer(kind=int16),intent(in) :: x1,x2
integer(kind=int16)            :: linspace_int16(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_int16=[x1,x2]
   else
      linspace_int16=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_int16
!-----------------------------------------------------------------------------------------------------------------------------------
function linspace_int8(x1,x2,n)
integer,intent(in)               :: n
integer(kind=int8),intent(in) :: x1,x2
integer(kind=int8)            :: linspace_int8(n)
integer(kind=int64)              :: i
   if(n.le.1)then
      linspace_int8=[x1,x2]
   else
      linspace_int8=[(x1+i*(x2-x1)/(n-1),i=0,n-1)]
   endif
end function linspace_int8
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_inverse_hilbert(a,lda,n)

! ident_1="@(#) M_LA mat_inverse_hilbert(3fp) generate doubleprecision inverse hilbert matrix"
!
! References:
! Forsythe, G. E. and C. B. Moler. Computer Solution of Linear Algebraic Systems. Englewood Cliffs, NJ: Prentice-Hall, 1967.

integer,intent(in)          :: lda
integer,intent(in)          :: n
doubleprecision,intent(out) :: a(lda,n)

doubleprecision :: p
doubleprecision :: r
integer         :: i
integer         :: j
integer         :: ip1

   p = dble(n)

   do i = 1, n
      if (i.ne.1) p = (dble(n-i+1) * p * dble(n+i-1)) / dble(i-1)**2
      r = p * p
      a(i,i) = r / dble(2*i-1)
      if (i.eq.n) cycle
      ip1 = i + 1
      do j = ip1, n
         r = (-1) * (dble(n-j+1) * r * (n+j-1)) / dble(j-1)**2
         a(i,j) = r/ dble(i+j-1)
         a(j,i) = a(i,j)
      enddo
   enddo

end subroutine mat_inverse_hilbert

!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!   mat_magic(3f) - [M_LA] create an N x N magic square array, N>2
!!##SYNOPSIS
!!
!!    subroutine mat_magic(a,rows,n)
!!
!!       integer         :: rows
!!       integer         :: n
!!       doubleprecision :: a(rows,n)
!!
!!##DESCRIPTION
!!    This procedure returns the values to create a magic squares array,
!!    an n by n matrix in which each integer 1, 2, ..., n*n appears exactly
!!    once; and all columns, rows, and diagonals sum to the same number.
!!
!!##OPTIONS
!!    A             An array to fill with the magic square values. The
!!                  smallest dimension should be >= 3. Since a square is
!!                  required only the first N will be filled,
!!                  where n=min(rows,columns).
!!    ROWS          size of a row of A; must be >= N
!!    N             size of an edge of the magic square. A() must have at
!!                  least this many columns.
!!
!!##PEDIGREE
!!   Based on an algorithm for magic squares from
!!
!!     Mathematical Recreations and Essays, 12th ed.,
!!     by W. W. Rouse Ball and H. S. M. Coxeter
!!##EXAMPLES
!!
!!   Sample program
!!
!!    program demo_mat_magic
!!    use M_LA, only : mat_magic
!!    implicit none
!!    integer,parameter :: isize=10
!!    doubleprecision   :: arr(isize,isize)
!!    integer           :: i, j, k
!!       do k=1,isize
!!          write(*,'(*(g0,1x))')'K=',k
!!          call mat_magic(arr,size(arr,dim=1),k)
!!          do i=1,k
!!             write(*,'(i2,":",*(i5):)')i,&
!!              (nint(arr(i,j)),j=1,k),&
!!              nint(sum(arr(k,:k)))
!!          enddo
!!       enddo
!!    end program demo_mat_magic
!!
!!   Results:
!!
!!     K= 1
!!     1:    1    1
!!     K= 2
!!     1:    1    3    6
!!     2:    4    2    6
!!     K= 3
!!     1:    8    1    6   15
!!     2:    3    5    7   15
!!     3:    4    9    2   15
!!     K= 4
!!     1:   16    2    3   13   34
!!     2:    5   11   10    8   34
!!     3:    9    7    6   12   34
!!     4:    4   14   15    1   34
!!     K= 5
!!     1:   17   24    1    8   15   65
!!     2:   23    5    7   14   16   65
!!     3:    4    6   13   20   22   65
!!     4:   10   12   19   21    3   65
!!     5:   11   18   25    2    9   65
!!     K= 6
!!     1:   35    1    6   26   19   24  111
!!     2:    3   32    7   21   23   25  111
!!     3:   31    9    2   22   27   20  111
!!     4:    8   28   33   17   10   15  111
!!     5:   30    5   34   12   14   16  111
!!     6:    4   36   29   13   18   11  111
!!     K= 7
!!     1:   30   39   48    1   10   19   28  175
!!     2:   38   47    7    9   18   27   29  175
!!     3:   46    6    8   17   26   35   37  175
!!     4:    5   14   16   25   34   36   45  175
!!     5:   13   15   24   33   42   44    4  175
!!     6:   21   23   32   41   43    3   12  175
!!     7:   22   31   40   49    2   11   20  175
!!     K= 8
!!     1:   64    2    3   61   60    6    7   57  260
!!     2:    9   55   54   12   13   51   50   16  260
!!     3:   17   47   46   20   21   43   42   24  260
!!     4:   40   26   27   37   36   30   31   33  260
!!     5:   32   34   35   29   28   38   39   25  260
!!     6:   41   23   22   44   45   19   18   48  260
!!     7:   49   15   14   52   53   11   10   56  260
!!     8:    8   58   59    5    4   62   63    1  260
!!     K= 9
!!     1:   47   58   69   80    1   12   23   34   45  369
!!     2:   57   68   79    9   11   22   33   44   46  369
!!     3:   67   78    8   10   21   32   43   54   56  369
!!     4:   77    7   18   20   31   42   53   55   66  369
!!     5:    6   17   19   30   41   52   63   65   76  369
!!     6:   16   27   29   40   51   62   64   75    5  369
!!     7:   26   28   39   50   61   72   74    4   15  369
!!     8:   36   38   49   60   71   73    3   14   25  369
!!     9:   37   48   59   70   81    2   13   24   35  369
!!     K= 10
!!     1:   92   99    1    8   15   67   74   51   58   40  505
!!     2:   98   80    7   14   16   73   55   57   64   41  505
!!     3:    4   81   88   20   22   54   56   63   70   47  505
!!     4:   85   87   19   21    3   60   62   69   71   28  505
!!     5:   86   93   25    2    9   61   68   75   52   34  505
!!     6:   17   24   76   83   90   42   49   26   33   65  505
!!     7:   23    5   82   89   91   48   30   32   39   66  505
!!     8:   79    6   13   95   97   29   31   38   45   72  505
!!     9:   10   12   94   96   78   35   37   44   46   53  505
!!    10:   11   18  100   77   84   36   43   50   27   59  505
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_magic(a,rows,n)
!
! ident_2="@(#) M_LA mat_magic(3fp) Algorithms for magic squares"

integer,intent(in) :: rows
integer,intent(in) :: n
doubleprecision    :: a(rows,n)

doubleprecision    :: t
integer            :: i, j, k, m
integer            :: i1, j1, m1, m2
integer            :: im, jm, mm

   if (mod(n,4) .eq. 0)then
      !
      !     double even order
      !
      k = 1
      do i = 1, n
         do j = 1, n
            a(i,j) = k
            if (mod(i,4)/2 .eq. mod(j,4)/2) a(i,j) = n*n+1 - k
            k = k+1
         enddo
      enddo
      return
   endif
   if (mod(n,2) .eq. 0) m = n/2
   if (mod(n,2) .ne. 0) m = n
   !
   !     odd order or upper corner of even order
   !
   do j = 1,m
      do i = 1,m
         a(i,j) = 0
      enddo
   enddo
   i = 1
   j = (m+1)/2
   mm = m*m
   do k = 1, mm
      a(i,j) = k
      i1 = i-1
      j1 = j+1
      if(i1.lt.1) i1 = m
      if(j1.gt.m) j1 = 1
      if(int(a(i1,j1)).ne.0) then
         i1 = i+1
         j1 = j
      endif
      i = i1
      j = j1
   enddo
   if (mod(n,2) .ne. 0) return

   !
   !     rest of even order
   !
   t = dble(m*m)
   do i = 1, m
      do j = 1, m
         im = i+m
         jm = j+m
         a(i,jm) = a(i,j) + 2*t
         a(im,j) = a(i,j) + 3*t
         a(im,jm) = a(i,j) + t
      enddo
   enddo
   m1 = (m-1)/2
   if (m1.eq.0) return

   do j = 1, m1
      call mat_rswap(m,a(1,j),1,a(m+1,j),1)
   enddo
   m1 = (m+1)/2
   m2 = m1 + m
   call mat_rswap(1,a(m1,1),1,a(m2,1),1)
   call mat_rswap(1,a(m1,m1),1,a(m2,m1),1)
   m1 = n+1-(m-3)/2
   if(m1.gt.n) return

   do j = m1, n
      call mat_rswap(m,a(1,j),1,a(m+1,j),1)
   enddo
end subroutine mat_magic
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rref(ar,ai,lda,m,n,eps)
integer,intent(in) :: lda
doubleprecision    :: ar(lda,*)
doubleprecision    :: ai(lda,*)
integer            :: m
integer            :: n
doubleprecision    :: eps

doubleprecision    :: tol
doubleprecision    :: tr
doubleprecision    :: ti
integer            :: i, j, k, l

   tol = 0.0d0
   do j = 1, n
      tol = dmax1(tol,mat_wasum(m,ar(1,j),ai(1,j),1))
   enddo
   tol = eps*dble(2*max0(m,n))*tol
   k = 1
   l = 1
   infinite: do
      if (k.gt.m .or. l.gt.n) return

      i = mat_iwamax(m-k+1,ar(k,l),ai(k,l),1) + k-1
      if (dabs(ar(i,l))+dabs(ai(i,l)) .le. tol)then
         call mat_wset(m-k+1,0.0d0,0.0d0,ar(k,l),ai(k,l),1)
         l = l+1
         cycle infinite
      endif

      call mat_wswap(n-l+1,ar(i,l),ai(i,l),lda,ar(k,l),ai(k,l),lda)
      call mat_wdiv(1.0d0,0.0d0,ar(k,l),ai(k,l),tr,ti)
      call mat_wscal(n-l+1,tr,ti,ar(k,l),ai(k,l),lda)
      ar(k,l) = 1.0d0
      ai(k,l) = 0.0d0
      do i = 1, m
         tr = -ar(i,l)
         ti = -ai(i,l)
         if (i .ne. k) call matx_waxpy(n-l+1,tr,ti,ar(k,l),ai(k,l),lda,ar(i,l),ai(i,l),lda)
      enddo
      k = k+1
      l = l+1
   enddo infinite
end subroutine mat_rref
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_pythag(a,b)
doubleprecision :: a
doubleprecision :: b

doubleprecision :: p
doubleprecision :: q
doubleprecision :: r
doubleprecision :: s
doubleprecision :: t

   p = dmax1(dabs(a),dabs(b))
   q = dmin1(dabs(a),dabs(b))

   if (q .ne. 0.0d0) then

      infinite : do
         r = (q/p)**2
         t = 4.0d0 + r
         if (t .eq. 4.0d0) exit infinite
         s = r/t
         p = p + 2.0d0*p*s
         q = q*s
      enddo infinite

   endif

   mat_pythag = p
end function mat_pythag
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotur(n,xr,xi,incx,yr,yi,incy)
integer,intent(in) :: n
doubleprecision    :: xr(*)
doubleprecision    :: xi(*)
integer            :: incx
doubleprecision    :: yr(*)
doubleprecision    :: yi(*)
integer            :: incy

doubleprecision    :: s
integer            :: ix
integer            :: iy
integer            :: i

   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = mat_flop(s + xr(ix)*yr(iy) - xi(ix)*yi(iy))
         ix = ix + incx
         iy = iy + incy
      enddo
   endif

   mat_wdotur = s

end function mat_wdotur
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wcopy(number_of_values,xr,xi,incx,yr,yi,incy)
integer,intent(in)          :: number_of_values
doubleprecision,intent(in)  :: xr(*)
doubleprecision,intent(in)  :: xi(*)
integer,intent(in)          :: incx
doubleprecision,intent(out) :: yr(*)
doubleprecision,intent(out) :: yi(*)
integer,intent(in)          :: incy

integer                     :: ix
integer                     :: iy
integer                     :: i
   if (number_of_values .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-number_of_values+1)*incx + 1
      if (incy.lt.0) iy = (-number_of_values+1)*incy + 1
      do i = 1, number_of_values
         yr(iy) = xr(ix)
         yi(iy) = xi(ix)
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
end subroutine mat_wcopy
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wset(n,xr,xi,yr,yi,incy)

! ident_18="@(#)M_LA::mat_set(3f):"

integer,intent(in)         :: n     ! number of Y values to set
doubleprecision,intent(in) :: xr    ! constant to assign Y real values to
doubleprecision,intent(in) :: xi    ! constant to assign Y imaginary values to
doubleprecision            :: yr(*) ! Y real component to set to XR
doubleprecision            :: yi(*) ! Y imaginary component to set to XI
integer                    :: incy  ! stride to take while setting output values

integer         :: iy
integer         :: i
   iy = 1
   if (n .le. 0 ) return
   do i = 1,n
      yr(iy) = xr
      yi(iy) = xi
      iy = iy + incy
   enddo
end subroutine mat_wset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wswap(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

doubleprecision :: t

integer         :: i
integer         :: ix
integer         :: iy

   if (n .le. 0) return
   ix = 1
   iy = 1
   if (incx.lt.0) ix = (-n+1)*incx + 1
   if (incy.lt.0) iy = (-n+1)*incy + 1
   do i = 1, n
      t = xr(ix)
      xr(ix) = yr(iy)
      yr(iy) = t
      t = xi(ix)
      xi(ix) = yi(iy)
      yi(iy) = t
      ix = ix + incx
      iy = iy + incy
   enddo
end subroutine mat_wswap
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wpow(in_real,in_imag,out_real,out_imag,power_real,power_imag)

! ident_21="@(#)M_LA::mat_wpow(3fp): y = x**p

doubleprecision,intent(in)  :: in_real
doubleprecision,intent(in)  :: in_imag
doubleprecision,intent(in)  :: power_real
doubleprecision,intent(in)  :: power_imag
doubleprecision,intent(out) :: out_real
doubleprecision,intent(out) :: out_imag
complex(kind=real64)        :: t
   ! placeholder method, just using Fortran
   t=cmplx(in_real,in_imag,kind=real64)**cmplx(power_real,power_imag,kind=real64)
   out_real=real(t,kind=real64)
   out_imag=aimag(t)
end subroutine mat_wpow
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wsqrt(x_real,x_imag,y_real,y_imag)

! ident_21="@(#)M_LA::mat_wsqrt(3fp): y = sqrt(x) with y_real .ge. 0.0 and sign(y_imag) .eq. sign(x_imag)"

doubleprecision,intent(in)  :: x_real
doubleprecision,intent(in)  :: x_imag
doubleprecision,intent(out) :: y_real
doubleprecision,intent(out) :: y_imag
doubleprecision             :: s
doubleprecision             :: tr
doubleprecision             :: ti
!
   tr = x_real
   ti = x_imag
   s = dsqrt(0.5d0*(mat_pythag(tr,ti) + dabs(tr)))
   if (tr .ge. 0.0d0) y_real = mat_flop(s)
   if (ti .lt. 0.0d0) s = -s
   if (tr .le. 0.0d0) y_imag = mat_flop(s)
   if (tr .lt. 0.0d0) y_real = mat_flop(0.5d0*(ti/y_imag))
   if (tr .gt. 0.0d0) y_imag = mat_flop(0.5d0*(ti/y_real))
end subroutine mat_wsqrt
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rswap(n,x,incx,y,incy)
integer         :: n
doubleprecision :: x(*)
integer         :: incx
doubleprecision :: y(*)
integer         :: incy

doubleprecision :: t
integer         :: ix
integer         :: iy
integer         :: i

   if (n .le. 0) return
   ix = 1
   iy = 1
   if (incx.lt.0) ix = (-n+1)*incx+1
   if (incy.lt.0) iy = (-n+1)*incy+1
   do i = 1, n
      t = x(ix)
      x(ix) = y(iy)
      y(iy) = t
      ix = ix + incx
      iy = iy + incy
   enddo
end subroutine mat_rswap
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wrscal(n,s,xr,xi,incx)
integer         :: n
doubleprecision :: s
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx

integer         :: ix
integer         :: i
   if (n .le. 0) return
   ix = 1
   do i = 1, n
      xr(ix) = mat_flop(s*xr(ix))
      if (xi(ix) .ne. 0.0d0) xi(ix) = mat_flop(s*xi(ix))
      ix = ix + incx
   enddo
end subroutine mat_wrscal
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wscal(n,sr,si,xr,xi,incx)
integer,intent(in)         :: n
doubleprecision,intent(in) :: sr
doubleprecision,intent(in) :: si
doubleprecision            :: xr(*)
doubleprecision            :: xi(*)
integer                    :: incx
integer                    :: ix
integer                    :: i
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         call mat_wmul(sr,si,xr(ix),xi(ix),xr(ix),xi(ix))
         ix = ix + incx
      enddo
   endif
end subroutine mat_wscal
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wmul(ar,ai,br,bi,cr,ci)

! ident_25="@(#)M_LA::mat_wmul(3fp) c = a*b"

doubleprecision,intent(in)  :: ar
doubleprecision,intent(in)  :: ai
doubleprecision,intent(in)  :: br
doubleprecision,intent(in)  :: bi
doubleprecision,intent(out) :: cr
doubleprecision,intent(out) :: ci

doubleprecision :: t
   t = ar*bi + ai*br
   if (t .ne. 0.0d0) t = mat_flop(t)
   cr = mat_flop(ar*br - ai*bi)
   ci = t
end subroutine mat_wmul
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rrot(n,dx,incx,dy,incy,c,s)

! ident_27="@(#)M_LA::mat_rrot(3f): Applies a plane rotation."

integer         :: n
doubleprecision :: dx(*)
integer         :: incx
doubleprecision :: dy(*)
integer         :: incy
doubleprecision :: c
doubleprecision :: s

doubleprecision :: dtemp
integer         :: i
integer         :: ix
integer         :: iy
!
   if (n.gt.0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1,n
           dtemp = mat_flop(c*dx(ix) + s*dy(iy))
           dy(iy) = mat_flop(c*dy(iy) - s*dx(ix))
           dx(ix) = dtemp
           ix = ix + incx
           iy = iy + incy
      enddo
   endif
end subroutine mat_rrot
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rset(n,dx,dy,incy)

! ident_28="@(#)M_LA::mat_rset(3f): copies a scalar, dx, to a vector, dy."

integer         :: n
doubleprecision :: dx,dy(*)
integer         :: incy
integer         :: i
integer         :: iy

   if (n.gt.0) then
      iy = 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1,n
         dy(iy) = dx
         iy = iy + incy
      enddo
   endif
end subroutine mat_rset
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rat(x,len,maxd,a,b,d)

! ident_39="@(#)M_LA::mat_rat(3fp): A/B = continued fraction approximation to X using  len  terms each less than MAXD"

integer         :: len,maxd
doubleprecision :: x,a,b,d(len)
doubleprecision :: s,t,z
integer         :: i
integer         :: ib
integer         :: k
   z = x
   k=0  ! preset to illegal value
   if(len.lt.1)then
      write(*,*)'*mat_rat* internal error -- len<1'
      return
   endif
   do i = 1, len
      k = i
      d(k) = mat_round(z)
      z = z - d(k)
      if (dabs(z)*dble(maxd) .le. 1.0d0) exit
      z = 1.0d0/z
   enddo
   t = d(k)
   s = 1.0d0
   if (k .ge. 2) then
      do ib = 2, k
         i = k+1-ib
         z = t
         t = d(i)*t + s
         s = z
      enddo
   endif
   if (s .lt. 0.0d0) t = -t
   if (s .lt. 0.0d0) s = -s

   a = t
   b = s
end subroutine mat_rat
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_urand(iy)
!>
!!##NAME
!!    mat_urand(3f) - [] uniform random number generator
!!    LICENSE(MIT)
!!
!!##SYNOPSIS
!!
!!     doubleprecision function mat_urand(iy)
!!
!!      integer,intent(inout) :: iy
!!
!!##DESCRIPTION
!!    mat_urand(3f) is a uniform random number generator based on theory and
!!    suggestions given in D.E. Knuth (1969), Vol 2. The integer IY should
!!    be initialized to an arbitrary integer prior to the first call to
!!    mat_urand(3f). The calling program should not alter the value of IY
!!    between subsequent calls to mat_urand(3f). Values of mat_urand(3f) will
!!    be returned in the interval (0,1).
!!
!!##OPTIONS
!!    IY seed for generating a sequence.
!!
!!##EXAMPLE
!!
integer              :: iy
integer,save         :: ia
integer,save         :: ic
integer,save         :: itwo=2
integer,save         :: m2=0
integer              :: m
integer,save         :: mic
doubleprecision      :: halfm
doubleprecision,save :: s
doubleprecision      :: datan
doubleprecision      :: dsqrt
!-----------------------------------------------------------------------
   if (m2 .eq. 0) then                                ! if first entry, compute machine integer word length
      m = 1
      infinite : do
         m2 = m
         m = itwo*m2
         if (m .le. m2) exit infinite
      enddo infinite
      halfm = m2
      ia = 8*int(halfm*datan(1.d0)/8.d0) + 5          ! compute multiplier and increment for linear congruential method
      ic = 2*int(halfm*(0.5d0-dsqrt(3.d0)/6.d0)) + 1
      mic = (m2 - ic) + m2
      s = 0.5d0/halfm                                 ! s is the scale factor for converting to floating point
   endif
   ! compute next random number
   iy = iy*ia

   if (iy .gt. mic) iy = (iy - m2) - m2     ! this statement is for computers which do not allow integer overflow on addition

   iy = iy + ic

   if (iy/2 .gt. m2) iy = (iy - m2) - m2    ! this statement is for computers where the word length for addition is greater than
                                            ! for multiplication
   if (iy .lt. 0) iy = (iy + m2) + m2       ! this statement is for computers where integer overflow affects the sign bit

   mat_urand = dble(iy)*s
end function mat_urand
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wnrm2(n,xr,xi,incx)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
integer         :: ix
integer         :: i
   !     norm2(x)
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         s = mat_pythag(s,xr(ix))
         s = mat_pythag(s,xi(ix))
         ix = ix + incx
      enddo
   endif
   mat_wnrm2 = s
   end function mat_wnrm2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wasum(n,xr,xi,incx)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
integer         :: ix
integer         :: i

   !     norm1(x)
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      do i = 1, n
         s = mat_flop(s + dabs(xr(ix)) + dabs(xi(ix)))
         ix = ix + incx
      enddo
   endif
   mat_wasum = s
end function mat_wasum
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotui(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy
doubleprecision :: s
integer         :: ix
integer         :: iy
integer         :: i
   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = s + xr(ix)*yi(iy) + xi(ix)*yr(iy)
         if (s .ne. 0.0d0) s = mat_flop(s)
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
   mat_wdotui = s
end function mat_wdotui
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotcr(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

doubleprecision :: s
integer         :: ix
integer         :: iy
integer         :: i

   s = 0.0d0
   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1
      do i = 1, n
         s = mat_flop(s + xr(ix)*yr(iy) + xi(ix)*yi(iy))
         ix = ix + incx
         iy = iy + incy
      enddo
   endif
   mat_wdotcr = s
end function mat_wdotcr
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_wdotci(n,xr,xi,incx,yr,yi,incy)
integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: yr(*)
doubleprecision :: yi(*)
integer         :: incy

integer         :: ix
integer         :: iy
integer         :: i
doubleprecision :: s

   s = 0.0d0

   if (n .gt. 0) then
      ix = 1
      iy = 1
      if (incx.lt.0) ix = (-n+1)*incx + 1
      if (incy.lt.0) iy = (-n+1)*incy + 1

      do i = 1, n
         s = s + xr(ix)*yi(iy) - xi(ix)*yr(iy)
         if (s .ne. 0.0d0) s = mat_flop(s)
         ix = ix + incx
         iy = iy + incy
      enddo

   endif

   mat_wdotci = s
end function mat_wdotci
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
integer function mat_iwamax(n,xr,xi,incx)

! ident_41="@(#)M_LA::mat_iwamax(3fp):index of norminf(x)"

integer         :: n
doubleprecision :: xr(*)
doubleprecision :: xi(*)
integer         :: incx
doubleprecision :: s
doubleprecision :: p
integer         :: i, k
integer         :: ix

   k = 0
   if (n .gt. 0) then
      k = 1
      s = 0.0d0
      ix = 1
      do i = 1, n
         p = dabs(xr(ix)) + dabs(xi(ix))
         if (p .gt. s) k = i
         if (p .gt. s) s = p
         ix = ix + incx
      enddo
   endif
   mat_iwamax = k
end function mat_iwamax
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_flop(x)
!>
!!##NAME
!!    mat_flop(3fp) - [M_LA] count and possibly chop each floating point operation
!!    LICENSE(MIT)
!!
!!##SYNOPSIS
!!
!!
!!##DESCRIPTION
!!    Count and possibly chop each floating point operation.
!!
!!    this is a system-dependent function
!!##OPTIONS
!!
!!##NOTES
!!    FLP(1)  is flop counter
!!    FLP(2)  is number of places to be chopped
doubleprecision,intent(in) :: x
doubleprecision            :: mask(14),xx,mm
integer                    :: k
logical                    :: lx(2),lm(2)
equivalence (lx(1),xx),(lm(1),mm)
equivalence (mask(1),mas(1,1))
!>>>>>>>>>>>>>>>>>>
!*!GFORTRAN BUG in 8.3
!*!real,save                  :: mas(2,14)=reshape([ &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'fff0ffff',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'ff00ffff',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'f000ffff',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000ffff',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000fff0',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000ff00',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'0000f000',kind=kind(0.0)),     &
!*!   & real(Z'ffffffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'fff0ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'ff00ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'f000ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'0000ffff',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'0000fff0',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0)),     &
!*!   & real(Z'0000ff80',kind=kind(0.0)),real(Z'00000000',kind=kind(0.0))],shape(mas))
integer :: i,j
logical,save :: setup=.false.
real,save                  :: mas(2,14)
character(len=8),save      :: setmas(2,14)=reshape([ &
   & 'ffffffff','fff0ffff', &
   & 'ffffffff','ff00ffff', &
   & 'ffffffff','f000ffff', &
   & 'ffffffff','0000ffff', &
   & 'ffffffff','0000fff0', &
   & 'ffffffff','0000ff00', &
   & 'ffffffff','0000f000', &
   & 'ffffffff','00000000', &
   & 'fff0ffff','00000000', &
   & 'ff00ffff','00000000', &
   & 'f000ffff','00000000', &
   & '0000ffff','00000000', &
   & '0000fff0','00000000', &
   & '0000ff80','00000000'],shape(mas))
   if(.not.setup)then
      do i=1,2
         do j=1,14
            read(setmas(i,j),'(z8)')mas(i,j)
         enddo
      enddo
      setup=.true.
   endif
!<<<<<<<<<<<<<<<<<<

   la_flop_counter(1) = la_flop_counter(1) + 1
   k = la_flop_counter(2)

   select case(k)
   case(:0)
      mat_flop = x
   case(1:15)
      mat_flop = 0.0d0
   case default
      xx = x
      mm = mask(k)
      lx(1) = lx(1) .and. lm(1)
      lx(2) = lx(2) .and. lm(2)
      mat_flop = xx
   end select

end function mat_flop
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
doubleprecision function mat_round(x)
doubleprecision           :: x,y,z,e
doubleprecision,parameter :: h=1.0d9
   z = dabs(x)
   y = z + 1.0d0
   if (y .ne. z)then
      y = 0.0d0
      e = h
      do
         if (e .ge. z) exit
         e = 2.0d0*e
      enddo
      do
         if (e .le. h) exit
         if (e .le. z) y = y + e
         if (e .le. z) z = z - e
         e = e/2.0d0
      enddo
      z = int(z + 0.5d0)
      y = y + z
      if (x .lt. 0.0d0) y = -y
      mat_round = y
   else
      mat_round = x
   endif
end function mat_round
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==mat_wpofa.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine mat_wpofa(ar,ai,lda,n,info)
implicit none
integer          :: lda
double precision :: ar(lda,*)
double precision :: ai(lda,*)
integer          :: n
integer          :: info

double precision :: s
double precision :: tr
double precision :: ti
integer          :: j
integer          :: jm1
integer          :: k

   do j = 1 , n
      info = j
      s = 0.0d0
      jm1 = j - 1
      if ( jm1>=1 ) then
         do k = 1 , jm1
            tr = ar(k,j) - mat_wdotcr(k-1,ar(1,k),ai(1,k),1,ar(1,j),ai(1,j),1)
            ti = ai(k,j) - mat_wdotci(k-1,ar(1,k),ai(1,k),1,ar(1,j),ai(1,j),1)
            call mat_wdiv(tr,ti,ar(k,k),ai(k,k),tr,ti)
            ar(k,j) = tr
            ai(k,j) = ti
            s = s + tr*tr + ti*ti
         enddo
      endif
      s = ar(j,j) - s
      if ( s<=0.0d0 .or. ai(j,j)/=0.0d0 ) return
      ar(j,j) = dsqrt(s)
   enddo
   info = 0
end subroutine mat_wpofa
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_rrotg(da,db,c,s)

! ident_48="@(#)M_LA::mat_rrotg(3fp): construct Givens plane rotation."

doubleprecision :: da
doubleprecision :: db
doubleprecision :: c
doubleprecision :: s

doubleprecision :: rho
doubleprecision :: r
doubleprecision :: z

   rho = db
   if ( dabs(da) .gt. dabs(db) ) rho = da
   c = 1.0d0
   s = 0.0d0
   z = 1.0d0
   r = mat_flop(dsign(mat_pythag(da,db),rho))
   if (r .ne. 0.0d0) c = mat_flop(da/r)
   if (r .ne. 0.0d0) s = mat_flop(db/r)
   if ( dabs(da) .gt. dabs(db) ) z = s
   if (dabs(db) .ge. dabs(da) .and. c .ne. 0.0d0)z = mat_flop(1.0d0/c)
   da = r
   db = z
end subroutine mat_rrotg
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wsign(xr,xi,yr,yi,zr,zi)

! ident_49="@(#)M_LA::mat_wsign(3fp): if y .ne. 0, z = x*y/abs(y)"

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi
doubleprecision :: zr
doubleprecision :: zi
doubleprecision :: t
   t = mat_pythag(yr,yi)
   zr = xr
   zi = xi
   if (t .ne. 0.0d0) call mat_wmul(yr/t,yi/t,zr,zi,zr,zi)
end subroutine mat_wsign
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wdiv(ar,ai,br,bi,cr,ci)

! ident_17="@(#)M_LA::mat_wdiv(3fp): c = a/b"

doubleprecision :: ar
doubleprecision :: ai
doubleprecision :: br
doubleprecision :: bi
doubleprecision :: cr
doubleprecision :: ci

doubleprecision :: s
doubleprecision :: d
doubleprecision :: ars
doubleprecision :: ais
doubleprecision :: brs
doubleprecision :: bis

   s = dabs(br) + dabs(bi)
   if (s .eq. 0.0d0) then
      call la_err(27)
      return
   endif
   ars = ar/s
   ais = ai/s
   brs = br/s
   bis = bi/s
   d = brs**2 + bis**2
   cr = mat_flop((ars*brs + ais*bis)/d)
   ci = (ais*brs - ars*bis)/d
   if (ci .ne. 0.0d0) ci = mat_flop(ci)
end subroutine mat_wdiv
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wlog(in_real,in_imag,out_real,out_imag)

! ident_22="@(#)M_LA::mat_wlog(3fp): y = log(x)"

doubleprecision :: in_real, in_imag
doubleprecision :: out_real, out_imag
doubleprecision :: t
doubleprecision :: r
   r = mat_pythag(in_real,in_imag)

   if (r .eq. 0.0d0) then
      call la_err(32) !  Singularity of LOG or ATAN
   else
      t = datan2(in_imag,in_real)
      if (in_imag.eq.0.0d0 .and. in_real.lt.0.0d0) t = dabs(t)
      out_real = dlog(r)
      out_imag = t
   endif

end subroutine mat_wlog
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_watan(xr,xi,yr,yi)

! ident_47="@(#)M_LA::mat_watan(3fp): y = atan(x) = (i/2)*log((i+x)/(i-x))"

doubleprecision :: xr
doubleprecision :: xi
doubleprecision :: yr
doubleprecision :: yi
doubleprecision :: tr
doubleprecision :: ti

   if (xi .eq. 0.0d0) then
      yr = datan2(xr,1.0d0)
      yi = 0.0d0
   elseif (xr.ne.0.0d0 .or. dabs(xi).ne.1.0d0) then
      call mat_wdiv(xr,1.0d0+xi,-xr,1.0d0-xi,tr,ti)
      call mat_wlog(tr,ti,tr,ti)
      yr = -(ti/2.0d0)
      yi = tr/2.0d0
   else
      call la_err(32) ! Singularity of LOG or ATAN
   endif

end subroutine mat_watan
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine la_err(n)

! ident_3="@(#) M_matrix la_err(3fp) given error number write associated error message"

integer,intent(in)   :: n
character(len=255)   :: msg
   select case(n)
    case(27); msg='Division by zero is a NO-NO'
    case(32); msg='Singularity of LOG or ATAN'
    case default
       write(msg,'(a,i0)')'<ERROR>:*la_err* internal error: unknown error code=',n
   end select

   write(*,*)'<ERROR>:'//msg

end subroutine la_err
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
end module m_la
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine matx_waxpy(n,sr,si,xr,xi,incx,yr,yi,incy)
use m_la
implicit none
integer,intent(in)         :: n
doubleprecision,intent(in) :: sr
doubleprecision,intent(in) :: si
doubleprecision,intent(in) :: xr(*)
doubleprecision,intent(in) :: xi(*)
integer,intent(in)         :: incx
integer,intent(in)         :: incy

doubleprecision            :: yr(*)
doubleprecision            :: yi(*)
integer                    :: ix, iy

integer                    :: i

   if (n .le. 0) return
   if (sr .eq. 0.0d0 .and. si .eq. 0.0d0) return
   ix = 1
   iy = 1
   if (incx.lt.0) ix = (-n+1)*incx + 1
   if (incy.lt.0) iy = (-n+1)*incy + 1
   do i = 1, n
      yr(iy) = mat_flop(yr(iy) + sr*xr(ix) - si*xi(ix))
      yi(iy) = yi(iy) + sr*xi(ix) + si*xr(ix)
      if (yi(iy) .ne. 0.0d0) yi(iy) = mat_flop(yi(iy))
      ix = ix + incx
      iy = iy + incy
   enddo
end subroutine matx_waxpy
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_wgeco.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_wgeco(ar,ai,lda,n,ipvt,rcond,zr,zi)
use m_la
implicit none
integer          :: lda , n , ipvt(*)
double precision :: ar(lda,*) , ai(lda,*) , zr(*) , zi(*)
double precision :: rcond
!
!     WGECO FACTORS A DOUBLE-COMPLEX MATRIX BY GAUSSIAN ELIMINATION
!     AND ESTIMATES THE CONDITION OF THE MATRIX.
!
!     IF  RCOND  IS NOT NEEDED, WGEFA IS SLIGHTLY FASTER.
!     TO SOLVE  A*X = B , FOLLOW WGECO BY WGESL.
!     TO COMPUTE  INVERSE(A)*C , FOLLOW WGECO BY WGESL.
!     TO COMPUTE  DETERMINANT(A) , FOLLOW WGECO BY WGEDI.
!     TO COMPUTE  INVERSE(A) , FOLLOW WGECO BY WGEDI.
!
!     ON ENTRY
!
!        A       DOUBLE-COMPLEX(LDA, N)
!                THE MATRIX TO BE FACTORED.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!     ON RETURN
!
!        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
!                WHICH WERE USED TO OBTAIN IT.
!                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
!                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
!                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
!
!        IPVT    INTEGER(N)
!                AN INTEGER VECTOR OF PIVOT INDICES.
!
!        RCOND   DOUBLEPRECISION
!                AN ESTIMATE OF THE RECIPROCAL CONDITION OF  A .
!                FOR THE SYSTEM  A*X = B , RELATIVE PERTURBATIONS
!                IN  A  AND  B  OF SIZE  EPSILON  MAY CAUSE
!                RELATIVE PERTURBATIONS IN  X  OF SIZE  EPSILON/RCOND .
!                IF  RCOND  IS SO SMALL THAT THE LOGICAL EXPRESSION
!        1.0 + RCOND .EQ. 1.0
!                IS TRUE, THEN  A  MAY BE SINGULAR TO WORKING
!                PRECISION. IN PARTICULAR,  RCOND  IS ZERO  IF
!                EXACT SINGULARITY IS DETECTED OR THE ESTIMATE
!                UNDERFLOWS.
!
!        Z       DOUBLE-COMPLEX(N)
!                A WORK VECTOR WHOSE CONTENTS ARE USUALLY UNIMPORTANT.
!                IF  A  IS CLOSE TO A SINGULAR MATRIX, THEN  Z  IS
!                AN APPROXIMATE NULL VECTOR IN THE SENSE THAT
!                NORM(A*Z) = RCOND*NORM(A)*NORM(Z) .
!
!     LINPACK. THIS VERSION DATED 07/01/79 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     LINPACK WGEFA
!     BLAS WAXPY,WDOTC,mat_wasum
!     FORTRAN DABS,DMAX1
!
!     INTERNAL VARIABLES
!
double precision :: ekr , eki , tr , ti , wkr , wki , wkmr , wkmi
double precision :: anorm , s , sm , ynorm
integer          :: info , j , k , kb , kp1 , l
!
double precision :: zdumr , zdumi
double precision :: cabs1
   cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
!
!     COMPUTE 1-NORM OF A
!
   anorm = 0.0d0
   do j = 1 , n
      anorm = dmax1(anorm,mat_wasum(n,ar(1,j),ai(1,j),1))
   enddo
!
!     FACTOR
!
   call ml_wgefa(ar,ai,lda,n,ipvt,info)
!
!     RCOND = 1/(NORM(A)*(ESTIMATE OF NORM(INVERSE(A)))) .
!     ESTIMATE = NORM(Z)/NORM(Y) WHERE  A*Z = Y  AND  CTRANS(A)*Y = E .
!     CTRANS(A)  IS THE CONJUGATE TRANSPOSE OF A .
!     THE COMPONENTS OF  E  ARE CHOSEN TO CAUSE MAXIMUM LOCAL
!     GROWTH IN THE ELEMENTS OF W  WHERE  CTRANS(U)*W = E .
!     THE VECTORS ARE FREQUENTLY RESCALED TO AVOID OVERFLOW.
!
!     SOLVE CTRANS(U)*W = E
!
   ekr = 1.0d0
   eki = 0.0d0
   do j = 1 , n
      zr(j) = 0.0d0
      zi(j) = 0.0d0
   enddo
   do k = 1 , n
      call mat_wsign(ekr,eki,-zr(k),-zi(k),ekr,eki)
      if ( cabs1(ekr-zr(k),eki-zi(k))>cabs1(ar(k,k),ai(k,k)) ) then
         s = cabs1(ar(k,k),ai(k,k))/cabs1(ekr-zr(k),eki-zi(k))
         call mat_wrscal(n,s,zr,zi,1)
         ekr = s*ekr
         eki = s*eki
      endif
      wkr = ekr - zr(k)
      wki = eki - zi(k)
      wkmr = -ekr - zr(k)
      wkmi = -eki - zi(k)
      s = cabs1(wkr,wki)
      sm = cabs1(wkmr,wkmi)
      if ( cabs1(ar(k,k),ai(k,k))==0.0d0 ) then
         wkr = 1.0d0
         wki = 0.0d0
         wkmr = 1.0d0
         wkmi = 0.0d0
      else
         call mat_wdiv(wkr,wki,ar(k,k),-ai(k,k),wkr,wki)
         call mat_wdiv(wkmr,wkmi,ar(k,k),-ai(k,k),wkmr,wkmi)
      endif
      kp1 = k + 1
      if ( kp1<=n ) then
         do j = kp1 , n
            call mat_wmul(wkmr,wkmi,ar(k,j),-ai(k,j),tr,ti)
            sm = mat_flop(sm+cabs1(zr(j)+tr,zi(j)+ti))
            call matx_waxpy(1,wkr,wki,[ar(k,j)],[-ai(k,j)],1,zr(j),zi(j),1)
            s = mat_flop(s+cabs1(zr(j),zi(j)))
         enddo
         if ( s<sm ) then
            tr = wkmr - wkr
            ti = wkmi - wki
            wkr = wkmr
            wki = wkmi
            do j = kp1 , n
               call matx_waxpy(1,tr,ti,[ar(k,j)],[-ai(k,j)],1,zr(j),zi(j),1)
            enddo
         endif
      endif
      zr(k) = wkr
      zi(k) = wki
   enddo
   s = 1.0d0/mat_wasum(n,zr,zi,1)
   call mat_wrscal(n,s,zr,zi,1)
!
!     SOLVE CTRANS(L)*Y = W
!
   do kb = 1 , n
      k = n + 1 - kb
      if ( k<n ) then
         zr(k) = zr(k) + mat_wdotcr(n-k,ar(k+1,k),ai(k+1,k),1,zr(k+1),zi(k+1),1)
         zi(k) = zi(k) + mat_wdotci(n-k,ar(k+1,k),ai(k+1,k),1,zr(k+1),zi(k+1),1)
      endif
      if ( cabs1(zr(k),zi(k))>1.0d0 ) then
         s = 1.0d0/cabs1(zr(k),zi(k))
         call mat_wrscal(n,s,zr,zi,1)
      endif
      l = ipvt(k)
      tr = zr(l)
      ti = zi(l)
      zr(l) = zr(k)
      zi(l) = zi(k)
      zr(k) = tr
      zi(k) = ti
   enddo
   s = 1.0d0/mat_wasum(n,zr,zi,1)
   call mat_wrscal(n,s,zr,zi,1)
!
   ynorm = 1.0d0
!
!     SOLVE L*V = Y
!
   do k = 1 , n
      l = ipvt(k)
      tr = zr(l)
      ti = zi(l)
      zr(l) = zr(k)
      zi(l) = zi(k)
      zr(k) = tr
      zi(k) = ti
      if ( k<n ) call matx_waxpy(n-k,tr,ti,ar(k+1,k),ai(k+1,k),1,zr(k+1),zi(k+1),1)
      if ( cabs1(zr(k),zi(k))<=1.0d0 ) cycle
      s = 1.0d0/cabs1(zr(k),zi(k))
      call mat_wrscal(n,s,zr,zi,1)
      ynorm = s*ynorm
   enddo
   s = 1.0d0/mat_wasum(n,zr,zi,1)
   call mat_wrscal(n,s,zr,zi,1)
   ynorm = s*ynorm
!
!     SOLVE  U*Z = V
!
   do kb = 1 , n
      k = n + 1 - kb
      if ( cabs1(zr(k),zi(k))>cabs1(ar(k,k),ai(k,k)) ) then
         s = cabs1(ar(k,k),ai(k,k))/cabs1(zr(k),zi(k))
         call mat_wrscal(n,s,zr,zi,1)
         ynorm = s*ynorm
      endif
      if ( cabs1(ar(k,k),ai(k,k))/=0.0d0 ) call mat_wdiv(zr(k),zi(k),ar(k,k),ai(k,k),zr(k),zi(k))
      if ( cabs1(ar(k,k),ai(k,k))==0.0d0 ) then
         zr(k) = 1.0d0
         zi(k) = 0.0d0
      endif
      tr = -zr(k)
      ti = -zi(k)
      call matx_waxpy(k-1,tr,ti,ar(1,k),ai(1,k),1,zr(1),zi(1),1)
   enddo
!     MAKE ZNORM = 1.0
   s = 1.0d0/mat_wasum(n,zr,zi,1)
   call mat_wrscal(n,s,zr,zi,1)
   ynorm = s*ynorm
!
   if ( anorm/=0.0d0 ) rcond = ynorm/anorm
   if ( anorm==0.0d0 ) rcond = 0.0d0
end subroutine ml_wgeco
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_wgefa.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_wgefa(ar,ai,lda,n,ipvt,info)
use m_la
implicit none
integer          :: lda , n , ipvt(*) , info
double precision :: ar(lda,*) , ai(lda,*)
!
!     WGEFA FACTORS A DOUBLE-COMPLEX MATRIX BY GAUSSIAN ELIMINATION.
!
!     WGEFA IS USUALLY CALLED BY WGECO, BUT IT CAN BE CALLED
!     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.
!     (TIME FOR WGECO) = (1 + 9/N)*(TIME FOR WGEFA) .
!
!     ON ENTRY
!
!        A       DOUBLE-COMPLEX(LDA, N)
!                THE MATRIX TO BE FACTORED.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!     ON RETURN
!
!        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS
!                WHICH WERE USED TO OBTAIN IT.
!                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE
!                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER
!                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.
!
!        IPVT    INTEGER(N)
!                AN INTEGER VECTOR OF PIVOT INDICES.
!
!        INFO    INTEGER
!                = 0  NORMAL VALUE.
!                = K  IF  U(K,K) .EQ. 0.0 . THIS IS NOT AN ERROR
!  CONDITION FOR THIS SUBROUTINE, BUT IT DOES
!  INDICATE THAT WGESL OR WGEDI WILL DIVIDE BY ZERO
!  IF CALLED. USE  RCOND  IN WGECO FOR A RELIABLE
!  INDICATION OF SINGULARITY.
!
!     LINPACK. THIS VERSION DATED 07/01/79 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS WAXPY,mat_wscal,mat_iwamax
!     FORTRAN DABS
!
!     INTERNAL VARIABLES
!
double precision :: tr , ti
integer          :: j , k , kp1 , l , nm1
!
double precision :: zdumr , zdumi
double precision :: cabs1
   cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
!
!     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING
!
   info = 0
   nm1 = n - 1
   if ( nm1>=1 ) then
      do k = 1 , nm1
         kp1 = k + 1
!
!        FIND L = PIVOT INDEX
!
         l = mat_iwamax(n-k+1,ar(k,k),ai(k,k),1) + k - 1
         ipvt(k) = l
!
!        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED
!
         if ( cabs1(ar(l,k),ai(l,k))==0.0d0 ) then
            info = k
         else
!
!           INTERCHANGE IF NECESSARY
!
            if ( l/=k ) then
               tr = ar(l,k)
               ti = ai(l,k)
               ar(l,k) = ar(k,k)
               ai(l,k) = ai(k,k)
               ar(k,k) = tr
               ai(k,k) = ti
            endif
!
!           COMPUTE MULTIPLIERS
!
            call mat_wdiv(-1.0d0,0.0d0,ar(k,k),ai(k,k),tr,ti)
            call mat_wscal(n-k,tr,ti,ar(k+1,k),ai(k+1,k),1)
!
!           ROW ELIMINATION WITH COLUMN INDEXING
!
            do j = kp1 , n
               tr = ar(l,j)
               ti = ai(l,j)
               if ( l/=k ) then
                  ar(l,j) = ar(k,j)
                  ai(l,j) = ai(k,j)
                  ar(k,j) = tr
                  ai(k,j) = ti
               endif
               call matx_waxpy(n-k,tr,ti,ar(k+1,k),ai(k+1,k),1,ar(k+1,j),ai(k+1,j),1)
            enddo
         endif
      enddo
   endif
   ipvt(n) = n
   if ( cabs1(ar(n,n),ai(n,n))==0.0d0 ) info = n
end subroutine ml_wgefa
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_wgesl.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_wgesl(ar,ai,lda,n,ipvt,br,bi,job)
use m_la
implicit none
integer          :: lda , n , ipvt(*) , job
double precision :: ar(lda,*) , ai(lda,*) , br(*) , bi(*)
!
!     WGESL SOLVES THE DOUBLE-COMPLEX SYSTEM
!     A * X = B  OR  CTRANS(A) * X = B
!     USING THE FACTORS COMPUTED BY WGECO OR WGEFA.
!
!     ON ENTRY
!
!        A       DOUBLE-COMPLEX(LDA, N)
!                THE OUTPUT FROM WGECO OR WGEFA.
!
!        LDA     INTEGER
!                THE LEADING DIMENSION OF THE ARRAY  A .
!
!        N       INTEGER
!                THE ORDER OF THE MATRIX  A .
!
!        IPVT    INTEGER(N)
!                THE PIVOT VECTOR FROM WGECO OR WGEFA.
!
!        B       DOUBLE-COMPLEX(N)
!                THE RIGHT HAND SIDE VECTOR.
!
!        JOB     INTEGER
!                = 0         TO SOLVE  A*X = B ,
!                = NONZERO   TO SOLVE  CTRANS(A)*X = B  WHERE
!         CTRANS(A)  IS THE CONJUGATE TRANSPOSE.
!
!     ON RETURN
!
!        B       THE SOLUTION VECTOR  X .
!
!     ERROR CONDITION
!
!        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS A
!        ZERO ON THE DIAGONAL. TECHNICALLY THIS INDICATES SINGULARITY
!        BUT IT IS OFTEN CAUSED BY IMPROPER ARGUMENTS OR IMPROPER
!        SETTING OF LDA . IT WILL NOT OCCUR IF THE SUBROUTINES ARE
!        CALLED CORRECTLY AND IF WGECO HAS SET RCOND .GT. 0.0
!        OR WGEFA HAS SET INFO .EQ. 0 .
!
!     TO COMPUTE  INVERSE(A) * C  WHERE  C  IS A MATRIX
!     WITH  P  COLUMNS
!           CALL ML_WGECO(A,LDA,N,IPVT,RCOND,Z)
!           IF (RCOND IS TOO SMALL) GOTO ...
!           DO J = 1, P
!              CALL ML_WGESL(A,LDA,N,IPVT,C(1,J),0)
!           enddo
!
!     LINPACK. THIS VERSION DATED 07/01/79 .
!     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.
!
!     SUBROUTINES AND FUNCTIONS
!
!     BLAS WAXPY,WDOTC
!
!     INTERNAL VARIABLES
!
double precision :: tr , ti
integer          :: k , kb , l , nm1
!
   nm1 = n - 1
   if ( job/=0 ) then
!
!  JOB = NONZERO, SOLVE  CTRANS(A) * X = B
!  FIRST SOLVE  CTRANS(U)*Y = B
!
      do k = 1 , n
         tr = br(k) - mat_wdotcr(k-1,ar(1,k),ai(1,k),1,br(1),bi(1),1)
         ti = bi(k) - mat_wdotci(k-1,ar(1,k),ai(1,k),1,br(1),bi(1),1)
         call mat_wdiv(tr,ti,ar(k,k),-ai(k,k),br(k),bi(k))
      enddo
!
!        NOW SOLVE CTRANS(L)*X = Y
!
      if ( nm1>=1 ) then
         do kb = 1 , nm1
            k = n - kb
            br(k) = br(k) + mat_wdotcr(n-k,ar(k+1,k),ai(k+1,k),1,br(k+1),bi(k+1),1)
            bi(k) = bi(k) + mat_wdotci(n-k,ar(k+1,k),ai(k+1,k),1,br(k+1),bi(k+1),1)
            l = ipvt(k)
            if ( l==k ) cycle
            tr = br(l)
            ti = bi(l)
            br(l) = br(k)
            bi(l) = bi(k)
            br(k) = tr
            bi(k) = ti
         enddo
      endif
   else
!
!        JOB = 0 , SOLVE  A * X = B
!        FIRST SOLVE  L*Y = B
!
      if ( nm1>1 ) then
         do k = 1 , nm1
            l = ipvt(k)
            tr = br(l)
            ti = bi(l)
            if ( l/=k ) then
               br(l) = br(k)
               bi(l) = bi(k)
               br(k) = tr
               bi(k) = ti
            endif
            call matx_waxpy(n-k,tr,ti,ar(k+1,k),ai(k+1,k),1,br(k+1),bi(k+1),1)
         enddo
      endif
!
!        NOW SOLVE  U*X = Y
!
      do kb = 1 , n
         k = n + 1 - kb
         call mat_wdiv(br(k),bi(k),ar(k,k),ai(k,k),br(k),bi(k))
         tr = -br(k)
         ti = -bi(k)
         call matx_waxpy(k-1,tr,ti,ar(1,k),ai(1,k),1,br(1),bi(1),1)
      enddo
   endif
end subroutine ml_wgesl
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!! name
!!    wgedi(3f) - [m_la] computes the determinant and inverse of a matrix
!!                using the factors computed by wgeco(3f) or wgefa(3f).
!! synopsis
!!    subroutine ml_wgedi(ar,ai,lda,n,ipvt,detr,deti,workr,worki,job)
!!
!!      integer(kind=4) :: lda
!!      real(kind=8) :: ar(lda,*)
!!      real(kind=8) :: ai(lda,*)
!!      integer(kind=4) :: n
!!      integer(kind=4) :: ipvt(*)
!!      real(kind=8) :: detr(2)
!!      real(kind=8) :: deti(2)
!!      real(kind=8) :: workr(*)
!!      real(kind=8) :: worki(*)
!!      integer(kind=4) :: job
!!
!! description
!!    wgedi(3f) computes the determinant and inverse of a matrix
!!    using the factors computed by wgeco(3f) or wgefa(3f).
!!
!! on entry
!!
!!     a       double-complex(lda, n)
!!             the output from wgeco or wgefa.
!!
!!     lda     integer
!!             the leading dimension of the array a.
!!
!!     n       integer
!!             the order of the matrix a.
!!
!!     ipvt    integer(n)
!!             the pivot vector from wgeco(3f) or wgefa(3f).
!!
!!     work    double-complex(n)
!!             work vector. contents destroyed.
!!
!!     job     integer
!!
!!              = 11   both determinant and inverse.
!!              = 01   inverse only.
!!              = 10   determinant only.
!!
!! on return
!!
!!     a       inverse of original matrix if requested.
!!             otherwise unchanged.
!!
!!     det     double-complex(2)
!!             determinant of original matrix if requested.
!!             otherwise not referenced.
!!
!!              determinant = det(1) * 10.0**det(2)
!!              with 1.0 .le. cabs1(det(1) .lt. 10.0
!!              or det(1) .eq. 0.0 .
!!
!! error condition
!!
!!    a division by zero will occur if the input factor contains a zero
!!    on the diagonal and the inverse is requested. it will not occur if
!!    the subroutines are called correctly and if wgeco(3f) has set rcond
!!    .gt. 0.0 or wgefa(3f) has set info .eq. 0 .
!!
!!      linpack. this version dated 07/01/79 .
!!      cleve moler, university of new mexico, argonne national lab.
!!
!! subroutines and functions
!!
!!      blas waxpy,mat_wscal,mat_wswap
!!      fortran dabs,mod
!*==ml_wgedi.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_wgedi(ar,ai,lda,n,ipvt,detr,deti,workr,worki,job)
use m_la
implicit none
integer          :: lda , n , ipvt(*) , job
double precision :: ar(lda,*) , ai(lda,*) , detr(2) , deti(2) , workr(*) , worki(*)
!     INTERNAL VARIABLES
!
double precision :: tr , ti
double precision :: ten
integer          :: i , j , k , kb , kp1 , l , nm1
!
double precision :: zdumr , zdumi
double precision :: cabs1
   cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
!
!     COMPUTE DETERMINANT
!
   if ( job/10/=0 ) then
      detr(1) = 1.0d0
      deti(1) = 0.0d0
      detr(2) = 0.0d0
      deti(2) = 0.0d0
      ten = 10.0d0
      spag_loop_1_1: do i = 1 , n
         if ( ipvt(i)/=i ) then
            detr(1) = -detr(1)
            deti(1) = -deti(1)
         endif
         call mat_wmul(ar(i,i),ai(i,i),detr(1),deti(1),detr(1),deti(1))
!          ...EXIT
!       ...EXIT
         if ( cabs1(detr(1),deti(1))==0.0d0 ) exit spag_loop_1_1
         do while ( cabs1(detr(1),deti(1))<1.0d0 )
            detr(1) = ten*detr(1)
            deti(1) = ten*deti(1)
            detr(2) = detr(2) - 1.0d0
            deti(2) = deti(2) - 0.0d0
         enddo
         do while ( cabs1(detr(1),deti(1))>=ten )
            detr(1) = detr(1)/ten
            deti(1) = deti(1)/ten
            detr(2) = detr(2) + 1.0d0
            deti(2) = deti(2) + 0.0d0
         enddo
      enddo spag_loop_1_1
   endif
!
!     COMPUTE INVERSE(U)
!
   if ( mod(job,10)/=0 ) then
      do k = 1 , n
         call mat_wdiv(1.0d0,0.0d0,ar(k,k),ai(k,k),ar(k,k),ai(k,k))
         tr = -ar(k,k)
         ti = -ai(k,k)
         call mat_wscal(k-1,tr,ti,ar(1,k),ai(1,k),1)
         kp1 = k + 1
         if ( n<kp1 ) cycle
         do j = kp1 , n
            tr = ar(k,j)
            ti = ai(k,j)
            ar(k,j) = 0.0d0
            ai(k,j) = 0.0d0
            call matx_waxpy(k,tr,ti,ar(1,k),ai(1,k),1,ar(1,j),ai(1,j),1)
         enddo
      enddo
!
!        FORM INVERSE(U)*INVERSE(L)
!
      nm1 = n - 1
      if ( nm1>=1 ) then
         do kb = 1 , nm1
            k = n - kb
            kp1 = k + 1
            do i = kp1 , n
               workr(i) = ar(i,k)
               worki(i) = ai(i,k)
               ar(i,k) = 0.0d0
               ai(i,k) = 0.0d0
            enddo
            do j = kp1 , n
               tr = workr(j)
               ti = worki(j)
               call matx_waxpy(n,tr,ti,ar(1,j),ai(1,j),1,ar(1,k),ai(1,k),1)
            enddo
            l = ipvt(k)
            if ( l/=k ) call mat_wswap(n,ar(1,k),ai(1,k),1,ar(1,l),ai(1,l),1)
         enddo
      endif
   endif
end subroutine ml_wgedi
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_htridi.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_htridi(nm,n,ar,ai,d,e,e2,tau)
use m_la
implicit none
!
integer          :: i , j , k , l , n , ii , nm , jp1
double precision :: ar(nm,n) , ai(nm,n) , d(n) , e(n) , e2(n) , tau(2,n)
double precision :: f , g , h , fi , gi , hh , si , scale
integer          :: spag_nextblock_1
!
!     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
!     THE ALGOL PROCEDURE TRED1, NUM. MATH. 11, 181-195(1968)
!     BY MARTIN, REINSCH, AND WILKINSON.
!     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
!
!     THIS SUBROUTINE REDUCES A COMPLEX HERMITIAN MATRIX
!     TO A REAL SYMMETRIC TRIDIAGONAL MATRIX USING
!     UNITARY SIMILARITY TRANSFORMATIONS.
!
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
!          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!          DIMENSION STATEMENT.
!
!        N IS THE ORDER OF THE MATRIX.
!
!        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE COMPLEX HERMITIAN INPUT MATRIX.
!          ONLY THE LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!
!     ON OUTPUT.
!
!        AR AND AI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
!          FORMATIONS USED IN THE REDUCTION IN THEIR FULL LOWER
!          TRIANGLES. THEIR STRICT UPPER TRIANGLES AND THE
!          DIAGONAL OF AR ARE UNALTERED.
!
!        D CONTAINS THE DIAGONAL ELEMENTS OF THE THE TRIDIAGONAL MATRIX.
!
!        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!          MATRIX IN ITS LAST N-1 POSITIONS. E(1) IS SET TO ZERO.
!
!        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
!          E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
!        TAU CONTAINS FURTHER INFORMATION ABOUT THE TRANSFORMATIONS.
!
!     MODIFIED TO GET RID OF ALL COMPLEX ARITHMETIC, C. MOLER, 6/27/79.
!
!     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
!     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
!
!     ------------------------------------------------------------------
!
   tau(1,n) = 1.0d0
   tau(2,n) = 0.0d0
!
   do i = 1 , n
      d(i) = ar(i,i)
   enddo
!     .......... FOR I=N STEP -1 UNTIL 1 DO -- ..........
   do ii = 1 , n
      spag_nextblock_1 = 1
      spag_dispatchloop_1: do
         select case (spag_nextblock_1)
         case (1)
            i = n + 1 - ii
            l = i - 1
            h = 0.0d0
            scale = 0.0d0
            if ( l>=1 ) then
!     .......... SCALE ROW (ALGOL TOL THEN NOT NEEDED) ..........
               do k = 1 , l
                  scale = mat_flop(scale+dabs(ar(i,k))+dabs(ai(i,k)))
               enddo
!
               if ( scale/=0.0d0 ) then
!
                  do k = 1 , l
                     ar(i,k) = mat_flop(ar(i,k)/scale)
                     ai(i,k) = mat_flop(ai(i,k)/scale)
                     h = mat_flop(h+ar(i,k)*ar(i,k)+ai(i,k)*ai(i,k))
                  enddo
!
                  e2(i) = mat_flop(scale*scale*h)
                  g = mat_flop(dsqrt(h))
                  e(i) = mat_flop(scale*g)
                  f = mat_pythag(ar(i,l),ai(i,l))
!     .......... FORM NEXT DIAGONAL ELEMENT OF MATRIX T ..........
                  if ( f==0.0d0 ) then
                     tau(1,l) = -tau(1,i)
                     si = tau(2,i)
                     ar(i,l) = g
                     spag_nextblock_1 = 2
                     cycle spag_dispatchloop_1
                  else
                     tau(1,l) = mat_flop((ai(i,l)*tau(2,i)-ar(i,l)*tau(1,i))/f)
                     si = mat_flop((ar(i,l)*tau(2,i)+ai(i,l)*tau(1,i))/f)
                     h = mat_flop(h+f*g)
                     g = mat_flop(1.0d0+g/f)
                     ar(i,l) = mat_flop(g*ar(i,l))
                     ai(i,l) = mat_flop(g*ai(i,l))
                     if ( l/=1 ) then
                        spag_nextblock_1 = 2
                        cycle spag_dispatchloop_1
                     endif
                     spag_nextblock_1 = 3
                     cycle spag_dispatchloop_1
                  endif
               else
                  tau(1,l) = 1.0d0
                  tau(2,l) = 0.0d0
               endif
            endif
            e(i) = 0.0d0
            e2(i) = 0.0d0
            spag_nextblock_1 = 4
            cycle spag_dispatchloop_1
         case (2)
            f = 0.0d0
!
            do j = 1 , l
               g = 0.0d0
               gi = 0.0d0
!     .......... FORM ELEMENT OF A*U ..........
               do k = 1 , j
                  g = mat_flop(g+ar(j,k)*ar(i,k)+ai(j,k)*ai(i,k))
                  gi = mat_flop(gi-ar(j,k)*ai(i,k)+ai(j,k)*ar(i,k))
               enddo
!
               jp1 = j + 1
               if ( l>=jp1 ) then
!
                  do k = jp1 , l
                     g = mat_flop(g+ar(k,j)*ar(i,k)-ai(k,j)*ai(i,k))
                     gi = mat_flop(gi-ar(k,j)*ai(i,k)-ai(k,j)*ar(i,k))
                  enddo
               endif
!     .......... FORM ELEMENT OF P ..........
               e(j) = mat_flop(g/h)
               tau(2,j) = mat_flop(gi/h)
               f = mat_flop(f+e(j)*ar(i,j)-tau(2,j)*ai(i,j))
            enddo
!
            hh = mat_flop(f/(h+h))
!     .......... FORM REDUCED A ..........
            do j = 1 , l
               f = ar(i,j)
               g = mat_flop(e(j)-hh*f)
               e(j) = g
               fi = -ai(i,j)
               gi = mat_flop(tau(2,j)-hh*fi)
               tau(2,j) = -gi
!
               do k = 1 , j
                  ar(j,k) = mat_flop(ar(j,k)-f*e(k)-g*ar(i,k)+fi*tau(2,k)+gi*ai(i,k))
                  ai(j,k) = mat_flop(ai(j,k)-f*tau(2,k)-g*ai(i,k)-fi*e(k)-gi*ar(i,k))
               enddo
            enddo
            spag_nextblock_1 = 3
         case (3)
!
            do k = 1 , l
               ar(i,k) = mat_flop(scale*ar(i,k))
               ai(i,k) = mat_flop(scale*ai(i,k))
            enddo
!
            tau(2,l) = -si
            spag_nextblock_1 = 4
         case (4)
            hh = d(i)
            d(i) = ar(i,i)
            ar(i,i) = hh
            ai(i,i) = mat_flop(scale*dsqrt(h))
            exit spag_dispatchloop_1
         end select
      enddo spag_dispatchloop_1
   enddo
!
end subroutine ml_htridi
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_htribk.f90 processed by SPAG 8.01RF 01:46 13 Dec 2024
subroutine ml_htribk(nm,n,ar,ai,tau,m,zr,zi)
use m_la
implicit none
!
integer          :: i , j , k , l , m , n , nm
double precision :: ar(nm,n) , ai(nm,n) , tau(2,n) , zr(nm,m) , zi(nm,m)
double precision :: h , s , si
!
!     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
!     THE ALGOL PROCEDURE TRBAK1, NUM. MATH. 11, 181-195(1968)
!     BY MARTIN, REINSCH, AND WILKINSON.
!     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
!
!     THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX HERMITIAN
!     MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!     REAL SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY  HTRIDI.
!
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
!          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!          DIMENSION STATEMENT.
!
!        N IS THE ORDER OF THE MATRIX.
!
!        AR AND AI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
!          FORMATIONS USED IN THE REDUCTION BY  HTRIDI  IN THEIR
!          FULL LOWER TRIANGLES EXCEPT FOR THE DIAGONAL OF AR.
!
!        TAU CONTAINS FURTHER INFORMATION ABOUT THE TRANSFORMATIONS.
!
!        M IS THE NUMBER OF EIGENVECTORS TO BE BACK TRANSFORMED.
!
!        ZR CONTAINS THE EIGENVECTORS TO BE BACK TRANSFORMED
!          IN ITS FIRST M COLUMNS.
!
!     ON OUTPUT.
!
!        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE TRANSFORMED EIGENVECTORS
!          IN THEIR FIRST M COLUMNS.
!
!     NOTE THAT THE LAST COMPONENT OF EACH RETURNED VECTOR
!     IS REAL AND THAT VECTOR EUCLIDEAN NORMS ARE PRESERVED.
!
!     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
!     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
!
!     ------------------------------------------------------------------
!
   if ( m/=0 ) then
!     .......... TRANSFORM THE EIGENVECTORS OF THE REAL SYMMETRIC
!                TRIDIAGONAL MATRIX TO THOSE OF THE HERMITIAN
!                TRIDIAGONAL MATRIX. ..........
      do k = 1 , n
         do j = 1 , m
            zi(k,j) = mat_flop(-(zr(k,j)*tau(2,k)))
            zr(k,j) = mat_flop(zr(k,j)*tau(1,k))
         enddo
      enddo
!
      if ( n/=1 ) then
!     .......... RECOVER AND APPLY THE HOUSEHOLDER MATRICES ..........
         spag_loop_1_1: do i = 2 , n
            l = i - 1
            h = ai(i,i)
            if ( h==0.0d0 ) exit spag_loop_1_1
            do j = 1 , m
               s = 0.0d0
               si = 0.0d0
               do k = 1 , l
                  s = mat_flop(s+ar(i,k)*zr(k,j)-ai(i,k)*zi(k,j))
                  si = mat_flop(si+ar(i,k)*zi(k,j)+ai(i,k)*zr(k,j))
               enddo
!     .......... DOUBLE DIVISIONS AVOID POSSIBLE UNDERFLOW ..........
               s = mat_flop((s/h)/h)
               si = mat_flop((si/h)/h)
               do k = 1 , l
                  zr(k,j) = mat_flop(zr(k,j)-s*ar(i,k)-si*ai(i,k))
                  zi(k,j) = mat_flop(zi(k,j)-si*ar(i,k)+s*ai(i,k))
               enddo
            enddo
         enddo spag_loop_1_1
      endif
   endif
!
end subroutine ml_htribk
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_comqr3.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_comqr3(nm,n,low,igh,ortr,orti,hr,hi,wr,wi,zr,zi,ierr,job)
use m_la
implicit none
!*****
!     MODIFICATION OF EISPACK COMQR2 TO ADD JOB PARAMETER
!     JOB = 0  OUTPUT H = SCHUR TRIANGULAR FORM, Z NOT USED
!         = 1  OUTPUT H = SCHUR FORM, Z = UNITARY SIMILARITY
!         = 2  SAME AS COMQR2
!         = 3  OUTPUT H = HESSENBERG FORM, Z = UNITARY SIMILARITY
!     ALSO ELIMINATE MACHEP
!     C. MOLER, 11/22/78 AND 09/14/80
!     OVERFLOW CONTROL IN EIGENVECTOR BACKSUBSTITUTION, 3/16/82
!*****
!
!
!     THIS SUBROUTINE IS A TRANSLATION OF A UNITARY ANALOGUE OF THE
!     ALGOL PROCEDURE  COMLR2, NUM. MATH. 16, 181-204(1970) BY PETERS
!     AND WILKINSON.
!     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971).
!     THE UNITARY ANALOGUE SUBSTITUTES THE QR ALGORITHM OF FRANCIS
!     (COMP. JOUR. 4, 332-345(1962)) FOR THE LR ALGORITHM.
!
!     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
!     OF A COMPLEX UPPER HESSENBERG MATRIX BY THE QR
!     METHOD. THE EIGENVECTORS OF A COMPLEX GENERAL MATRIX
!     CAN ALSO BE FOUND IF  CORTH  HAS BEEN USED TO REDUCE
!     THIS GENERAL MATRIX TO HESSENBERG FORM.
!
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
!          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!          DIMENSION STATEMENT.
!
!        N IS THE ORDER OF THE MATRIX.
!
!        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING
!          SUBROUTINE ML_CBAL. IF  CBAL  HAS NOT BEEN USED,
!          SET LOW=1, IGH=N.
!
!        ORTR AND ORTI CONTAIN INFORMATION ABOUT THE UNITARY TRANS-
!          FORMATIONS USED IN THE REDUCTION BY  CORTH, IF PERFORMED.
!          ONLY ELEMENTS LOW THROUGH IGH ARE USED. IF THE EIGENVECTORS
!          OF THE HESSENBERG MATRIX ARE DESIRED, SET ORTR(J) AND
!          ORTI(J) TO 0.0D0 FOR THESE ELEMENTS.
!
!        HR AND HI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE COMPLEX UPPER HESSENBERG MATRIX.
!          THEIR LOWER TRIANGLES BELOW THE SUBDIAGONAL CONTAIN FURTHER
!          INFORMATION ABOUT THE TRANSFORMATIONS WHICH WERE USED IN THE
!          REDUCTION BY  CORTH, IF PERFORMED. IF THE EIGENVECTORS OF
!          THE HESSENBERG MATRIX ARE DESIRED, THESE ELEMENTS MAY BE
!          ARBITRARY.
!
!     ON OUTPUT.
!
!        ORTR, ORTI, AND THE UPPER HESSENBERG PORTIONS OF HR AND HI
!          HAVE BEEN DESTROYED.
!
!        WR AND WI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE EIGENVALUES. IF AN ERROR
!          EXIT IS MADE, THE EIGENVALUES SHOULD BE CORRECT
!          FOR INDICES IERR+1,...,N.
!
!        ZR AND ZI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE EIGENVECTORS. THE EIGENVECTORS
!          ARE UNNORMALIZED. IF AN ERROR EXIT IS MADE, NONE OF
!          THE EIGENVECTORS HAS BEEN FOUND.
!
!        IERR IS SET TO
!          ZERO       FOR NORMAL RETURN,
!          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
!  DETERMINED AFTER A TOTAL OF 30*N ITERATIONS.
!
!     MODIFIED TO GET RID OF ALL COMPLEX ARITHMETIC, C. MOLER, 6/27/79.
!
!     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
!     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
!
!     ------------------------------------------------------------------
integer          :: i, j, k, l, m, n, en, ii, ll, nm, nn, igh, ip1, itn, its, low, lp1, enm1, iend, ierr
double precision :: hr(nm,n), hi(nm,n), wr(n), wi(n), zr(nm,n), zi(nm,n), ortr(igh), orti(igh)
double precision :: si, sr, ti, tr, xi, xr, yi, yr, zzi, zzr, norm
integer          :: job
integer          :: jj
integer          :: spag_nextblock_1
   spag_nextblock_1 = 1
   spag_dispatchloop_1: do
      select case (spag_nextblock_1)
       case (1)
         ierr = 0
         !*****
         if ( job/=0 ) then
            !*****
!     .......... INITIALIZE EIGENVECTOR MATRIX ..........
            do i = 1, n
               do j = 1, n
                  zr(i,j) = 0.0d0
                  zi(i,j) = 0.0d0
                  if ( i==j ) zr(i,j) = 1.0d0
               enddo
            enddo
!     .......... FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS
!                FROM THE INFORMATION LEFT BY CORTH ..........
            iend = igh - low - 1
            if ( iend<0 ) then
               spag_nextblock_1 = 2
               cycle spag_dispatchloop_1
            endif
            if ( iend/=0 ) then
!     .......... for i=igh-1 step -1 until low+1 do -- ..........
               do ii = 1, iend
                  i = igh - ii
                  if ( ortr(i)==0.0d0 .and. orti(i)==0.0d0 ) cycle
                  if ( hr(i,i-1)==0.0d0 .and. hi(i,i-1)==0.0d0 ) cycle
!     .......... NORM BELOW IS NEGATIVE OF H FORMED IN CORTH ..........
                  norm = mat_flop(hr(i,i-1)*ortr(i)+hi(i,i-1)*orti(i))
                  ip1 = i + 1

                  do k = ip1, igh
                     ortr(k) = hr(k,i-1)
                     orti(k) = hi(k,i-1)
                  enddo

                  do j = i, igh
                     sr = 0.0d0
                     si = 0.0d0

                     do k = i, igh
                        sr = mat_flop(sr+ortr(k)*zr(k,j)+orti(k)*zi(k,j))
                        si = mat_flop(si+ortr(k)*zi(k,j)-orti(k)*zr(k,j))
                     enddo

                     sr = mat_flop(sr/norm)
                     si = mat_flop(si/norm)

                     do k = i, igh
                        zr(k,j) = mat_flop(zr(k,j)+sr*ortr(k)-si*orti(k))
                        zi(k,j) = mat_flop(zi(k,j)+sr*orti(k)+si*ortr(k))
                     enddo

                  enddo

               enddo
               !*****
               if ( job==3 ) return
            endif
         endif
         !*****
!     .......... CREATE REAL SUBDIAGONAL ELEMENTS ..........
         l = low + 1

         do i = l, igh
            ll = min0(i+1,igh)
            if ( hi(i,i-1)==0.0d0 ) cycle
            norm = mat_pythag(hr(i,i-1),hi(i,i-1))
            yr = mat_flop(hr(i,i-1)/norm)
            yi = mat_flop(hi(i,i-1)/norm)
            hr(i,i-1) = norm
            hi(i,i-1) = 0.0d0

            do j = i, n
               si = mat_flop(yr*hi(i,j)-yi*hr(i,j))
               hr(i,j) = mat_flop(yr*hr(i,j)+yi*hi(i,j))
               hi(i,j) = si
            enddo

            do j = 1, ll
               si = mat_flop(yr*hi(j,i)+yi*hr(j,i))
               hr(j,i) = mat_flop(yr*hr(j,i)-yi*hi(j,i))
               hi(j,i) = si
            enddo
            !*****
            if ( job==0 ) cycle
            !*****
            do j = low, igh
               si = mat_flop(yr*zi(j,i)+yi*zr(j,i))
               zr(j,i) = mat_flop(yr*zr(j,i)-yi*zi(j,i))
               zi(j,i) = si
            enddo

         enddo
         spag_nextblock_1 = 2
       case (2)
!     .......... STORE ROOTS ISOLATED BY CBAL ..........
         do i = 1, n
            if ( i>=low .and. i<=igh ) cycle
            wr(i) = hr(i,i)
            wi(i) = hi(i,i)
         enddo

         en = igh
         tr = 0.0d0
         ti = 0.0d0
         itn = 30*n
         spag_nextblock_1 = 3
       case (3)
!     .......... SEARCH FOR NEXT EIGENVALUE ..........
         if ( en<low ) then
!     .......... ALL ROOTS FOUND. BACKSUBSTITUTE TO FIND
!                VECTORS OF UPPER TRIANGULAR FORM ..........
!
!*****  THE FOLLOWING SECTION CHANGED FOR OVERFLOW CONTROL
!       C. MOLER, 3/16/82
!
            if ( job==2 ) then

               norm = 0.0d0
               do i = 1, n
                  do j = i, n
                     tr = mat_flop(dabs(hr(i,j))) + mat_flop(dabs(hi(i,j)))
                     if ( tr>norm ) norm = tr
                  enddo
               enddo
               if ( n/=1 .and. norm/=0.0d0 ) then
!     .......... FOR EN=N STEP -1 UNTIL 2 DO -- ..........
                  do nn = 2, n
                     en = n + 2 - nn
                     xr = wr(en)
                     xi = wi(en)
                     hr(en,en) = 1.0d0
                     hi(en,en) = 0.0d0
                     enm1 = en - 1
!     .......... FOR I=EN-1 STEP -1 UNTIL 1 DO -- ..........
                     do ii = 1, enm1
                        i = en - ii
                        zzr = 0.0d0
                        zzi = 0.0d0
                        ip1 = i + 1
                        do j = ip1, en
                           zzr = mat_flop(zzr+hr(i,j)*hr(j,en)-hi(i,j)*hi(j,en))
                           zzi = mat_flop(zzi+hr(i,j)*hi(j,en)+hi(i,j)*hr(j,en))
                        enddo
                        yr = mat_flop(xr-wr(i))
                        yi = mat_flop(xi-wi(i))
                        if ( yr==0.0d0 .and. yi==0.0d0 ) then
                           yr = norm
                           spag_loop_3_1: do
                              yr = mat_flop(yr/100.0d0)
                              yi = mat_flop(norm+yr)
                              if ( yi==norm ) then
                                 yi = 0.0d0
                                 exit spag_loop_3_1
                              endif
                           enddo spag_loop_3_1
                        endif
                        call mat_wdiv(zzr,zzi,yr,yi,hr(i,en),hi(i,en))
                        tr = mat_flop(dabs(hr(i,en))) + mat_flop(dabs(hi(i,en)))
                        if ( tr==0.0d0 ) cycle
                        if ( tr+1.0d0/tr>tr ) cycle
                        do j = i, en
                           hr(j,en) = mat_flop(hr(j,en)/tr)
                           hi(j,en) = mat_flop(hi(j,en)/tr)
                        enddo
                     enddo
                  enddo
!*****
!     .......... END BACKSUBSTITUTION ..........
                  enm1 = n - 1
!     .......... VECTORS OF ISOLATED ROOTS ..........
                  do i = 1, enm1
                     if ( i>=low .and. i<=igh ) cycle
                     ip1 = i + 1

                     do j = ip1, n
                        zr(i,j) = hr(i,j)
                        zi(i,j) = hi(i,j)
                     enddo

                  enddo
!     .......... MULTIPLY BY TRANSFORMATION MATRIX TO GIVE
!                VECTORS OF ORIGINAL FULL MATRIX.
!                FOR J=N STEP -1 UNTIL LOW+1 DO -- ..........
                  do jj = low, enm1
                     j = n + low - jj
                     m = min0(j,igh)

                     do i = low, igh
                        zzr = 0.0d0
                        zzi = 0.0d0

                        do k = low, m
                           zzr = mat_flop(zzr+zr(i,k)*hr(k,j)-zi(i,k)*hi(k,j))
                           zzi = mat_flop(zzi+zr(i,k)*hi(k,j)+zi(i,k)*hr(k,j))
                        enddo

                        zr(i,j) = zzr
                        zi(i,j) = zzi
                     enddo
!
                  enddo
               endif
            endif
            return
         else
            its = 0
            enm1 = en - 1
         endif
         spag_nextblock_1 = 4
       case (4)
!     .......... LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT
!                FOR L=EN STEP -1 UNTIL LOW DO -- ..........
         spag_loop_1_2: do ll = low, en
            l = en + low - ll
            if ( l==low ) exit spag_loop_1_2
            !*****
            xr = mat_flop(dabs(hr(l-1,l-1))+dabs(hi(l-1,l-1))+dabs(hr(l,l))+dabs(hi(l,l)))
            yr = mat_flop(xr+dabs(hr(l,l-1)))
            if ( xr==yr ) exit spag_loop_1_2
            !*****
         enddo spag_loop_1_2
!     .......... FORM SHIFT ..........
         if ( l==en ) then
!     .......... A ROOT FOUND ..........
            hr(en,en) = mat_flop(hr(en,en)+tr)
            wr(en) = hr(en,en)
            hi(en,en) = mat_flop(hi(en,en)+ti)
            wi(en) = hi(en,en)
            en = enm1
            spag_nextblock_1 = 3
            cycle spag_dispatchloop_1
         elseif ( itn==0 ) then
!     .......... SET ERROR -- NO CONVERGENCE TO AN
!                EIGENVALUE AFTER 30 ITERATIONS ..........
            ierr = en
         else
            if ( its==10 .or. its==20 ) then
!     .......... FORM EXCEPTIONAL SHIFT ..........
               sr = mat_flop(dabs(hr(en,enm1))+dabs(hr(enm1,en-2)))
               si = 0.0d0
            else
               sr = hr(en,en)
               si = hi(en,en)
               xr = mat_flop(hr(enm1,en)*hr(en,enm1))
               xi = mat_flop(hi(enm1,en)*hr(en,enm1))
               if ( xr/=0.0d0 .or. xi/=0.0d0 ) then
                  yr = mat_flop((hr(enm1,enm1)-sr)/2.0d0)
                  yi = mat_flop((hi(enm1,enm1)-si)/2.0d0)
                  call mat_wsqrt(yr**2-yi**2+xr,2.0d0*yr*yi+xi,zzr,zzi)
                  if ( yr*zzr+yi*zzi<0.0d0 ) then
                     zzr = -zzr
                     zzi = -zzi
                  endif
                  call mat_wdiv(xr,xi,yr+zzr,yi+zzi,zzr,zzi)
                  sr = mat_flop(sr-zzr)
                  si = mat_flop(si-zzi)
               endif
            endif

            do i = low, en
               hr(i,i) = mat_flop(hr(i,i)-sr)
               hi(i,i) = mat_flop(hi(i,i)-si)
            enddo

            tr = mat_flop(tr+sr)
            ti = mat_flop(ti+si)
            its = its + 1
            itn = itn - 1
!     .......... REDUCE TO TRIANGLE (ROWS) ..........
            lp1 = l + 1

            do i = lp1, en
               sr = hr(i,i-1)
               hr(i,i-1) = 0.0d0
               norm = mat_flop(dabs(hr(i-1,i-1))+dabs(hi(i-1,i-1))+dabs(sr))
               norm = mat_flop(norm*dsqrt((hr(i-1,i-1)/norm)**2+(hi(i-1,i-1)/norm)**2+(sr/norm)**2))
               xr = mat_flop(hr(i-1,i-1)/norm)
               wr(i-1) = xr
               xi = mat_flop(hi(i-1,i-1)/norm)
               wi(i-1) = xi
               hr(i-1,i-1) = norm
               hi(i-1,i-1) = 0.0d0
               hi(i,i-1) = mat_flop(sr/norm)

               do j = i, n
                  yr = hr(i-1,j)
                  yi = hi(i-1,j)
                  zzr = hr(i,j)
                  zzi = hi(i,j)
                  hr(i-1,j) = mat_flop(xr*yr+xi*yi+hi(i,i-1)*zzr)
                  hi(i-1,j) = mat_flop(xr*yi-xi*yr+hi(i,i-1)*zzi)
                  hr(i,j) = mat_flop(xr*zzr-xi*zzi-hi(i,i-1)*yr)
                  hi(i,j) = mat_flop(xr*zzi+xi*zzr-hi(i,i-1)*yi)
               enddo

            enddo

            si = hi(en,en)
            if ( si/=0.0d0 ) then
               norm = mat_pythag(hr(en,en),si)
               sr = mat_flop(hr(en,en)/norm)
               si = mat_flop(si/norm)
               hr(en,en) = norm
               hi(en,en) = 0.0d0
               if ( en/=n ) then
                  ip1 = en + 1

                  do j = ip1, n
                     yr = hr(en,j)
                     yi = hi(en,j)
                     hr(en,j) = mat_flop(sr*yr+si*yi)
                     hi(en,j) = mat_flop(sr*yi-si*yr)
                  enddo
               endif
            endif
!     .......... INVERSE OPERATION (COLUMNS) ..........
            do j = lp1, en
               xr = wr(j-1)
               xi = wi(j-1)

               do i = 1, j
                  yr = hr(i,j-1)
                  yi = 0.0d0
                  zzr = hr(i,j)
                  zzi = hi(i,j)
                  if ( i/=j ) then
                     yi = hi(i,j-1)
                     hi(i,j-1) = mat_flop(xr*yi+xi*yr+hi(j,j-1)*zzi)
                  endif
                  hr(i,j-1) = mat_flop(xr*yr-xi*yi+hi(j,j-1)*zzr)
                  hr(i,j) = mat_flop(xr*zzr+xi*zzi-hi(j,j-1)*yr)
                  hi(i,j) = mat_flop(xr*zzi-xi*zzr-hi(j,j-1)*yi)
               enddo
!*****
               if ( job==0 ) cycle
!*****
               do i = low, igh
                  yr = zr(i,j-1)
                  yi = zi(i,j-1)
                  zzr = zr(i,j)
                  zzi = zi(i,j)
                  zr(i,j-1) = mat_flop(xr*yr-xi*yi+hi(j,j-1)*zzr)
                  zi(i,j-1) = mat_flop(xr*yi+xi*yr+hi(j,j-1)*zzi)
                  zr(i,j) = mat_flop(xr*zzr+xi*zzi-hi(j,j-1)*yr)
                  zi(i,j) = mat_flop(xr*zzi-xi*zzr-hi(j,j-1)*yi)
               enddo

            enddo

            if ( si/=0.0d0 ) then

               do i = 1, en
                  yr = hr(i,en)
                  yi = hi(i,en)
                  hr(i,en) = mat_flop(sr*yr-si*yi)
                  hi(i,en) = mat_flop(sr*yi+si*yr)
               enddo
!*****
               if ( job/=0 ) then
!*****
                  do i = low, igh
                     yr = zr(i,en)
                     yi = zi(i,en)
                     zr(i,en) = mat_flop(sr*yr-si*yi)
                     zi(i,en) = mat_flop(sr*yi+si*yr)

                  enddo
               endif
            endif
            spag_nextblock_1 = 4
            cycle spag_dispatchloop_1
         endif
         exit spag_dispatchloop_1
      end select
   enddo spag_dispatchloop_1
end subroutine ml_comqr3
!*==ml_corth.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_corth(nm,n,low,igh,ar,ai,ortr,orti)
use m_la
implicit none
!
integer          :: i, j, m, n, ii, jj, la, mp, nm, igh, kp1, low
double precision :: ar(nm,n), ai(nm,n), ortr(igh), orti(igh)
double precision :: f, g, h, fi, fr, scale
!
!     THIS SUBROUTINE IS A TRANSLATION OF A COMPLEX ANALOGUE OF
!     THE ALGOL PROCEDURE ORTHES, NUM. MATH. 12, 349-368(1968)
!     BY MARTIN AND WILKINSON.
!     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 339-358(1971).
!
!     GIVEN A COMPLEX GENERAL MATRIX, THIS SUBROUTINE
!     REDUCES A SUBMATRIX SITUATED IN ROWS AND COLUMNS
!     LOW THROUGH IGH TO UPPER HESSENBERG FORM BY
!     UNITARY SIMILARITY TRANSFORMATIONS.
!
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
!          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!          DIMENSION STATEMENT.
!
!        N IS THE ORDER OF THE MATRIX.
!
!        LOW AND IGH ARE INTEGERS DETERMINED BY THE BALANCING
!          SUBROUTINE ML_CBAL. IF  CBAL  HAS NOT BEEN USED,
!          SET LOW=1, IGH=N.
!
!        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE COMPLEX INPUT MATRIX.
!
!     ON OUTPUT.
!
!        AR AND AI CONTAIN THE REAL AND IMAGINARY PARTS,
!          RESPECTIVELY, OF THE HESSENBERG MATRIX. INFORMATION
!          ABOUT THE UNITARY TRANSFORMATIONS USED IN THE REDUCTION
!          IS STORED IN THE REMAINING TRIANGLES UNDER THE
!          HESSENBERG MATRIX.
!
!        ORTR AND ORTI CONTAIN FURTHER INFORMATION ABOUT THE
!          TRANSFORMATIONS. ONLY ELEMENTS LOW THROUGH IGH ARE USED.
!
!     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
!     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
!
!     ------------------------------------------------------------------
!
   la = igh - 1
   kp1 = low + 1
   if ( la>=kp1 ) then
!
      do m = kp1, la
         h = 0.0d0
         ortr(m) = 0.0d0
         orti(m) = 0.0d0
         scale = 0.0d0
!     .......... SCALE COLUMN (ALGOL TOL THEN NOT NEEDED) ..........
         do i = m, igh
            scale = mat_flop(scale+dabs(ar(i,m-1))+dabs(ai(i,m-1)))
         enddo
!
         if ( scale==0.0d0 ) cycle
         mp = m + igh
!     .......... FOR I=IGH STEP -1 UNTIL M DO -- ..........
         do ii = m, igh
            i = mp - ii
            ortr(i) = mat_flop(ar(i,m-1)/scale)
            orti(i) = mat_flop(ai(i,m-1)/scale)
            h = mat_flop(h+ortr(i)*ortr(i)+orti(i)*orti(i))
         enddo
!
         g = mat_flop(dsqrt(h))
         f = mat_pythag(ortr(m),orti(m))
         if ( f==0.0d0 ) then
!
            ortr(m) = g
            ar(m,m-1) = scale
         else
            h = mat_flop(h+f*g)
            g = mat_flop(g/f)
            ortr(m) = mat_flop((1.0d0+g)*ortr(m))
            orti(m) = mat_flop((1.0d0+g)*orti(m))
         endif
!     .......... FORM (I-(U*UT)/H)*A ..........
         do j = m, n
            fr = 0.0d0
            fi = 0.0d0
!     .......... FOR I=IGH STEP -1 UNTIL M DO -- ..........
            do ii = m, igh
               i = mp - ii
               fr = mat_flop(fr+ortr(i)*ar(i,j)+orti(i)*ai(i,j))
               fi = mat_flop(fi+ortr(i)*ai(i,j)-orti(i)*ar(i,j))
            enddo
!
            fr = mat_flop(fr/h)
            fi = mat_flop(fi/h)
!
            do i = m, igh
               ar(i,j) = mat_flop(ar(i,j)-fr*ortr(i)+fi*orti(i))
               ai(i,j) = mat_flop(ai(i,j)-fr*orti(i)-fi*ortr(i))
            enddo
!
         enddo
!     .......... FORM (I-(U*UT)/H)*A*(I-(U*UT)/H) ..........
         do i = 1, igh
            fr = 0.0d0
            fi = 0.0d0
!     .......... FOR J=IGH STEP -1 UNTIL M DO -- ..........
            do jj = m, igh
               j = mp - jj
               fr = mat_flop(fr+ortr(j)*ar(i,j)-orti(j)*ai(i,j))
               fi = mat_flop(fi+ortr(j)*ai(i,j)+orti(j)*ar(i,j))
            enddo
!
            fr = mat_flop(fr/h)
            fi = mat_flop(fi/h)
!
            do j = m, igh
               ar(i,j) = mat_flop(ar(i,j)-fr*ortr(j)-fi*orti(j))
               ai(i,j) = mat_flop(ai(i,j)+fr*orti(j)-fi*ortr(j))
            enddo
!
         enddo
!
         ortr(m) = mat_flop(scale*ortr(m))
         orti(m) = mat_flop(scale*orti(m))
         ar(m,m-1) = mat_flop(-(g*ar(m,m-1)))
         ai(m,m-1) = mat_flop(-(g*ai(m,m-1)))
      enddo
   endif
!
end subroutine ml_corth
!*==ml_imtql2.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_imtql2(nm,n,d,e,z,ierr,job)
use m_la
implicit none
integer          :: i, j, k, l, m, n, ii, nm, mml, ierr
integer          :: job
double precision :: d(n), e(n), z(nm,n)
double precision :: b, c, f, g, p, r, s
integer          :: spag_nextblock_1
integer          :: spag_nextblock_2
   spag_nextblock_1 = 1
   spag_dispatchloop_1: do
      select case (spag_nextblock_1)
       case (1)
!
!     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE IMTQL2,
!     NUM. MATH. 12, 377-383(1968) BY MARTIN AND WILKINSON,
!     AS MODIFIED IN NUM. MATH. 15, 450(1970) BY DUBRULLE.
!     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 241-248(1971).
!
!     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
!     OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE IMPLICIT QL METHOD.
!     THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
!     BE FOUND IF  TRED2  HAS BEEN USED TO REDUCE THIS
!     FULL MATRIX TO TRIDIAGONAL FORM.
!
!     ON INPUT.
!
!        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
!          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
!          DIMENSION STATEMENT.
!
!        N IS THE ORDER OF THE MATRIX.
!
!        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
!          IN ITS LAST N-1 POSITIONS. E(1) IS ARBITRARY.
!
!        Z CONTAINS THE TRANSFORMATION MATRIX PRODUCED IN THE
!          REDUCTION BY  TRED2, IF PERFORMED. IF THE EIGENVECTORS
!          OF THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN
!          THE IDENTITY MATRIX.
!
!      ON OUTPUT.
!
!        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER. IF AN
!          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
!          UNORDERED FOR INDICES 1,2,...,IERR-1.
!
!        E HAS BEEN DESTROYED.
!
!        Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
!          TRIDIAGONAL (OR FULL) MATRIX. IF AN ERROR EXIT IS MADE,
!          Z CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED
!          EIGENVALUES.
!
!        IERR IS SET TO
!          ZERO       FOR NORMAL RETURN,
!          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
!  DETERMINED AFTER 30 ITERATIONS.
!
!     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
!     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
!
!     ------------------------------------------------------------------
!
!
!*****
!     MODIFIED BY C. MOLER TO ELIMINATE MACHEP 11/22/78
!     MODIFIED TO ADD JOB PARAMETER 08/27/79
!*****
         ierr = 0
         if ( n/=1 ) then
!
            do i = 2, n
               e(i-1) = e(i)
            enddo
!
            e(n) = 0.0d0
!
            do l = 1, n
               spag_nextblock_2 = 1
               spag_dispatchloop_2: do
                  select case (spag_nextblock_2)
                   case (1)
                     j = 0
                     spag_nextblock_2 = 2
                   case (2)
!     .......... LOOK FOR SMALL SUB-DIAGONAL ELEMENT ..........
                     spag_loop_2_1: do m = l, n
                        if ( m==n ) exit spag_loop_2_1
!*****
                        p = mat_flop(dabs(d(m))+dabs(d(m+1)))
                        s = mat_flop(p+dabs(e(m)))
                        if ( p==s ) exit spag_loop_2_1
!*****
                     enddo spag_loop_2_1
!
                     p = d(l)
                     if ( m/=l ) then
                        if ( j==30 ) then
                           spag_nextblock_1 = 2
                           cycle spag_dispatchloop_1
                        endif
                        j = j + 1
!     .......... FORM SHIFT ..........
                        g = mat_flop((d(l+1)-p)/(2.0d0*e(l)))
                        r = mat_flop(dsqrt(g*g+1.0d0))
                        g = mat_flop(d(m)-p+e(l)/(g+dsign(r,g)))
                        s = 1.0d0
                        c = 1.0d0
                        p = 0.0d0
                        mml = m - l
!     .......... FOR I=M-1 STEP -1 UNTIL L DO -- ..........
                        do ii = 1, mml
                           i = m - ii
                           f = mat_flop(s*e(i))
                           b = mat_flop(c*e(i))
                           if ( dabs(f)<dabs(g) ) then
                              s = mat_flop(f/g)
                              r = mat_flop(dsqrt(s*s+1.0d0))
                              e(i+1) = mat_flop(g*r)
                              c = mat_flop(1.0d0/r)
                              s = mat_flop(s*c)
                           else
                              c = mat_flop(g/f)
                              r = mat_flop(dsqrt(c*c+1.0d0))
                              e(i+1) = mat_flop(f*r)
                              s = mat_flop(1.0d0/r)
                              c = mat_flop(c*s)
                           endif
                           g = mat_flop(d(i+1)-p)
                           r = mat_flop((d(i)-g)*s+2.0d0*c*b)
                           p = mat_flop(s*r)
                           d(i+1) = g + p
                           g = mat_flop(c*r-b)
                           if ( job/=0 ) then
!     .......... FORM VECTOR ..........
                              do k = 1, n
                                 f = z(k,i+1)
                                 z(k,i+1) = mat_flop(s*z(k,i)+c*f)
                                 z(k,i) = mat_flop(c*z(k,i)-s*f)
                              enddo
                           endif
!
                        enddo
!
                        d(l) = mat_flop(d(l)-p)
                        e(l) = g
                        e(m) = 0.0d0
                        spag_nextblock_2 = 2
                        cycle spag_dispatchloop_2
                     endif
                     exit spag_dispatchloop_2
                  end select
               enddo spag_dispatchloop_2
            enddo
!     .......... ORDER EIGENVALUES AND EIGENVECTORS ..........
            spag_loop_1_3: do ii = 2, n
               i = ii - 1
               k = i
               p = d(i)
!
               spag_loop_2_2: do j = ii, n
                  if ( d(j)>=p ) exit spag_loop_2_2
                  k = j
                  p = d(j)
               enddo spag_loop_2_2
!
               if ( k==i ) exit spag_loop_1_3
               d(k) = d(i)
               d(i) = p
!
               if ( job==0 ) cycle
               do j = 1, n
                  p = z(j,i)
                  z(j,i) = z(j,k)
                  z(j,k) = p
               enddo
!
            enddo spag_loop_1_3
         endif
         return
       case (2)
!     .......... SET ERROR -- NO CONVERGENCE TO AN
!                EIGENVALUE AFTER 30 ITERATIONS ..........
         ierr = l
         exit spag_dispatchloop_1
      end select
   enddo spag_dispatchloop_1
end subroutine ml_imtql2
!*==ml_wqrdc.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_wqrdc(xr,xi,ldx,n,p,qrauxr,qrauxi,jpvt,workr,worki,job)
use m_la
implicit none
integer          :: ldx, n, p, job
integer          :: jpvt(*)
double precision :: xr(ldx,*), xi(ldx,*), qrauxr(*), qrauxi(*), workr(*), worki(*)
!
!     WQRDC uses Householder transformations to compute the QR
!     factorization of an N by P matrix X. column pivoting
!     based on the 2-norms of the reduced columns may be
!     performed at the users option.
!
!     ON ENTRY
!
!        X       DOUBLE-COMPLEX(LDX,P), where LDX .ge. N.
!                X contains the matrix whose decomposition is to be
!                computed.
!
!        LDX     INTEGER.
!                LDX is the leading dimension of the array X.
!
!        N       INTEGER.
!                N is the number of rows of the matrix X.
!
!        P       INTEGER.
!                P is the number of columns of the matrix X.
!
!        JPVT    INTEGER(P).
!                JPVT contains integers that control the selection
!                of the pivot columns. The K-th column X(K) of X
!                is placed in one of three classes according to the
!                value of JPVT(K).
!
!                   If JPVT(K) .gt. 0, then X(K) is an initial
!                   column.
!
!                   If JPVT(K) .eq. 0, then X(K) is a free column.
!
!                   If JPVT(K) .lt. 0, then X(K) is a final column.
!
!                Before the decomposition is computed, initial columns
!                are moved to the beginning of the array X and final
!                columns to the end. Both initial and final columns
!                are frozen in place during the computation and only
!                free columns are moved. At the K-th stage of the
!                reduction, if X(K) is occupied by a free column
!                it is interchanged with the free column of largest
!                reduced norm. JPVT is not referenced if
!                JOB .eq. 0.
!
!        WORK    double-complex(P).
!                Work is a work array. work is not referenced if
!                JOB .eq. 0.
!
!        JOB     integer.
!                Job is an integer that initiates column pivoting.
!                If JOB .eq. 0, no pivoting is done.
!                If JOB .ne. 0, pivoting is done.
!
!     ON RETURN
!
!        X       X contains in its upper triangle the upper
!                triangular matrix R of the QR factorization.
!                below its diagonal X contains information from
!                which the unitary part of the decomposition
!                can be recovered. Note that if pivoting has
!                been requested, the decomposition is not that
!                of the original matrix X but that of X
!                with its columns permuted as described by JPVT.
!
!        QRAUX   DOUBLE-COMPLEX(P).
!                QRAUX contains further information required to recover
!                the unitary part of the decomposition.
!
!        JPVT    JPVT(K) contains the index of the column of the
!                original matrix that has been interchanged into
!                the K-th column, if pivoting was requested.
!
!     LINPACK. This version dated 07/03/79 .
!     G.W. Stewart, University of Maryland, Argonne National Lab.
!
!     WQRDC uses the following functions and subprograms.
!
!     BLAS matX_waxpy,mat_pythag,mat_wdotcr,mat_wdotci,mat_wscal
!     blas mat_wswap ,mat_wnrm2
!     FORTRAN DABS,DIMAG,DMAX1,MIN0
!
!     INTERNAL VARIABLES
!
integer          :: jj
integer          :: j, jp, l, lp1, lup, maxj, pl, pu
double precision :: maxnrm, tt
double precision :: nrmxlr, nrmxli, tr, ti
logical          :: negj, swapj
!
double precision :: zdumr, zdumi
double precision :: cabs1
cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
!
   pl = 1
   pu = 0
   if ( job/=0 ) then
!
!        PIVOTING HAS BEEN REQUESTED. REARRANGE THE COLUMNS
!        ACCORDING TO JPVT.
!
      do j = 1, p
         swapj = jpvt(j)>0
         negj = jpvt(j)<0
         jpvt(j) = j
         if ( negj ) jpvt(j) = -j
         if ( swapj ) then
            if ( j/=pl ) call mat_wswap(n,xr(1,pl),xi(1,pl),1,xr(1,j),xi(1,j),1)
            jpvt(j) = jpvt(pl)
            jpvt(pl) = j
            pl = pl + 1
         endif
      enddo
      pu = p
      do jj = 1, p
         j = p - jj + 1
         if ( jpvt(j)<0 ) then
            jpvt(j) = -jpvt(j)
            if ( j/=pu ) then
               call mat_wswap(n,xr(1,pu),xi(1,pu),1,xr(1,j),xi(1,j),1)
               jp = jpvt(pu)
               jpvt(pu) = jpvt(j)
               jpvt(j) = jp
            endif
            pu = pu - 1
         endif
      enddo
   endif
!
!     COMPUTE THE NORMS OF THE FREE COLUMNS.
!
   if ( pu>=pl ) then
      do j = pl, pu
         qrauxr(j) = mat_wnrm2(n,xr(1,j),xi(1,j),1)
         qrauxi(j) = 0.0d0
         workr(j) = qrauxr(j)
         worki(j) = qrauxi(j)
      enddo
   endif
!
!     PERFORM THE HOUSEHOLDER REDUCTION OF X.
!
   lup = min0(n,p)
   do l = 1, lup
      if ( l>=pl .and. l<pu ) then
!
!           LOCATE THE COLUMN OF LARGEST NORM AND BRING IT
!           INTO THE PIVOT POSITION.
!
         maxnrm = 0.0d0
         maxj = l
         do j = l, pu
            if ( qrauxr(j)<=maxnrm ) cycle
            maxnrm = qrauxr(j)
            maxj = j
         enddo
         if ( maxj/=l ) then
            call mat_wswap(n,xr(1,l),xi(1,l),1,xr(1,maxj),xi(1,maxj),1)
            qrauxr(maxj) = qrauxr(l)
            qrauxi(maxj) = qrauxi(l)
            workr(maxj) = workr(l)
            worki(maxj) = worki(l)
            jp = jpvt(maxj)
            jpvt(maxj) = jpvt(l)
            jpvt(l) = jp
         endif
      endif
      qrauxr(l) = 0.0d0
      qrauxi(l) = 0.0d0
      if ( l/=n ) then
!
!           COMPUTE THE HOUSEHOLDER TRANSFORMATION FOR COLUMN L.
!
         nrmxlr = mat_wnrm2(n-l+1,xr(l,l),xi(l,l),1)
         nrmxli = 0.0d0
         if ( cabs1(nrmxlr,nrmxli)/=0.0d0 ) then
            if ( cabs1(xr(l,l),xi(l,l))/=0.0d0 ) call mat_wsign(nrmxlr,nrmxli,xr(l,l),xi(l,l),nrmxlr,nrmxli)
            call mat_wdiv(1.0d0,0.0d0,nrmxlr,nrmxli,tr,ti)
            call mat_wscal(n-l+1,tr,ti,xr(l,l),xi(l,l),1)
            xr(l,l) = mat_flop(1.0d0+xr(l,l))
!
!             APPLY THE TRANSFORMATION TO THE REMAINING COLUMNS,
!             UPDATING THE NORMS.
!
            lp1 = l + 1
            if ( p>=lp1 ) then
               do j = lp1, p
                  tr = -mat_wdotcr(n-l+1,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                  ti = -mat_wdotci(n-l+1,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                  call mat_wdiv(tr,ti,xr(l,l),xi(l,l),tr,ti)
                  call matx_waxpy(n-l+1,tr,ti,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                  if ( j>=pl .and. j<=pu ) then
                     if ( cabs1(qrauxr(j),qrauxi(j))/=0.0d0 ) then
                        tt = 1.0d0 - (mat_pythag(xr(l,j),xi(l,j))/qrauxr(j))**2
                        tt = dmax1(tt,0.0d0)
                        tr = mat_flop(tt)
                        tt = mat_flop(1.0d0+0.05d0*tt*(qrauxr(j)/workr(j))**2)
                        if ( tt==1.0d0 ) then
                           qrauxr(j) = mat_wnrm2(n-l,xr(l+1,j),xi(l+1,j),1)
                           qrauxi(j) = 0.0d0
                           workr(j) = qrauxr(j)
                           worki(j) = qrauxi(j)
                        else
                           qrauxr(j) = qrauxr(j)*dsqrt(tr)
                           qrauxi(j) = qrauxi(j)*dsqrt(tr)
                        endif
                     endif
                  endif
               enddo
            endif
!
!              SAVE THE TRANSFORMATION.
!
            qrauxr(l) = xr(l,l)
            qrauxi(l) = xi(l,l)
            xr(l,l) = -nrmxlr
            xi(l,l) = -nrmxli
         endif
      endif
   enddo
end subroutine ml_wqrdc
!*==ml_wqrsl.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_wqrsl(xr,xi,ldx,n,k,qrauxr,qrauxi,yr,yi,qyr,qyi,qtyr,qtyi,br,bi,rsdr,rsdi,xbr,xbi,job,info)
use m_la
implicit none
integer          :: ldx, n, k, job, info
double precision :: xr(ldx,*), xi(ldx,*), qrauxr(*), qrauxi(*), yr(*), yi(*), qyr(*), qyi(*), qtyr(*), qtyi(*), br(*),   &
& bi(*), rsdr(*), rsdi(*), xbr(*), xbi(*)
!
!     WQRSL APPLIES THE OUTPUT OF WQRDC TO COMPUTE COORDINATE
!     TRANSFORMATIONS, PROJECTIONS, AND LEAST SQUARES SOLUTIONS.
!     FOR K .LE. MIN(N,P), LET XK BE THE MATRIX
!
!            XK = (X(JPVT(1)),X(JPVT(2)), ... ,X(JPVT(K)))
!
!     FORMED FROM COLUMNS JPVT(1), ... ,JPVT(K) OF THE ORIGINAL
!     N X P MATRIX X THAT WAS INPUT TO WQRDC (IF NO PIVOTING WAS
!     DONE, XK CONSISTS OF THE FIRST K COLUMNS OF X IN THEIR
!     ORIGINAL ORDER). WQRDC PRODUCES A FACTORED UNITARY MATRIX Q
!     AND AN UPPER TRIANGULAR MATRIX R SUCH THAT
!
!              XK = Q * (R)
!    (0)
!
!     THIS INFORMATION IS CONTAINED IN CODED FORM IN THE ARRAYS
!     X AND QRAUX.
!
!     ON ENTRY
!
!        X      DOUBLE-COMPLEX(LDX,P).
!               X CONTAINS THE OUTPUT OF WQRDC.
!
!        LDX    INTEGER.
!               LDX IS THE LEADING DIMENSION OF THE ARRAY X.
!
!        N      INTEGER.
!               N IS THE NUMBER OF ROWS OF THE MATRIX XK. IT MUST
!               HAVE THE SAME VALUE AS N IN WQRDC.
!
!        K      INTEGER.
!               K IS THE NUMBER OF COLUMNS OF THE MATRIX XK. K
!               MUST NNOT BE GREATER THAN MIN(N,P), WHERE P IS THE
!               SAME AS IN THE CALLING SEQUENCE TO WQRDC.
!
!        QRAUX  DOUBLE-COMPLEX(P).
!               QRAUX CONTAINS THE AUXILIARY OUTPUT FROM WQRDC.
!
!        Y      DOUBLE-COMPLEX(N)
!               Y CONTAINS AN N-VECTOR THAT IS TO BE MANIPULATED
!               BY WQRSL.
!
!        JOB    INTEGER.
!               JOB SPECIFIES WHAT IS TO BE COMPUTED. JOB HAS
!               THE DECIMAL EXPANSION ABCDE, WITH THE FOLLOWING
!               MEANING.
!
! IF A.NE.0, COMPUTE QY.
! IF B,C,D, OR E .NE. 0, COMPUTE QTY.
! IF C.NE.0, COMPUTE B.
! IF D.NE.0, COMPUTE RSD.
! IF E.NE.0, COMPUTE XB.
!
!               NOTE THAT A REQUEST TO COMPUTE B, RSD, OR XB
!               AUTOMATICALLY TRIGGERS THE COMPUTATION OF QTY, FOR
!               WHICH AN ARRAY MUST BE PROVIDED IN THE CALLING
!               SEQUENCE.
!
!     ON RETURN
!
!        QY     DOUBLE-COMPLEX(N).
!               QY CONTAINS Q*Y, IF ITS COMPUTATION HAS BEEN
!               REQUESTED.
!
!        QTY    DOUBLE-COMPLEX(N).
!               QTY CONTAINS CTRANS(Q)*Y, IF ITS COMPUTATION HAS
!               BEEN REQUESTED. HERE CTRANS(Q) IS THE CONJUGATE
!               TRANSPOSE OF THE MATRIX Q.
!
!        B      DOUBLE-COMPLEX(K)
!               B CONTAINS THE SOLUTION OF THE LEAST SQUARES PROBLEM
!
! MINIMIZE NORM2(Y - XK*B),
!
!               IF ITS COMPUTATION HAS BEEN REQUESTED. (NOTE THAT
!               IF PIVOTING WAS REQUESTED IN WQRDC, THE J-TH
!               COMPONENT OF B WILL BE ASSOCIATED WITH COLUMN JPVT(J)
!               OF THE ORIGINAL MATRIX X THAT WAS INPUT INTO WQRDC.)
!
!        RSD    DOUBLE-COMPLEX(N).
!               RSD CONTAINS THE LEAST SQUARES RESIDUAL Y - XK*B,
!               IF ITS COMPUTATION HAS BEEN REQUESTED. RSD IS
!               ALSO THE ORTHOGONAL PROJECTION OF Y ONTO THE
!               ORTHOGONAL COMPLEMENT OF THE COLUMN SPACE OF XK.
!
!        XB     DOUBLE-COMPLEX(N).
!               XB CONTAINS THE LEAST SQUARES APPROXIMATION XK*B,
!               IF ITS COMPUTATION HAS BEEN REQUESTED. XB IS ALSO
!               THE ORTHOGONAL PROJECTION OF Y ONTO THE COLUMN SPACE
!               OF X.
!
!        INFO   INTEGER.
!               INFO IS ZERO UNLESS THE COMPUTATION OF B HAS
!               BEEN REQUESTED AND R IS EXACTLY SINGULAR. IN
!               THIS CASE, INFO IS THE INDEX OF THE FIRST ZERO
!               DIAGONAL ELEMENT OF R AND B IS LEFT UNALTERED.
!
!     THE PARAMETERS QY, QTY, B, RSD, AND XB ARE NOT REFERENCED
!     IF THEIR COMPUTATION IS NOT REQUESTED AND IN THIS CASE
!     CAN BE REPLACED BY DUMMY VARIABLES IN THE CALLING PROGRAM.
!     TO SAVE STORAGE, THE USER MAY IN SOME CASES USE THE SAME
!     ARRAY FOR DIFFERENT PARAMETERS IN THE CALLING SEQUENCE. A
!     FREQUENTLY OCCURRING EXAMPLE IS WHEN ONE WISHES TO COMPUTE
!     ANY OF B, RSD, OR XB AND DOES NOT NEED Y OR QTY. IN THIS
!     CASE ONE MAY IDENTIFY Y, QTY, AND ONE OF B, RSD, OR XB, WHILE
!     PROVIDING SEPARATE ARRAYS FOR ANYTHING ELSE THAT IS TO BE
!     COMPUTED. THUS THE CALLING SEQUENCE
!
!          CALL ML_WQRSL(X,LDX,N,K,QRAUX,Y,DUM,Y,B,Y,DUM,110,INFO)
!
!     WILL RESULT IN THE COMPUTATION OF B AND RSD, WITH RSD
!     OVERWRITING Y. MORE GENERALLY, EACH ITEM IN THE FOLLOWING
!     LIST CONTAINS GROUPS OF PERMISSIBLE IDENTIFICATIONS FOR
!     A SINGLE CALLING SEQUENCE.
!
!          1. (Y,QTY,B) (RSD) (XB) (QY)
!
!          2. (Y,QTY,RSD) (B) (XB) (QY)
!
!          3. (Y,QTY,XB) (B) (RSD) (QY)
!
!          4. (Y,QY) (QTY,B) (RSD) (XB)
!
!          5. (Y,QY) (QTY,RSD) (B) (XB)
!
!          6. (Y,QY) (QTY,XB) (B) (RSD)
!
!     IN ANY GROUP THE VALUE RETURNED IN THE ARRAY ALLOCATED TO
!     THE GROUP CORRESPONDS TO THE LAST MEMBER OF THE GROUP.
!
!     LINPACK. THIS VERSION DATED 07/03/79 .
!     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB.
!
!     ML_WQRSL USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS.
!
!     BLAS matX_waxpy,mat_wcopy,mat_wdotcr,mat_wdotci
!     FORTRAN DABS,DIMAG,MIN0,MOD
!
!     INTERNAL VARIABLES
!
integer          :: i, j, jj, ju, kp1
double precision :: tr, ti, tempr, tempi
logical          :: cb, cqy, cqty, cr, cxb
!
double precision :: zdumr, zdumi
double precision :: cabs1
   cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
!
!     SET INFO FLAG.
!
   info = 0
!
!     DETERMINE WHAT IS TO BE COMPUTED.
!
   cqy = job/10000/=0
   cqty = mod(job,10000)/=0
   cb = mod(job,1000)/100/=0
   cr = mod(job,100)/10/=0
   cxb = mod(job,10)/=0
   ju = min0(k,n-1)
!
!     SPECIAL ACTION WHEN N=1.
!
   if ( ju/=0 ) then
!
!        SET UP TO COMPUTE QY OR QTY.
!
      if ( cqy ) call mat_wcopy(n,yr,yi,1,qyr,qyi,1)
      if ( cqty ) call mat_wcopy(n,yr,yi,1,qtyr,qtyi,1)
      if ( cqy ) then
!
!           COMPUTE QY.
!
         do jj = 1, ju
            j = ju - jj + 1
            if ( cabs1(qrauxr(j),qrauxi(j))==0.0d0 ) cycle
            tempr = xr(j,j)
            tempi = xi(j,j)
            xr(j,j) = qrauxr(j)
            xi(j,j) = qrauxi(j)
            tr = -mat_wdotcr(n-j+1,xr(j,j),xi(j,j),1,qyr(j),qyi(j),1)
            ti = -mat_wdotci(n-j+1,xr(j,j),xi(j,j),1,qyr(j),qyi(j),1)
            call mat_wdiv(tr,ti,xr(j,j),xi(j,j),tr,ti)
            call matx_waxpy(n-j+1,tr,ti,xr(j,j),xi(j,j),1,qyr(j),qyi(j),1)
            xr(j,j) = tempr
            xi(j,j) = tempi
         enddo
      endif
      if ( cqty ) then
!
!           COMPUTE CTRANS(Q)*Y.
!
         do j = 1, ju
            if ( cabs1(qrauxr(j),qrauxi(j))==0.0d0 ) cycle
            tempr = xr(j,j)
            tempi = xi(j,j)
            xr(j,j) = qrauxr(j)
            xi(j,j) = qrauxi(j)
            tr = -mat_wdotcr(n-j+1,xr(j,j),xi(j,j),1,qtyr(j),qtyi(j),1)
            ti = -mat_wdotci(n-j+1,xr(j,j),xi(j,j),1,qtyr(j),qtyi(j),1)
            call mat_wdiv(tr,ti,xr(j,j),xi(j,j),tr,ti)
            call matx_waxpy(n-j+1,tr,ti,xr(j,j),xi(j,j),1,qtyr(j),qtyi(j),1)
            xr(j,j) = tempr
            xi(j,j) = tempi
         enddo
      endif
!
!        SET UP TO COMPUTE B, RSD, OR XB.
!
      if ( cb ) call mat_wcopy(k,qtyr,qtyi,1,br,bi,1)
      kp1 = k + 1
      if ( cxb ) call mat_wcopy(k,qtyr,qtyi,1,xbr,xbi,1)
      if ( cr .and. k<n ) call mat_wcopy(n-k,qtyr(kp1),qtyi(kp1),1,rsdr(kp1),rsdi(kp1),1)
      if ( .not.(.not.cxb .or. kp1>n) ) then
         do i = kp1, n
            xbr(i) = 0.0d0
            xbi(i) = 0.0d0
         enddo
      endif
      if ( cr ) then
         do i = 1, k
            rsdr(i) = 0.0d0
            rsdi(i) = 0.0d0
         enddo
      endif
      if ( cb ) then
!
!           COMPUTE B.
!
         spag_loop_1_1: do jj = 1, k
            j = k - jj + 1
            if ( cabs1(xr(j,j),xi(j,j))/=0.0d0 ) then
               call mat_wdiv(br(j),bi(j),xr(j,j),xi(j,j),br(j),bi(j))
               if ( j/=1 ) then
                  tr = -br(j)
                  ti = -bi(j)
                  call matx_waxpy(j-1,tr,ti,xr(1,j),xi(1,j),1,br,bi,1)
               endif
            else
               info = j
!                 ......EXIT
!           ......EXIT
               exit spag_loop_1_1
            endif
         enddo spag_loop_1_1
      endif
      if ( .not.(.not.cr .and. .not.cxb) ) then
!
!           COMPUTE RSD OR XB AS REQUIRED.
!
         do jj = 1, ju
            j = ju - jj + 1
            if ( cabs1(qrauxr(j),qrauxi(j))==0.0d0 ) cycle
            tempr = xr(j,j)
            tempi = xi(j,j)
            xr(j,j) = qrauxr(j)
            xi(j,j) = qrauxi(j)
            if ( cr ) then
               tr = -mat_wdotcr(n-j+1,xr(j,j),xi(j,j),1,rsdr(j),rsdi(j),1)
               ti = -mat_wdotci(n-j+1,xr(j,j),xi(j,j),1,rsdr(j),rsdi(j),1)
               call mat_wdiv(tr,ti,xr(j,j),xi(j,j),tr,ti)
               call matx_waxpy(n-j+1,tr,ti,xr(j,j),xi(j,j),1,rsdr(j),rsdi(j),1)
            endif
            if ( cxb ) then
               tr = -mat_wdotcr(n-j+1,xr(j,j),xi(j,j),1,xbr(j),xbi(j),1)
               ti = -mat_wdotci(n-j+1,xr(j,j),xi(j,j),1,xbr(j),xbi(j),1)
               call mat_wdiv(tr,ti,xr(j,j),xi(j,j),tr,ti)
               call matx_waxpy(n-j+1,tr,ti,xr(j,j),xi(j,j),1,xbr(j),xbi(j),1)
            endif
            xr(j,j) = tempr
            xi(j,j) = tempi
         enddo
      endif
   else
      if ( cqy ) then
         qyr(1) = yr(1)
         qyi(1) = yi(1)
      endif
      if ( cqty ) then
         qtyr(1) = yr(1)
         qtyi(1) = yi(1)
      endif
      if ( cxb ) then
         xbr(1) = yr(1)
         xbi(1) = yi(1)
      endif
      if ( cb ) then
         if ( cabs1(xr(1,1),xi(1,1))/=0.0d0 ) then
            call mat_wdiv(yr(1),yi(1),xr(1,1),xi(1,1),br(1),bi(1))
         else
            info = 1
         endif
      endif
      if ( cr ) then
         rsdr(1) = 0.0d0
         rsdi(1) = 0.0d0
      endif
   endif
end subroutine ml_wqrsl
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!*==ml_wsvdc.f90 processed by SPAG 8.01RF 01:28 13 Dec 2024
subroutine ml_wsvdc(xr,xi,ldx,n,p,sr,si,er,ei,ur,ui,ldu,vr,vi,ldv,workr,worki,job,info)
use m_la
implicit none
integer          :: ldx, n, p, ldu, ldv, job, info
double precision :: xr(ldx,*), xi(ldx,*), sr(*), si(*), er(*), ei(*), ur(ldu,*), ui(ldu,*), vr(ldv,*), vi(ldv,*), workr(*)&
&, worki(*)
!
!
!     WSVDC IS A SUBROUTINE TO REDUCE A DOUBLE-COMPLEX NXP MATRIX X BY
!     UNITARY TRANSFORMATIONS U AND V TO DIAGONAL FORM. THE
!     DIAGONAL ELEMENTS S(I) ARE THE SINGULAR VALUES OF X. THE
!     COLUMNS OF U ARE THE CORRESPONDING LEFT SINGULAR VECTORS,
!     AND THE COLUMNS OF V THE RIGHT SINGULAR VECTORS.
!
!     ON ENTRY
!
!         X         DOUBLE-COMPLEX(LDX,P), WHERE LDX.GE.N.
!                   X CONTAINS THE MATRIX WHOSE SINGULAR VALUE
!                   DECOMPOSITION IS TO BE COMPUTED. X IS
!                   DESTROYED BY WSVDC.
!
!         LDX       INTEGER.
!                   LDX IS THE LEADING DIMENSION OF THE ARRAY X.
!
!         N         INTEGER.
!                   N IS THE NUMBER OF COLUMNS OF THE MATRIX X.
!
!         P         INTEGER.
!                   P IS THE NUMBER OF ROWS OF THE MATRIX X.
!
!         LDU       INTEGER.
!                   LDU IS THE LEADING DIMENSION OF THE ARRAY U
!                   (SEE BELOW).
!
!         LDV       INTEGER.
!                   LDV IS THE LEADING DIMENSION OF THE ARRAY V
!                   (SEE BELOW).
!
!         WORK      DOUBLE-COMPLEX(N).
!                   WORK IS A SCRATCH ARRAY.
!
!         JOB       INTEGER.
!                   JOB CONTROLS THE COMPUTATION OF THE SINGULAR
!                   VECTORS. IT HAS THE DECIMAL EXPANSION AB
!                   WITH THE FOLLOWING MEANING
!
!     A.EQ.0    DO NOT COMPUTE THE LEFT SINGULAR
!               VECTORS.
!     A.EQ.1    RETURN THE N LEFT SINGULAR VECTORS
!               IN U.
!     A.GE.2    RETURNS THE FIRST MIN(N,P)
!               LEFT SINGULAR VECTORS IN U.
!     B.EQ.0    DO NOT COMPUTE THE RIGHT SINGULAR
!               VECTORS.
!     B.EQ.1    RETURN THE RIGHT SINGULAR VECTORS
!               IN V.
!
!     ON RETURN
!
!         S         DOUBLE-COMPLEX(MM), WHERE MM=MIN(N+1,P).
!                   THE FIRST MIN(N,P) ENTRIES OF S CONTAIN THE
!                   SINGULAR VALUES OF X ARRANGED IN DESCENDING
!                   ORDER OF MAGNITUDE.
!
!         E         DOUBLE-COMPLEX(P).
!                   E ORDINARILY CONTAINS ZEROS. HOWEVER SEE THE
!                   DISCUSSION OF INFO FOR EXCEPTIONS.
!
!         U         DOUBLE-COMPLEX(LDU,K), WHERE LDU.GE.N.
!                   IF JOBA.EQ.1 THEN K.EQ.N,
!                   IF JOBA.EQ.2 THEN K.EQ.MIN(N,P).
!                   U CONTAINS THE MATRIX OF RIGHT SINGULAR VECTORS.
!                   U IS NOT REFERENCED IF JOBA.EQ.0. IF N.LE.P
!                   OR IF JOBA.GT.2, THEN U MAY BE IDENTIFIED WITH X
!                   IN THE SUBROUTINE CALL.
!
!         V         DOUBLE-COMPLEX(LDV,P), WHERE LDV.GE.P.
!                   V CONTAINS THE MATRIX OF RIGHT SINGULAR VECTORS.
!                   V IS NOT REFERENCED IF JOBB.EQ.0. IF P.LE.N,
!                   THEN V MAY BE IDENTIFIED WITH X IN THE
!                   SUBROUTINE ML_CALL.
!
!         INFO      INTEGER.
!                   THE SINGULAR VALUES (AND THEIR CORRESPONDING
!                   SINGULAR VECTORS) S(INFO+1),S(INFO+2),...,S(M)
!                   ARE CORRECT (HERE M=MIN(N,P)). THUS IF
!                   INFO.EQ.0, ALL THE SINGULAR VALUES AND THEIR
!                   VECTORS ARE CORRECT. IN ANY EVENT, THE MATRIX
!                   B = CTRANS(U)*X*V IS THE BIDIAGONAL MATRIX
!                   WITH THE ELEMENTS OF S ON ITS DIAGONAL AND THE
!                   ELEMENTS OF E ON ITS SUPER-DIAGONAL (CTRANS(U)
!                   IS THE CONJUGATE-TRANSPOSE OF U). THUS THE
!                   SINGULAR VALUES OF X AND B ARE THE SAME.
!
!     LINPACK. THIS VERSION DATED 07/03/79 .
!     G.W. STEWART, UNIVERSITY OF MARYLAND, ARGONNE NATIONAL LAB.
!
!     WSVDC USES THE FOLLOWING FUNCTIONS AND SUBPROGRAMS.
!
!     BLAS    matX_waxpy,mat_pythag,mat_wdotcr,mat_wdotci,mat_wscal,mat_wswap,
!             mat_rrotg,mat_wnrm2
!     FORTRAN DABS,DIMAG,DMAX1
!     FORTRAN MAX0,MIN0,MOD,DSQRT
!
!     INTERNAL VARIABLES
!
integer :: i, iter, j, jobu, k, kase, kk, l, ll, lls, lm1, lp1, ls, lu, m, maxit, mm, mm1, mp1, nct, nctp1,    &
& ncu, nrt, nrtp1
double precision :: tr, ti, rr, ri
double precision :: b, c, cs, el, emm1, f, g, scale, shift, sl, sm, sn, smm1, t1, test, ztest, small
logical :: wantu, wantv
!
double precision :: zdumr, zdumi
double precision :: cabs1
cabs1(zdumr,zdumi) = dabs(zdumr) + dabs(zdumi)
integer :: spag_nextblock_1
!
!     SET THE MAXIMUM NUMBER OF ITERATIONS.
!
   maxit = 75
!
!     SMALL NUMBER, ROUGHLY MACHINE EPSILON, USED TO AVOID UNDERFLOW
!
   small = 1.d0/2.d0**48
!
!     DETERMINE WHAT IS TO BE COMPUTED.
!
   wantu = .false.
   wantv = .false.
   jobu = mod(job,100)/10
   ncu = n
   if ( jobu>1 ) ncu = min0(n,p)
   if ( jobu/=0 ) wantu = .true.
   if ( mod(job,10)/=0 ) wantv = .true.
!
!     REDUCE X TO BIDIAGONAL FORM, STORING THE DIAGONAL ELEMENTS
!     IN S AND THE SUPER-DIAGONAL ELEMENTS IN E.
!
   info = 0
   nct = min0(n-1,p)
   nrt = max0(0,min0(p-2,n))
   lu = max0(nct,nrt)
   if ( lu>=1 ) then
      do l = 1, lu
         lp1 = l + 1
         if ( l<=nct ) then
!
!           COMPUTE THE TRANSFORMATION FOR THE L-TH COLUMN AND
!           PLACE THE L-TH DIAGONAL IN S(L).
!
            sr(l) = mat_wnrm2(n-l+1,xr(l,l),xi(l,l),1)
            si(l) = 0.0d0
            if ( cabs1(sr(l),si(l))/=0.0d0 ) then
               if ( cabs1(xr(l,l),xi(l,l))/=0.0d0 ) call mat_wsign(sr(l),si(l),xr(l,l),xi(l,l),sr(l),si(l))
               call mat_wdiv(1.0d0,0.0d0,sr(l),si(l),tr,ti)
               call mat_wscal(n-l+1,tr,ti,xr(l,l),xi(l,l),1)
               xr(l,l) = mat_flop(1.0d0+xr(l,l))
            endif
            sr(l) = -sr(l)
            si(l) = -si(l)
         endif
         if ( p>=lp1 ) then
            do j = lp1, p
               if ( l<=nct ) then
                  if ( cabs1(sr(l),si(l))/=0.0d0 ) then
!
!              APPLY THE TRANSFORMATION.
!
                     tr = -mat_wdotcr(n-l+1,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                     ti = -mat_wdotci(n-l+1,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                     call mat_wdiv(tr,ti,xr(l,l),xi(l,l),tr,ti)
                     call matx_waxpy(n-l+1,tr,ti,xr(l,l),xi(l,l),1,xr(l,j),xi(l,j),1)
                  endif
               endif
!
!           PLACE THE L-TH ROW OF X INTO  E FOR THE
!           SUBSEQUENT CALCULATION OF THE ROW TRANSFORMATION.
!
               er(j) = xr(l,j)
               ei(j) = -xi(l,j)
            enddo
         endif
         if ( .not.(.not.wantu .or. l>nct) ) then
!
!           PLACE THE TRANSFORMATION IN U FOR SUBSEQUENT BACK
!           MULTIPLICATION.
!
            do i = l, n
               ur(i,l) = xr(i,l)
               ui(i,l) = xi(i,l)
            enddo
         endif
         if ( l<=nrt ) then
!
!           COMPUTE THE L-TH ROW TRANSFORMATION AND PLACE THE
!           L-TH SUPER-DIAGONAL IN E(L).
!
            er(l) = mat_wnrm2(p-l,er(lp1),ei(lp1),1)
            ei(l) = 0.0d0
            if ( cabs1(er(l),ei(l))/=0.0d0 ) then
               if ( cabs1(er(lp1),ei(lp1))/=0.0d0 ) call mat_wsign(er(l),ei(l),er(lp1),ei(lp1),er(l),ei(l))
               call mat_wdiv(1.0d0,0.0d0,er(l),ei(l),tr,ti)
               call mat_wscal(p-l,tr,ti,er(lp1),ei(lp1),1)
               er(lp1) = mat_flop(1.0d0+er(lp1))
            endif
            er(l) = -er(l)
            ei(l) = +ei(l)
            if ( lp1<=n .and. cabs1(er(l),ei(l))/=0.0d0 ) then
!
!              APPLY THE TRANSFORMATION.
!
               do i = lp1, n
                  workr(i) = 0.0d0
                  worki(i) = 0.0d0
               enddo
               do j = lp1, p
                  call matx_waxpy(n-l,er(j),ei(j),xr(lp1,j),xi(lp1,j),1,workr(lp1),worki(lp1),1)
               enddo
               do j = lp1, p
                  call mat_wdiv(-er(j),-ei(j),er(lp1),ei(lp1),tr,ti)
                  call matx_waxpy(n-l,tr,-ti,workr(lp1),worki(lp1),1,xr(lp1,j),xi(lp1,j),1)
               enddo
            endif
            if ( wantv ) then
!
!              PLACE THE TRANSFORMATION IN V FOR SUBSEQUENT
!              BACK MULTIPLICATION.
!
               do i = lp1, p
                  vr(i,l) = er(i)
                  vi(i,l) = ei(i)
               enddo
            endif
         endif
      enddo
   endif
!
!     SET UP THE FINAL BIDIAGONAL MATRIX OR ORDER M.
!
   m = min0(p,n+1)
   nctp1 = nct + 1
   nrtp1 = nrt + 1
   if ( nct<p ) then
      sr(nctp1) = xr(nctp1,nctp1)
      si(nctp1) = xi(nctp1,nctp1)
   endif
   if ( n<m ) then
      sr(m) = 0.0d0
      si(m) = 0.0d0
   endif
   if ( nrtp1<m ) then
      er(nrtp1) = xr(nrtp1,m)
      ei(nrtp1) = xi(nrtp1,m)
   endif
   er(m) = 0.0d0
   ei(m) = 0.0d0
!
!     IF REQUIRED, GENERATE U.
!
   if ( wantu ) then
      if ( ncu>=nctp1 ) then
         do j = nctp1, ncu
            do i = 1, n
               ur(i,j) = 0.0d0
               ui(i,j) = 0.0d0
            enddo
            ur(j,j) = 1.0d0
            ui(j,j) = 0.0d0
         enddo
      endif
      if ( nct>=1 ) then
         do ll = 1, nct
            l = nct - ll + 1
            if ( cabs1(sr(l),si(l))==0.0d0 ) then
               do i = 1, n
                  ur(i,l) = 0.0d0
                  ui(i,l) = 0.0d0
               enddo
               ur(l,l) = 1.0d0
               ui(l,l) = 0.0d0
            else
               lp1 = l + 1
               if ( ncu>=lp1 ) then
                  do j = lp1, ncu
                     tr = -mat_wdotcr(n-l+1,ur(l,l),ui(l,l),1,ur(l,j),ui(l,j),1)
                     ti = -mat_wdotci(n-l+1,ur(l,l),ui(l,l),1,ur(l,j),ui(l,j),1)
                     call mat_wdiv(tr,ti,ur(l,l),ui(l,l),tr,ti)
                     call matx_waxpy(n-l+1,tr,ti,ur(l,l),ui(l,l),1,ur(l,j),ui(l,j),1)
                  enddo
               endif
               call mat_wrscal(n-l+1,-1.0d0,ur(l,l),ui(l,l),1)
               ur(l,l) = mat_flop(1.0d0+ur(l,l))
               lm1 = l - 1
               if ( lm1>=1 ) then
                  do i = 1, lm1
                     ur(i,l) = 0.0d0
                     ui(i,l) = 0.0d0
                  enddo
               endif
            endif
         enddo
      endif
   endif
!
!     IF IT IS REQUIRED, GENERATE V.
!
   if ( wantv ) then
      do ll = 1, p
         l = p - ll + 1
         lp1 = l + 1
         if ( l<=nrt ) then
            if ( cabs1(er(l),ei(l))/=0.0d0 ) then
               do j = lp1, p
                  tr = -mat_wdotcr(p-l,vr(lp1,l),vi(lp1,l),1,vr(lp1,j),vi(lp1,j),1)
                  ti = -mat_wdotci(p-l,vr(lp1,l),vi(lp1,l),1,vr(lp1,j),vi(lp1,j),1)
                  call mat_wdiv(tr,ti,vr(lp1,l),vi(lp1,l),tr,ti)
                  call matx_waxpy(p-l,tr,ti,vr(lp1,l),vi(lp1,l),1,vr(lp1,j),vi(lp1,j),1)
               enddo
            endif
         endif
         do i = 1, p
            vr(i,l) = 0.0d0
            vi(i,l) = 0.0d0
         enddo
         vr(l,l) = 1.0d0
         vi(l,l) = 0.0d0
      enddo
   endif
!
!     TRANSFORM S AND E SO THAT THEY ARE REAL.
!
   spag_loop_1_1: do i = 1, m
      tr = mat_pythag(sr(i),si(i))
      if ( tr/=0.0d0 ) then
         rr = sr(i)/tr
         ri = si(i)/tr
         sr(i) = tr
         si(i) = 0.0d0
         if ( i<m ) call mat_wdiv(er(i),ei(i),rr,ri,er(i),ei(i))
         if ( wantu ) call mat_wscal(n,rr,ri,ur(1,i),ui(1,i),1)
      endif
!     ...EXIT
      if ( i==m ) exit spag_loop_1_1
      tr = mat_pythag(er(i),ei(i))
      if ( tr/=0.0d0 ) then
         call mat_wdiv(tr,0.0d0,er(i),ei(i),rr,ri)
         er(i) = tr
         ei(i) = 0.0d0
         call mat_wmul(sr(i+1),si(i+1),rr,ri,sr(i+1),si(i+1))
         if ( wantv ) call mat_wscal(p,rr,ri,vr(1,i+1),vi(1,i+1),1)
      endif
   enddo spag_loop_1_1
!
!     MAIN ITERATION LOOP FOR THE SINGULAR VALUES.
!
   mm = m
   iter = 0
!
!        QUIT IF ALL THE SINGULAR VALUES HAVE BEEN FOUND.
!
!     ...EXIT
   spag_loop_1_5: do while ( m/=0 )
      spag_nextblock_1 = 1
      spag_dispatchloop_1: do
         select case (spag_nextblock_1)
          case (1)
!
!        IF TOO MANY ITERATIONS HAVE BEEN PERFORMED, SET
!        FLAG AND RETURN.
!
            if ( iter<maxit ) then
!
!        THIS SECTION OF THE PROGRAM INSPECTS FOR
!        NEGLIGIBLE ELEMENTS IN THE S AND E ARRAYS. ON
!        COMPLETION THE VARIABLE KASE IS SET AS FOLLOWS.
!
!           KASE = 1     IF SR(M) AND ER(L-1) ARE NEGLIGIBLE AND L.LT.M
!           KASE = 2     IF SR(L) IS NEGLIGIBLE AND L.LT.M
!           KASE = 3     IF ER(L-1) IS NEGLIGIBLE, L.LT.M, AND
!     SR(L), ..., SR(M) ARE NOT NEGLIGIBLE (QR STEP).
!           KASE = 4     IF ER(M-1) IS NEGLIGIBLE (CONVERGENCE).
!
               spag_loop_2_2: do ll = 1, m
                  l = m - ll
!        ...EXIT
                  if ( l==0 ) exit spag_loop_2_2
                  test = mat_flop(dabs(sr(l))+dabs(sr(l+1)))
                  ztest = mat_flop(test+dabs(er(l))/2.0d0)
                  if ( small*ztest==small*test ) then
                     er(l) = 0.0d0
!        ......EXIT
                     exit spag_loop_2_2
                  endif
               enddo spag_loop_2_2
               if ( l/=m-1 ) then
                  lp1 = l + 1
                  mp1 = m + 1
                  spag_loop_2_3: do lls = lp1, mp1
                     ls = m - lls + lp1
!           ...EXIT
                     if ( ls==l ) exit spag_loop_2_3
                     test = 0.0d0
                     if ( ls/=m ) test = mat_flop(test+dabs(er(ls)))
                     if ( ls/=l+1 ) test = mat_flop(test+dabs(er(ls-1)))
                     ztest = mat_flop(test+dabs(sr(ls))/2.0d0)
                     if ( small*ztest==small*test ) then
                        sr(ls) = 0.0d0
!           ......EXIT
                        exit spag_loop_2_3
                     endif
                  enddo spag_loop_2_3
                  if ( ls==l ) then
                     kase = 3
                  elseif ( ls/=m ) then
                     kase = 2
                     l = ls
                  else
                     kase = 1
                  endif
               else
                  kase = 4
               endif
               l = l + 1
!
!        PERFORM THE TASK INDICATED BY KASE.
!
               if ( kase==2 ) then
!
!        SPLIT AT NEGLIGIBLE SR(L).
!
                  f = er(l-1)
                  er(l-1) = 0.0d0
                  do k = l, m
                     t1 = sr(k)
                     call mat_rrotg(t1,f,cs,sn)
                     sr(k) = t1
                     f = mat_flop(-(sn*er(k)))
                     er(k) = mat_flop(cs*er(k))
                     if ( wantu ) call mat_rrot(n,ur(1,k),1,ur(1,l-1),1,cs,sn)
                     if ( wantu ) call mat_rrot(n,ui(1,k),1,ui(1,l-1),1,cs,sn)
                  enddo
               elseif ( kase==3 ) then
!
!        PERFORM ONE QR STEP.
!
!
!           CALCULATE THE SHIFT.
!
                  scale = dmax1(dabs(sr(m)),dabs(sr(m-1)),dabs(er(m-1)),dabs(sr(l)),dabs(er(l)))
                  sm = sr(m)/scale
                  smm1 = sr(m-1)/scale
                  emm1 = er(m-1)/scale
                  sl = sr(l)/scale
                  el = er(l)/scale
                  b = mat_flop(((smm1+sm)*(smm1-sm)+emm1**2)/2.0d0)
                  c = mat_flop((sm*emm1)**2)
                  shift = 0.0d0
                  if ( b/=0.0d0 .or. c/=0.0d0 ) then
                     shift = mat_flop(dsqrt(b**2+c))
                     if ( b<0.0d0 ) shift = -shift
                     shift = mat_flop(c/(b+shift))
                  endif
                  f = mat_flop((sl+sm)*(sl-sm)-shift)
                  g = mat_flop(sl*el)
!
!           CHASE ZEROS.
!
                  mm1 = m - 1
                  do k = l, mm1
                     call mat_rrotg(f,g,cs,sn)
                     if ( k/=l ) er(k-1) = f
                     f = mat_flop(cs*sr(k)+sn*er(k))
                     er(k) = mat_flop(cs*er(k)-sn*sr(k))
                     g = mat_flop(sn*sr(k+1))
                     sr(k+1) = mat_flop(cs*sr(k+1))
                     if ( wantv ) call mat_rrot(p,vr(1,k),1,vr(1,k+1),1,cs,sn)
                     if ( wantv ) call mat_rrot(p,vi(1,k),1,vi(1,k+1),1,cs,sn)
                     call mat_rrotg(f,g,cs,sn)
                     sr(k) = f
                     f = mat_flop(cs*er(k)+sn*sr(k+1))
                     sr(k+1) = mat_flop(-(sn*er(k))+cs*sr(k+1))
                     g = mat_flop(sn*er(k+1))
                     er(k+1) = mat_flop(cs*er(k+1))
                     if ( wantu .and. k<n ) call mat_rrot(n,ur(1,k),1,ur(1,k+1),1,cs,sn)
                     if ( wantu .and. k<n ) call mat_rrot(n,ui(1,k),1,ui(1,k+1),1,cs,sn)
                  enddo
                  er(m-1) = f
                  iter = iter + 1
               elseif ( kase==4 ) then
!
!        CONVERGENCE
!
!
!           MAKE THE SINGULAR VALUE  POSITIVE
!
                  if ( sr(l)<0.0d0 ) then
                     sr(l) = -sr(l)
                     if ( wantv ) call mat_wrscal(p,-1.0d0,vr(1,l),vi(1,l),1)
                  endif
!
!           ORDER THE SINGULAR VALUE.
!
                  spag_loop_2_4: do while ( l/=mm )
!           ...EXIT
                     if ( sr(l)>=sr(l+1) ) exit spag_loop_2_4
                     tr = sr(l)
                     sr(l) = sr(l+1)
                     sr(l+1) = tr
                     if ( wantv .and. l<p ) call mat_wswap(p,vr(1,l),vi(1,l),1,vr(1,l+1),vi(1,l+1),1)
                     if ( wantu .and. l<n ) call mat_wswap(n,ur(1,l),ui(1,l),1,ur(1,l+1),ui(1,l+1),1)
                     l = l + 1
                  enddo spag_loop_2_4
                  spag_nextblock_1 = 2
                  cycle spag_dispatchloop_1
               else
!
!        DEFLATE NEGLIGIBLE SR(M).
!
                  mm1 = m - 1
                  f = er(m-1)
                  er(m-1) = 0.0d0
                  do kk = l, mm1
                     k = mm1 - kk + l
                     t1 = sr(k)
                     call mat_rrotg(t1,f,cs,sn)
                     sr(k) = t1
                     if ( k/=l ) then
                        f = mat_flop(-(sn*er(k-1)))
                        er(k-1) = mat_flop(cs*er(k-1))
                     endif
                     if ( wantv ) call mat_rrot(p,vr(1,k),1,vr(1,m),1,cs,sn)
                     if ( wantv ) call mat_rrot(p,vi(1,k),1,vi(1,m),1,cs,sn)
                  enddo
               endif
               cycle
            else
               info = m
!     ......EXIT
               exit spag_loop_1_5
            endif
          case (2)
            iter = 0
            m = m - 1
            exit spag_dispatchloop_1
         end select
      enddo spag_dispatchloop_1
   enddo spag_loop_1_5
end subroutine ml_wsvdc
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!

!>>>>> build/dependencies/M_intrinsics/src/M_intrinsics.f90
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
module M_intrinsics
implicit none
private
public help_intrinsics
!interface help_intrinsics
!   module procedure help_intrinsics_all
!   module procedure help_intrinsics_one
!end interface help_intrinsics
contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)                       :: name
logical,intent(in),optional                       :: prefix
logical,intent(in),optional                       :: topic
logical,intent(in),optional                       :: m_help
character(len=256),allocatable                    :: textblock(:)
character(len=256),allocatable                    :: narrow(:)
character(len=256)                                :: header
character(len=:),allocatable                      :: a, b, c
integer                                           :: i, j, k, p, pg
   select case(name)
   case('','manual','intrinsics','fortranmanual','fortran_manual')
      textblock=help_intrinsics_all(prefix,topic,m_help)
   case('fortran','toc','toc3','toc5','toc7')
      textblock=help_intrinsics_section()
      do i=1,size(textblock)
         p = index(textblock(i), '[')
         pg = index(textblock(i), ']')
         if(p.gt.0.and.pg.gt.p)then
          a=textblock(i)(:p-1)
          b=textblock(i)(p:pg)
          c=textblock(i)(pg+1:)
          textblock(i)=b//' '//a//c
         endif
      enddo
      call sort_name(textblock)
      allocate(narrow(0))
      header=''
      do i=1,size(textblock)
       j=index(textblock(i),']')
       select case(name)
       case('toc3')
          if(index(textblock(i),'(3)').eq.0)cycle
       case('toc5')
          if(index(textblock(i),'(5)').eq.0)cycle
       case('toc7')
          k=0
          k=max(k,index(textblock(i),'(7)'))
          k=max(k,index(textblock(i),'(7f)'))
          if(k==0)cycle
       end select
       if (textblock(i)(:j).ne.header)then
          header=textblock(i)(:j)
          narrow=[character(len=256) :: narrow,header]
       endif
       textblock(i)=textblock(i)(j+1:)
       narrow=[character(len=256) :: narrow,'     '//paragraph(textblock(i),70)]
      enddo
      textblock=narrow
   case default
      textblock=help_intrinsics_one(name,prefix,topic,m_help)
   end select
end function help_intrinsics
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function paragraph(source_string,length)

!$@(#) M_strings::paragraph(3f): wrap a long string into a paragraph

character(len=*),intent(in)       :: source_string
integer,intent(in)                :: length
integer                           :: itoken
integer                           :: ibegin
integer                           :: iend
character(len=*),parameter        :: delimiters=' '
character(len=:),allocatable      :: paragraph(:)
integer                           :: ilines
integer                           :: ilength
integer                           :: iword, iword_max
integer                           :: i
!-----------------------------------------------------------------------------------------------------------------------------------
!  parse string once to find out how big to make the returned array, then redo everything but store the data
!  could store array of endpoints and leave original whitespace alone or many other options
   do i=1,2
      iword_max=0                                  ! length of longest token
      ilines=1                                     ! number of output line output will go on
      ilength=0                                    ! length of output line so far
      itoken=0                                     ! must set ITOKEN=0 before looping on strtok(3f) on a new string.
      do while ( strtok(source_string,itoken,ibegin,iend,delimiters) )
         iword=iend-ibegin+1
         iword_max=max(iword_max,iword)
         if(iword > length)then                   ! this token is longer than the desired line length so put it on a line by itself
            if(ilength /= 0)then
               ilines=ilines+1
            endif
            if(i == 2)then     ! if paragraph has been allocated store data, else just gathering data to determine size of paragraph
               paragraph(ilines)=source_string(ibegin:iend)//' '
            endif
            ilength=iword+1
         elseif(ilength+iword <= length)then       ! this word will fit on current line
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=ilength+iword+1
         else                                      ! adding this word would make line too long so start new line
            ilines=ilines+1
            ilength=0
            if(i == 2)then
               paragraph(ilines)=paragraph(ilines)(:ilength)//source_string(ibegin:iend)
            endif
            ilength=iword+1
         endif
      enddo
      if(i==1)then                                 ! determined number of lines needed so allocate output array
         allocate(character(len=max(length,iword_max)) :: paragraph(ilines))
         paragraph=' '
      endif
   enddo
   paragraph=paragraph(:ilines)
end function paragraph
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
FUNCTION strtok(source_string,itoken,token_start,token_end,delimiters) result(strtok_status)
! JSU- 20151030

!$@(#) M_strings::strtok(3f): Tokenize a string

character(len=*),intent(in)  :: source_string    ! Source string to tokenize.
character(len=*),intent(in)  :: delimiters       ! list of separator characters. May change between calls
integer,intent(inout)        :: itoken           ! token count since started
logical                      :: strtok_status    ! returned value
integer,intent(out)          :: token_start      ! beginning of token found if function result is .true.
integer,intent(inout)        :: token_end        ! end of token found if function result is .true.
integer,save                 :: isource_len
!----------------------------------------------------------------------------------------------------------------------------
!  calculate where token_start should start for this pass
   if(itoken <= 0)then                           ! this is assumed to be the first call
      token_start=1
   else                                          ! increment start to previous end + 1
      token_start=token_end+1
   endif
!----------------------------------------------------------------------------------------------------------------------------
   isource_len=len(source_string)                ! length of input string
!----------------------------------------------------------------------------------------------------------------------------
   if(token_start > isource_len)then            ! user input error or at end of string
      token_end=isource_len                      ! assume end of token is end of string until proven otherwise so it is set
      strtok_status=.false.
      return
   endif
!----------------------------------------------------------------------------------------------------------------------------
   ! find beginning of token
   do while (token_start  <=  isource_len)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_start:token_start))  /=  0) then
         token_start = token_start + 1
      else
         exit
      endif
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   token_end=token_start
   do while (token_end  <=  isource_len-1)       ! step thru each character to find next delimiter, if any
      if(index(delimiters,source_string(token_end+1:token_end+1))  /=  0) then  ! found a delimiter in next character
         exit
      endif
      token_end = token_end + 1
   enddo
!----------------------------------------------------------------------------------------------------------------------------
   if (token_start  >  isource_len) then        ! determine if finished
      strtok_status=.false.                      ! flag that input string has been completely processed
   else
      itoken=itoken+1                            ! increment count of tokens found
      strtok_status=.true.                       ! flag more tokens may remain
   endif
!----------------------------------------------------------------------------------------------------------------------------
end function strtok
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_section() result (textblock)

!@(#) grab lines in NAME section and append them to generate an index of manpages

character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: add(:)
character(len=256),allocatable  :: label
character(len=10)               :: cnum
integer                         :: i
integer                         :: icount
logical                         :: is_label
logical                         :: grab
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum) ! get a document by number
      if( size(add) .eq. 0 ) exit
      label=''
      grab=.false.
      is_label=.false.
      ! look for NAME then append everything together till a line starting in column 1 that is all uppercase letters
      ! and assume that is the beginning of the next section to extract the NAME section as one line
      do i=1,size(add)
         if(add(i).eq.'')cycle
            is_label=verify(trim(add(i)),'ABCDEFGHIJKLMNOPQRSTUVWXYZ _') == 0
         if(is_label.and.add(i).eq.'NAME')then
            grab=.true.
         elseif(is_label)then
            exit
         elseif(grab)then
            label=adjustl(trim(label))//' '//adjustl(trim(add(i)))
         endif
      enddo
      textblock=[character(len=256) :: textblock,label]
      icount=icount + 1
   enddo
end function help_intrinsics_section
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_all(prefix,topic,m_help) result (textblock)
logical,intent(in),optional     :: prefix
logical,intent(in),optional     :: topic
logical,intent(in),optional     :: m_help
character(len=256),allocatable  :: textblock(:)
character(len=256),allocatable  :: header(:)
character(len=256),allocatable  :: add(:)
character(len=10)               :: cnum
integer                         :: icount
   allocate(textblock(0))
   icount=1
   do
      write(cnum,'(i0)') icount
      add=help_intrinsics_one(cnum,prefix,topic,m_help)
      if( size(add) .eq. 0 ) exit
      textblock=[character(len=256) :: textblock,add]
      icount=icount + 1
   enddo
   if(present(m_help))then
      if(m_help)then
         header=[ character(len=256) :: &
         '================================================================================',    &
         'SUMMARY',    &
         ' The primary Fortran topics are',    &
         ' abs                   achar                     acos',    &
         ' acosh                 adjustl                   adjustr',    &
         ' aimag                 aint                      all',    &
         ' allocated             anint                     any',    &
         ' asin                  asinh                     associated',    &
         ' atan                  atan2                     atanh',    &
         ' atomic_add            atomic_and                atomic_cas',    &
         ' atomic_define         atomic_fetch_add          atomic_fetch_and',    &
         ' atomic_fetch_or       atomic_fetch_xor          atomic_or',    &
         ' atomic_ref            atomic_xor                backspace',    &
         ' bessel_j0             bessel_j1                 bessel_jn',    &
         ' bessel_y0             bessel_y1                 bessel_yn',    &
         ' bge                   bgt                       bit_size',    &
         ' ble                   block                     blt',    &
         ' btest                 c_associated              ceiling',    &
         ' c_f_pointer           c_f_procpointer           c_funloc',    &
         ' char                  c_loc                     close',    &
         ' cmplx                 co_broadcast              co_lbound',    &
         ' co_max                co_min                    command_argument_count',    &
         ' compiler_options      compiler_version          conjg',    &
         ' continue              co_reduce                 cos',    &
         ' cosh                  co_sum                    co_ubound',    &
         ' count                 cpu_time                  cshift',    &
         ' c_sizeof              date_and_time             dble',    &
         ' digits                dim                       dot_product',    &
         ' dprod                 dshiftl                   dshiftr',    &
         ' eoshift               epsilon                   erf',    &
         ' erfc                  erfc_scaled               event_query',    &
         ' execute_command_line  exit                      exp',    &
         ' exponent              extends_type_of           findloc',    &
         ' float                 floor                     flush',    &
         ' fraction              gamma                     get_command',    &
         ' get_command_argument  get_environment_variable  huge',    &
         ' hypot                 iachar                    iall',    &
         ' iand                  iany                      ibclr',    &
         ' ibits                 ibset                     ichar',    &
         ' ieor                  image_index               include',    &
         ' index                 int                       ior',    &
         ' iparity               is_contiguous             ishft',    &
         ' ishftc                is_iostat_end             is_iostat_eor',    &
         ' kind                  lbound                    leadz',    &
         ' len                   len_trim                  lge',    &
         ' lgt                   lle                       llt',    &
         ' log                   log10                     log_gamma',    &
         ' logical               maskl                     maskr',    &
         ' matmul                max                       maxexponent',    &
         ' maxloc                maxval                    merge',    &
         ' merge_bits            min                       minexponent',    &
         ' minloc                minval                    mod',    &
         ' modulo                move_alloc                mvbits',    &
         ' nearest               new_line                  nint',    &
         ' norm2                 not                       null',    &
         ' num_images            pack                      parity',    &
         ' popcnt                poppar                    precision',    &
         ' present               product                   radix',    &
         ' random_number         random_seed               range',    &
         ' rank                  real                      repeat',    &
         ' reshape               return                    rewind',    &
         ' rrspacing             same_type_as              scale',    &
         ' scan                  selected_char_kind        selected_int_kind',    &
         ' selected_real_kind    set_exponent              shape',    &
         ' shifta                shiftl                    shiftr',    &
         ' sign                  sin                       sinh',    &
         ' size                  sngl                      spacing',    &
         ' spread                sqrt                      stop',    &
         ' storage_size          sum                       system_clock',    &
         ' tan                   tanh                      this_image',    &
         ' tiny                  trailz                    transfer',    &
         ' transpose             trim                      ubound',    &
         ' unpack                verify',    &
         '']
         textblock=[header,textblock]
      endif
   endif
end function help_intrinsics_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function help_intrinsics_one(name,prefix,topic,m_help) result (textblock)
character(len=*),intent(in)      :: name
logical,intent(in),optional      :: prefix
logical,intent(in),optional      :: m_help
logical,intent(in),optional      :: topic
character(len=256),allocatable   :: textblock(:)
character(len=:),allocatable     :: shortname
integer                          :: i
select case(name)

case('1','abs')

textblock=[character(len=256) :: &
'', &
'abs(3fortran)                                                   abs(3fortran)', &
'', &
'NAME', &
'  ABS(3) - [NUMERIC] Absolute value', &
'', &
'SYNOPSIS', &
'  result = abs(a)', &
'', &
'          elemental TYPE(kind=KIND) function abs(a)', &
'', &
'           TYPE(kind=KIND),intent(in) :: a', &
'', &
'CHARACTERISTICS', &
'  o  A may be any real, integer, or complex value.', &
'', &
'  o  If A is complex the returned value will be a real with the same kind as', &
'     A.', &
'', &
'     Otherwise the returned type and kind is the same as for A.', &
'', &
'DESCRIPTION', &
'  ABS(3) computes the absolute value of numeric argument A.', &
'', &
'  In mathematics, the absolute value or modulus of a real number X, denoted', &
'  |X|, is the magnitude of X without regard to its sign.', &
'', &
'  The absolute value of a number may be thought of as its distance from zero.', &
'  So for a complex value the absolute value is a real number with magnitude', &
'  SQRT(X%RE**2,X%IM**2), as if the real component is the x value and the', &
'  imaginary value is the y value for the point <x,y>.', &
'', &
'OPTIONS', &
'  o  A : The value to compute the absolute value of.', &
'', &
'RESULT', &
'  If A is of type integer or real, the value of the result is the absolute', &
'  value |A| and of the same type and kind as the input argument.', &
'', &
'  If A is complex with value (X, Y), the result is a real equal to a', &
'  processor-dependent approximation to', &
'', &
'             sqrt(x**2 + y**2)', &
'', &
'  computed without undue overflow or underflow (that means the computation of', &
'  the result can overflow the allowed magnitude of the real value returned,', &
'  and that very small values can produce underflows if they are squared while', &
'  calculating the returned value, for example).', &
'', &
'  That is, if you think of non-complex values as being complex values on the', &
'  x-axis and complex values as being x-y points <x%re,x%im> the result of', &
'  ABS(3) is the (positive) magnitude of the distance of the value from the', &
'  origin.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_abs', &
'        implicit none', &
'        integer,parameter :: dp=kind(0.0d0)', &
'', &
'      ! some values to use with ABS(3)', &
'        integer           :: i = -1', &
'        real              :: x = -1.0', &
'        complex           :: z = (-3.0,-4.0)', &
'        doubleprecision   :: rr = -45.78_dp', &
'', &
'      ! some formats for pretty-printing some information', &
'        character(len=*),parameter :: &', &
'           frmt  =  ''(1x,a15,1x," In: ",g0,           T51," Out: ",g0)'', &', &
'           frmtc = ''(1x,a15,1x," In: (",g0,",",g0,")",T51," Out: ",g0)'',  &', &
'           gen   = ''(*(g0,1x))''', &
'', &
'        ! the basics', &
'        print gen,  ''basic usage:''', &
'        ! any integer, real, or complex type', &
'        write(*, frmt)  ''integer        '',  i, abs(i)', &
'        write(*, frmt)  ''real           '',  x, abs(x)', &
'        write(*, frmt)  ''doubleprecision '', rr, abs(rr)', &
'        write(*, frmtc) ''complex        '',  z, abs(z)', &
'', &
'        ! elemental', &
'        print gen, ''abs is elemental:'', abs([20,  0,  -1,  -3,  100])', &
'', &
'        ! the returned value for complex input can be thought of as the', &
'        ! distance from the origin <0,0>', &
'        print gen, ''distance of ('', z, '') from zero is'', abs( z )', &
'', &
'        call DUSTY_CORNERS_1("beware of abs(-huge(0)-1)")', &
'        call DUSTY_CORNERS_2("beware of losing precision using CMPLX(3)")', &
'        call DUSTY_CORNERS_3("beware of overflow of complex values")', &
'        call DUSTY_CORNERS_4("custom meaning for absolute value of COMPLEX")', &
'', &
'      contains', &
'', &
'        subroutine DUSTY_CORNERS_1(message)', &
'        character(len=*),intent(in) :: message', &
'', &
'          ! A dusty corner is that abs(-huge(0)-1) of an integer would be', &
'          ! a representable negative value on most machines but result in a', &
'          ! positive value out of range.', &
'', &
'          print gen,  message', &
'          ! By definition:', &
'          !   You can take the absolute value of any value whose POSITIVE value', &
'          !   is representable with the same type and kind.', &
'', &
'          print gen, ''abs range test : '', abs(huge(0)), abs(-huge(0))', &
'          print gen, ''abs range test : '', abs(huge(0.0)), abs(-huge(0.0))', &
'          print gen, ''abs range test : '', abs(tiny(0.0)), abs(-tiny(0.0))', &
'', &
'        end subroutine DUSTY_CORNERS_1', &
'', &
'        subroutine DUSTY_CORNERS_2(message)', &
'        character(len=*),intent(in) :: message', &
'', &
'          ! dusty corner: "kind=dp" is required or the value returned by', &
'          ! CMPLX() is a default real instead of double precision.', &
'', &
'          ! Working with complex values you often encounter the CMPLX(3)', &
'          ! function. CMPLX(3) defaults to returning a default REAL regardless', &
'          ! of input type. Not really a direct problem with ABS(2f) per-se,', &
'          ! but a common error when working with doubleprecision complex values', &
'', &
'          print gen,  message', &
'          print gen, ''real result versus doubleprecision result'', &', &
'          & abs(cmplx(30.0_dp,40.0_dp)), &', &
'          & abs(cmplx(30.0_dp,40.0_dp,kind=dp))', &
'', &
'        end subroutine DUSTY_CORNERS_2', &
'', &
'        subroutine DUSTY_CORNERS_3(message)', &
'        character(len=*),intent(in) :: message', &
'          print gen, message', &
'', &
'          ! this will probably cause an overflow error, or', &
'          !print gen,  abs(cmplx( huge(0.0), huge(0.0) ))', &
'', &
'          print gen, ''because the biggest default real is'',huge(0.0)', &
'          print gen, ''because returning magnitude of sqrt(x%re**2,x%im**2)''', &
'', &
'        end subroutine DUSTY_CORNERS_3', &
'', &
'        subroutine DUSTY_CORNERS_4(message)', &
'        character(len=*),intent(in) :: message', &
'          print gen, message', &
'', &
'          ! if you do not want the distance for a complex value you', &
'          ! might want something like returning a complex value with', &
'          ! both the imaginary and real parts. One way to do that is', &
'', &
'          print gen, cmplx(abs(z%re),abs(z%im),kind=kind(z))', &
'', &
'        end subroutine DUSTY_CORNERS_4', &
'', &
'      end program demo_abs', &
'', &
'  Results:', &
'', &
'       >  integer         In: -1                        Out: 1', &
'       >  real            In: -1.00000000               Out: 1.00000000', &
'       >  doubleprecision  In: -45.78000000000000       Out: 45.78000000000000', &
'       >  complex         In: (-3.00000000,-4.00000000) Out: 5.00000000', &
'       > abs is elemental: 20 0 1 3 100', &
'       > distance of ( -3.00000000 -4.00000000 ) from zero is 5.00000000', &
'       > beware of abs(-huge(0)-1)', &
'       > abs range test :  2147483647 2147483647', &
'       > abs range test :  0.340282347E+39 0.340282347E+39', &
'       > abs range test :  0.117549435E-37 0.117549435E-37', &
'       > beware of losing precision using CMPLX(3)', &
'       > real result versus doubleprecision result 50.0000000 50.00000000000000', &
'       > beware of overflow of complex values', &
'       > because the biggest default real is 0.340282347E+39', &
'       > because returning magnitude of sqrt(x%re**2,x%im**2)', &
'       > making your own meaning for ABS(COMPLEX_VALUE)', &
'       > 3.00000000 4.00000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  SIGN(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   abs(3fortran)', &
'']

shortname="abs"
call process()

case('2','achar')

textblock=[character(len=256) :: &
'', &
'achar(3fortran)                                               achar(3fortran)', &
'', &
'NAME', &
'  ACHAR(3) - [CHARACTER:CONVERSION] Returns a character in a specified', &
'  position in the ASCII collating sequence', &
'', &
'SYNOPSIS', &
'  result = achar(i [,kind])', &
'', &
'          elemental character(len=1,kind=KIND) function achar(i,KIND)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  The character kind returned is the value of KIND if present.  otherwise,', &
'     a single default character is returned.', &
'', &
'DESCRIPTION', &
'  ACHAR(3) returns the character located at position I (commonly called the', &
'  ADE or ASCII Decimal Equivalent) in the ASCII collating sequence.', &
'', &
'  The ACHAR(3) function is often used for generating in-band escape sequences', &
'  to control terminal attributes, as it makes it easy to print unprintable', &
'  characters such as escape and tab. For example:', &
'', &
'        write(*,''(*(a))'')achar(27),''[2J''', &
'', &
'  will clear the screen on an ANSI-compatible terminal display,', &
'', &
'NOTE', &
'  The ADEs (ASCII Decimal Equivalents) for ASCII are', &
'', &
'      *-------*-------*-------*-------*-------*-------*-------*-------*', &
'      | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|', &
'      | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |', &
'      | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|', &
'      | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |', &
'      | 32 sp | 33  ! | 34  " | 35  # | 36  $ | 37  % | 38  & | 39  '' |', &
'      | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |', &
'      | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |', &
'      | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |', &
'      | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |', &
'      | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |', &
'      | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |', &
'      | 88  X | 89  Y | 90  Z | 91  [ | 92  \ | 93  ] | 94  ^ | 95  _ |', &
'      | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |', &
'      |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |', &
'      |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |', &
'      |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|', &
'      *-------*-------*-------*-------*-------*-------*-------*-------*', &
'', &
'OPTIONS', &
'  o  I : the integer value to convert to an ASCII character, in the range 0 to', &
'     127. : ACHAR(3) shall have the value C for any character C capable of', &
'     representation as a default character.', &
'', &
'  o  KIND : a integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  Assuming I has a value in the range 0 <= I <= 127, the result is the', &
'  character in position I of the ASCII collating sequence, provided the', &
'  processor is capable of representing that character in the character kind of', &
'  the result; otherwise, the result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_achar', &
'      use,intrinsic::iso_fortran_env,only:int8,int16,int32,int64', &
'      implicit none', &
'      integer :: i', &
'        i=65', &
'        write(*,''("decimal    =",i0)'')i', &
'        write(*,''("character  =",a1)'')achar(i)', &
'        write(*,''("binary     =",b0)'')achar(i)', &
'        write(*,''("octal      =",o0)'')achar(i)', &
'        write(*,''("hexadecimal =",z0)'')achar(i)', &
'', &
'        write(*,''(8(i3,1x,a,1x))'')(i,achar(i), i=32,126)', &
'', &
'        write(*,''(a)'')upper(''Mixed Case'')', &
'      contains', &
'      ! a classic use of achar(3) is to convert the case of a string', &
'', &
'      pure elemental function upper(str) result (string)', &
'      !', &
'      !$@(#) upper(3): function to return a trimmed uppercase-only string', &
'      !', &
'      ! input string to convert to all uppercase', &
'      character(*), intent(in)     :: str', &
'      ! output string that contains no miniscule letters', &
'      character(len(str))          :: string', &
'      integer                      :: i, iend', &
'      integer,parameter            :: toupper = iachar(''A'')-iachar(''a'')', &
'        iend=len_trim(str)', &
'        ! initialize output string to trimmed input string', &
'        string = str(:iend)', &
'        ! process each letter in the string', &
'        do concurrent (i = 1:iend)', &
'            select case (str(i:i))', &
'            ! located miniscule letter', &
'            case (''a'':''z'')', &
'               ! change miniscule to majuscule letter', &
'               string(i:i) = achar(iachar(str(i:i))+toupper)', &
'            end select', &
'        enddo', &
'      end function upper', &
'      end program demo_achar', &
'', &
'  Results:', &
'', &
'       > decimal     =65', &
'       > character   =A', &
'       > binary      =1000001', &
'       > octal      =101', &
'       > hexadecimal =41', &
'       >  32   33 !  34 "  35 #  36 $  37 %  38 &  39 ''', &
'       >  40 ( 41 )  42 *  43 +  44 ,  45 -  46 .  47 /', &
'       >  48 0 49 1  50 2  51 3  52 4  53 5  54 6  55 7', &
'       >  56 8 57 9  58 :  59 ;  60 <  61 =  62 >  63 ?', &
'       >  64 @ 65 A  66 B  67 C  68 D  69 E  70 F  71 G', &
'       >  72 H 73 I  74 J  75 K  76 L  77 M  78 N  79 O', &
'       >  80 P 81 Q  82 R  83 S  84 T  85 U  86 V  87 W', &
'       >  88 X 89 Y  90 Z  91 [  92 \  93 ]  94 ^  95 _', &
'       >  96 ` 97 a  98 b  99 c 100 d 101 e 102 f 103 g', &
'       > 104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o', &
'       > 112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w', &
'       > 120 x 121 y 122 z 123 { 124 | 125 } 126 ~', &
'       > MIXED CASE', &
'', &
'STANDARD', &
'  FORTRAN 77. KIND argument added Fortran 2003', &
'', &
'SEE ALSO', &
'  CHAR(3), IACHAR(3), ICHAR(3)', &
'', &
'RESOURCES', &
'  o  ANSI escape sequences', &
'', &
'  o  M_attr module for controlling ANSI-compatible terminals', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 achar(3fortran)', &
'']

shortname="achar"
call process()

case('3','acos')

textblock=[character(len=256) :: &
'', &
'acos(3fortran)                                                 acos(3fortran)', &
'', &
'NAME', &
'  ACOS(3) - [MATHEMATICS:TRIGONOMETRIC] Arccosine (inverse cosine) function', &
'', &
'SYNOPSIS', &
'  result = acos(x)', &
'', &
'          elemental TYPE(kind=KIND) function acos(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex', &
'', &
'  o  KIND may be any kind supported by the associated type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ACOS(3) computes the arccosine of X (inverse of COS(X)).', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arctangent of. If the type is real, the', &
'     value must satisfy |X| <= 1.', &
'', &
'RESULT', &
'  The return value is of the same type and kind as X. The real part of the', &
'  result is in radians and lies in the range 0 <= ACOS(X%RE) <= PI .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acos', &
'      use, intrinsic :: iso_fortran_env, only : real32,real64,real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64) :: x , d2r', &
'', &
'        ! basics', &
'         x = 0.866_real64', &
'         print all,''acos('',x,'') is '', acos(x)', &
'', &
'        ! acos(-1) should be PI', &
'         print all,''for reference'', new_line(''a''), &', &
'         &''PI ~= 3.14159265358979323846264338327950288419716939937510''', &
'         write(*,*) acos(-1.0_real64)', &
'         d2r=acos(-1.0_real64)/180.0_real64', &
'         print all,''90 degrees is '', d2r*90.0_real64, '' radians''', &
'        ! elemental', &
'         print all,''elemental'',acos([-1.0,-0.5,0.0,0.50,1.0])', &
'        ! complex', &
'         print *,''complex'',acos( (-1.0,  0.0) )', &
'         print *,''complex'',acos( (-1.0, -1.0) )', &
'         print *,''complex'',acos( ( 0.0, -0.0) )', &
'         print *,''complex'',acos( ( 1.0,  0.0) )', &
'', &
'      end program demo_acos', &
'', &
'  Results:', &
'', &
'       > acos( 0.86599999999999999 ) is  0.52364958093182890', &
'       > for reference', &
'       >  PI ~= 3.14159265358979323846264338327950288419716939937510', &
'       >    3.1415926535897931', &
'       > 90 degrees is 1.5707963267948966  radians', &
'       > elemental 3.14159274 2.09439516 1.57079637 1.04719758 0.00000000', &
'       >  complex           (3.14159274,-0.00000000)', &
'       >  complex            (2.23703575,1.06127501)', &
'       >  complex            (1.57079637,0.00000000)', &
'       >  complex           (0.00000000,-0.00000000)', &
'', &
'STANDARD', &
'  FORTRAN 77 ; for a complex argument - Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: COS(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  acos(3fortran)', &
'']

shortname="acos"
call process()

case('4','acosd')

textblock=[character(len=256) :: &
'', &
'acosd(3fortran)                                               acosd(3fortran)', &
'', &
'NAME', &
'  ACOSD(3) - [MATHEMATICS:TRIGONOMETRIC] Arccosine (inverse cosine) function', &
'  in degrees', &
'', &
'SYNOPSIS', &
'  result = acosd(x)', &
'', &
'          elemental real(kind=KIND) function acosd(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any kind supported by the real type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ACOSD(3) computes the arccosine of X in degrees (inverse of COSD(X)).  For', &
'  example, ACOSD(-1.0) has the value 180.0 (approximately).', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arctangent of. If the type is real, the', &
'     value must satisfy |X| <= 1.', &
'', &
'RESULT', &
'  The return value is of the same type and kind as X. The result has a value', &
'  equal to a processor-dependent approximation to the arc cosine of X. It is', &
'  expressed in degrees and lies in the range', &
'', &
'    0 <= ACOSD (X) <= 180', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acosd', &
'      use, intrinsic :: iso_fortran_env, only : real32,real64,real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64) :: x , d2r', &
'', &
'        ! basics', &
'         print *,''acosd(-1.0) -->'',acosd( -1.0 )', &
'         print *,''acosd( 0.0) -->'',acosd( -1.0 )', &
'         print *,''acosd( 1.0) -->'',acosd(  0.0 )', &
'         x = 0.866_real64', &
'         print all,''acosd('',x,'') is '', acosd(x)', &
'        ! any real kind', &
'         write(*,*) acosd(-1.0_real64)', &
'        ! elemental', &
'         print all,''elemental'',acosd([-1.0,-0.5,0.0,0.50,1.0])', &
'        !', &
'      end program demo_acosd', &
'', &
'  Results:', &
'', &
'       >  acosd(-1.0) -->   180.000000', &
'       >  acosd( 0.0) -->   180.000000', &
'       >  acosd( 1.0) -->   90.0000000', &
'       > acosd( 0.86599999999999999 ) is  30.002910931188026', &
'       >    180.00000000000000', &
'       > elemental 180.000000 120.000000 90.0000000 60.0000000 0.00000000', &
'', &
'STANDARD', &
'  FORTRAN 2023', &
'', &
'SEE ALSO', &
'  Inverse function: COSD(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 acosd(3fortran)', &
'']

shortname="acosd"
call process()

case('5','acosh')

textblock=[character(len=256) :: &
'', &
'acosh(3fortran)                                               acosh(3fortran)', &
'', &
'NAME', &
'  ACOSH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic cosine function', &
'', &
'SYNOPSIS', &
'  result = acosh(x)', &
'', &
'          elemental TYPE(kind=KIND) function acosh(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex', &
'', &
'  o  KIND may be any kind supported by the associated type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ACOSH(3) computes the inverse hyperbolic cosine of X in radians.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the hyperbolic cosine of. A real value should be', &
'     >= 1 or the result with be a Nan.', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  inverse hyperbolic cosine function of X.', &
'', &
'  If X is complex, the imaginary part of the result is in radians and lies', &
'  between', &
'', &
'    0 <= aimag(acosh(x)) <= PI', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acosh', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=dp), dimension(3) :: x = [ 1.0_dp, 2.0_dp, 3.0_dp ]', &
'        if( any(x.lt.1) )then', &
'           write (*,*) '' warning: values < 1 are present''', &
'        endif', &
'        write (*,*) acosh(x)', &
'      end program demo_acosh', &
'', &
'  Results:', &
'', &
'       >    0.0000000000000000 1.3169578969248166 1.7627471740390861', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: COSH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 acosh(3fortran)', &
'']

shortname="acosh"
call process()

case('6','acospi')

textblock=[character(len=256) :: &
'', &
'acospi(3fortran)                                             acospi(3fortran)', &
'', &
'NAME', &
'  ACOSPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular Arccosine (inverse circular', &
'  cosine) function', &
'', &
'SYNOPSIS', &
'  result = acospi(x)', &
'', &
'          elemental real(kind=KIND) function acospi(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any real kind', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ACOSPI(3) computes the circular arccosine of X (inverse of COSPI(X)).  The', &
'  result is expressed in half-revolutions (ie. PI''s) and lies in the range', &
'', &
'    0 <= ACOSPI (X) <= 1.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the circular arctangent of. The value must', &
'     satisfy |X| <= 1.', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  arc cosine of X.', &
'', &
'  The return value is of the same type and kind as X.', &
'', &
'  It is expressed in half-revolutions and lies in the range 0 <= ACOSPI (X) <=', &
'  1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_acospi', &
'      use, intrinsic :: iso_fortran_env, only : real32,real64,real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64) :: x , d2r', &
'      real(kind=real64),parameter :: &', &
'      & PI = 3.14159265358979323846264338327950288419716939937510_real64', &
'', &
'        ! basics', &
'         x = PI/4.0_real64', &
'         print all,''acospi('',x,'') is '', acospi(x)', &
'', &
'        ! acospi(-1) should be PI', &
'         write(*,*) acospi(-1.0_real64)', &
'         d2r=acospi(-1.0_real64)/180.0_real64', &
'         print all,''90 degrees is '', d2r*90.0_real64, '' radians''', &
'        ! elemental', &
'         print all,''elemental'',acospi([-1.0,-0.5,0.0,0.50,1.0])', &
'        !', &
'         print *,''-1.0'',acospi( -1.0 )', &
'         print *,'' 0.0'',acospi(  0.0 )', &
'         print *,'' 1.0'',acospi(  1.0 )', &
'', &
'      end program demo_acospi', &
'', &
'  Results:', &
'', &
'       > acospi( 0.78539816339744828 ) is  0.21245823046654463', &
'       >    1.0000000000000000', &
'       > 90 degrees is 0.50000000000000000  radians', &
'       > elemental 1.00000000 0.666666687 0.500000000 0.333333343 0.00000000', &
'       >  -1.0  1.00000000', &
'       >   0.0 0.500000000', &
'       >   1.0  0.00000000', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  arc cosine in radians: ACOS(3)', &
'', &
'  o  arc cosine in degrees: ACOSD(3)', &
'', &
'  o  Inverse function: COS(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                acospi(3fortran)', &
'']

shortname="acospi"
call process()

case('7','adjustl')

textblock=[character(len=256) :: &
'', &
'adjustl(3fortran)                                           adjustl(3fortran)', &
'', &
'NAME', &
'  ADJUSTL(3) - [CHARACTER:WHITESPACE] Left-justify a string', &
'', &
'SYNOPSIS', &
'  result = adjustl(string)', &
'', &
'        elemental character(len=len(string),kind=KIND) function adjustl(string)', &
'', &
'         character(len=*,kind=KIND),intent(in) :: string', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a character variable of any supported kind', &
'', &
'  o  The return value is a character variable of the same kind and length as', &
'     STRING', &
'', &
'DESCRIPTION', &
'  ADJUSTL(3) will left-justify a string by removing leading spaces. Spaces are', &
'  inserted at the end of the string as needed.', &
'', &
'OPTIONS', &
'  o  STRING : the string to left-justify', &
'', &
'RESULT', &
'  A copy of STRING where leading spaces are removed and the same number of', &
'  spaces are inserted on the end of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_adjustl', &
'      implicit none', &
'      character(len=20) :: str = ''   sample string''', &
'      character(len=:),allocatable :: astr', &
'      integer :: length', &
'', &
'        ! basic use', &
'         write(*,''(a,"[",a,"]")'') ''original: '',str', &
'         str=adjustl(str)', &
'         write(*,''(a,"[",a,"]")'') ''adjusted: '',str', &
'', &
'         ! a fixed-length string can be printed', &
'         ! trimmed using trim(3) or len_trim(3)', &
'         write(*,''(a,"[",a,"]")'') ''trimmed:  '',trim(str)', &
'         length=len_trim(str)', &
'         write(*,''(a,"[",a,"]")'') ''substring:'',str(:length)', &
'', &
'         ! note an allocatable string stays the same length too', &
'         ! and is not trimmed by just an adjustl(3) call.', &
'         astr=''    allocatable string  ''', &
'         write(*,''(a,"[",a,"]")'') ''original:'',astr', &
'         astr = adjustl(astr)', &
'         write(*,''(a,"[",a,"]")'') ''adjusted:'',astr', &
'         ! trim(3) can be used to change the length', &
'         astr = trim(astr)', &
'         write(*,''(a,"[",a,"]")'') ''trimmed: '',astr', &
'', &
'      end program demo_adjustl', &
'', &
'  Results:', &
'', &
'        > original: [   sample string    ]', &
'        > adjusted: [sample string       ]', &
'        > trimmed:  [sample string]', &
'        > substring:[sample string]', &
'        > original:[    allocatable string   ]', &
'        > adjusted:[allocatable string       ]', &
'        > trimmed: [allocatable string]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ADJUSTR(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               adjustl(3fortran)', &
'']

shortname="adjustl"
call process()

case('8','adjustr')

textblock=[character(len=256) :: &
'', &
'adjustr(3fortran)                                           adjustr(3fortran)', &
'', &
'NAME', &
'  ADJUSTR(3) - [CHARACTER:WHITESPACE] Right-justify a string', &
'', &
'SYNOPSIS', &
'  result = adjustr(string)', &
'', &
'        elemental character(len=len(string),kind=KIND) function adjustr(string)', &
'', &
'         character(len=*,kind=KIND),intent(in) :: string', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a character variable', &
'', &
'  o  The return value is a character variable of the same kind and length as', &
'     STRING', &
'', &
'DESCRIPTION', &
'  ADJUSTR(3) right-justifies a string by removing trailing spaces. Spaces are', &
'  inserted at the start of the string as needed to retain the original length.', &
'', &
'OPTIONS', &
'  o  STRING : the string to right-justify', &
'', &
'RESULT', &
'  Trailing spaces are removed and the same number of spaces are inserted at', &
'  the start of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_adjustr', &
'      implicit none', &
'      character(len=20) :: str', &
'        ! print a short number line', &
'        write(*,''(a)'')repeat(''1234567890'',2)', &
'', &
'       ! basic usage', &
'        str = ''  sample string ''', &
'        write(*,''(a)'') str', &
'        str = adjustr(str)', &
'        write(*,''(a)'') str', &
'', &
'        !', &
'        ! elemental', &
'        !', &
'        write(*,''(a)'')repeat(''1234567890'',5)', &
'        write(*,''(a)'')adjustr([character(len=50) :: &', &
'        ''  first          '', &', &
'        ''     second      '', &', &
'        ''        third    '' ])', &
'        write(*,''(a)'')repeat(''1234567890'',5)', &
'', &
'      end program demo_adjustr', &
'', &
'  Results:', &
'', &
'        > 12345678901234567890', &
'        >   sample string', &
'        >        sample string', &
'        > 12345678901234567890123456789012345678901234567890', &
'        >                                              first', &
'        >                                             second', &
'        >                                              third', &
'        > 12345678901234567890123456789012345678901234567890', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ADJUSTL(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               adjustr(3fortran)', &
'']

shortname="adjustr"
call process()

case('9','aimag')

textblock=[character(len=256) :: &
'', &
'aimag(3fortran)                                               aimag(3fortran)', &
'', &
'NAME', &
'  AIMAG(3) - [TYPE:CONVERSION] Imaginary part of complex number', &
'', &
'SYNOPSIS', &
'  result = aimag(z)', &
'', &
'          elemental function aimag(z)', &
'', &
'           complex(kind=KIND) aimag', &
'           complex(kind=KIND),intent(in) :: z', &
'', &
'CHARACTERISTICS', &
'  o  The type of the argument Z is complex. It may be of any supported complex', &
'     kind', &
'', &
'  o  The return value is of type real with the kind type parameter of the', &
'     argument Z.', &
'', &
'DESCRIPTION', &
'  AIMAG(3) yields the imaginary part of the complex argument Z.', &
'', &
'  This is similar to the modern complex-part-designator %IM which also', &
'  designates the imaginary part of a value, accept a designator is treated as', &
'  a variable. This means it may appear on the left-hand side of an assignment', &
'  as well, as in VAL%IM=10.0 or as an argument in a procedure call that will', &
'  act as a typical variable passed by reference.', &
'', &
'OPTIONS', &
'  o  Z : The complex value to extract the imaginary component of.', &
'', &
'RESULT', &
'  The return value is a real value with the magnitude and sign of the', &
'  imaginary component of the argument Z.', &
'', &
'  That is, If Z has the value (X,Y), the result has the value Y.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aimag', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      character(len=*),parameter :: it=''(*(1x,g0))''', &
'      integer             :: i', &
'      complex             :: z4', &
'      complex             :: arr(3)', &
'      complex(kind=real64) :: z8', &
'', &
'         print it, ''basics:''', &
'', &
'         z4 = cmplx(1.e0, 2.e0)', &
'         print *,  ''value='',z4', &
'         print it, ''imaginary part='',aimag(z4),''or'', z4%im', &
'', &
'         print it, ''kinds other than the default may be supported''', &
'', &
'         z8 = cmplx(3.e0_real64, 4.e0_real64,kind=real64)', &
'         print *,  ''value='',z8', &
'         print it, ''imaginary part='',aimag(z8),''or'', z8%im', &
'', &
'         print it, ''an elemental function can be passed an array''', &
'         print it, ''given a complex array:''', &
'', &
'         arr=[z4,z4/2.0,z4+z4]', &
'         print *,  (arr(i),new_line(''a''),i=1,size(arr))', &
'         print it, ''the imaginary component is:''', &
'         print it, aimag( arr )', &
'', &
'      end program demo_aimag', &
'', &
'  Results:', &
'', &
'       >  basics:', &
'       >  value=            (1.00000000,2.00000000)', &
'       >  imaginary part= 2.00000000 or 2.00000000', &
'       >  kinds other than the default may be supported', &
'       >  value=              (3.0000000000000000,4.0000000000000000)', &
'       >  imaginary part= 4.0000000000000000 or 4.0000000000000000', &
'       >  an elemental function can be passed an array', &
'       >  given a complex array:', &
'       >             (1.00000000,2.00000000)', &
'       >            (0.500000000,1.00000000)', &
'       >             (2.00000000,4.00000000)', &
'       >', &
'       >  the imaginary component is:', &
'       >  2.00000000 1.00000000 4.00000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  CMPLX(3) - Complex conversion function', &
'', &
'  o  CONJG(3) - Complex conjugate function', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  Fortran has strong support for complex values, including many intrinsics', &
'  that take or produce complex values in addition to algebraic and logical', &
'  expressions:', &
'', &
'  ABS(3), ACOSH(3), ACOS(3), ASINH(3), ASIN(3), ATAN2(3), ATANH(3), ATAN(3),', &
'  COSH(3), COS(3), CO_SUM(3), DBLE(3), DOT_PRODUCT(3), EXP(3), INT(3),', &
'  IS_CONTIGUOUS(3), KIND(3), LOG(3), MATMUL(3), PRECISION(3), PRODUCT(3),', &
'  RANGE(3), RANK(3), SINH(3), SIN(3), SQRT(3), STORAGE_SIZE(3), SUM(3),', &
'  TANH(3), TAN(3), UNPACK(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 aimag(3fortran)', &
'']

shortname="aimag"
call process()

case('10','aint')

textblock=[character(len=256) :: &
'', &
'aint(3fortran)                                                 aint(3fortran)', &
'', &
'NAME', &
'  AINT(3) - [NUMERIC] Truncate toward zero to a whole number', &
'', &
'SYNOPSIS', &
'  result = aint(x [,kind])', &
'', &
'          elemental real(kind=KIND) function iaint(x,KIND)', &
'', &
'           real(kind=**),intent(in)   :: x', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  the result is a real of the default kind unless KIND is specified.', &
'', &
'  o  KIND is an integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'DESCRIPTION', &
'  AINT(3) truncates its argument toward zero to a whole number.', &
'', &
'OPTIONS', &
'  o  X : the real value to truncate.', &
'', &
'  o  KIND : indicates the kind parameter of the result.', &
'', &
'RESULT', &
'  The sign is the same as the sign of X unless the magnitude of X is less than', &
'  one, in which case zero is returned.', &
'', &
'  Otherwise AINT(3) returns the largest whole number that does not exceed the', &
'  magnitude of X with the same sign as the input.', &
'', &
'  That is, it truncates the value towards zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aint', &
'      use, intrinsic :: iso_fortran_env, only : sp=>real32, dp=>real64', &
'      implicit none', &
'      real(kind=dp) :: x8', &
'        print *,''basics:''', &
'        print *,'' just chops off the fractional part''', &
'        print *,  aint(-2.999), aint(-2.1111)', &
'        print *,'' if |x| < 1 a positive zero is returned''', &
'        print *,  aint(-0.999), aint( 0.9999)', &
'        print *,'' input may be of any real kind''', &
'        x8 = 4.3210_dp', &
'        print *, aint(-x8), aint(x8)', &
'        print *,''elemental:''', &
'        print *,aint([ &', &
'         &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'         &  0.0,   &', &
'         &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'      end program demo_aint', &
'', &
'  Results:', &
'', &
'       > basics:', &
'       >  just chops off the fractional part', &
'       >  -2.000000     -2.000000', &
'       >  if |x| < 1 a positive zero is returned', &
'       >  0.0000000E+00  0.0000000E+00', &
'       >  input may be of any real kind', &
'       >  -4.00000000000000       4.00000000000000', &
'       > elemental:', &
'       >  -2.000000     -2.000000      -2.000000      -2.000000      -1.000000', &
'       >  -1.000000     0.0000000E+00  0.0000000E+00  0.0000000E+00   1.000000', &
'       >   1.000000      2.000000       2.000000       2.000000       2.000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  ANINT(3), INT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  aint(3fortran)', &
'']

shortname="aint"
call process()

case('11','all')

textblock=[character(len=256) :: &
'', &
'all(3fortran)                                                   all(3fortran)', &
'', &
'NAME', &
'  ALL(3) - [ARRAY:REDUCTION] Determines if all the values are true', &
'', &
'SYNOPSIS', &
'  result = all(mask [,dim])', &
'', &
'          function all(mask ,dim)', &
'', &
'           logical(kind=KIND),intent(in) :: mask(..)', &
'           integer,intent(in),optional   :: dim', &
'           logical(kind=KIND)            :: all(..)', &
'', &
'CHARACTERISTICS', &
'  o  MASK is a logical array', &
'', &
'  o  DIM is an integer', &
'', &
'  o  the result is a logical array if DIM is supplied, otherwise it is a', &
'     logical scalar. It has the same characteristics as MASK', &
'', &
'DESCRIPTION', &
'  ALL(3) determines if all the values are true in MASK in the array along', &
'  dimension DIM if DIM is specified; otherwise all elements are tested', &
'  together.', &
'', &
'  This testing type is called a logical conjunction of elements of MASK along', &
'  dimension DIM.', &
'', &
'  The mask is generally a logical expression, allowing for comparing arrays', &
'  and many other common operations.', &
'', &
'OPTIONS', &
'  o  MASK : the logical array to be tested for all elements being .true.', &
'', &
'  o  DIM : DIM indicates the direction through the elements of MASK to group', &
'     elements for testing. : DIM has a value that lies between one and the', &
'     rank of MASK. The corresponding actual argument shall not be an optional', &
'     dummy argument. : If DIM is not present all elements are tested and a', &
'     single scalar value is returned.', &
'', &
'RESULT', &
'  1.  If DIM is not present ALL(MASK) is .true. if all elements of MASK are', &
'      .true.. It also is .true. if MASK has zero size; otherwise, it is', &
'      .false. .', &
'', &
'  2.  If the rank of MASK is one, then ALL(MASK, DIM) is equivalent to', &
'      ALL(MASK).', &
'', &
'  3.  If the rank of MASK is greater than one and DIM is present then', &
'      ALL(MASK,DIM) returns an array with the rank (number of dimensions) of', &
'      MASK minus 1. The shape is determined from the shape of MASK where the', &
'      DIM dimension is elided. A value is returned for each set of elements', &
'      along the DIM dimension.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_all', &
'      implicit none', &
'      logical,parameter :: T=.true., F=.false.', &
'      logical bool', &
'', &
'       ! basic usage', &
'        ! is everything true?', &
'        bool = all([ T,T,T ])', &
'        print *, ''are all values true?'', bool', &
'        bool = all([ T,F,T ])', &
'        print *, ''are all values true now?'', bool', &
'', &
'       ! compare matrices, even by a dimension', &
'        ARRAYS: block', &
'        integer :: a(2,3), b(2,3)', &
'         ! set everything to one except one value in b', &
'         a = 1', &
'         b = 1', &
'         b(2,2) = 2', &
'         ! now compare those two arrays', &
'         print *,''entire array :'', all(a ==  b )', &
'         print *,''compare columns:'', all(a ==        b, dim=1)', &
'         print *,''compare rows:'', all(a ==  b, dim=2)', &
'       end block ARRAYS', &
'', &
'      end program demo_all', &
'', &
'  Results:', &
'', &
'       >  T', &
'       >  F', &
'       >  entire array : F', &
'       >  compare columns: T F T', &
'       >  compare rows: T F', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ANY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   all(3fortran)', &
'']

shortname="all"
call process()

case('12','allocated')

textblock=[character(len=256) :: &
'', &
'allocated(3fortran)                                       allocated(3fortran)', &
'', &
'NAME', &
'  ALLOCATED(3) - [ARRAY:INQUIRY] Allocation status of an allocatable entity', &
'', &
'SYNOPSIS', &
'  result = allocated(array|scalar)', &
'', &
'          logical function allocated(array,scalar)', &
'', &
'           type(TYPE(kind=**)),allocatable,optional :: array(..)', &
'           type(TYPE(kind=**)),allocatable,optional :: scalar', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  ARRAY may be any allocatable array object of any type.', &
'', &
'  o  SCALAR may be any allocatable scalar of any type.', &
'', &
'  o  the result is a default logical scalar', &
'', &
'DESCRIPTION', &
'  ALLOCATED(3) checks the allocation status of both arrays and scalars.', &
'', &
'  At least one and only one of ARRAY or SCALAR must be specified.', &
'', &
'OPTIONS', &
'  o  ENTITY : the allocatable object to test.', &
'', &
'RESULT', &
'  If the argument is allocated then the result is .true.; otherwise, it', &
'  returns .false..', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_allocated', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp), allocatable :: x(:)', &
'      character(len=256) :: message', &
'      integer :: istat', &
'       ! basics', &
'        if( allocated(x)) then', &
'            write(*,*)''do things if allocated''', &
'        else', &
'            write(*,*)''do things if not allocated''', &
'        endif', &
'', &
'        ! if already allocated, deallocate', &
'        if ( allocated(x) ) deallocate(x,STAT=istat, ERRMSG=message )', &
'        if(istat.ne.0)then', &
'           write(*,*)trim(message)', &
'           stop', &
'        endif', &
'', &
'        ! only if not allocated, allocate', &
'        if ( .not. allocated(x) ) allocate(x(20))', &
'', &
'       ! allocation and intent(out)', &
'        call intentout(x)', &
'        write(*,*)''note it is deallocated!'',allocated(x)', &
'', &
'        contains', &
'', &
'        subroutine intentout(arr)', &
'        ! note that if arr has intent(out) and is allocatable,', &
'        ! arr is deallocated on entry', &
'        real(kind=sp),intent(out),allocatable :: arr(:)', &
'            write(*,*)''note it was allocated in calling program'',allocated(arr)', &
'        end subroutine intentout', &
'', &
'      end program demo_allocated', &
'', &
'  Results:', &
'', &
'       >  do things if not allocated', &
'       >  note it was allocated in calling program F', &
'       >  note it is deallocated! F', &
'', &
'STANDARD', &
'  Fortran 95. allocatable scalar entities were added in Fortran 2003.', &
'', &
'SEE ALSO', &
'  MOVE_ALLOC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025             allocated(3fortran)', &
'']

shortname="allocated"
call process()

case('13','anint')

textblock=[character(len=256) :: &
'', &
'anint(3fortran)                                               anint(3fortran)', &
'', &
'NAME', &
'  ANINT(3) - [NUMERIC] Real nearest whole number', &
'', &
'SYNOPSIS', &
'  result = anint(a [,kind])', &
'', &
'          elemental real(kind=KIND) function anint(x,KIND)', &
'', &
'           real(kind=**),intent(in)   :: x', &
'           integer,intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  A is type real of any kind', &
'', &
'  o  KIND is a scalar integer constant expression.', &
'', &
'  o  the result is type real. The kind of the result is the same as X unless', &
'     specified by KIND.', &
'', &
'DESCRIPTION', &
'  ANINT(3) rounds its argument to the nearest whole number.', &
'', &
'  Unlike NINT(3) which returns an integer the full range or real values can be', &
'  returned (integer types typically have a smaller range of values than real', &
'  types).', &
'', &
'OPTIONS', &
'  o  A : the value to round', &
'', &
'  o  KIND : specifies the kind of the result. The default is the kind of A.', &
'', &
'RESULT', &
'  The return value is the real whole number nearest A.', &
'', &
'  If A is greater than zero, ANINT(A)(3) returns AINT(A + 0.5).', &
'', &
'  If A is less than or equal to zero then it returns AINT(A - 0.5), except', &
'  AINT specifies that for |A| < 1 the result is zero (0).', &
'', &
'  It is processor-dependent whether anint(a) returns negative zero when -0.5 <', &
'  a <= -0.0. Compiler switches are often available which enable or disable', &
'  support of negative zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_anint', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real,allocatable :: arr(:)', &
'', &
'       ! basics', &
'        print *, ''ANINT (2.783) has the value 3.0 =>'', anint(2.783)', &
'        print *, ''ANINT (-2.783) has the value -3.0 =>'', anint(-2.783)', &
'', &
'        print *, ''by default the kind of the output is the kind of the input''', &
'        print *, anint(1234567890.1234567890e0)', &
'        print *, anint(1234567890.1234567890d0)', &
'', &
'        print *, ''sometimes specifying the result kind is useful when passing''', &
'        print *, ''results as an argument, for example.''', &
'        print *, ''do you know why the results are different?''', &
'        print *, anint(1234567890.1234567890,kind=real64)', &
'        print *, anint(1234567890.1234567890d0,kind=real64)', &
'', &
'       ! elemental', &
'        print *, ''numbers on a cusp are always the most troublesome''', &
'        print *, anint([ -2.7, -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, 0.0 ])', &
'', &
'        print *, ''negative zero is processor dependent''', &
'        arr=[ 0.0, 0.1, 0.5, 1.0, 1.5, 2.0, 2.2, 2.5, 2.7 ]', &
'        print *, anint(arr)', &
'        arr=[ -0.0, -0.1, -0.5, -1.0, -1.5, -2.0, -2.2, -2.5, -2.7 ]', &
'        print *, anint(arr)', &
'', &
'      end program demo_anint', &
'', &
'  Results:', &
'', &
'       >  ANINT (2.783) has the value 3.0 =>   3.000000', &
'       >  ANINT (-2.783) has the value -3.0 => -3.000000', &
'       >  by default the kind of the output is the kind of the input', &
'       >   1.2345679E+09', &
'       >    1234567890.00000', &
'       >  sometimes specifying the result kind is useful when passing', &
'       >  results as an argument, for example.', &
'       >  do you know why the results are different?', &
'       >    1234567936.00000', &
'       >    1234567890.00000', &
'       >  numbers on a cusp are always the most troublesome', &
'       >   -3.000000     -3.000000      -2.000000      -2.000000      -2.000000', &
'       >   -1.000000     -1.000000      0.0000000E+00', &
'       >  negative zero is processor dependent', &
'       >   0.0000000E+00  0.0000000E+00   1.000000      1.000000       2.000000', &
'       >    2.000000      2.000000       3.000000       3.000000', &
'       >   0.0000000E+00  0.0000000E+00  -1.000000     -1.000000      -2.000000', &
'       >   -2.000000     -2.000000      -3.000000      -3.000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  AINT(3), INT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 anint(3fortran)', &
'']

shortname="anint"
call process()

case('14','any')

textblock=[character(len=256) :: &
'', &
'any(3fortran)                                                   any(3fortran)', &
'', &
'NAME', &
'  ANY(3) - [ARRAY:REDUCTION] Determines if any of the values in the logical', &
'  array are .true.', &
'', &
'SYNOPSIS', &
'  result = any(mask [,dim])', &
'', &
'          function any(mask, dim)', &
'', &
'           logical(kind=KIND),intent(in) :: mask(..)', &
'           integer,intent(in),optional   :: dim', &
'           logical(kind=KIND)            :: any(..)', &
'', &
'CHARACTERISTICS', &
'  o  MASK is a logical array', &
'', &
'  o  DIM is a scalar integer', &
'', &
'  o  the result is a logical array if DIM is supplied, otherwise it is a', &
'     logical scalar.', &
'', &
'DESCRIPTION', &
'  ANY(3) determines if any of the values in the logical array MASK along', &
'  dimension DIM are .true..', &
'', &
'OPTIONS', &
'  o  MASK : an array of logical expressions or values to be tested in groups', &
'     or in total for a .true. value.', &
'', &
'  o  DIM : a whole number value that lies between one and RANK(MASK) that', &
'     indicates to return an array of values along the indicated dimension', &
'     instead of a scalar answer.', &
'', &
'RESULT', &
'  ANY(MASK) returns a scalar value of type logical where the kind type', &
'  parameter is the same as the kind type parameter of MASK. If DIM is present,', &
'  then ANY(MASK, DIM) returns an array with the rank of MASK minus 1. The', &
'  shape is determined from the shape of MASK where the DIM dimension is', &
'  elided.', &
'', &
'  1.  ANY(MASK) is .true. if any element of MASK is .true.; otherwise, it is', &
'      .false.. It also is .false. if MASK has zero size.', &
'', &
'  2.  If the rank of MASK is one, then ANY(MASK, DIM) is equivalent to', &
'      ANY(MASK). If the rank is greater than one, then ANY(MASK, DIM) is', &
'      determined by applying ANY(MASK) to the array sections.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_any', &
'      implicit none', &
'      logical,parameter :: T=.true., F=.false.', &
'      integer          :: a(2,3), b(2,3)', &
'      logical          :: bool', &
'       ! basic usage', &
'        bool = any([F,F,T,F])', &
'        print *,bool', &
'        bool = any([F,F,F,F])', &
'        print *,bool', &
'       ! fill two integer arrays with values for testing', &
'        a = 1', &
'        b = 1', &
'        b(:,2) = 2', &
'        b(:,3) = 3', &
'       ! using any(3) with logical expressions you can compare two arrays', &
'       ! in a myriad of ways', &
'        ! first, print where elements of b are bigger than in a', &
'        call printl( ''first print b > a            '', b > a        )', &
'        ! now use any() to test', &
'        call printl( ''any true values?  any(b > a)  '', any(b > a )   )', &
'        call printl( ''again by columns? any(b > a,1)'', any(b > a, 1) )', &
'        call printl( ''again by rows?   any(b > a,2)'', any(b > a, 2) )', &
'      contains', &
'      ! CONVENIENCE ROUTINE. this is not specific to ANY()', &
'      subroutine printl(title,a)', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       & stderr=>ERROR_UNIT,&', &
'       & stdin=>INPUT_UNIT,&', &
'       & stdout=>OUTPUT_UNIT', &
'      implicit none', &
'', &
'      !@(#) print small 2d logical scalar, vector, or matrix', &
'', &
'      character(len=*),parameter   :: all=''(*(g0,1x))''', &
'      character(len=*),parameter   :: row=''(" > [ ",*(l1:,","))''', &
'      character(len=*),intent(in)  :: title', &
'      logical,intent(in)          :: a(..)', &
'      integer                     :: i', &
'        write(*,*)', &
'        write(*,all,advance=''no'')trim(title),&', &
'         & '' : shape='',shape(a),'',rank='',rank(a),'',size='',size(a)', &
'        ! get size and shape of input', &
'        select rank(a)', &
'        rank (0); write(*,''(a)'')''(a scalar)''', &
'           write(*,fmt=row,advance=''no'')a', &
'           write(*,''(" ]")'')', &
'        rank (1); write(*,''(a)'')''(a vector)''', &
'           do i=1,size(a)', &
'              write(*,fmt=row,advance=''no'')a(i)', &
'              write(*,''(" ]")'')', &
'           enddo', &
'        rank (2); write(*,''(a)'')''(a matrix) ''', &
'           do i=1,size(a,dim=1)', &
'              write(*,fmt=row,advance=''no'')a(i,:)', &
'              write(*,''(" ]")'')', &
'           enddo', &
'        rank default', &
'           write(stderr,*)''*printl* did not expect rank='', rank(a), &', &
'            & ''shape='', shape(a),''size='',size(a)', &
'           stop ''*printl* unexpected rank''', &
'        end select', &
'', &
'      end subroutine printl', &
'', &
'      end program demo_any', &
'', &
'  Results:', &
'', &
'       >  T', &
'       >  F', &
'       >', &
'       > first print b > a : shape=23,rank=2,size=6(a matrix)', &
'       >  > [ F,T,T ]', &
'       >  > [ F,T,T ]', &
'       >', &
'       > any true values?  any(b > a) : shape=,rank=0,size=1(a scalar)', &
'       >  > [ T ]', &
'       >', &
'       > again by columns? any(b > a,1) : shape=3,rank=1,size=3(a vector)', &
'       >  > [ F ]', &
'       >  > [ T ]', &
'       >  > [ T ]', &
'       >', &
'       > again by rows?    any(b > a,2) : shape=2,rank=1,size=2(a vector)', &
'       >  > [ T ]', &
'       >  > [ T ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ALL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   any(3fortran)', &
'']

shortname="any"
call process()

case('15','asin')

textblock=[character(len=256) :: &
'', &
'asin(3fortran)                                                 asin(3fortran)', &
'', &
'NAME', &
'  ASIN(3) - [MATHEMATICS:TRIGONOMETRIC] Arcsine function', &
'', &
'SYNOPSIS', &
'  result = asin(x)', &
'', &
'          elemental TYPE(kind=KIND) function asin(x)', &
'', &
'           TYPE(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex', &
'', &
'  o  KIND may be any kind supported by the associated type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ASIN(3) computes the arcsine of its argument X.', &
'', &
'  The arcsine is the inverse function of the sine function. It is commonly', &
'  used in trigonometry when trying to find the angle when the lengths of the', &
'  hypotenuse and the opposite side of a right triangle are known.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arcsine of The type shall be either real and', &
'     a magnitude that is less than or equal to one; or be complex.', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to', &
'  arcsin(x).', &
'', &
'  If X is real the result is real and it is expressed in radians and lies in', &
'  the range', &
'', &
'             PI/2 <= ASIN (X) <= PI/2.', &
'', &
'  If the argument (and therefore the result) is imaginary the real part of the', &
'  result is in radians and lies in the range', &
'', &
'         -PI/2 <= real(asin(x)) <= PI/2', &
'', &
'EXAMPLES', &
'  The arcsine will allow you to find the measure of a right angle when you', &
'  know the ratio of the side opposite the angle to the hypotenuse.', &
'', &
'  So if you knew that a train track rose 1.25 vertical miles on a track that', &
'  was 50 miles long, you could determine the average angle of incline of the', &
'  track using the arcsine. Given', &
'', &
'       sin(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'', &
'  Sample program:', &
'', &
'      program demo_asin', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      ! value to convert degrees to radians', &
'      real(kind=dp),parameter :: D2R=acos(-1.0_dp)/180.0_dp', &
'      real(kind=dp)          :: angle, rise, run', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'       ! given sine(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'       ! then taking the arcsine of both sides of the equality yields', &
'       ! theta = arcsine(1.25 miles/50 miles) ie. arcsine(opposite/hypotenuse)', &
'       rise=1.250_dp', &
'       run=50.00_dp', &
'       angle = asin(rise/run)', &
'       print all, ''angle of incline(radians) = '', angle', &
'       angle = angle/D2R', &
'       print all, ''angle of incline(degrees) = '', angle', &
'', &
'       print all, ''percent grade='',rise/run*100.0_dp', &
'      end program demo_asin', &
'', &
'  Results:', &
'', &
'       >  angle of incline(radians) =   2.5002604899361139E-002', &
'       >  angle of incline(degrees) =   1.4325437375665075', &
'       >  percent grade=   2.5000000000000000', &
'', &
'  The percentage grade is the slope, written as a percent. To calculate the', &
'  slope you divide the rise by the run. In the example the rise is 1.25 mile', &
'  over a run of 50 miles so the slope is 1.25/50 = 0.025.  Written as a', &
'  percent this is 2.5 %.', &
'', &
'  For the US, two and 1/2 percent is generally thought of as the upper limit.', &
'  This means a rise of 2.5 feet when going 100 feet forward. In the US this', &
'  was the maximum grade on the first major US railroad, the Baltimore and', &
'  Ohio. Note curves increase the frictional drag on a train reducing the', &
'  allowable grade.', &
'', &
'STANDARD', &
'  FORTRAN 77 , for a complex argument Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: SIN(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  asin(3fortran)', &
'']

shortname="asin"
call process()

case('16','asind')

textblock=[character(len=256) :: &
'', &
'asind(3fortran)                                               asind(3fortran)', &
'', &
'NAME', &
'  ASIND(3) - [MATHEMATICS:TRIGONOMETRIC] Arcsine function in degrees', &
'', &
'SYNOPSIS', &
'  result = asind(x)', &
'', &
'          elemental real(kind=KIND) function asind(x)', &
'', &
'           real(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any kind supported by the real type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ASIND(3) computes the arc sine of its argument X in degrees', &
'', &
'  The arcsine is the inverse function of the sine function. It is commonly', &
'  used in trigonometry when trying to find the angle when the lengths of the', &
'  hypotenuse and the opposite side of a right triangle are known.', &
'', &
'  Example: ASIND(1.0) has the value 90.0 (approximately).', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arc sine of The type shall be real and a', &
'     magnitude that is less than or equal to one |X| <= 1. It is expressed in', &
'     degrees and lies in the range 90 <= asind(x) <= 90.', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to', &
'  arcsin(x).', &
'', &
'  If X is real the result is real and it is expressed in radians and lies in', &
'  the range', &
'', &
'             PI/2 <= asind (X) <= PI/2.', &
'', &
'  If the argument (and therefore the result) is imaginary the real part of the', &
'  result is in radians and lies in the range', &
'', &
'         -PI/2 <= real(asind(x)) <= PI/2', &
'', &
'EXAMPLES', &
'  The arcsine will allow you to find the measure of a right angle when you', &
'  know the ratio of the side opposite the angle to the hypotenuse.', &
'', &
'  So if you knew that a train track rose 1.25 vertical miles on a track that', &
'  was 50 miles long, you could determine the average angle of incline of the', &
'  track using the arcsine. Given', &
'', &
'       sin(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'', &
'  Sample program:', &
'', &
'      program demo_asind', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      ! value to convert degrees to radians', &
'      real(kind=dp),parameter :: R2D=180.0_dp/acos(-1.0_dp)', &
'      real(kind=dp)          :: angle, rise, run', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'       ! given sine(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'       ! then taking the arcsine of both sides of the equality yields', &
'       ! theta = arcsine(1.25 miles/50 miles) ie. arcsine(opposite/hypotenuse)', &
'       rise=1.250_dp', &
'       run=50.00_dp', &
'       angle = asind(rise/run)', &
'       print all, ''angle of incline(degrees) = '', angle', &
'       angle = angle/R2D', &
'       print all, ''angle of incline(radians) = '', angle', &
'', &
'       print all, ''percent grade='',rise/run*100.0_dp', &
'      contains', &
'      subroutine sub1()', &
'      ! notice the (incidently empty) type is defined below', &
'      ! the implicit statement', &
'      implicit type(nil) (a)', &
'      type nil', &
'      end type nil', &
'      type(nil) :: anull', &
'      end subroutine sub1', &
'      end program demo_asind', &
'', &
'  Results:', &
'', &
'       > angle of incline(degrees) =  1.4325437375665075', &
'       > angle of incline(radians) =  0.25002604899361135E-1', &
'       > percent grade= 2.5000000000000000', &
'', &
'  The percentage grade is the slope, written as a percent. To calculate the', &
'  slope you divide the rise by the run. In the example the rise is 1.25 mile', &
'  over a run of 50 miles so the slope is 1.25/50 = 0.025.  Written as a', &
'  percent this is 2.5 %.', &
'', &
'  For the US, two and 1/2 percent is generally thought of as the upper limit.', &
'  This means a rise of 2.5 feet when going 100 feet forward. In the US this', &
'  was the maximum grade on the first major US railroad, the Baltimore and', &
'  Ohio. Note curves increase the frictional drag on a train reducing the', &
'  allowable grade.', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  Inverse function: SIN(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 asind(3fortran)', &
'']

shortname="asind"
call process()

case('17','asinh')

textblock=[character(len=256) :: &
'', &
'asinh(3fortran)                                               asinh(3fortran)', &
'', &
'NAME', &
'  ASINH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic sine function', &
'', &
'SYNOPSIS', &
'  result = asinh(x)', &
'', &
'          elemental TYPE(kind=KIND) function asinh(x)', &
'', &
'           TYPE(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real or complex type', &
'', &
'  o  KIND may be any kind supported by the associated type', &
'', &
'  o  The returned value will be of the same type and kind as the argument', &
'', &
'   X', &
'DESCRIPTION', &
'  ASINH(3) computes the inverse hyperbolic sine of X.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the inverse hyperbolic sine of', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  inverse hyperbolic sine function of X.', &
'', &
'  If X is complex, the imaginary part of the result is in radians and lies', &
'  between', &
'', &
'            -PI/2 <= aimag(asinh(x)) <= PI/2', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_asinh', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=dp), dimension(3) :: x = [ -1.0d0, 0.0d0, 1.0d0 ]', &
'', &
'        ! elemental', &
'         write (*,*) asinh(x)', &
'', &
'      end program demo_asinh', &
'', &
'  Results:', &
'', &
'       >  -0.88137358701954305  0.0000000000000000  0.88137358701954305', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: SINH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 asinh(3fortran)', &
'']

shortname="asinh"
call process()

case('18','asinpi')

textblock=[character(len=256) :: &
'', &
'asinpi(3fortran)                                             asinpi(3fortran)', &
'', &
'NAME', &
'  ASINPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular arc sine function', &
'', &
'SYNOPSIS', &
'  result = asinpi(x)', &
'', &
'          elemental real(kind=KIND) function asinpi(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any real kind', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ASINPI(3) computes the arcsine of its argument X.', &
'', &
'  The arcsine is the inverse function of the sine function. It is commonly', &
'  used in trigonometry when trying to find the angle when the lengths of the', &
'  hypotenuse and the opposite side of a right triangle are known.', &
'', &
'  The returned value is in half-revolutions (ie. in multiples of PI).', &
'', &
'  Example: ASINPI(1:0) has the value 0:5 (approximately).', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arcsine of; where |X| <= 1. The type shall', &
'     be real', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  arc sine of X. The result is real and it is expressed in half-revolutions', &
'  and lies in the range', &
'', &
'             -1 <= asinpi (X) <= 1', &
'', &
'  and is the same kind as the input.', &
'', &
'EXAMPLES', &
'  The arcsine will allow you to find the measure of a right angle when you', &
'  know the ratio of the side opposite the angle to the hypotenuse.', &
'', &
'  So if you knew that a train track rose 1.25 vertical miles on a track that', &
'  was 50 miles long, you could determine the average angle of incline of the', &
'  track using the arcsine. Given', &
'', &
'       sin(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'', &
'  Sample program:', &
'', &
'      program demo_asinpi', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      ! value to convert degrees to half-revolutions', &
'      real(kind=dp),parameter :: D2HR=1/180.0_dp', &
'      real(kind=dp)          :: angle, rise, run', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'       ! basics', &
'       ! elemental', &
'       print all, asinpi( [0.0d0, 0.5d0, -0.5d0, 1.0d0, -1.0d0 ])', &
'       !', &
'       ! sample application', &
'       ! given sine(theta) = 1.25 miles/50 miles (opposite/hypotenuse)', &
'       ! then taking the arcsine of both sides of the equality yields', &
'       ! theta = arcsine(1.25 miles/50 miles) ie. arcsine(opposite/hypotenuse)', &
'       rise=1.250_dp', &
'       run=50.00_dp', &
'       angle = asinpi(rise/run)', &
'       print all, ''angle of incline(half-revolutions) = '', angle', &
'       angle = angle/D2HR', &
'       print all, ''angle of incline(degrees) = '', angle', &
'       print all, ''percent grade='',rise/run*100.0_dp', &
'      contains', &
'      elemental function asinpi(x)', &
'      real(kind=dp),parameter  :: PI=acos(-1.0_dp)', &
'      real(kind=dp),intent(in) :: x', &
'      real(kind=dp)           :: asinpi', &
'        asinpi=asin(x)/PI', &
'      end function asinpi', &
'      end program demo_asinpi', &
'', &
'  Results:', &
'', &
'       > 0.00, 0.166667, -0.166667, 0.50, -0.50', &
'       > angle of incline(half-revolutions) =  0.79585763198139307E-2', &
'       > angle of incline(degrees) =  1.4325437375665075', &
'       > percent grade= 2.5000000000000000', &
'', &
'  The percentage grade is the slope, written as a percent. To calculate the', &
'  slope you divide the rise by the run. In the example the rise is 1.25 mile', &
'  over a run of 50 miles so the slope is 1.25/50 = 0.025.  Written as a', &
'  percent this is 2.5 %.', &
'', &
'  For the US, two and 1/2 percent is generally thought of as the upper limit.', &
'  This means a rise of 2.5 feet when going 100 feet forward. In the US this', &
'  was the maximum grade on the first major US railroad, the Baltimore and', &
'  Ohio. Note curves increase the frictional drag on a train reducing the', &
'  allowable grade.', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  Inverse function in half-revolutions: SINPI(3)', &
'', &
'  o  function in radians: ASIN(3)', &
'', &
'  o  function in degrees : ASIND(3)', &
'', &
'  o  radians: SIN(3)', &
'', &
'  o  degrees: SIND(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                asinpi(3fortran)', &
'']

shortname="asinpi"
call process()

case('19','associate')

textblock=[character(len=256) :: &
'', &
'associate(7fortran)                                       associate(7fortran)', &
'', &
'NAME', &
'  ASSOCIATE(7f) - [EXECUTION CONTROL] aliases selected variable identifiers as', &
'  well as creates constants within the block from runtime expressions at entry', &
'  into the block (LICENSE:PD)', &
'', &
'SYNTAX', &
'  Syntax:', &
'', &
'       [ construct-name : ] ASSOCIATE ( associate-name => selector ...)', &
'         :', &
'         : the associate-block; zero or more statements or constructs', &
'         :', &
'       END ASSOCIATE [ construct-name ]', &
'', &
'  For example:', &
'', &
'        ! pi is an associate-name, acos(-1.0) is its selector', &
'        associate (pi => acos(-1.0) )', &
'           print *, pi', &
'        end associate', &
'', &
'  ASSOCIATE-NAME', &
'', &
'       An identifier that becomes associated with the selector within the', &
'       ASSOCIATE block. The "associate-name" must be unique within the', &
'       construct (but the name can be redefined in other nested subblocks', &
'       such as BLOCK constructs and additional ASSOCIATE blocks).', &
'', &
'   SELECTOR', &
'  Is an expression or variable that will be referred to by the associate-name.', &
'', &
'  CONSTRUCT-NAME', &
'', &
'       An optional name for the block. It is generally used so the block', &
'       can be exited by name or to distinguish which end statement', &
'       is connected with which ASSOCIATE statement when blocks are heavily', &
'       nested.', &
'', &
'       If a construct-name is specified the same name must appear at both', &
'       the beginning of the block in the ASSOCIATE statement and at the', &
'       end in the END ASSOCIATE statement.', &
'', &
'       Construct names must be unique in the scoping unit. Once used that', &
'       same construct-name must not be used for any other named constructs', &
'       in the same scoping unit.', &
'', &
'       It is permissible to branch to an end-associate-stmt only from', &
'       within its ASSOCIATE construct.', &
'', &
'             MYNAME: associate', &
'              :', &
'             if(something_is_true) exit MYNAME', &
'              :', &
'             end associate MYNAME', &
'', &
'  sample program:', &
'', &
'        program show_exiting', &
'        implicit none', &
'        integer :: values(8)', &
'', &
'        call date_and_time( values=values )', &
'', &
'        CALENDAR: associate ( cal=values([1,2,3,5,6,7,4]), &', &
'           year                        =>  VALUES(1), &', &
'           month                       =>  VALUES(2), &', &
'           day                         =>  VALUES(3), &', &
'           delta_from_UTC_in_minutes   =>  VALUES(4), &', &
'           hour_of_day                 =>  VALUES(5), &', &
'           minutes_of_the_hour         =>  VALUES(6), &', &
'           seconds_of_the_minute       =>  VALUES(7), &', &
'           milliseconds_of_the_second  =>  VALUES(8) )', &
'           if(hour_of_day.lt.6)  exit CALENDAR', &
'           if(hour_of_day.ge.18) exit CALENDAR', &
'           write(*,''(i4.4,"-",i2.2,"-",i2.2,"T", &', &
'           & i2.2,":",i2.2,":",i2.2,sp,i0.4)'')cal', &
'        end associate CALENDAR', &
'', &
'        end program show_exiting', &
'', &
'DESCRIPTION', &
'  An ASSOCIATE statement can rename syntactically complex data selectors with', &
'  simple or more descriptive aliases and also allows for simple names to be', &
'  used for the value of expressions at the top of the block (this value', &
'  becomes a constant in the code block). ASSOCIATE is thus used to make', &
'  complicated expressions more readable and maintainable by developers.', &
'', &
'  The ASSOCIATE construct creates a temporary association between a identifier', &
'  and a variable or the value of an expression. The association lasts for the', &
'  duration of the block.', &
'', &
'  Each ASSOCIATE statement must be followed by a matching END ASSOCIATE', &
'', &
'  The variable will have most, but not all of the attributes of the variable.', &
'', &
'  More specifically an ASSOCIATE statement either', &
'', &
'  1.  creates a name for a constant in the block using the value of an', &
'      expression defined in the ASSOCIATE statement.', &
'', &
'      or', &
'', &
'  2.  creates an alias for a long variable name. When the RHS is a variable', &
'      changing the alias value changes the associated name outside of the', &
'      block as well.', &
'', &
'      If the selector of an ASSOCIATE is a variable, the associate-name can be', &
'      changed in an ordinary assignment, which also changes the variable.', &
'', &
'  An alias for a variable is useful when you want to simplify multiple', &
'  accesses to a variable that has a lengthy description. An example would be', &
'  if the initial variable contains multiple subscripts and component names.', &
'', &
'  On the other hand an expression (instead of a variable) on the RHS becomes a', &
'  named constant in the block.', &
'', &
'  The ASSOCIATE statement is NOT equivalent to a function statement or a', &
'  macro. That would generally be implemented via a contained procedure.', &
'', &
'  o  If the selector is an expression or a variable that has a vector', &
'     subscript, the associate-name shall not appear in a variable definition', &
'     context but will behave as a constant, much like a parameter of a', &
'     procedure with INTENT(IN). That is, the associate-name cannot be changed', &
'     in an ordinary assignment.', &
'', &
'      Note: A vector subscript is an integer array expression of rank one,', &
'           designating a sequence of subscripts that correspond to the', &
'           values of the elements of the expression.', &
'', &
'           The sequence does not have to be in order, and may contain', &
'           duplicate values:', &
'', &
'              INTEGER A(10), B(3)', &
'              ! B(1) = A(1); B(2) = A(2); B(3) = A(2) also', &
'              B = A( [1,2,2] )', &
'', &
'  o  An associate-name shall not be the same as another associate-name in the', &
'     same associate-stmt.', &
'', &
'  o  The variable name on the RHS shall not be a coindexed object.', &
'', &
'  o  expr shall not be a variable. Note putting a variable in parentheses', &
'     makes it an expression.', &
'', &
'EXECUTION OF THE ASSOCIATE CONSTRUCT', &
'  Execution of an ASSOCIATE construct causes evaluation of every expression', &
'  used as a selector, followed by execution of its block.', &
'', &
'  During execution of the block within the construct, each associate-name', &
'  identifies an entity associated with the corresponding selector.', &
'', &
'  The associating entity assumes the declared type and type parameters of the', &
'  selector.', &
'', &
'  If and only if the selector is polymorphic, the associating entity is', &
'  polymorphic.', &
'', &
'ATTRIBUTES OF ASSOCIATE NAMES', &
'  Within an ASSOCIATE or SELECT TYPE construct, each associating entity has', &
'  the same rank and corank as its associated selector.', &
'', &
'  The lower bound of each dimension is the result of the intrinsic function', &
'  LBOUND(3f) applied to the corresponding dimension of selector.  The upper', &
'  bound of each dimension is one less than the sum of the lower bound and the', &
'  extent.', &
'', &
'  Sample showing affects on custom bounds:', &
'', &
'        program show_bounds', &
'        implicit none', &
'        character(len=*),parameter :: & ! a format', &
'        & bounds="(''bounds of '',a,''=>('',i0,'':'',i0,'','',i0,'':'',i0,'')'')"', &
'        integer :: arr(-5:5,-5:5) ! custom non-normal bounds', &
'        integer :: b(4)', &
'          ! first the different between queries of arr versus arr(:,:)', &
'           b([1,3,2,4])=[lbound(arr),ubound(arr)]', &
'           print bounds,''arr'', b', &
'           b([1,3,2,4])=[lbound(arr(:,:)),ubound(arr(:,:))]', &
'           print bounds,''arr(:,:)'',b', &
'          !', &
'          ! and the bounds assigned to the identifiers are what UBOUND(3f)', &
'          ! and LBOUND(3f) return given the selector as an argument so', &
'           associate ( &', &
'              alias=>   arr,       & ! keeps the custom bounds', &
'              normal=>  arr(:,:)   & ! gets normal bounds', &
'              )', &
'              b([1,3,2,4])=[lbound(alias),ubound(alias)]', &
'              print bounds,''alias'', b', &
'              b([1,3,2,4])=[lbound(normal),ubound(normal)]', &
'              print bounds,''normal'',b', &
'           end associate', &
'        end program show_bounds', &
'', &
'  Results:', &
'', &
'           bounds of arr=>(-5:5,-5:5)', &
'           bounds of arr(:,:)=>(1:11,1:11)', &
'           bounds of alias=>(-5:5,-5:5)', &
'           bounds of normal=>(1:11,1:11)', &
'', &
'  The cobounds of each codimension of the associating entity are the same as', &
'  those of the selector.', &
'', &
'  The associating entity has the ASYNCHRONOUS or VOLATILE attribute if and', &
'  only if the selector is a variable and has the attribute.', &
'', &
'  The associating entity has the TARGET attribute if and only if the selector', &
'  is a variable and has either the TARGET or POINTER attribute.', &
'', &
'  The selector must be allocated if allocatable. The associate-name is not', &
'  ALLOCATABLE even if the selector is.', &
'', &
'  If a selector has the POINTER attribute, it shall be associated. The', &
'  associate name is associated with the target of the pointer and does not', &
'  have the POINTER attribute.', &
'', &
'  If the associating entity is polymorphic, it assumes the dynamic type and', &
'  type parameter values of the selector.', &
'', &
'  If the selector has the OPTIONAL attribute, it shall be present (It cannot', &
'  be absent). The associating entity does not have the OPTIONAL attribute.', &
'', &
'  The associating entity is contiguous if and only if the selector is', &
'  contiguous.', &
'', &
'  If the selector is not permitted to appear in a variable definition context,', &
'  the associate name shall not appear in a variable definition context.', &
'', &
'  The selector has the TARGET attribute if and only if the selector is a', &
'  variable and has either the TARGET or POINTER attribute.', &
'', &
'  expr shall not be a designator of a procedure pointer or a function', &
'  reference that returns a procedure pointer.', &
'', &
'  Within an ASSOCIATE construct, each associating entity has the same corank', &
'  as its associated selector. If the selector is a coarray, the cobounds of', &
'  each codimension of the associating entity are the same as those of the', &
'  selector.', &
'', &
'  The associating entity itself is a variable, but if the selector is not a', &
'  definable variable, the associating entity is not definable and shall not be', &
'  defined or become undefined.', &
'', &
'  If a selector is not permitted to appear in a variable definition context,', &
'  neither the associate name nor any subobject thereof shall appear in a', &
'  variable definition context or pointer association context.', &
'', &
'NESTING', &
'  No other block may be created in an ASSOCIATE block that is not terminated', &
'  in the block; and the ASSOCIATE block must be terminated in the block it was', &
'  created in. For example, if an ASSOCIATE block is begun in a DO loop it must', &
'  be terminated before the end of the loop.  Conversely if a DO loop is', &
'  created in an ASSOCIATE block it must be terminated before the end of the', &
'  ASSOCIATE block.', &
'', &
'  An associate-name can appear in an ASSOCIATE statement even if it previously', &
'  appeared in an ASSOCIATE statement that has not been terminated.', &
'', &
'SAMPLES', &
'  The following shows association with an array section:', &
'', &
'        associate (array => ab % d(i, :) % x)', &
'          array(3) = array(1) + array(2)', &
'        end associate', &
'', &
'  instead of the equivalent statement', &
'', &
'        ab % d(i,3) % x = ab % d(i,1) % x + ab % d(i,2) % x', &
'', &
'  This example illustrates an association with an expression.', &
'', &
'          associate ( z => exp(-(x**2+y**2)) * cos(theta) )', &
'              ! creates the constant "z"', &
'              print *, a+z, a-z', &
'          end associate', &
'', &
'  an association with a derived-type variable:', &
'', &
'            associate ( xc => ax%b(i,j)%c )', &
'              xc%dv = xc%dv + product(xc%ev(1:n))', &
'            end associate', &
'', &
'  association with an array section:', &
'', &
'            associate ( quadrantIII =>  array(1:5,6:10) )', &
'              quadrantIII = 0', &
'            end associate', &
'', &
'  The next example illustrates multiple associations.', &
'', &
'            associate ( w => result(i,j)%w, &', &
'            & zx => ax%b(i,j)%d, &', &
'            & zy => ay%b(i,j)%d )', &
'              w = zx*x + zy*y', &
'            end associate', &
'', &
'  An ASSOCIATE block may not span other block boundaries', &
'', &
'      do i=1,3', &
'        associate (x => real(i)) !since this was started inside the DO loop', &
'           print*,i,sqrt(x)', &
'        end associate ! the end must appear before the end of the DO loop', &
'      enddo', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'        program demo_associate', &
'        implicit none', &
'        character(len=*),parameter :: g=''(*(g0,1x))''', &
'        character :: array(-5:5,-5:5)      ! custom non-normal bounds', &
'        ! note the different between queries of ARRAY versus ARRAY(:,:)', &
'          write(*,g)''array:    '',  ''lbound='',lbound(array), &', &
'                                    ''ubound='',ubound(array)', &
'          write(*,g)''array(:,:): '', ''lbound='',lbound(array(:,:)), &', &
'                                    ''ubound='',ubound(array(:,:))', &
'        ! the bounds assigned to the identifiers are what UBOUND(3f)', &
'        ! and LBOUND(3f) return given the selector as an argument', &
'          associate ( &', &
'           alias=>   array,              & ! keeps the custom bounds', &
'           normal=>  array(:,:),         & ! gets normal bounds', &
'           quadI=>   array(+1:+5,-5:-1), & ! quad* will have normal bounds', &
'           quadII=>  array(-5:-1,-5:-1), & !', &
'           quadIII=> array(-5:-1,+1:+5), & !', &
'           quadIV=>  array(+1:+5,+1:+5), & !', &
'           xaxis=>array(:,0), &', &
'           yaxis=>array(0,:) &', &
'           )', &
'           array=''.'' ! selector name is still valid in the block', &
'           xaxis=''-''', &
'           yaxis=''|''', &
'           alias(0,0)=''+'' ! uses non-normal bounds, equivalent to array(0,0)=''+''', &
'           write(*,''(11(g0,1x))'') alias', &
'           ! the quads have normalized dimension bounds (1:5,1:5):', &
'           quadI    =  ''1'';  quadI(1,1)    =  ''a'';  quadI(5,5)    =  ''A''', &
'           quadII   =  ''2'';  quadII(1,1)   =  ''b'';  quadII(5,5)   =  ''B''', &
'           quadIII  =  ''3'';  quadIII(1,1)  =  ''c'';  quadIII(5,5)  =  ''C''', &
'           quadIV   =  ''4'';  quadIV(1,1)   =  ''d'';  quadIV(5,5)   =  ''D''', &
'           write(*,''(11(g0,1x))'') alias', &
'           write(*,g)''array:  lbound='',lbound(array), ''ubound='',ubound(array)', &
'           write(*,g)''alias:  lbound='',lbound(alias), ''ubound='',ubound(alias)', &
'           write(*,g)''normal: lbound='',lbound(normal),''ubound='',ubound(normal)', &
'           write(*,g)''quadI:  lbound='',lbound(quadI), ''ubound='',ubound(quadI)', &
'           write(*,g)''quadII: lbound='',lbound(quadII),''ubound='',ubound(quadII)', &
'           write(*,g)''quadIV: lbound='',lbound(quadIV),''ubound='',ubound(quadIV)', &
'          end associate', &
'        end program demo_associate', &
'', &
'  Results:', &
'', &
'           array:      lbound= -5 -5 ubound= 5 5', &
'           array(:,:):  lbound= 1 1 ubound= 11 11', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           - - - - - + - - - - -', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           . . . . . | . . . . .', &
'           b 2 2 2 2 | a 1 1 1 1', &
'           2 2 2 2 2 | 1 1 1 1 1', &
'           2 2 2 2 2 | 1 1 1 1 1', &
'           2 2 2 2 2 | 1 1 1 1 1', &
'           2 2 2 2 B | 1 1 1 1 A', &
'           - - - - - + - - - - -', &
'           c 3 3 3 3 | d 4 4 4 4', &
'           3 3 3 3 3 | 4 4 4 4 4', &
'           3 3 3 3 3 | 4 4 4 4 4', &
'           3 3 3 3 3 | 4 4 4 4 4', &
'           3 3 3 3 C | 4 4 4 4 D', &
'           array:   lbound= -5 -5 ubound= 5 5', &
'           alias:   lbound= -5 -5 ubound= 5 5', &
'           normal:  lbound= 1 1 ubound= 11 11', &
'           quadI:   lbound= 1 1 ubound= 5 5', &
'           quadII:  lbound= 1 1 ubound= 5 5', &
'           quadIII: lbound= 1 1 ubound= 5 5', &
'           quadIV:  lbound= 1 1 ubound= 5 5', &
'', &
'  Dusty Corners', &
'', &
'  If the expressions have side-effects are they executed only when the block', &
'  is entered?', &
'', &
'  Selected variable names are still accessible in the ASSOCIATE block. This', &
'  is confusing and should be avoided, particular if the selectors are', &
'  allocatable or pointers. This is similiar to variables passed as arguments', &
'  to contained procedures but referenced via the argument name and the name in', &
'  the surrounding scope. The behavior is ill-defined. Does a change to the', &
'  argument take affect immediately or upon return from the procedure? If the', &
'  argument is not declared allocatable or is a pointer does the argument name', &
'  value get changed by deallocation or disassociation or changes to the', &
'  original names?', &
'', &
'  are you allowed to allocate v to a different size before the ASSOCIATE is', &
'  terminated? If so, what happens to c ?', &
'', &
'  Does that mean it is invalid to resize v within the ASSOCIATE block? Or is', &
'  it only invalid to resize v and then refer to c? Or only invalid to resize v', &
'  and refer to c when c is associated with elements of v that no longer exist?', &
'', &
'        implicit none', &
'        integer, allocatable, target :: v(:)', &
'        integer, pointer :: p(:)', &
'           v = [4,7,9]', &
'           p => v', &
'           print*,p', &
'           deallocate(v)', &
'           print*,p ! invalid, because target has been deallocated', &
'        end program main', &
'', &
'  are you allowed to allocate v to a different size before the ASSOCIATE is', &
'  terminated? If so, what happens to c?', &
'', &
'          program demonstrate_associate', &
'          implicit none', &
'          integer, allocatable :: v(:)', &
'          v = [3,4]', &
'', &
'          associate (c => v) ; call disp("1",v,c)', &
'          c = c*10           ; call disp("2",v,c)', &
'          v = [2,4,6]        ; call disp("3",v,c)', &
'          c = c*10           ; call disp("4",v,c)', &
'          v = [2]            ; call disp("5",v,c)', &
'          end associate', &
'', &
'          contains', &
'', &
'          subroutine disp(label,v,c)', &
'          character (len=*), intent(in) :: label', &
'          integer, intent(in) :: v(:),c(:)', &
'             write (*,"(a,'' v = '',*(1x,i0))",advance="no") label,v', &
'             write (*,"(3x,''c = '',*(1x,i0))") c', &
'          end subroutine disp', &
'', &
'          end program demonstrate_associate', &
'', &
'COMPARISONS TO OTHER CONSTRUCTS', &
'  When is it not true that', &
'', &
'        associate (a=>AA)', &
'        end associate', &
'', &
'  is equivalent to', &
'', &
'        call assoc(AA)', &
'        contains', &
'        subroutine assoc(a)', &
'        type(type(a)),intent(in) :: a(..) ! if a in an expression', &
'        type(type(a))            :: a(..) ! if a in a variable', &
'        end subroutine assoc', &
'        ! somewhat like the parameters being class(*) but without all the', &
'        ! SELECT statements like type(type(a)) worked.', &
'', &
'        ! so "a" in the subroutine does not have the allocatable, optional,', &
'        ! or pointer attributes even if AA did, and it is up to the programmer', &
'        ! to make sure AA is allocated or assigned a target or present if', &
'        ! optional when making the call if it has those attributes.', &
'', &
'        ! but it can have the target attribute.', &
'', &
'SEE ALSO', &
'  o  DO(3) - construct', &
'', &
'  o  IF(3) - selects a block based on a sequence of logical expressions.', &
'', &
'  o  CYCLE(3) - construct', &
'', &
'  o  EXIT(3) - statement', &
'', &
'  o  ASSOCIATE(3) - associate construct', &
'', &
'  o  BLOCK(3) - construct', &
'', &
'  o  GOTO(3) - jump to target line', &
'', &
'  o  SELECT(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  CASE(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  ENDSELECT(3) - select a block based on the value of an expression (a', &
'     case)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025             associate(7fortran)', &
'']

shortname="associate"
call process()

case('20','associated')

textblock=[character(len=256) :: &
'', &
'associated(3fortran)                                     associated(3fortran)', &
'', &
'NAME', &
'  ASSOCIATED(3) - [STATE:INQUIRY] Association status of a pointer or', &
'  pointer/target pair', &
'', &
'SYNOPSIS', &
'  result = associated(pointer [,target])', &
'', &
'          logical function associated(pointer,target)', &
'', &
'           type(TYPE(kind=KIND)),pointer :: pointer', &
'           type(TYPE(kind=KIND)),pointer,optional :: target', &
'', &
'CHARACTERISTICS', &
'  o  POINTER shall have the pointer attribute and it can be any type or may be', &
'     a procedure pointer', &
'', &
'  o  TARGET shall be a pointer or a target. It must have the same type, kind', &
'     type parameter, and array rank as POINTER.', &
'', &
'  o  The association status of neither POINTER nor TARGET shall be undefined.', &
'', &
'  o  the result is a default logical value', &
'', &
'DESCRIPTION', &
'  ASSOCIATED(3) determines the status of the pointer POINTER or if POINTER is', &
'  associated with the target TARGET.', &
'', &
'OPTIONS', &
'  o  POINTER : A pointer to test for association. Its pointer association', &
'     status shall not be undefined.', &
'', &
'  o  TARGET : A target that is to be tested for occupying the same storage', &
'     units as the pointer POINTER. That is, it is tested as to whether it is', &
'     pointed to by POINTER.', &
'', &
'RESULT', &
'  ASSOCIATED(3) returns a scalar value of type logical. There are several', &
'  cases:', &
'', &
'  1.  When the optional TARGET is not present then ASSOCIATED(POINTER) is', &
'      .true. if POINTER is associated with a target; otherwise, it returns', &
'      .false..', &
'', &
'  2.  If TARGET is present and a scalar target, the result is .true. if TARGET', &
'      is not a zero-sized storage sequence and the target associated with', &
'      POINTER occupies the same storage units. If POINTER is disassociated,', &
'      the result is .false..', &
'', &
'  3.  If TARGET is present and an array target, the result is .true. if TARGET', &
'      and POINTER have the same shape, are not zero-sized arrays, are arrays', &
'      whose elements are not zero-sized storage sequences, and TARGET and', &
'      POINTER occupy the same storage units in array element order.', &
'', &
'      As in case 2, the result is .false., if POINTER is disassociated.', &
'', &
'  4.  If TARGET is present and an scalar pointer, the result is .true. if', &
'      TARGET is associated with POINTER, the target associated with TARGET are', &
'      not zero-sized storage sequences and occupy the same storage units.', &
'', &
'      The result is .false., if either TARGET or POINTER is disassociated.', &
'', &
'  5.  If TARGET is present and an array pointer, the result is .true. if', &
'      target associated with POINTER and the target associated with TARGET', &
'      have the same shape, are not zero-sized arrays, are arrays whose', &
'      elements are not zero-sized storage sequences, and TARGET and POINTER', &
'      occupy the same storage units in array element order.', &
'', &
'  6.  If TARGET is present and is a procedure, the result is true if and only', &
'      if POINTER is associated with TARGET and, if TARGET is an internal', &
'      procedure, they have the same host instance.', &
'', &
'  7.  If TARGET is present and is a procedure pointer, the result is true if', &
'      and only if POINTER and TARGET are associated with the same procedure', &
'      and, if the procedure is an internal procedure, they have the same host', &
'      instance.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_associated', &
'      implicit none', &
'      real, target  :: tgt(2) = [1., 2.]', &
'      real, pointer :: ptr(:)', &
'        ptr => tgt', &
'        if (associated(ptr)     .eqv. .false.) &', &
'        & stop ''POINTER NOT ASSOCIATED''', &
'        if (associated(ptr,tgt) .eqv. .false.) &', &
'        & stop ''POINTER NOT ASSOCIATED TO TARGET''', &
'        if (associated(ptr) ) &', &
'        & print *, ''POINTER ASSOCIATED''', &
'        if (associated(ptr,tgt) ) &', &
'        & print *, ''POINTER ASSOCIATED TO TARGET''', &
'      end program demo_associated', &
'', &
'  Results:', &
'', &
'       >  POINTER ASSOCIATED', &
'       >  POINTER ASSOCIATED TO TARGET', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  NULL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025            associated(3fortran)', &
'']

shortname="associated"
call process()

case('21','atan2')

textblock=[character(len=256) :: &
'', &
'atan2(3fortran)                                               atan2(3fortran)', &
'', &
'NAME', &
'  ATAN2(3) - [MATHEMATICS:TRIGONOMETRIC] Arctangent (inverse tangent) function', &
'', &
'SYNOPSIS', &
'  result = atan2(y, x)', &
'', &
'          elemental real(kind=KIND) function atan2(y, x)', &
'', &
'           real,kind=KIND)            :: atan2', &
'           real,kind=KIND),intent(in) :: y, x', &
'', &
'CHARACTERISTICS', &
'  o  X and Y must be reals of the same kind.', &
'', &
'  o  The return value has the same type and kind as Y and X.', &
'', &
'DESCRIPTION', &
'  ATAN2(3) computes in radians a processor-dependent approximation of the', &
'  arctangent of the complex number ( X, Y ) or equivalently the principal', &
'  value of the arctangent of the value Y/X (which determines a unique angle).', &
'', &
'  If Y has the value zero, X shall not have the value zero.', &
'', &
'  The resulting phase lies in the range', &
'', &
'       -PI <= ATAN2 (Y,X) <= PI', &
'', &
'  and is equal to a processor-dependent approximation to a value of', &
'  arctan(Y/X).', &
'', &
'OPTIONS', &
'  o  Y : The imaginary component of the complex value (X,Y) or the Y component', &
'     of the point <X,Y>.', &
'', &
'  o  X : The real component of the complex value (X,Y) or the X component of', &
'     the point <X,Y>.', &
'', &
'RESULT', &
'  The value returned is by definition the principal value of the complex', &
'  number (X, Y), or in other terms, the phase of the phasor x+i*y.', &
'', &
'  The principal value is simply what we get when we adjust a radian value to', &
'  lie between -PI and PI inclusive,', &
'', &
'  The classic definition of the arctangent is the angle that is formed in', &
'  Cartesian coordinates of the line from the origin point <0,0> to the point', &
'  <X,Y> .', &
'', &
'  Pictured as a vector it is easy to see that if X and Y are both zero the', &
'  angle is indeterminate because it sits directly over the origin, so', &
'  ATAN(0.0,0.0) will produce an error.', &
'', &
'  Range of returned values by quadrant:', &
'', &
'      >                  +PI/2', &
'      >                    |', &
'      >                    |', &
'      >     PI/2 < z < PI   |  0 > z < PI/2', &
'      >                    |', &
'      >   +-PI -------------+---------------- +-0', &
'      >                    |', &
'      >     PI/2 < -z < PI  |  0 < -z < PI/2', &
'      >                    |', &
'      >                    |', &
'      >                  -PI/2', &
'      >', &
'        NOTES:', &
'', &
'        If the processor distinguishes -0 and +0 then the sign of the', &
'        returned value is that of Y when Y is zero, else when Y is zero', &
'        the returned value is always positive.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan2', &
'      real    :: z', &
'      complex :: c', &
'       !', &
'       ! basic usage', &
'       ! ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately).', &
'       z=atan2(1.5574077, 1.0)', &
'       write(*,*) ''radians='',z,''degrees='',r2d(z)', &
'       !', &
'       ! elemental : arrays', &
'       write(*,*)''elemental'',atan2( [10.0, 20.0], [30.0,40.0] )', &
'       !', &
'       ! elemental : arrays and scalars', &
'       write(*,*)''elemental'',atan2( [10.0, 20.0], 50.0 )', &
'       !', &
'       ! break complex values into real and imaginary components', &
'       ! (note TAN2() can take a complex type value )', &
'       c=(0.0,1.0)', &
'       write(*,*)''complex'',c,atan2( x=c%re, y=c%im )', &
'       !', &
'       ! extended sample converting cartesian coordinates to polar', &
'       COMPLEX_VALS: block', &
'       real                :: ang, radius', &
'       complex,allocatable :: vals(:)', &
'       integer             :: i', &
'       !', &
'       vals=[ &', &
'         !     0            45            90           135', &
'         ( 1.0, 0.0 ), ( 1.0, 1.0 ), ( 0.0, 1.0 ), (-1.0, 1.0 ), &', &
'         !    180           225          270', &
'         (-1.0, 0.0 ), (-1.0,-1.0 ), ( 0.0,-1.0 ) ]', &
'       do i=1,size(vals)', &
'          call cartesian_to_polar(vals(i), radius,ang)', &
'          write(*,101)vals(i),ang,r2d(ang),radius', &
'       enddo', &
'       101 format( ''X='',f5.2,'' Y='',f5.2,'' ANGLE='',g0, &', &
'       & T38,''DEGREES='',g0.4, T54,''DISTANCE='',g0)', &
'       endblock COMPLEX_VALS', &
'      !', &
'      contains', &
'      !', &
'      elemental real function r2d(radians)', &
'      ! input radians to convert to degrees', &
'      doubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians', &
'      real,intent(in)          :: radians', &
'        r2d=radians / DEGREE ! do the conversion', &
'      end function r2d', &
'      !', &
'      subroutine cartesian_to_polar(xy,radius,inclination)', &
'      ! return angle in radians in range 0 to 2*PI', &
'      implicit none', &
'      complex,intent(in)  :: xy', &
'      real,intent(out) :: radius,inclination', &
'        radius=abs( xy )', &
'        ! arbitrarily set angle to zero when radius is zero', &
'        inclination=merge(0.0,atan2(x=xy%re, y=xy%im),radius==0.0)', &
'        ! bring into range 0 <= inclination < 2*PI', &
'        if(inclination < 0.0)inclination=inclination+2*atan2(0.0d0,-1.0d0)', &
'      end subroutine cartesian_to_polar', &
'      !', &
'      end program demo_atan2', &
'', &
'      Results:', &
'', &
'       >  radians=   1.00000000     degrees=   57.2957802', &
'       >  elemental  0.321750551      0.463647604', &
'       >  elemental  0.197395563      0.380506366', &
'       >  complex            (0.00000000,1.00000000)   1.57079637', &
'       > X= 1.00 Y= 0.00 ANGLE= 0.00000000  DEGREES= 0.000 DISTANCE=1.00000000', &
'       > X= 1.00 Y= 1.00 ANGLE= 0.785398185 DEGREES= 45.00 DISTANCE=1.41421354', &
'       > X= 0.00 Y= 1.00 ANGLE= 1.57079637  DEGREES= 90.00 DISTANCE=1.00000000', &
'       > X=-1.00 Y= 1.00 ANGLE= 2.35619450  DEGREES= 135.0 DISTANCE=1.41421354', &
'       > X=-1.00 Y= 0.00 ANGLE= 3.14159274  DEGREES= 180.0 DISTANCE=1.00000000', &
'       > X=-1.00 Y=-1.00 ANGLE= 3.92699075  DEGREES= 225.0 DISTANCE=1.41421354', &
'       > X= 0.00 Y=-1.00 ANGLE= 4.71238899  DEGREES= 270.0 DISTANCE=1.00000000', &
'', &
'      # STANDARD', &
'', &
'      FORTRAN 77', &
'', &
'      # SEE ALSO', &
'', &
'      - [**atan**(3)](#atan)', &
'      - [**tan**(3)](#tan)', &
'      - [**tan2**(3)](#tan2)', &
'', &
'      # RESOURCES', &
'', &
'      - [arctan:wikipedia]', &
'       (https://en.wikipedia.org/wiki/Inverse_trigonometric_functions)', &
'       _Fortran intrinsic descriptions (license: MIT) \@urbanjost_', &
'', &
'                               March 16, 2025                 atan2(3fortran)', &
'']

shortname="atan2"
call process()

case('22','atan2d')

textblock=[character(len=256) :: &
'', &
'atan2d(3fortran)                                             atan2d(3fortran)', &
'', &
'NAME', &
'  ATAN2D(3) - [MATHEMATICS:TRIGONOMETRIC] Arc tangent function in degrees', &
'  (inverse tangent)', &
'', &
'SYNOPSIS', &
'  result = atan2d(y, x)', &
'', &
'          elemental real(kind=KIND) function atan2d(y, x)', &
'', &
'           real,kind=KIND) :: atan2d', &
'           real,kind=KIND),intent(in) :: y, x', &
'', &
'CHARACTERISTICS', &
'  o  X and Y must be reals of the same kind.', &
'', &
'  o  The return value has the same type and kind as Y and X.', &
'', &
'DESCRIPTION', &
'  ATAN2D(3) computes in degrees a processor-dependent approximation of the', &
'  arctangent of the principal value of the arctangent of the value Y/X (which', &
'  determines a unique angle).', &
'', &
'  If Y has the value zero, X shall not have the value zero.', &
'', &
'  The resulting phase lies in the range -180 <= atan2d (Y,X) <= 180 and is', &
'  equal to a processor-dependent approximation to a value of arctan(Y/X)', &
'  expressed in degrees.', &
'', &
'  It is equivalent to ATAN2(Y, X)*180/PI but limited to real values.', &
'', &
'OPTIONS', &
'  o  Y : The imaginary component of the complex value (X,Y) or the Y component', &
'     of the point <X,Y>.', &
'', &
'  o  X : The real component of the complex value (X,Y) or the X component of', &
'     the point <X,Y>.', &
'', &
'RESULT', &
'  The result is in degrees, not radians.', &
'', &
'  The radian value is by definition the principal value of the complex number', &
'  (X, Y), or in other terms, the phase of the phasor x+i*y.', &
'', &
'  The principal value is simply what we get when we adjust the value to lie', &
'  between -180 and 180 degrees inclusive,', &
'', &
'  The classic definition of the arctangent is the angle that is formed in', &
'  Cartesian coordinates of the line from the origin point <0,0> to the point', &
'  <X,Y> .', &
'', &
'  Pictured as a vector it is easy to see that if X and Y are both zero the', &
'  angle is indeterminate because it sits directly over the origin, so', &
'  ATAN2D(0.0,0.0) will produce an error.', &
'', &
'  Range of returned values by quadrant:', &
'', &
'      >                  +90', &
'      >                    |', &
'      >                    |', &
'      >     90 < z < 180    |  0 > z < 90', &
'      >                    |', &
'      >   +-180 ------------+---------------- +-0', &
'      >                    |', &
'      >     90 < -z < 180   |  0 < -z < 90', &
'      >                    |', &
'      >                    |', &
'      >                  -90', &
'      >', &
'          NOTES:', &
'', &
'          If the processor distinguishes -0 and +0 then the sign of the', &
'          returned value is that of Y when Y is zero, else when Y is zero', &
'          the returned value is always positive.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan2d', &
'      implicit none', &
'      integer,parameter  :: wp=kind(0.0)', &
'      real(wp),parameter :: d2r=acos(-1.0_wp)/180.0_wp', &
'      real :: z', &
'      complex :: c', &
'       !', &
'       ! basic usage', &
'       ! atan2d (1.5574077, 1.0) has the value 1.0 radian (approximately).', &
'       z=atan2d(1.5574077, 1.0)', &
'       write(*,*) ''degrees='',z,''radians='',d2r*z', &
'       !', &
'       ! elemental arrays', &
'       write(*,*)''elemental'',atan2d( [10.0, 20.0], [30.0,40.0] )', &
'       !', &
'       ! elemental arrays and scalars', &
'       write(*,*)''elemental'',atan2d( [10.0, 20.0], 50.0 )', &
'       !', &
'       ! multi-dimensional returns multi-dimensional', &
'       write(*,*) atan2(reshape([1.0,1.0,1.0,1.0],[2,2]),&', &
'       & reshape([1.0,1.0,1.0,1.0],[2,2]) )', &
'       !', &
'       ! break complex values into real and imaginary components', &
'       c=(0.0,1.0)', &
'       write(*,*)''complex value treated as components'', &', &
'       & c,atan2d( x=c%re, y=c%im )', &
'       !', &
'       ! extended sample', &
'       COMPLEX_VALS: block', &
'       real                :: ang', &
'       complex,allocatable :: vals(:)', &
'       integer             :: i', &
'       !', &
'       vals=[ &', &
'         ( 1.0, 0.0 ), & ! 0', &
'         ( 1.0, 1.0 ), & ! 45', &
'         ( 0.0, 1.0 ), & ! 90', &
'         (-1.0, 1.0 ), & ! 135', &
'         (-1.0, 0.0 ), & ! 180', &
'         (-1.0,-1.0 ), & ! 225', &
'         ( 0.0,-1.0 )]   ! 270', &
'       do i=1,size(vals)', &
'          ang=atan2d(vals(i)%im, vals(i)%re)', &
'          write(*,101)vals(i),ang,d2r*ang', &
'       enddo', &
'       101 format(             &', &
'       & ''X= '',f5.2,         &', &
'       & '' Y= '',f5.2,                &', &
'       & '' ANGLE= '',g0,      &', &
'       & T38,''RADIANS= '',g0.4)', &
'       endblock COMPLEX_VALS', &
'      !', &
'      end program demo_atan2d', &
'', &
'  Results:', &
'', &
'       >  degrees=   57.2957802     radians=   1.00000000', &
'       >  elemental   18.4349480       26.5650520', &
'       >  elemental   11.3099327       21.8014107', &
'       >   0.785398185 0.785398185 0.785398185  0.785398185', &
'       >  complex value treated as components (0.0000,1.0000) 90.000', &
'       > X=  1.00 Y=  0.00 ANGLE= 0.00000000  RADIANS= 0.000', &
'       > X=  1.00 Y=  1.00 ANGLE= 45.0000000  RADIANS= 0.7854', &
'       > X=  0.00 Y=  1.00 ANGLE= 90.0000000  RADIANS= 1.571', &
'       > X= -1.00 Y=  1.00 ANGLE= 135.000000  RADIANS= 2.356', &
'       > X= -1.00 Y=  0.00 ANGLE= 180.000000  RADIANS= 3.142', &
'       > X= -1.00 Y= -1.00 ANGLE= -135.000000 RADIANS= -2.356', &
'       > X=  0.00 Y= -1.00 ANGLE= -90.0000000 RADIANS= -1.571', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  ATAN(3)', &
'', &
'  o  ATANPI(3)', &
'', &
'RESOURCES', &
'  o  arctan:wikipedia', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                atan2d(3fortran)', &
'']

shortname="atan2d"
call process()

case('23','atan2pi')

textblock=[character(len=256) :: &
'', &
'atan2pi(3fortran)                                           atan2pi(3fortran)', &
'', &
'NAME', &
'  ATAN2PI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular Arc tangent (inverse', &
'  tangent) function', &
'', &
'SYNOPSIS', &
'  result = atan2pi(y, x)', &
'', &
'          elemental real(kind=KIND) function atan2pi(y, x)', &
'', &
'           real,kind=KIND) :: atan2pi', &
'           real,kind=KIND),intent(in) :: y, x', &
'', &
'CHARACTERISTICS', &
'  o  X and Y must be reals of the same kind.', &
'', &
'  o  The return value has the same type and kind as Y and X.', &
'', &
'DESCRIPTION', &
'  ATAN2PI(3) computes in half-revolutions a processor-dependent approximation', &
'  of the arctangent of the components of the complex number ( X, Y ) or', &
'  equivalently the principal value of the arctangent of the value Y/X (which', &
'  determines a unique angle).', &
'', &
'  If Y has the value zero, X shall not have the value zero.', &
'', &
'  The resulting phase lies in the range -1 <= atan2pi (Y,X) <= 1 and is equal', &
'  to a processor-dependent approximation to a value of arctan(Y/X).', &
'', &
'OPTIONS', &
'  o  Y : The imaginary component of the complex value (X,Y) or the Y component', &
'     of the point <X,Y>.', &
'', &
'  o  X : The real component of the complex value (X,Y) or the X component of', &
'     the point <X,Y>.', &
'', &
'RESULT', &
'  The value returned is by definition the principal value of the complex', &
'  number (X, Y), or in other terms, the phase of the phasor x+i*y.', &
'', &
'  The principal value is simply what we get when we adjust an angular half-', &
'  revolution value to lie between -1 and 1 inclusive,', &
'', &
'  The classic definition of the arctangent is the angle that is formed in', &
'  Cartesian coordinates of the line from the origin point <0,0> to the point', &
'  <X,Y> .', &
'', &
'  Pictured as a vector it is easy to see that if X and Y are both zero the', &
'  angle is indeterminate because it sits directly over the origin, so', &
'  ATAN(0.0,0.0) will produce an error.', &
'', &
'  Range of returned values by quadrant:', &
'', &
'      >                  +1/2', &
'      >                    |', &
'      >                    |', &
'      >       1/2 < z < 1   |  0 > z < 1/2', &
'      >                    |', &
'      >    +-1 -------------+---------------- +-0', &
'      >                    |', &
'      >       1/2 < -z < 1  |  0 < -z < 1/2', &
'      >                    |', &
'      >                    |', &
'      >                  -1/2', &
'      >', &
'          NOTES:', &
'', &
'          If the processor distinguishes -0 and +0 then the sign of the', &
'          returned value is that of Y when Y is zero, else when Y is zero', &
'          the returned value is always positive.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan2pi', &
'      real :: z', &
'      complex :: c', &
'      real, parameter :: h2d = 180.0', &
'       !', &
'       ! basic usage', &
'       ! atan2pi (1.5574077, 1.0) has the value 1.0 (approximately).', &
'       z=atan2pi(1.5574077, 1.0)', &
'       write(*,*) ''half-revolutions='',z,''degrees='',h2d*z', &
'       !', &
'       ! elemental arrays', &
'       write(*,*)''elemental'',atan2pi( [10.0, 20.0], [30.0,40.0] )', &
'       !', &
'       ! elemental arrays and scalars', &
'       write(*,*)''elemental'',atan2pi( [10.0, 20.0], 50.0 )', &
'       !', &
'       ! break complex values into real and imaginary components', &
'       ! (note TAN2() can take a complex type value )', &
'       c=(0.0,1.0)', &
'       write(*,*)''complex'',c,atan2pi( x=c%re, y=c%im )', &
'       !', &
'       ! extended sample converting cartesian coordinates to polar', &
'       COMPLEX_VALS: block', &
'       real                :: ang', &
'       complex,allocatable :: vals(:)', &
'       integer             :: i', &
'       !', &
'       vals=[ &', &
'         ( 1.0, 0.0 ), & ! 0', &
'         ( 1.0, 1.0 ), & ! 45', &
'         ( 0.0, 1.0 ), & ! 90', &
'         (-1.0, 1.0 ), & ! 135', &
'         (-1.0, 0.0 ), & ! 180', &
'         (-1.0,-1.0 ), & ! 225', &
'         ( 0.0,-1.0 )]   ! 270', &
'         write(*,''(a)'')repeat(''1234567890'',8)', &
'       do i=1,size(vals)', &
'          ang=atan2pi(vals(i)%im,vals(i)%re)', &
'          write(*,101)vals(i),ang,h2d*ang', &
'       enddo', &
'       101 format(             &', &
'       & ''X= '',f5.2,         &', &
'       & '' Y= '',f5.2,                &', &
'       & '' HALF-REVOLUTIONS= '',f7.3,      &', &
'       & T50,'' DEGREES= '',g0.4)', &
'       endblock COMPLEX_VALS', &
'      !', &
'      end program demo_atan2pi', &
'', &
'  Results:', &
'', &
'       >  half-revolutions=  0.318309873     degrees=  57.2957764', &
'       >  elemental  0.102416381      0.147583619', &
'       >  elemental   6.28329590E-02  0.121118948', &
'       >  complex            (0.00000000,1.00000000)  0.500000000', &
'       > X=  1.00 Y=  0.00 HALF-REVOLUTIONS=   0.000      DEGREES= 0.000', &
'       > X=  1.00 Y=  1.00 HALF-REVOLUTIONS=   0.250      DEGREES= 45.00', &
'       > X=  0.00 Y=  1.00 HALF-REVOLUTIONS=   0.500      DEGREES= 90.00', &
'       > X= -1.00 Y=  1.00 HALF-REVOLUTIONS=   0.750      DEGREES= 135.0', &
'       > X= -1.00 Y=  0.00 HALF-REVOLUTIONS=   1.000      DEGREES= 180.0', &
'       > X= -1.00 Y= -1.00 HALF-REVOLUTIONS=  -0.750      DEGREES= -135.0', &
'       > X=  0.00 Y= -1.00 HALF-REVOLUTIONS=  -0.500      DEGREES= -90.00', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  ATAN(3)', &
'', &
'RESOURCES', &
'  o  arctan:wikipedia Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               atan2pi(3fortran)', &
'']

shortname="atan2pi"
call process()

case('24','atan')

textblock=[character(len=256) :: &
'', &
'atan(3fortran)                                                 atan(3fortran)', &
'', &
'NAME', &
'  ATAN(3) - [MATHEMATICS:TRIGONOMETRIC] Arctangent AKA inverse tangent', &
'  function', &
'', &
'SYNOPSIS', &
'  result = atan([x) | atan(y, x)', &
'', &
'          elemental TYPE(kind=KIND) function atan(y,x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'           TYPE(kind=**),intent(in),optional :: y', &
'', &
'CHARACTERISTICS', &
'  o  If Y is present X and Y must both be real. Otherwise, X may be complex.', &
'', &
'  o  KIND can be any kind supported by the associated type.', &
'', &
'  o  The returned value is of the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  ATAN(3) computes the arctangent of X.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the arctangent of. if Y is present, X shall be', &
'     real.', &
'', &
'  o  Y : is of the same type and kind as X. If X is zero, Y must not be zero.', &
'', &
'RESULT', &
'  The returned value is of the same type and kind as X. If Y is present, the', &
'  result is identical to ATAN2(Y,X). Otherwise, it is the arc tangent of X,', &
'  where the real part of the result is in radians and lies in the range -PI/2', &
'  <= ATAN(X) <= PI/2', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atan', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64),parameter :: &', &
'       Deg_Per_Rad = 57.2957795130823208767981548_real64', &
'      real(kind=real64) :: x', &
'         x=2.866_real64', &
'         print all, atan(x)', &
'', &
'         print all, atan( 2.0d0, 2.0d0),atan( 2.0d0, 2.0d0)*Deg_Per_Rad', &
'         print all, atan( 2.0d0,-2.0d0),atan( 2.0d0,-2.0d0)*Deg_Per_Rad', &
'         print all, atan(-2.0d0, 2.0d0),atan(-2.0d0, 2.0d0)*Deg_Per_Rad', &
'         print all, atan(-2.0d0,-2.0d0),atan(-2.0d0,-2.0d0)*Deg_Per_Rad', &
'', &
'      end program demo_atan', &
'', &
'  Results:', &
'', &
'       > 1.235085437457879', &
'       > .7853981633974483 45.00000000000000', &
'       > 2.356194490192345 135.0000000000000', &
'       > -.7853981633974483 -45.00000000000000', &
'       > -2.356194490192345 -135.0000000000000', &
'', &
'STANDARD', &
'  FORTRAN 77 for a complex argument; and for two arguments Fortran 2008', &
'', &
'SEE ALSO', &
'  ATAN2(3), TAN(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  atan(3fortran)', &
'']

shortname="atan"
call process()

case('25','atand')

textblock=[character(len=256) :: &
'', &
'atand(3fortran)                                               atand(3fortran)', &
'', &
'NAME', &
'  ATAND(3) - [MATHEMATICS:TRIGONOMETRIC] Arc tangent AKA inverse tangent', &
'  function in degrees', &
'', &
'SYNOPSIS', &
'  result = atand(x) | atand(y, x)', &
'', &
'          elemental real(kind=KIND) function atand(y,x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'           real(kind=**),intent(in),optional :: y', &
'', &
'CHARACTERISTICS', &
'  o  If Y is present X and Y must both be of the same kind.', &
'', &
'  o  KIND can be any kind supported by the associated type.', &
'', &
'  o  The returned value is real of the same kind as X.', &
'', &
'DESCRIPTION', &
'  ATAND(3) calculates the Arc Tangent function in degrees.', &
'', &
'OPTIONS', &
'  o  X : The real value to compute the arctangent of.', &
'', &
'  o  Y : is real of the same kind as X. If X is zero, Y must not be zero.', &
'', &
'RESULT', &
'  The returned value is a real type of the same kind as X that approximates', &
'  the arc tangent of X expressed in degrees. If Y is present, the result is', &
'  identical to ATAN2D(Y,X). The result lies in the range -90 <= ATAND(X) <= 90', &
'  .', &
'', &
'EXAMPLES', &
'  atand(1.0) has the value 45.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_atand', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64),parameter :: &', &
'       Deg_Per_Rad = 57.2957795130823208767981548_real64', &
'      real(kind=real64) :: x', &
'         x=2.866_real64', &
'         print all, atand(x)', &
'', &
'         print all, atand( 2.0d0, 2.0d0),atand( 2.0d0, 2.0d0)/Deg_Per_Rad', &
'         print all, atand( 2.0d0,-2.0d0),atand( 2.0d0,-2.0d0)/Deg_Per_Rad', &
'         print all, atand(-2.0d0, 2.0d0),atand(-2.0d0, 2.0d0)/Deg_Per_Rad', &
'         print all, atand(-2.0d0,-2.0d0),atand(-2.0d0,-2.0d0)/Deg_Per_Rad', &
'', &
'      end program demo_atand', &
'', &
'  Results:', &
'', &
'       > 70.765182904405478', &
'       > 45.000000000000000 0.78539816339744828', &
'       > 135.00000000000000 2.3561944901923448', &
'       > -45.000000000000000 -0.78539816339744828', &
'       > -135.00000000000000 -2.3561944901923448', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ATAN2D(3), TAND(3), ATAN2(3), TAN(3), ATAN2PI(3), TANPI(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 atand(3fortran)', &
'']

shortname="atand"
call process()

case('26','atanh')

textblock=[character(len=256) :: &
'', &
'atanh(3fortran)                                               atanh(3fortran)', &
'', &
'NAME', &
'  ATANH(3) - [MATHEMATICS:TRIGONOMETRIC] Inverse hyperbolic tangent function', &
'', &
'SYNOPSIS', &
'  result = atanh(x)', &
'', &
'          elemental TYPE(kind=KIND) function atanh(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be real or complex of any associated type', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  ATANH(3) computes the inverse hyperbolic tangent of X.', &
'', &
'OPTIONS', &
'  o  X : The type shall be real or complex.', &
'', &
'RESULT', &
'  The return value has same type and kind as X. If X is complex, the imaginary', &
'  part of the result is in radians and lies between', &
'', &
'            -PI/2 <= aimag(atanh(x)) <= PI/2', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atanh', &
'      implicit none', &
'      real, dimension(3) :: x = [ -1.0, 0.0, 1.0 ]', &
'', &
'        write (*,*) atanh(x)', &
'', &
'      end program demo_atanh', &
'', &
'  Results:', &
'', &
'       >       -Infinity  0.0000000E+00       Infinity', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: TANH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 atanh(3fortran)', &
'']

shortname="atanh"
call process()

case('27','atanpi')

textblock=[character(len=256) :: &
'', &
'atanpi(3fortran)                                             atanpi(3fortran)', &
'', &
'NAME', &
'  ATANPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular Arctangent AKA inverse', &
'  tangent function', &
'', &
'SYNOPSIS', &
'  result = atanpi([x) | atanpi(y, x)', &
'', &
'          elemental real(kind=KIND) function atanpi(y,x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'           real(kind=KIND),intent(in),optional :: y', &
'', &
'CHARACTERISTICS', &
'  o  Y and X must both be real and of the same KIND', &
'', &
'  o  KIND can be any kind supported by the real type.', &
'', &
'  o  The returned value is of the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  ATAN(3) computes the circular arctangent of X in half-revolutions.', &
'', &
'  If Y appears, the result is the same as the result of ATAN2PI(Y,X). If Y', &
'  does not appear, the result has a value equal to a processor-dependent', &
'  approximation to the arc tangent of X; it is expressed in half-revolutions', &
'  and lies in the range -0.5 <= ATANPI(X) <= 0.5.', &
'', &
'  Example. ATANPI(1.0) has the value 0.25 (approximately).', &
'', &
'OPTIONS', &
'  o  X : The real value to compute the arctangent of.', &
'', &
'  o  Y : is of the same type and kind as X. If X is zero, Y must not be zero.', &
'', &
'RESULT', &
'  The returned value is of the same type and kind as X. If Y is present, the', &
'  result is identical to ATAN2PI(Y,X). Otherwise, it is the arc tangent of X,', &
'  where the result is in half-revolutions and lies in the range -1 <= ATAN(X)', &
'  <= 1', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atanpi', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      real(kind=real64) :: x, y', &
'         x=2.866_real64', &
'         print all, atanpi(x)', &
'', &
'         print all, atanpi( 2.0d0, 2.0d0),atanpi( 2.0d0, 2.0d0)*180', &
'         print all, atanpi( 2.0d0,-2.0d0),atanpi( 2.0d0,-2.0d0)*180', &
'         print all, atanpi(-2.0d0, 2.0d0),atanpi(-2.0d0, 2.0d0)*180', &
'         print all, atanpi(-2.0d0,-2.0d0),atanpi(-2.0d0,-2.0d0)*180', &
'', &
'      end program demo_atanpi', &
'', &
'  Results:', &
'', &
'       > 0.39313990502447488', &
'       > 0.25000000000000000 45.000000000000000', &
'       > 0.75000000000000000 135.00000000000000', &
'       > -0.25000000000000000 -45.000000000000000', &
'       > -0.75000000000000000 -135.00000000000000', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ATAN2D(3), TAN2D(3), ATAN2PI(3), TAN2PI(3)', &
'', &
'RESOURCES', &
'  o  wikipedia: inverse trigonometric functions', &
'', &
'                               March 16, 2025                atanpi(3fortran)', &
'']

shortname="atanpi"
call process()

case('28','atomic_add')

textblock=[character(len=256) :: &
'', &
'atomic_add(3fortran)                                     atomic_add(3fortran)', &
'', &
'NAME', &
'  ATOMIC_ADD(3) - [ATOMIC] Atomic ADD operation', &
'', &
'SYNOPSIS', &
'  call atomic_add (atom, value [,stat] )', &
'', &
'          subroutine atomic_add(atom,value,stat)', &
'', &
'           integer(atomic_int_kind)            :: atom[*]', &
'           integer(atomic_int_kind),intent(in) :: value', &
'           integer,intent(out),intent(out)     :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM is a scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE is a scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT is a Scalar default-kind integer variable.', &
'', &
'DESCRIPTION', &
'  ATOMIC_ADD(3) atomically adds the value of VAR to the variable ATOM. When', &
'  STAT is present and the invocation was successful, it is assigned the value', &
'  0. If it is present and the invocation has failed, it is assigned a positive', &
'  value; in particular, for a coindexed ATOM, if the remote image has stopped,', &
'  it is assigned the value of iso_fortran_env''s STAT_STOPPED_IMAGE and if the', &
'  remote image has failed, the value STAT_FAILED_IMAGE.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_add', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'        call atomic_add (atom[1], this_image())', &
'      end program demo_atomic_add', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_ADD(3), ATOMIC_AND(3), ATOMIC_OR(3),', &
'  ATOMIC_XOR(3) ISO_FORTRAN_ENV(3),', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            atomic_add(3fortran)', &
'']

shortname="atomic_add"
call process()

case('29','atomic_and')

textblock=[character(len=256) :: &
'', &
'atomic_and(3fortran)                                     atomic_and(3fortran)', &
'', &
'NAME', &
'  ATOMIC_AND(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation', &
'', &
'SYNOPSIS', &
'  call atomic_and(atom, value [,stat])', &
'', &
'          subroutine atomic_and(atom,value,stat)', &
'', &
'           integer(atomic_int_kind)            :: atom[*]', &
'           integer(atomic_int_kind),intent(in) :: value', &
'           integer,intent(out),intent(out)     :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM is a scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE is a scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT is a Scalar default-kind integer variable.', &
'', &
'DESCRIPTION', &
'  ATOMIC_AND(3) atomically defines ATOM with the bitwise AND between the', &
'  values of ATOM and VALUE. When STAT is present and the invocation was', &
'  successful, it is assigned the value 0. If it is present and the invocation', &
'  has failed, it is assigned a positive value; in particular, for a coindexed', &
'  ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_and', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'        call atomic_and(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_and', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_FETCH_AND(3), ATOMIC_DEFINE(3), ATOMIC_REF(3), ATOMIC_CAS(3),', &
'  ISO_FORTRAN_ENV(3), ATOMIC_ADD(3), ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            atomic_and(3fortran)', &
'']

shortname="atomic_and"
call process()

case('30','atomic_cas')

textblock=[character(len=256) :: &
'', &
'atomic_cas(3fortran)                                     atomic_cas(3fortran)', &
'', &
'NAME', &
'  ATOMIC_CAS(3) - [ATOMIC] Atomic compare and swap', &
'', &
'SYNOPSIS', &
'  call atomic_cas (atom, old, compare, new [,stat] )', &
'', &
'          subroutine atomic_cas (atom, old, compare, new, stat)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_CAS(3) compares the variable ATOM with the value of COMPARE; if the', &
'  value is the same, ATOM is set to the value of NEW. Additionally, OLD is set', &
'  to the value of ATOM that was used for the comparison. When STAT is present', &
'  and the invocation was successful, it is assigned the value 0. If it is', &
'  present and the invocation has failed, it is assigned a positive value; in', &
'  particular, for a coindexed ATOM, if the remote image has stopped, it is', &
'  assigned the value of iso_fortran_env''s stat_stopped_image and if the remote', &
'  image has failed, the value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  COMPARE : Scalar variable of the same type and kind as ATOM.', &
'', &
'  o  NEW : Scalar variable of the same type as ATOM. If kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_cas', &
'      use iso_fortran_env', &
'      implicit none', &
'      logical(atomic_logical_kind) :: atom[*], prev', &
'        call atomic_cas(atom[1], prev, .false., .true.)', &
'      end program demo_atomic_cas', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_REF(3), ISO_FORTRAN_ENV(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            atomic_cas(3fortran)', &
'']

shortname="atomic_cas"
call process()

case('31','atomic_define')

textblock=[character(len=256) :: &
'', &
'atomic_define(3fortran)                               atomic_define(3fortran)', &
'', &
'NAME', &
'  ATOMIC_DEFINE(3) - [ATOMIC] Setting a variable atomically', &
'', &
'SYNOPSIS', &
'  call atomic_define (atom, value [,stat] )', &
'', &
'          subroutine atomic_define(atom, value, stat)', &
'', &
'           TYPE(kind=atomic_KIND_kind) :: atom[*]', &
'           TYPE(kind=KIND) :: value', &
'           integer,intent(out),optional :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'DESCRIPTION', &
'  ATOMIC_DEFINE(3) defines the variable ATOM with the value VALUE atomically.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable to atomically assign the', &
'     value VALUE to. kind.', &
'', &
'  o  VALUE : value to assign to ATOM', &
'', &
'  o  STAT : When STAT is present and the invocation was successful, it is', &
'     assigned the value 0. If it is present and the invocation has failed, it', &
'     is assigned a positive value; in particular, for a coindexed ATOM, if the', &
'     remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'     stat_stopped_image and if the remote image has failed, the value', &
'     stat_failed_image.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_define', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'         call atomic_define(atom[1], this_image())', &
'      end program demo_atomic_define', &
'', &
'STANDARD', &
'  Fortran 2008 ; with STAT, TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_REF(3), ATOMIC_CAS(3), ISO_FORTRAN_ENV(3), ATOMIC_ADD(3),', &
'  ATOMIC_AND(3), ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025         atomic_define(3fortran)', &
'']

shortname="atomic_define"
call process()

case('32','atomic_fetch_add')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_add(3fortran)                         atomic_fetch_add(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_ADD(3) - [ATOMIC] Atomic ADD operation with prior fetch', &
'', &
'SYNOPSIS', &
'  call atomic_fetch_add(atom, value, old [,stat] )', &
'', &
'          subroutine atomic_fetch_add(atom, value, old, stat)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_FETCH_ADD(3) atomically stores the value of ATOM in OLD and adds the', &
'  value of VAR to the variable ATOM. When STAT is present and the invocation', &
'  was successful, it is assigned the value 0. If it is present and the', &
'  invocation has failed, it is assigned a positive value; in particular, for a', &
'  coindexed ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind. atomic_logical_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_add', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'        call atomic_add(atom[1], this_image(), old)', &
'      end program demo_atomic_fetch_add', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_ADD(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_AND(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025      atomic_fetch_add(3fortran)', &
'']

shortname="atomic_fetch_add"
call process()

case('33','atomic_fetch_and')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_and(3fortran)                         atomic_fetch_and(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_AND(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise AND operation', &
'  with prior fetch', &
'', &
'SYNOPSIS', &
'  call atomic_fetch_and(atom, value, old [,stat] )', &
'', &
'          subroutine atomic_fetch_and(atom, value, old, stat)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_FETCH_AND(3) atomically stores the value of ATOM in OLD and defines', &
'  ATOM with the bitwise AND between the values of ATOM and VALUE.  When STAT', &
'  is present and the invocation was successful, it is assigned the value 0. If', &
'  it is present and the invocation has failed, it is assigned a positive', &
'  value; in particular, for a coindexed ATOM, if the remote image has stopped,', &
'  it is assigned the value of iso_fortran_env''s stat_stopped_image and if the', &
'  remote image has failed, the value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_and', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'        call atomic_fetch_and (atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_and', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_AND(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025      atomic_fetch_and(3fortran)', &
'']

shortname="atomic_fetch_and"
call process()

case('34','atomic_fetch_or')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_or(3fortran)                           atomic_fetch_or(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_OR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'  with prior fetch', &
'', &
'SYNOPSIS', &
'  call atomic_fetch_or(atom, value, old [,stat] )', &
'', &
'          subroutine atomic_fetch_or(atom, value, old, stat)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_FETCH_OR(3) atomically stores the value of ATOM in OLD and defines', &
'  ATOM with the bitwise OR between the values of ATOM and VALUE.  When STAT is', &
'  present and the invocation was successful, it is assigned the value 0. If it', &
'  is present and the invocation has failed, it is assigned a positive value;', &
'  in particular, for a coindexed ATOM, if the remote image has stopped, it is', &
'  assigned the value of iso_fortran_env''s stat_stopped_image and if the remote', &
'  image has failed, the value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_or', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'        call atomic_fetch_or(atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_or', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_OR(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025       atomic_fetch_or(3fortran)', &
'']

shortname="atomic_fetch_or"
call process()

case('35','atomic_fetch_xor')

textblock=[character(len=256) :: &
'', &
'atomic_fetch_xor(3fortran)                         atomic_fetch_xor(3fortran)', &
'', &
'NAME', &
'  ATOMIC_FETCH_XOR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise XOR operation', &
'  with prior fetch', &
'', &
'SYNOPSIS', &
'  call atomic_fetch_xor (atom, value, old [,stat] )', &
'', &
'          subroutine atomic_fetch_xor (atom, value, old, stat)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_FETCH_XOR(3) atomically stores the value of ATOM in OLD and defines', &
'  ATOM with the bitwise XOR between the values of ATOM and VALUE.  When STAT', &
'  is present and the invocation was successful, it is assigned the value 0. If', &
'  it is present and the invocation has failed, it is assigned a positive', &
'  value; in particular, for a coindexed ATOM, if the remote image has stopped,', &
'  it is assigned the value of iso_fortran_env''s stat_stopped_image and if the', &
'  remote image has failed, the value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  OLD : Scalar of the same type and kind as ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_fetch_xor', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*], old', &
'        call atomic_fetch_xor (atom[1], int(b''10100011101''), old)', &
'      end program demo_atomic_fetch_xor', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_XOR(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_OR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025      atomic_fetch_xor(3fortran)', &
'']

shortname="atomic_fetch_xor"
call process()

case('36','atomic_or')

textblock=[character(len=256) :: &
'', &
'atomic_or(3fortran)                                       atomic_or(3fortran)', &
'', &
'NAME', &
'  ATOMIC_OR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'', &
'SYNOPSIS', &
'  call atomic_or(atom, value [,stat] )', &
'', &
'          subroutine atomic_or(atom,value,stat)', &
'', &
'           integer(atomic_int_kind)            :: atom[*]', &
'           integer(atomic_int_kind),intent(in) :: value', &
'           integer,intent(out),intent(out)     :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM is a scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE is a scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT is a Scalar default-kind integer variable.', &
'', &
'DESCRIPTION', &
'  ATOMIC_OR(3) atomically defines ATOM with the bitwise OR between the values', &
'  of ATOM and VALUE. When STAT is present and the invocation was successful,', &
'  it is assigned the value 0. If it is present and the invocation has failed,', &
'  it is assigned a positive value; in particular, for a coindexed ATOM, if the', &
'  remote image has stopped, it is assigned the value of iso_fortran_env''s', &
'  stat_stopped_image and if the remote image has failed, the value', &
'  stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_or', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'        call atomic_or(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_or', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_OR(3),', &
'', &
'  ISO_FORTRAN_ENV(3), ATOMIC_ADD(3), ATOMIC_OR(3),', &
'', &
'  ATOMIC_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             atomic_or(3fortran)', &
'']

shortname="atomic_or"
call process()

case('37','atomic_ref')

textblock=[character(len=256) :: &
'', &
'atomic_ref(3fortran)                                     atomic_ref(3fortran)', &
'', &
'NAME', &
'  ATOMIC_REF(3) - [ATOMIC] Obtaining the value of a variable atomically', &
'', &
'SYNOPSIS', &
'  call atomic_ref(value, atom [,stat] )', &
'', &
'          subroutine atomic_ref(value,atom,stat)', &
'', &
'           integer(atomic_int_kind),intent(in) :: value', &
'           integer(atomic_int_kind)            :: atom[*]', &
'           integer,intent(out),intent(out)     :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM is a scalar coarray or coindexed variable of either integer type', &
'     with atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  VALUE is a scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT is a Scalar default-kind integer variable.', &
'', &
'DESCRIPTION', &
'  ATOMIC_REF(3) atomically assigns the value of the variable ATOM to VALUE.', &
'  When STAT is present and the invocation was successful, it is assigned the', &
'  value 0. If it is present and the invocation has failed, it is assigned a', &
'  positive value; in particular, for a coindexed ATOM, if the remote image has', &
'  stopped, it is assigned the value of iso_fortran_env''s STAT_STOPPED_IMAGE', &
'  and if the remote image has failed, the value STAT_FAILED_IMAGE.', &
'', &
'OPTIONS', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  ATOM : Scalar coarray or coindexed variable of either integer type with', &
'     atomic_int_kind kind or logical type with atomic_logical_kind kind.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_ref', &
'      use iso_fortran_env', &
'      implicit none', &
'      logical(atomic_logical_kind) :: atom[*]', &
'      logical :: val', &
'        call atomic_ref( val, atom[1] )', &
'        if (val) then', &
'           print *, "Obtained"', &
'        endif', &
'      end program demo_atomic_ref', &
'', &
'STANDARD', &
'  Fortran 2008 ; with STAT, TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_CAS(3), ISO_FORTRAN_ENV(3),', &
'', &
'  ATOMIC_FETCH_ADD(3), ATOMIC_FETCH_AND(3),', &
'', &
'  ATOMIC_FETCH_OR(3), ATOMIC_FETCH_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            atomic_ref(3fortran)', &
'']

shortname="atomic_ref"
call process()

case('38','atomic_xor')

textblock=[character(len=256) :: &
'', &
'atomic_xor(3fortran)                                     atomic_xor(3fortran)', &
'', &
'NAME', &
'  ATOMIC_XOR(3) - [ATOMIC:BIT MANIPULATION] Atomic bitwise OR operation', &
'', &
'SYNOPSIS', &
'  call atomic_xor(atom, value [,stat] )', &
'', &
'          subroutine atomic_xor(atom,value,stat)', &
'', &
'           integer(atomic_int_kind)            :: atom[*]', &
'           integer(atomic_int_kind),intent(in) :: value', &
'           integer,intent(out),intent(out)     :: stat', &
'', &
'CHARACTERISTICS', &
'  o  ATOM is a scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE is a scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT is a Scalar default-kind integer variable.', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  ATOMIC_XOR(3) atomically defines ATOM with the bitwise XOR between the', &
'  values of ATOM and VALUE. When STAT is present and the invocation was', &
'  successful, it is assigned the value 0. If it is present and the invocation', &
'  has failed, it is assigned a positive value; in particular, for a coindexed', &
'  ATOM, if the remote image has stopped, it is assigned the value of', &
'  iso_fortran_env''s stat_stopped_image and if the remote image has failed, the', &
'  value stat_failed_image.', &
'', &
'OPTIONS', &
'  o  ATOM : Scalar coarray or coindexed variable of integer type with', &
'     atomic_int_kind kind.', &
'', &
'  o  VALUE : Scalar of the same type as ATOM. If the kind is different, the', &
'     value is converted to the kind of ATOM.', &
'', &
'  o  STAT : (optional) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_atomic_xor', &
'      use iso_fortran_env', &
'      implicit none', &
'      integer(atomic_int_kind) :: atom[*]', &
'        call atomic_xor(atom[1], int(b''10100011101''))', &
'      end program demo_atomic_xor', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  ATOMIC_DEFINE(3), ATOMIC_FETCH_XOR(3), ISO_FORTRAN_ENV(3), ATOMIC_ADD(3),', &
'  ATOMIC_OR(3), ATOMIC_XOR(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            atomic_xor(3fortran)', &
'']

shortname="atomic_xor"
call process()

case('39','backspace')

textblock=[character(len=256) :: &
'', &
'backspace(7fortran)                                       backspace(7fortran)', &
'', &
'NAME', &
'  backspace(7f) - [IO:FILE POSITIONING] - backspace one record on specified', &
'  I/O unit', &
'', &
'SYNOPSIS', &
'  BACKSPACE file-unit-number', &
'', &
'  BACKSPACE([UNIT=]unit-number][,IOMSG=iomsg][,IOSTAT=iostat][,ERR=label])', &
'', &
'DESCRIPTION', &
'  backspace(7f) positions the specified file back to the beginning of the', &
'  current record or if already at the beginning of a record, back to the', &
'  beginning of the previous record.', &
'', &
'  If the file is at its initial point, the position of the file is not', &
'  changed.', &
'', &
'  It is most often used when a program has partially read a line and then', &
'  wants to go back and reread the line using the information from the previous', &
'  read(7f),', &
'', &
'  backspace(7f) is rarely used in new code as the subsequent addition of', &
'  Fortran features such as non-advancing I/O and internal reads into a', &
'  CHARACTER variable (which can be read from multiple times) are typically far', &
'  more efficient and provide much of the same functionality when re-reading', &
'  the current line.', &
'', &
'  Backspacing is very inefficient on many current platforms. Reading a file', &
'  with stream-I/O and indexing relevant line positions to return to; or using', &
'  direct-access files is far more efficient than backspacing through a file', &
'  when moving back large numbers of lines on Linux and Unix platforms.', &
'', &
'  A unit open for direct access or unformatted access cannot be referenced by', &
'  backspace(7f). backspace(7f) only works with formatted sequential files that', &
'  may be repositioned. So it does not generally work with standard input from', &
'  a terminal, pipes, and other formatted sequential file types that cannot be', &
'  rewound or positioned.', &
'', &
'  Backspacing over records written using list-directed or namelist formatting', &
'  is prohibited. It will usually work, but since the compiler is free to write', &
'  list-directed or namelist output on a varying number of lines it is not', &
'  supported, as it is not certain what data is on which line unless the', &
'  program itself searches for particular strings.', &
'', &
'  Backspacing a file that is connected but does not exist is prohibited.', &
'', &
'  If a BACKSPACE statement causes the implicit writing of an endfile record,', &
'  the file is positioned before the record that precedes the endfile record.', &
'', &
'  If the preceding record is an endfile record, the file is positioned before', &
'  the endfile record.', &
'', &
'OPTIONS', &
'  UNIT : unit number of file to backspace one line on. A unit open for direct', &
'  access or unformatted access cannot be referenced by a BACKSPACE.  IOSTAT :', &
'  a compiler-specific number that indicates an error occurred if non-zero.', &
'  IOMSG : a message describing error IOSTAT if IOSTAT is not zero. ERR : a', &
'  label number to jump to if an error occurs', &
'', &
'EXAMPLE', &
'  An example of a BACKSPACE statement is:', &
'', &
'        program demo_backspace', &
'        implicit none', &
'        character(len=256) :: line', &
'        character(len=256) :: mssge', &
'        integer            :: i', &
'        integer            :: j', &
'        integer            :: ios', &
'        integer,allocatable :: iarr(:)', &
'', &
'           ! create a basic sequential file', &
'           open(10,file=''dem_backspace.txt'',action=''readwrite'') ! open a file', &
'           do i=1,30                         ! write lines to it', &
'              write(10,''(a,i3,*(i3))'') ''line '',i, (j,j=1,i)', &
'           enddo', &
'', &
'           ! back up several lines', &
'           do i=1,14', &
'              backspace(10, iostat=ios,iomsg=mssge)', &
'              if(ios.ne.0)then', &
'                      write(*,''(*(a))'') ''*dem_backspace* ERROR:'',mssge', &
'              endif', &
'           enddo', &
'           read(10,''(a)'')line', &
'           write(*,*)''back at a previous record !''', &
'', &
'           ! read line as a string', &
'           write(*,''("string=",a)'')trim(line)', &
'', &
'           ! backspace so can read again as numbers', &
'           backspace(10)', &
'           ! read part of a line numerically to get size of array to read', &
'           read(10,''(5x,i3)'')i', &
'           allocate(iarr(i))', &
'', &
'           ! reread line just reading array', &
'           backspace(10)', &
'           read(10,''(8x,*(i3))'')iarr', &
'           write(*,''(*(g0,1x))'')''size='',i,''array='',iarr', &
'', &
'           !! Note: writing a new line will truncate file', &
'           !!       to current record position', &
'', &
'           close(10,status=''delete'')', &
'', &
'        end program demo_backspace', &
'', &
'  Results:', &
'', &
'       >  back at a previous record !', &
'       > string=line  17  1  2 3  4  5  6  7  8  9 10 11 12 13 14 15 16 17', &
'       > size= 17 array= 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025             backspace(7fortran)', &
'']

shortname="backspace"
call process()

case('40','bessel_j0')

textblock=[character(len=256) :: &
'', &
'bessel_j0(3fortran)                                       bessel_j0(3fortran)', &
'', &
'NAME', &
'  BESSEL_J0(3) - [MATHEMATICS] Bessel function of the first kind of order 0', &
'', &
'SYNOPSIS', &
'  result = bessel_j0(x)', &
'', &
'          elemental real(kind=KIND) function bessel_j0(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any KIND supported by the real type.', &
'', &
'  o  The result is the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  BESSEL_J0(3) computes the Bessel function of the first kind of order 0 of X.', &
'', &
'OPTIONS', &
'  o  X : The value to operate on.', &
'', &
'RESULT', &
'  the Bessel function of the first kind of order 0 of X. The result lies in', &
'  the range -0.4027 <= BESSEL(0,X) <= 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_j0', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'        implicit none', &
'        real(kind=real64) :: x', &
'        x = 0.0_real64', &
'        x = bessel_j0(x)', &
'        write(*,*)x', &
'      end program demo_bessel_j0', &
'', &
'  Results:', &
'', &
'       > 1.0000000000000000', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_j0(3fortran)', &
'']

shortname="bessel_j0"
call process()

case('41','bessel_j1')

textblock=[character(len=256) :: &
'', &
'bessel_j1(3fortran)                                       bessel_j1(3fortran)', &
'', &
'NAME', &
'  BESSEL_J1(3) - [MATHEMATICS] Bessel function of the first kind of order 1', &
'', &
'SYNOPSIS', &
'  result = bessel_j1(x)', &
'', &
'          elemental real(kind=KIND) function bessel_j1(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any supported real KIND.', &
'', &
'  o  the result is of the same type and kind as X', &
'', &
'DESCRIPTION', &
'  BESSEL_J1(3) computes the Bessel function of the first kind of order 1 of X.', &
'', &
'OPTIONS', &
'  o  X : The type shall be real.', &
'', &
'RESULT', &
'  The return value is of type real and lies in the range -0.5818 <=', &
'  BESSEL(0,X) <= 0.5818 . It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_j1', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'        x = bessel_j1(x)', &
'        write(*,*)x', &
'      end program demo_bessel_j1', &
'', &
'  Results:', &
'', &
'       > 0.44005058574493350', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_j1(3fortran)', &
'']

shortname="bessel_j1"
call process()

case('42','bessel_jn')

textblock=[character(len=256) :: &
'', &
'bessel_jn(3fortran)                                       bessel_jn(3fortran)', &
'', &
'NAME', &
'  BESSEL_JN(3) - [MATHEMATICS] Bessel function of the first kind', &
'', &
'SYNOPSIS', &
'  result = bessel_jn(n, x)', &
'', &
'          elemental real(kind=KIND) function bessel_jn(n,x)', &
'', &
'           integer(kind=**),intent(in) :: n', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'  o  KIND may be any valid value for type real', &
'', &
'     o X is real', &
'', &
'     o The return value has the same type and kind as X.', &
'', &
'            result = bessel_jn(n1, n2, x)', &
'', &
'             real(kind=KIND) function bessel_jn(n1, n2, ,x)', &
'', &
'             integer(kind=**),intent(in) :: n1', &
'             integer(kind=**),intent(in) :: n2', &
'             real(kind=KIND),intent(in) :: x', &
'', &
'     o N1 is integer', &
'', &
'     o N2 is integer', &
'', &
'     o X is real', &
'', &
'     o The return value has the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  BESSEL_JN( N, X ) computes the Bessel function of the first kind of order N', &
'  of X.', &
'', &
'  BESSEL_JN(N1, N2, X) returns an array with the Bessel function|Bessel', &
'  functions of the first kind of the orders N1 to N2.', &
'', &
'OPTIONS', &
'  o  N : a non-negative scalar integer..', &
'', &
'  o  N1 : a non-negative scalar integer.', &
'', &
'  o  N2 : a non-negative scalar integer.', &
'', &
'  o  X : Shall be a scalar for BESSEL_JN(N,X) or an array For BESSEL_JN(N1,', &
'     N2, X).', &
'', &
'RESULT', &
'  The result value of BESSEL_JN (N, X) is a processor-dependent approximation', &
'  to the Bessel function of the first kind and order N of X.', &
'', &
'  The result of BESSEL_JN (N1, N2, X) is a rank-one array with extent MAX', &
'  (N2-N1+1, 0). Element i of the result value of BESSEL_JN (N1, N2, X) is a', &
'  processor-dependent approximation to the Bessel function of the first kind', &
'  and order N1+i-1 of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_jn', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'         x = bessel_jn(5,x)', &
'         write(*,*)x', &
'      end program demo_bessel_jn', &
'', &
'  Results:', &
'', &
'       > 2.4975773021123450E-004', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_Y0(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_jn(3fortran)', &
'']

shortname="bessel_jn"
call process()

case('43','bessel_y0')

textblock=[character(len=256) :: &
'', &
'bessel_y0(3fortran)                                       bessel_y0(3fortran)', &
'', &
'NAME', &
'  BESSEL_Y0(3) - [MATHEMATICS] Bessel function of the second kind of order 0', &
'', &
'SYNOPSIS', &
'  result = bessel_y0(x)', &
'', &
'          elemental real(kind=KIND) function bessel_y0(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any supported real KIND.', &
'', &
'  o  the result characteristics (type, kind) are the same as X', &
'', &
'DESCRIPTION', &
'  BESSEL_Y0(3) computes the Bessel function of the second kind of order 0 of', &
'  X.', &
'', &
'OPTIONS', &
'  o  X : The type shall be real. Its value shall be greater than zero.', &
'', &
'RESULT', &
'  The return value is of type real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_y0', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'       real(kind=real64) :: x = 0.0_real64', &
'       x = bessel_y0(x)', &
'       write(*,*)x', &
'      end program demo_bessel_y0', &
'', &
'  Results:', &
'', &
'        > -Infinity', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y1(3), BESSEL_YN(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_y0(3fortran)', &
'']

shortname="bessel_y0"
call process()

case('44','bessel_y1')

textblock=[character(len=256) :: &
'', &
'bessel_y1(3fortran)                                       bessel_y1(3fortran)', &
'', &
'NAME', &
'  BESSEL_Y1(3) - [MATHEMATICS] Bessel function of the second kind of order 1', &
'', &
'SYNOPSIS', &
'  result = bessel_y1(x)', &
'', &
'          elemental real(kind=KIND) function bessel_y1(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  KIND may be any supported real KIND.', &
'', &
'  o  the characteristics (type, kind) of the result are the same as X', &
'', &
'DESCRIPTION', &
'  BESSEL_Y1(3) computes the Bessel function of the second kind of order 1 of', &
'  X.', &
'', &
'OPTIONS', &
'  o  X : The type shall be real. Its value shall be greater than zero.', &
'', &
'RESULT', &
'  The return value is real. It has the same kind as X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_y1', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'       real(kind=real64) :: x = 1.0_real64', &
'       write(*,*)x, bessel_y1(x)', &
'      end program demo_bessel_y1', &
'', &
'  Results:', &
'', &
'       >    1.00000000000000     -0.781212821300289', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_YN(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_y1(3fortran)', &
'']

shortname="bessel_y1"
call process()

case('45','bessel_yn')

textblock=[character(len=256) :: &
'', &
'bessel_yn(3fortran)                                       bessel_yn(3fortran)', &
'', &
'NAME', &
'  BESSEL_YN(3) - [MATHEMATICS] Bessel function of the second kind', &
'', &
'SYNOPSIS', &
'  result = bessel_yn(n, x)', &
'', &
'          elemental real(kind=KIND) function bessel_yn(n,x)', &
'', &
'           integer(kind=**),intent(in) :: n', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  N is integer', &
'', &
'  o  X is real', &
'', &
'  o  The return value has the same type and kind as X.', &
'', &
'         result = bessel_yn(n1, n2, x)', &
'', &
'          real(kind=KIND) function bessel_yn(n1, n2, ,x)', &
'', &
'           integer(kind=**),intent(in) :: n1', &
'           integer(kind=**),intent(in) :: n2', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'  o  N1 is integer', &
'', &
'  o  N2 is integer', &
'', &
'  o  X is real', &
'', &
'  o  The return value has the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  BESSEL_YN(N, X) computes the Bessel function of the second kind of order N', &
'  of X.', &
'', &
'  BESSEL_YN(N1, N2, X) returns an array with the Bessel function|Bessel', &
'  functions of the first kind of the orders N1 to N2.', &
'', &
'OPTIONS', &
'  o  N : Shall be a scalar or an array of type integer and non-negative.', &
'', &
'  o  N1 : Shall be a non-negative scalar of type integer and non-negative.', &
'', &
'  o  N2 : Shall be a non-negative scalar of type integer and non-negative.', &
'', &
'  o  X : A real non-negative value. Note BESSEL_YN(N1, N2, X) is not', &
'     elemental, in which case it must be a scalar.', &
'', &
'RESULT', &
'  The result value of BESSEL_YN (N, X) is a processor-dependent approximation', &
'  to the Bessel function of the second kind and order N of X.', &
'', &
'  The result of BESSEL_YN (N1, N2, X) is a rank-one array with extent MAX', &
'  (N2-N1+1, 0). Element i of the result value of BESSEL_YN (N1, N2, X) is a', &
'  processor-dependent approximation to the Bessel function of the second kind', &
'  and order N1+i-1 of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bessel_yn', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'       write(*,*) x,bessel_yn(5,x)', &
'      end program demo_bessel_yn', &
'', &
'  Results:', &
'', &
'       > 1.0000000000000000       -260.40586662581222', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BESSEL_J0(3), BESSEL_J1(3), BESSEL_JN(3), BESSEL_Y0(3), BESSEL_Y1(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             bessel_yn(3fortran)', &
'']

shortname="bessel_yn"
call process()

case('46','bge')

textblock=[character(len=256) :: &
'', &
'bge(3fortran)                                                   bge(3fortran)', &
'', &
'NAME', &
'  BGE(3) - [BIT:COMPARE] Bitwise greater than or equal to', &
'', &
'SYNOPSIS', &
'  result = bge(i,j)', &
'', &
'           elemental logical function bge(i, j)', &
'', &
'            integer(kind=**),intent(in) :: i', &
'            integer(kind=**),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  the integer kind of I and J may not necessarily be the same. In addition,', &
'     values may be a BOZ constant with a value valid for the integer kind', &
'     available with the most bits on the current platform.', &
'', &
'  o  The return value is of type default logical.', &
'', &
'DESCRIPTION', &
'  BGE(3) Determines whether one integer is bitwise greater than or equal to', &
'  another.', &
'', &
'  The bit-level representation of a value is platform dependent. The endian-', &
'  ness of a system and whether the system uses a "two''s complement"', &
'  representation of signs can affect the results, for example.', &
'', &
'  A BOZ constant (Binary, Octal, Hexadecimal) does not have a kind or type of', &
'  its own, so be aware it is subject to truncation when transferred to an', &
'  integer type. The most bits the constant may contain is limited by the most', &
'  bits representable by any integer kind supported by the compilation.', &
'', &
'  Bit Sequence Comparison', &
'', &
'  When bit sequences of unequal length are compared, the shorter sequence is', &
'  padded with zero bits on the left to the same length as the longer sequence', &
'  (up to the largest number of bits any available integer kind supports).', &
'', &
'  Bit sequences are compared from left to right, one bit at a time, until', &
'  unequal bits are found or until all bits have been compared and found to be', &
'  equal.', &
'', &
'  The bits are always evaluated in this order, not necessarily from MSB to LSB', &
'  (most significant bit to least significant bit).', &
'', &
'  If unequal bits are found the sequence with zero in the unequal position is', &
'  considered to be less than the sequence with one in the unequal position.', &
'', &
'OPTIONS', &
'  o  I : The value to test if >= J based on the bit representation of the', &
'     values.', &
'', &
'  o  J : The value to test I against.', &
'', &
'RESULT', &
'  Returns .true. if I is bit-wise greater than J and .false. otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bge', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer           :: i', &
'      integer(kind=int8) :: byte', &
'      integer(kind=int8),allocatable :: arr1(:), arr2(:)', &
'', &
'       ! BASIC USAGE', &
'        write(*,*)''bge(-127,127)='',bge( -127, 127 )', &
'        ! on (very common) "two''s complement" machines that are', &
'        ! little-endian -127 will be greater than 127', &
'', &
'        ! BOZ constants', &
'        ! BOZ constants are subject to truncation, so make sure', &
'        ! your values are valid for the integer kind being compared to', &
'        write(*,*)''bge(b"0001",2)='',bge( b"1", 2)', &
'', &
'       ! ELEMENTAL', &
'        ! an array and scalar', &
'        write(*, *)''compare array of values [-128, -0, +0, 127] to 127''', &
'        write(*, *)bge(int([-128, -0, +0, 127], kind=int8), 127_int8)', &
'', &
'        ! two arrays', &
'        write(*, *)''compare two arrays''', &
'        arr1=int( [ -127, -0, +0,  127], kind=int8 )', &
'        arr2=int( [  127,  0,  0, -127], kind=int8 )', &
'        write(*,*)''arr1='',arr1', &
'        write(*,*)''arr2='',arr2', &
'        write(*, *)''bge(arr1,arr2)='',bge( arr1, arr2 )', &
'', &
'       ! SHOW TESTS AND BITS', &
'        ! actually looking at the bit patterns should clarify what affect', &
'        ! signs have ...', &
'        write(*,*)''Compare some one-byte values to 64.''', &
'        write(*,*)''Notice that the values are tested as bits not as integers''', &
'        write(*,*)''so the results are as if values are unsigned integers.''', &
'        do i=-128,127,32', &
'           byte=i', &
'           write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,bge(byte,64_int8),byte', &
'        enddo', &
'', &
'       ! SIGNED ZERO', &
'        ! are +0 and -0 the same on your platform? When comparing at the', &
'        ! bit level this is important', &
'        write(*,''("plus zero=",b0)'')  +0', &
'        write(*,''("minus zero=",b0)'') -0', &
'', &
'      end program demo_bge', &
'', &
'  Results:', &
'', &
'  How an integer value is represented at the bit level can vary. These are', &
'  just the values expected on Today''s most common platforms ...', &
'', &
'         > bge(-127,127)= T', &
'         > bge(b"0001",2)= F', &
'         > compare array of values [-128, -0, +0, 127] to 127', &
'         > T F F T', &
'         > compare two arrays', &
'         > arr1= -127    0    0  127', &
'         > arr2=  127    0    0 -127', &
'         > bge(arr1,arr2)= T T T F', &
'         > Compare some one-byte values to 64.', &
'         > Notice that the values are tested as bits not as integers', &
'         > so the results are as if values are unsigned integers.', &
'         > -0128  T 10000000', &
'         > -0096  T 10100000', &
'         > -0064  T 11000000', &
'         > -0032  T 11100000', &
'         > +0000  F 00000000', &
'         > +0032  F 00100000', &
'         > +0064  T 01000000', &
'         > +0096  T 01100000', &
'         > plus zero=0', &
'         > minus zero=0', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BGT(3), BLE(3), BLT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   bge(3fortran)', &
'']

shortname="bge"
call process()

case('47','bgt')

textblock=[character(len=256) :: &
'', &
'bgt(3fortran)                                                   bgt(3fortran)', &
'', &
'NAME', &
'  BGT(3) - [BIT:COMPARE] Bitwise greater than', &
'', &
'SYNOPSIS', &
'  result = bgt(i, j)', &
'', &
'           elemental logical function bgt(i, j)', &
'', &
'            integer(kind=**),intent(in) :: i', &
'            integer(kind=**),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I is an integer or a boz-literal-constant.', &
'', &
'  o  J is an integer or a boz-literal-constant.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type The', &
'     integer kind of I and J may not necessarily be the same. kind. In', &
'     addition, values may be a BOZ constant with a value valid for the integer', &
'     kind available with the most bits on the current platform.', &
'', &
'  o  The return value is of type logical and of the default kind.', &
'', &
'DESCRIPTION', &
'  BGT determines whether an integer is bitwise greater than another.  Bit-', &
'  level representations of values are platform-dependent.', &
'', &
'OPTIONS', &
'  o  I : reference value to compare against', &
'', &
'  o  J : value to compare to I', &
'', &
'RESULT', &
'  The return value is of type logical and of the default kind. The result is', &
'  true if the sequence of bits represented by i is greater than the sequence', &
'  of bits represented by j, otherwise the result is false.', &
'', &
'  Bits are compared from right to left.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bgt', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer           :: i', &
'      integer(kind=int8) :: byte', &
'       ! Compare some one-byte values to 64.', &
'        ! Notice that the values are tested as bits not as integers', &
'        ! so sign bits in the integer are treated just like any other', &
'        write(*,''(a)'') ''we will compare other values to 64''', &
'        i=64', &
'        byte=i', &
'        write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,bgt(byte,64_int8),byte', &
'', &
'        write(*,''(a)'') "comparing at the bit level, not as whole numbers."', &
'        write(*,''(a)'') "so pay particular attention to the negative"', &
'        write(*,''(a)'') "values on this two''s complement platform ..."', &
'        do i=-128,127,32', &
'           byte=i', &
'           write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,bgt(byte,64_int8),byte', &
'        enddo', &
'', &
'        ! see the BGE() description for an extended description', &
'        ! of related information', &
'', &
'      end program demo_bgt', &
'', &
'  Results:', &
'', &
'       > we will compare other values to 64', &
'       > +0064 F 01000000', &
'       > comparing at the bit level, not as whole numbers.', &
'       > so pay particular attention to the negative', &
'       > values on this two''s complement platform ...', &
'       > -0128 T 10000000', &
'       > -0096 T 10100000', &
'       > -0064 T 11000000', &
'       > -0032 T 11100000', &
'       > +0000 F 00000000', &
'       > +0032 F 00100000', &
'       > +0064 F 01000000', &
'       > +0096 T 01100000', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BGE(3), BLE(3), BLT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   bgt(3fortran)', &
'']

shortname="bgt"
call process()

case('48','bit_size')

textblock=[character(len=256) :: &
'', &
'bit_size(3fortran)                                         bit_size(3fortran)', &
'', &
'NAME', &
'  BIT_SIZE(3) - [BIT:INQUIRY] Bit size inquiry function', &
'', &
'SYNOPSIS', &
'  result = bit_size(i)', &
'', &
'          integer(kind=KIND) function bit_size(i)', &
'', &
'           integer(kind=KIND),intent(in) :: i(..)', &
'', &
'CHARACTERISTICS', &
'  o  I shall be of type integer. It may be a scalar or an array.', &
'', &
'  o  the value of KIND is any valid value for an integer kind parameter on the', &
'     processor.', &
'', &
'  o  the return value is a scalar of the same kind as the input value.', &
'', &
'DESCRIPTION', &
'  BIT_SIZE(3) returns the number of bits (integer precision plus sign bit)', &
'  represented by the type of the integer I.', &
'', &
'OPTIONS', &
'  o  I : An integer value of any kind whose size in bits is to be determined.', &
'     Because only the type of the argument is examined, the argument need not', &
'     be defined; I can be a scalar or an array, but a scalar representing just', &
'     a single element is always returned.', &
'', &
'RESULT', &
'  The number of bits used to represent a value of the type and kind of i.  The', &
'  result is a integer scalar of the same kind as i.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_bit_size', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      use,intrinsic :: iso_fortran_env, only : integer_kinds', &
'      implicit none', &
'      character(len=*),parameter   :: fmt=&', &
'      & ''(a,": bit size is ",i3," which is kind=",i3," on this platform")''', &
'', &
'         ! default integer bit size on this platform', &
'         write(*,fmt) "default", bit_size(0), kind(0)', &
'', &
'         write(*,fmt) "int8   ", bit_size(0_int8),   kind(0_int8)', &
'         write(*,fmt) "int16  ", bit_size(0_int16),  kind(0_int16)', &
'         write(*,fmt) "int32  ", bit_size(0_int32),  kind(0_int32)', &
'         write(*,fmt) "int64  ", bit_size(0_int64),  kind(0_int64)', &
'', &
'         write(*,''(a,*(i0:,", "))'') "The available kinds are ",integer_kinds', &
'', &
'      end program demo_bit_size', &
'', &
'  Typical Results:', &
'', &
'       > default: bit size is  32 which is kind=  4 on this platform', &
'       > int8   : bit size is   8 which is kind=  1 on this platform', &
'       > int16  : bit size is  16 which is kind=  2 on this platform', &
'       > int32  : bit size is  32 which is kind=  4 on this platform', &
'       > int64  : bit size is  64 which is kind=  8 on this platform', &
'       > The available kinds are 1, 2, 4, 8, 16', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              bit_size(3fortran)', &
'']

shortname="bit_size"
call process()

case('49','ble')

textblock=[character(len=256) :: &
'', &
'ble(3fortran)                                                   ble(3fortran)', &
'', &
'NAME', &
'  BLE(3) - [BIT:COMPARE] Bitwise less than or equal to', &
'', &
'SYNOPSIS', &
'  result = ble(i,j)', &
'', &
'          elemental logical function ble(i, j)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I and J may be of any supported integer kind, not necessarily the same.', &
'     An exception is that values may be a BOZ constant with a value valid for', &
'     the integer kind available with the most bits on the current platform.', &
'', &
'  o  the returned value is a logical scalar of default kind', &
'', &
'DESCRIPTION', &
'  BLE(3) determines whether an integer is bitwise less than or equal to', &
'  another, assuming any shorter value is padded on the left with zeros to the', &
'  length of the longer value.', &
'', &
'OPTIONS', &
'  o  I : the value to compare J to', &
'', &
'  o  J : the value to be tested for being less than or equal to I', &
'', &
'RESULT', &
'  The return value is .true. if any bit in J is less than any bit in I', &
'  starting with the rightmost bit and continuing tests leftward.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ble', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer           :: i', &
'      integer(kind=int8) :: byte', &
'       ! Compare some one-byte values to 64.', &
'        ! Notice that the values are tested as bits not as integers', &
'        ! so sign bits in the integer are treated just like any other', &
'        do i=-128,127,32', &
'           byte=i', &
'           write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,ble(byte,64_int8),byte', &
'           write(*,''(sp,i0.4,*(4x,b0.8))'')64_int8,64_int8', &
'        enddo', &
'', &
'        ! see the BGE() description for an extended description', &
'        ! of related information', &
'', &
'      end program demo_ble', &
'', &
'  Results:', &
'', &
'       >  -0128  F 10000000', &
'       >  +0064    01000000', &
'       >  -0096  F 10100000', &
'       >  +0064    01000000', &
'       >  -0064  F 11000000', &
'       >  +0064    01000000', &
'       >  -0032  F 11100000', &
'       >  +0064    01000000', &
'       >  +0000  T 00000000', &
'       >  +0064    01000000', &
'       >  +0032  T 00100000', &
'       >  +0064    01000000', &
'       >  +0064  T 01000000', &
'       >  +0064    01000000', &
'       >  +0096  F 01100000', &
'       >  +0064    01000000', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BGE(3), BGT(3), BLT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   ble(3fortran)', &
'']

shortname="ble"
call process()

case('50','block')

textblock=[character(len=256) :: &
'', &
'block(7fortran)                                               block(7fortran)', &
'', &
'NAME', &
'  BLOCK(7f) - [EXECUTION CONTROL] block construct', &
'', &
'SYNOPSIS', &
'  Syntax:', &
'', &
'         [block-construct-name:] BLOCK', &
'         [specification-part]', &
'         ENDBLOCK [block-construct-name]', &
'', &
'DESCRIPTION', &
'  The BLOCK(7F) construct is an executable construct which may contain', &
'  declarations, and may be exited using the EXIT(7F) statement.', &
'', &
'  Aside from the following restrictions a block construct is in many ways', &
'  similiar to a contained procedure without parameters accept it is', &
'  constructed in-line instead of after the body of the current procedure.', &
'', &
'  So if you are thinking about making a contained procedure that will be', &
'  called once it will probably be clearer inlined using a block construct.', &
'', &
'  The specification-part of a BLOCK(7F) construct cannot contain a COMMON,', &
'  EQUIVALENCE, IMPLICIT, INTENT, NAMELIST, or OPTIONAL statement.', &
'', &
'  A SAVE of a common-block-name is not allowed in a BLOCK(7F) construct.', &
'', &
'  Except for the ASYNCHRONOUS and VOLATILE statements, specifications in a', &
'  BLOCK(7F) construct declare construct entities whose scope is that of the', &
'  block construct.', &
'', &
'EXAMPLES', &
'  Sample programs:', &
'', &
'         program demo_block', &
'         implicit none', &
'         integer,parameter :: arr1(*)=[1,2,3,4,5,6,7]', &
'         integer,parameter :: arr2(*)=[0,1,2,3,4,5,6,7]', &
'', &
'         ! so when you want error processing to be skipped', &
'         ! if you exhaust a series of tries and really hate GOTO ...', &
'         DEBUG: block', &
'         integer :: icount', &
'            do icount=1,100 ! look for answer up to 100 times', &
'               if(icount.eq.40)exit DEBUG ! found answer, go on', &
'            enddo', &
'            ! never get here unless exhausted the DO loop', &
'            write(*,*)''never found the answer''', &
'            stop 3', &
'         endblock DEBUG', &
'            !', &
'            call showme(arr1)', &
'            call showme(arr2)', &
'            !', &
'         contains', &
'         !', &
'         subroutine showme(a)', &
'         integer,intent(in) :: a(:)', &
'         integer :: i=-100', &
'         integer :: tan', &
'           tan=20 ! intentionally cause a conflict with intrinsic', &
'           ! cannot use tan(3f) right here because using name for a variable', &
'           TESTFORZERO: block', &
'              integer :: I      ! local block variable', &
'              intrinsic :: tan  ! can use the TAN intrinsic in the block now', &
'                                ! as this definition supercedes the one in the', &
'                                ! parent body', &
'              do i=1,size(a)', &
'                 if(a(i).eq.0) then', &
'                    write(*,*)''found zero at index'',i', &
'                    exit TESTFORZERO', &
'                 endif', &
'              enddo', &
'              write(*,*)''Never found a zero, tried '',i-1,'' times''', &
'              return', &
'            endblock TESTFORZERO', &
'            ! note the variable I in the block is local to the block', &
'            write(*,*)''this is the variable back in the main scope, I='',i', &
'         end subroutine showme', &
'', &
'         end program demo_block', &
'', &
'  Results:', &
'', &
'       >  Never found a zero, tried 7  times', &
'       >  found zero at index 1', &
'       >  this is the variable in the main scope of the program, I=-100', &
'', &
'SEE ALSO', &
'  o  DO(3) - construct', &
'', &
'  o  IF(3) - selects a block based on a sequence of logical expressions.', &
'', &
'  o  CYCLE(3) - construct', &
'', &
'  o  EXIT(3) - statement', &
'', &
'  o  ASSOCIATE(3) - associate construct', &
'', &
'  o  BLOCK(3) - construct', &
'', &
'  o  GOTO(3) - jump to target line', &
'', &
'  o  SELECT(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  CASE(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  ENDSELECT(3) - select a block based on the value of an expression (a', &
'     case)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 block(7fortran)', &
'']

shortname="block"
call process()

case('51','blt')

textblock=[character(len=256) :: &
'', &
'blt(3fortran)                                                   blt(3fortran)', &
'', &
'NAME', &
'  BLT(3) - [BIT:COMPARE] Bitwise less than', &
'', &
'SYNOPSIS', &
'  result = blt(i,j)', &
'', &
'          elemental logical function blt(i, j)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I is an integer of any kind or a BOZ-literal-constant', &
'', &
'  o  J is an integer of any kind or a BOZ-literal-constant, not necessarily', &
'     the same as I.', &
'', &
'  o  the result is of default logical kind', &
'', &
'  BOZ constants must have a value valid for the integer kind available with', &
'  the most bits on the current platform.', &
'', &
'DESCRIPTION', &
'  BLT(3) determines whether an integer is bitwise less than another.', &
'', &
'OPTIONS', &
'  o  I : Shall be of integer type or a BOZ literal constant.', &
'', &
'  o  J : Shall be of integer type or a BOZ constant.', &
'', &
'RESULT', &
'  The return value is of type logical and of the default kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_blt', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer           :: i', &
'      integer(kind=int8) :: byte', &
'       ! Compare some one-byte values to 64.', &
'        ! Notice that the values are tested as bits not as integers', &
'        ! so sign bits in the integer are treated just like any other', &
'        do i=-128,127,32', &
'           byte=i', &
'           write(*,''(sp,i0.4,*(1x,1l,1x,b0.8))'')i,blt(byte,64_int8),byte', &
'        enddo', &
'       ! BOZ literals', &
'        write(*,*)blt(z''1000'', z''101011010'')', &
'        ! see the BGE() description for an extended description', &
'        ! of related information', &
'', &
'      end program demo_blt', &
'', &
'  Results:', &
'', &
'        > -0128  F 10000000', &
'        > -0096  F 10100000', &
'        > -0064  F 11000000', &
'        > -0032  F 11100000', &
'        > +0000  T 00000000', &
'        > +0032  T 00100000', &
'        > +0064  F 01000000', &
'        > +0096  F 01100000', &
'        > T', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BGE(3), BGT(3), BLE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   blt(3fortran)', &
'']

shortname="blt"
call process()

case('52','btest')

textblock=[character(len=256) :: &
'', &
'btest(3fortran)                                               btest(3fortran)', &
'', &
'NAME', &
'  BTEST(3) - [BIT:INQUIRY] Tests a bit of an integer value.', &
'', &
'SYNOPSIS', &
'  result = btest(i,pos)', &
'', &
'          elemental logical function btest(i,pos)', &
'', &
'           integer(kind=**),intent(in)  :: i', &
'           integer(kind=**),intent(in)  :: pos', &
'', &
'CHARACTERISTICS', &
'  o  I is an integer of any kind', &
'', &
'  o  POS is a integer of any kind', &
'', &
'  o  the result is a default logical', &
'', &
'DESCRIPTION', &
'  BTEST(3) returns logical .true. if the bit at POS in I is set to 1.', &
'  Position zero is the right-most bit. Bit position increases from right to', &
'  left up to BITSIZE(I)-1.', &
'', &
'OPTIONS', &
'  o  I : The integer containing the bit to be tested', &
'', &
'  o  POS : The position of the bit to query. it must be a valid position for', &
'     the value I; ie. 0 <= POS <= BIT_SIZE(I).', &
'', &
'RESULT', &
'  The result is a logical that has the value .true. if bit position POS of I', &
'  has the value 1 and the value .false. if bit POS of I has the value 0.', &
'', &
'  Positions of bits in the sequence are numbered from right to left, with the', &
'  position of the rightmost bit being zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_btest', &
'      implicit none', &
'      integer :: i, j, pos, a(2,2)', &
'      logical :: bool', &
'      character(len=*),parameter :: g=''(*(g0))''', &
'', &
'          i = 32768 + 1024 + 64', &
'         write(*,''(a,i0,"=>",b32.32,/)'')''Looking at the integer: '',i', &
'', &
'         ! looking one bit at a time from LOW BIT TO HIGH BIT', &
'         write(*,g)''from bit 0 to bit '',bit_size(i),''==>''', &
'         do pos=0,bit_size(i)-1', &
'             bool = btest(i, pos)', &
'             write(*,''(l1)'',advance=''no'')bool', &
'         enddo', &
'         write(*,*)', &
'', &
'         ! a binary format the hard way.', &
'         ! Note going from bit_size(i) to zero.', &
'         write(*,*)', &
'         write(*,g)''so for '',i,'' with a bit size of '',bit_size(i)', &
'         write(*,''(b32.32)'')i', &
'         write(*,g)merge(''^'',''_'',[(btest(i,j),j=bit_size(i)-1,0,-1)])', &
'         write(*,*)', &
'         write(*,g)''and for '',-i,'' with a bit size of '',bit_size(i)', &
'         write(*,''(b32.32)'')-i', &
'         write(*,g)merge(''^'',''_'',[(btest(-i,j),j=bit_size(i)-1,0,-1)])', &
'', &
'         ! elemental:', &
'         !', &
'         a(1,:)=[ 1, 2 ]', &
'         a(2,:)=[ 3, 4 ]', &
'         write(*,*)', &
'         write(*,''(a,/,*(i2,1x,i2,/))'')''given the array a ...'',a', &
'         ! the second bit of all the values in a', &
'         write(*,''(a,/,*(l2,1x,l2,/))'')''the value of btest (a, 2)'',btest(a,2)', &
'         ! bits 1,2,3,4 of the value 2', &
'         write(*,''(a,/,*(l2,1x,l2,/))'')''the value of btest (2, a)'',btest(2,a)', &
'      end program demo_btest', &
'', &
'  Results:', &
'', &
'       > Looking at the integer: 33856=>11111111111111110111101111000000', &
'       >', &
'       > 00000000000000001000010001000000', &
'       > 11111111111111110111101111000000', &
'       > 1000010001000000', &
'       > 11111111111111110111101111000000', &
'       > from bit 0 to bit 32==>', &
'       > FFFFFFTFFFTFFFFTFFFFFFFFFFFFFFFF', &
'       >', &
'       > so for 33856 with a bit size of 32', &
'       > 00000000000000001000010001000000', &
'       > ________________^____^___^______', &
'       >', &
'       > and for -33856 with a bit size of 32', &
'       > 11111111111111110111101111000000', &
'       > ^^^^^^^^^^^^^^^^_^^^^_^^^^______', &
'       >', &
'       > given the array a ...', &
'       >  1  3', &
'       >  2  4', &
'       >', &
'       > the value of btest (a, 2)', &
'       >  F  F', &
'       >  F  T', &
'       >', &
'       > the value of btest (2, a)', &
'       >  T  F', &
'       >  F  F', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  IAND(3), IBCLR(3), IBITS(3), IBSET(3), IEOR(3), IOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 btest(3fortran)', &
'']

shortname="btest"
call process()

case('53','c_associated')

textblock=[character(len=256) :: &
'', &
'c_associated(3fortran)                                 c_associated(3fortran)', &
'', &
'NAME', &
'  C_ASSOCIATED(3) - [ISO_C_BINDING] Status of a C pointer', &
'', &
'SYNOPSIS', &
'  result = c_associated(c_prt_1, [c_ptr_2] )', &
'', &
'          logical function c_associated(c_prt_1, cptr_2)', &
'', &
'           TYPE,intent(in) ::c_ptr_1', &
'           TYPE,intent(in),optional ::c_ptr_2', &
'', &
'CHARACTERISTICS', &
'  o  C_PTR_1 is a scalar of the type c_ptr or c_funptr.', &
'', &
'  o  C_PTR_2 is a scalar of the same type as c_ptr_1.', &
'', &
'  o  The return value is of type logical', &
'', &
'DESCRIPTION', &
'  C_ASSOCIATED(3) determines the status of the C pointer c_ptr_1 or if c_ptr_1', &
'  is associated with the target c_ptr_2.', &
'', &
'OPTIONS', &
'  o  C_PTR_1 : C pointer to test for being a C NULL pointer, or to test if', &
'     pointing to the same association as C_PTR_2 when present.', &
'', &
'  o  C_PTR_2 : C pointer to test for shared association with C_PTR_1', &
'', &
'RESULT', &
'  The return value is of type logical; it is .false. if either c_ptr_1 is a C', &
'  NULL pointer or if c_ptr1 and c_ptr_2 point to different addresses.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_associated', &
'', &
'      contains', &
'', &
'      subroutine association_test(a,b)', &
'      use iso_c_binding, only: c_associated, c_loc, c_ptr', &
'      implicit none', &
'      real, pointer :: a', &
'      type(c_ptr) :: b', &
'        if(c_associated(b, c_loc(a))) &', &
'           stop ''b and a do not point to same target''', &
'      end subroutine association_test', &
'', &
'      end program demo_c_associated', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_FUNLOC(3), ISO_C_BINDING(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          c_associated(3fortran)', &
'']

shortname="c_associated"
call process()

case('54','ceiling')

textblock=[character(len=256) :: &
'', &
'ceiling(3fortran)                                           ceiling(3fortran)', &
'', &
'NAME', &
'  CEILING(3) - [NUMERIC] returns the least integer greater than or equal to A.', &
'', &
'SYNOPSIS', &
'  result = ceiling(a [,kind])', &
'', &
'          elemental integer(KIND) function ceiling(a,KIND)', &
'', &
'           real(kind=**),intent(in)  :: a', &
'           integer,intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  A is of type real', &
'', &
'  o  if present KIND is a scalar integer constant expression that specifies', &
'     the kind of the result.', &
'', &
'  o  the result is integer. It is default kind if KIND is not specified', &
'', &
'DESCRIPTION', &
'  CEILING(3) returns the least integer greater than or equal to A.', &
'', &
'  On the number line -n <-- 0 -> +n the value returned is always at or to the', &
'  right of the input value.', &
'', &
'  For example, ceil(0.5) is 1.0, and ceil(-0.5) is 0.0.', &
'', &
'  The input value may be too large to store the result in an integer type.  To', &
'  avoid an overflow (which produces an undefined result), an application', &
'  should perform a range check on the input value before using ceiling(3).', &
'', &
'OPTIONS', &
'  o  A : A real value to produce a ceiling for.', &
'', &
'  o  KIND : indicates the kind parameter of the result.', &
'', &
'RESULT', &
'  The result will be the integer value equal to A or the least integer greater', &
'  than A if the input value is not equal to a whole number.', &
'', &
'  If A is equal to a whole number, the returned value is INT(A).', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ceiling', &
'      implicit none', &
'      ! just a convenient format for a list of integers', &
'      character(len=*),parameter :: gen=''(1x,*(g0:,1x))''', &
'      real             :: x', &
'      real             :: y', &
'      integer          :: ierr', &
'      real,parameter   :: arr(*)=[ &', &
'        &  -2.7,  -2.5, -2.2, -2.0, -1.5, &', &
'        &  -1.0,  -0.5,  0.0, +0.5, +1.0, &', &
'        &  +1.5,  +2.0, +2.2, +2.5, +2.7  ]', &
'      character(len=80) :: message', &
'        print *, ''Basic Usage''', &
'        x = 63.29', &
'        y = -63.59', &
'        print gen, ceiling(x), ceiling(y)', &
'        ! note the result was the next integer larger to the right', &
'', &
'        print *, ''Whole Numbers'' ! real values equal to whole numbers', &
'        x = 63.0', &
'        y = -63.0', &
'        print gen, ceiling(x), ceiling(y)', &
'', &
'        print *, ''Elemental'' ! (so an array argument is allowed)', &
'        print gen , ceiling(arr)', &
'', &
'        print *, ''Advanced Usage'' ! Dealing with large magnitude values', &
'        print ''(a)'',[character(len=80):: &', &
'        ''Limits                                                          '',&', &
'        ''You only care about Limits if you are using values near or above '',&', &
'        ''the limits of the integer type you are using (see huge(3)).     '',&', &
'        '''',&', &
'        ''Surprised by some of the following results?                     '',&', &
'        ''What do real values clearly out of the range of integers return? '',&', &
'        ''What do values near the end of the range of integers return?    '',&', &
'        ''The standard only specifies what happens for representable values'',&', &
'        ''in the range of integer values.                                 '',&', &
'        '''',&', &
'        ''It is common but not required that if the input is out of range  '',&', &
'        ''and positive the result is -huge(0) and -huge(0)-1 if negative.  '',&', &
'        ''Note you are out of range before you get to real(huge(0)).      '',&', &
'        '''' ]', &
'        print gen , ''For reference: huge(0)='',huge(0),''-huge(0)-1='',-huge(0)-1', &
'', &
'        x=huge(0)', &
'        call displayx()', &
'', &
'        x=2*x', &
'        call displayx()', &
'', &
'        x=-huge(0)-1', &
'        call displayx()', &
'', &
'        x=2*x', &
'        call displayx()', &
'', &
'        print gen , repeat(''='',80)', &
'', &
'      contains', &
'', &
'      subroutine displayx()', &
'      use,intrinsic :: iso_fortran_env, only: int8,int16,int32,int64', &
'        print gen , repeat(''='',80)', &
'        print gen , ''x='',x,'' spacing='',spacing(x)', &
'        print gen , '' ceiling(x):'',ceiling(x)', &
'        print gen , '' ceiling(x,kind=int64):'',ceiling(x,kind=int64)', &
'        print gen , '' ceiling_robust(x):'',ceiling_robust(x,ierr,message)', &
'        if(ierr.ne.0)then', &
'           print gen, ierr,''=>'',trim(message)', &
'        endif', &
'      end subroutine displayx', &
'', &
'      elemental impure function ceiling_robust(x,ierr,message)', &
'      ! return the least integer >= x', &
'      use,intrinsic :: iso_fortran_env, only: int8,int16,int32,int64', &
'      use,intrinsic :: iso_fortran_env, only: real32,real64,real128', &
'      real,intent(in)                      :: x', &
'      integer,intent(out),optional         :: ierr', &
'      character(len=*),intent(out),optional :: message', &
'      character(len=80)                    :: message_local', &
'      integer                              :: ceiling_robust', &
'      integer                              :: ierr_local', &
'        ierr_local=0', &
'        message_local=''''', &
'        ! allow -huge(0)-1 or not?', &
'        if(spacing(x) > 128)then ! bounds checking', &
'           if(x.ge.0)then', &
'              write(message_local,*)''<ERROR>X='',x,'' >='',anint(real(huge(0)))', &
'              ierr_local=1', &
'              ceiling_robust=huge(0)', &
'           else', &
'              ierr_local=2', &
'              ceiling_robust=-huge(0)-1', &
'              write(message_local,*)''<ERROR>X='',x,'' <='',anint(real(-huge(0)-1))', &
'           endif', &
'        else', &
'           ! used to use a computed goto to do this!', &
'           ceiling_robust = int(x)', &
'           if (x > 0.0) then', &
'              if (real(ceiling_robust) < x)then', &
'                 ceiling_robust = ceiling_robust + 1', &
'              endif', &
'           endif', &
'        endif', &
'        if(present(ierr))then', &
'           ierr=ierr_local', &
'        elseif(ierr_local.ne.0)then', &
'           stop message_local', &
'        endif', &
'        if(present(message))then', &
'           message=message_local', &
'        endif', &
'      end function ceiling_robust', &
'', &
'      end program demo_ceiling', &
'', &
'  Results:', &
'', &
'       >  Basic Usage', &
'       >  64 -63', &
'       >  Whole Numbers', &
'       >  63 -63', &
'       >  Elemental', &
'       >  -2 -2 -2 -2 -1 -1 0 0 1 1 2 2 3 3 3', &
'       > Limits', &
'       >', &
'       > Surprised by some of the following results?', &
'       > What do real values clearly out of the range of integers return?', &
'       > What do values near the end of the range of integers return?', &
'       > The standard only specifies what happens for representable values', &
'       > in the range of integer values.', &
'       >', &
'       > It is common but not required that if the input is out of range', &
'       > and positive the result is -huge(0) and -huge(0)-1 if negative.', &
'       > Note you are out of range before you get to real(huge(0)).', &
'       >', &
'       >  For reference: huge(0)= 2147483647 -huge(0)-1= -2147483648', &
'       >  ======================================================================', &
'       >  x= 0.214748365E+10  spacing= 256.000000', &
'       >   ceiling(x): -2147483647', &
'       >   ceiling(x,kind=int64): 2147483648', &
'       >   ceiling_robust(x): 2147483647', &
'       >  1 => <ERROR>X=   2.14748365E+09  >=   2.14748365E+09', &
'       >  ======================================================================', &
'       >  x= 0.429496730E+10  spacing= 512.000000', &
'       >   ceiling(x): -2147483647', &
'       >   ceiling(x,kind=int64): 4294967296', &
'       >   ceiling_robust(x): 2147483647', &
'       >  1 => <ERROR>X=   4.29496730E+09  >=   2.14748365E+09', &
'       >  ======================================================================', &
'       >  x= -0.214748365E+10  spacing= 256.000000', &
'       >   ceiling(x): -2147483648', &
'       >   ceiling(x,kind=int64): -2147483648', &
'       >   ceiling_robust(x): -2147483648', &
'       >  2 => <ERROR>X=  -2.14748365E+09  <=  -2.14748365E+09', &
'       >  ======================================================================', &
'       >  x= -0.429496730E+10  spacing= 512.000000', &
'       >   ceiling(x): -2147483648', &
'       >   ceiling(x,kind=int64): -4294967296', &
'       >   ceiling_robust(x): -2147483648', &
'       >  2 => <ERROR>X=  -4.29496730E+09  <=  -2.14748365E+09', &
'       >  ======================================================================', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  FLOOR(3), NINT(3)', &
'', &
'  AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3)', &
'', &
'  NEAREST(3), SPACING(3), EPSILON(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               ceiling(3fortran)', &
'']

shortname="ceiling"
call process()

case('55','c_f_pointer')

textblock=[character(len=256) :: &
'', &
'c_f_pointer(3fortran)                                   c_f_pointer(3fortran)', &
'', &
'NAME', &
'  C_F_POINTER(3) - [ISO_C_BINDING] Convert C into Fortran pointer', &
'', &
'SYNOPSIS', &
'  call c_f_pointer(cptr, fptr [,shape] )', &
'', &
'          subroutine c_f_pointer(cptr, fptr ,shape )', &
'', &
'           type(c_ptr),intent(in) :: cprt', &
'           type(TYPE),pointer,intent(out) :: fprt', &
'           integer,intent(in),optional :: shape(:)', &
'', &
'CHARACTERISTICS', &
'  The Fortran pointer FPRT must be interoperable with CPTR', &
'', &
'  SHAPE is only specified if FPTR is an array.', &
'', &
'DESCRIPTION', &
'  C_F_POINTER(3) assigns the target (the C pointer CPTR) to the Fortran', &
'  pointer FPTR and specifies its shape if FPTR points to an array.', &
'', &
'OPTIONS', &
'  o  CPTR : scalar of the type c_ptr. It is INTENT(IN).', &
'', &
'  o  FPTR : pointer interoperable with CPTR. it is INTENT(OUT).', &
'', &
'  o  SHAPE : (Optional) Rank-one array of type integer with INTENT(IN) .  It', &
'     shall be present if and only if FPTR is an array. The size must be equal', &
'     to the rank of FPTR.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_f_pointer', &
'      use iso_c_binding', &
'      implicit none', &
'      interface', &
'        subroutine my_routine(p) bind(c,name=''myC_func'')', &
'           import :: c_ptr', &
'           type(c_ptr), intent(out) :: p', &
'        end subroutine', &
'      end interface', &
'      type(c_ptr) :: cptr', &
'      real,pointer :: a(:)', &
'        call my_routine(cptr)', &
'        call c_f_pointer(cptr, a, [12])', &
'      end program demo_c_f_pointer', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025           c_f_pointer(3fortran)', &
'']

shortname="c_f_pointer"
call process()

case('56','c_f_procpointer')

textblock=[character(len=256) :: &
'', &
'c_f_procpointer(3fortran)                           c_f_procpointer(3fortran)', &
'', &
'NAME', &
'  C_F_PROCPOINTER(3) - [ISO_C_BINDING] Convert C into Fortran procedure', &
'  pointer', &
'', &
'SYNOPSIS', &
'  call c_f_procpointer(cptr, fptr)', &
'', &
'          subroutine c_f_procpointer(cptr, fptr )', &
'', &
'           type(c_funptr),intent(in) :: cprt', &
'           type(TYPE),pointer,intent(out) :: fprt', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  C_F_PROCPOINTER(3) assigns the target of the C function pointer CPTR to the', &
'  Fortran procedure pointer FPTR.', &
'', &
'OPTIONS', &
'  o  CPTR : scalar of the type c_funptr. It is INTENT(IN).', &
'', &
'  o  FPTR : procedure pointer interoperable with CPTR. It is INTENT(OUT).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_f_procpointer', &
'      use iso_c_binding', &
'      implicit none', &
'      abstract interface', &
'        function func(a)', &
'        import :: c_float', &
'        real(c_float), intent(in) :: a', &
'        real(c_float) :: func', &
'        end function', &
'      end interface', &
'      interface', &
'        function getIterFunc() bind(c,name="getIterFunc")', &
'        import :: c_funptr', &
'        type(c_funptr) :: getIterFunc', &
'        end function', &
'      end interface', &
'      type(c_funptr) :: cfunptr', &
'      procedure(func), pointer :: myFunc', &
'        cfunptr = getIterFunc()', &
'        call c_f_procpointer(cfunptr, myFunc)', &
'      end program demo_c_f_procpointer', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  C_LOC(3), C_F_POINTER(3), ISO_C_BINDING(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025       c_f_procpointer(3fortran)', &
'']

shortname="c_f_procpointer"
call process()

case('57','c_funloc')

textblock=[character(len=256) :: &
'', &
'c_funloc(3fortran)                                         c_funloc(3fortran)', &
'', &
'NAME', &
'  C_FUNLOC(3) - [ISO_C_BINDING] Obtain the C address of a procedure', &
'', &
'SYNOPSIS', &
'  result = c_funloc(x)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  C_FUNLOC(3) determines the C address of the argument.', &
'', &
'OPTIONS', &
'  o  X : Interoperable function or pointer to such function.', &
'', &
'RESULT', &
'  The return value is of type c_funptr and contains the C address of the', &
'  argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      ! program demo_c_funloc and module', &
'      module x', &
'      use iso_c_binding', &
'      implicit none', &
'      contains', &
'      subroutine sub(a) bind(c)', &
'      real(c_float) :: a', &
'        a = sqrt(a)+5.0', &
'      end subroutine sub', &
'      end module x', &
'      !', &
'      program demo_c_funloc', &
'      use iso_c_binding', &
'      use x', &
'      implicit none', &
'      interface', &
'        subroutine my_routine(p) bind(c,name=''myC_func'')', &
'          import :: c_funptr', &
'          type(c_funptr), intent(in) :: p', &
'        end subroutine', &
'      end interface', &
'        call my_routine(c_funloc(sub))', &
'      !', &
'      end program demo_c_funloc', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  C_ASSOCIATED(3), C_LOC(3), C_F_POINTER(3),', &
'', &
'  C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              c_funloc(3fortran)', &
'']

shortname="c_funloc"
call process()

case('58','char')

textblock=[character(len=256) :: &
'', &
'char(3fortran)                                                 char(3fortran)', &
'', &
'NAME', &
'  CHAR(3) - [CHARACTER:CONVERSION] Generate a character from a code value', &
'', &
'SYNOPSIS', &
'  result = char(i [,kind])', &
'', &
'          elemental character(kind=KIND) function char(i,KIND)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer of any kind', &
'', &
'  o  KIND is an integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'  o  The returned value is a character with the kind specified by KIND or if', &
'     KIND is not present, the default character kind.', &
'', &
'DESCRIPTION', &
'  Generates a character value given a numeric code representing the position I', &
'  in the collating sequence associated with the specified kind KIND.', &
'', &
'  Note that ACHAR(3) is a similar function specifically for ASCII characters', &
'  that is preferred when only ASCII is being processed, which is equivalent to', &
'  CHAR(I,KIND=SELECTED_CHAR_KIND("ASCII") )', &
'', &
'  The ICHAR(3) function is the reverse of CHAR(3), converting characters to', &
'  their collating sequence value.', &
'', &
'OPTIONS', &
'  o  I : a value in the range 0 <= I <= N-1, where N is the number of', &
'     characters in the collating sequence associated with the specified kind', &
'     type parameter. : For ASCII, N is 127. The default character set may or', &
'     may not allow higher values.', &
'', &
'  o  KIND : A constant integer initialization expression indicating the kind', &
'     parameter of the result. If not present, the default kind is assumed.', &
'', &
'RESULT', &
'  The return value is a single character of the specified kind, determined by', &
'  the position of I in the collating sequence associated with the specified', &
'  KIND.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_char', &
'      implicit none', &
'      integer, parameter :: ascii =  selected_char_kind ("ascii")', &
'      character(len=1, kind=ascii ) :: c, esc', &
'      integer :: i', &
'       ! basic', &
'        i=74', &
'        c=char(i)', &
'        write(*,*)''ASCII character '',i,''is '',c', &
'        write(*,''(*(g0))'')''Uppercase ASCII: '',(char(i),i=65,90)', &
'        write(*,''(*(g0))'')''lowercase ASCII: '',(char(i),i=97,122)', &
'        esc=char(27)', &
'        write(*,''(*(g0))'')''Elemental: '',char([65,97,90,122])', &
'       !', &
'        print *, ''a selection of ASCII characters (shows hex if not printable)''', &
'        do i=0,127,10', &
'           c = char(i,kind=ascii)', &
'           select case(i)', &
'           case(32:126)', &
'              write(*,''(i3,1x,a)'')i,c', &
'           case(0:31,127)', &
'              ! print hexadecimal value for unprintable characters', &
'              write(*,''(i3,1x,z2.2)'')i,c', &
'           case default', &
'              write(*,''(i3,1x,a,1x,a)'')i,c,''non-standard ASCII''', &
'           end select', &
'        enddo', &
'', &
'      end program demo_char', &
'', &
'  Results:', &
'', &
'       >  ASCII character          74 is J', &
'       > Uppercase ASCII: ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
'       > lowercase ASCII: abcdefghijklmnopqrstuvwxyz', &
'       > Elemental: AaZz', &
'       >  a selection of ASCII characters (shows hex if not printable)', &
'       >   0 00', &
'       >  10 0A', &
'       >  20 14', &
'       >  30 1E', &
'       >  40 (', &
'       >  50 2', &
'       >  60 <', &
'       >  70 F', &
'       >  80 P', &
'       >  90 Z', &
'       > 100 d', &
'       > 110 n', &
'       > 120 x', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  ACHAR(3), IACHAR(3), ICHAR(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  char(3fortran)', &
'']

shortname="char"
call process()

case('59','c_loc')

textblock=[character(len=256) :: &
'', &
'c_loc(3fortran)                                               c_loc(3fortran)', &
'', &
'NAME', &
'  C_LOC(3) - [ISO_C_BINDING] Obtain the C address of an object', &
'', &
'SYNOPSIS', &
'  result = c_loc(x)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  C_LOC(3) determines the C address of the argument.', &
'', &
'OPTIONS', &
'  o  X : Shall have either the pointer or target attribute. It shall not be a', &
'     coindexed object. It shall either be a variable with interoperable type', &
'     and kind type parameters, or be a scalar, nonpolymorphic variable with no', &
'     length type parameters.', &
'', &
'RESULT', &
'  The return value is of type c_ptr and contains the C address of the', &
'  argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'        subroutine association_test(a,b)', &
'        use iso_c_binding, only: c_associated, c_loc, c_ptr', &
'        implicit none', &
'        real, pointer :: a', &
'        type(c_ptr) :: b', &
'          if(c_associated(b, c_loc(a))) &', &
'             stop ''b and a do not point to same target''', &
'        end subroutine association_test', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  C_ASSOCIATED(3), C_FUNLOC(3), C_F_POINTER(3),', &
'', &
'  C_F_PROCPOINTER(3), ISO_C_BINDING(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                 c_loc(3fortran)', &
'']

shortname="c_loc"
call process()

case('60','close')

textblock=[character(len=256) :: &
'', &
'close(7fortran)                                               close(7fortran)', &
'', &
'NAME', &
'  close(7f) - [IO] terminate the connection of a specified unit to an external', &
'  file.', &
'', &
'SYNOPSIS', &
'  CLOSE ( [UNIT= ] file-unit-number,', &
'', &
'         [IOSTAT= scalar-int-variable,]', &
'         [IOMSG= iomsg-variable,]', &
'         [ERR= label,]', &
'         [STATUS= scalar-default-char-expr]', &
'  )', &
'', &
'DESCRIPTION', &
'  The CLOSE statement is used to terminate the connection of a specified unit', &
'  to an external file.', &
'', &
'  Execution of a CLOSE statement for a unit may occur in any program unit of a', &
'  program and need not occur in the same program unit as the execution of an', &
'  OPEN statement referring to that unit.', &
'', &
'  Execution of a CLOSE statement performs a wait operation for any pending', &
'  asynchronous data transfer operations for the specified unit.', &
'', &
'  Execution of a CLOSE statement specifying a unit that does not exist or has', &
'  no file connected to it is permitted and affects no file or unit.', &
'', &
'  After a unit has been disconnected by execution of a CLOSE statement, it may', &
'  be connected again within the same program, either to the same file or to a', &
'  different file. After a named file has been disconnected by execution of a', &
'  CLOSE statement, it may be connected again within the same program, either', &
'  to the same unit or to a different unit, provided that the file still', &
'  exists.', &
'', &
'  The input/output statements are the OPEN, CLOSE, READ, WRITE, PRINT,', &
'  BACKSPACE, ENDFILE, REWIND, FLUSH, WAIT, and INQUIRE statements.', &
'', &
'  OPEN, CLOSE, BACKSPACE, ENDFILE, and REWIND statements shall not be executed', &
'  while a parent data transfer statement is active.', &
'', &
'  A pure subprogram shall not contain a print-stmt, open-stmt, close-stmt,', &
'  backspace-stmt, endfile-stmt, rewind-stmt, flush-stmt, wait-stmt, or', &
'  inquire-stmt.', &
'', &
'  The READ statement is a data transfer input statement. The WRITE statement', &
'  and the PRINT statement are data transfer output statements. The OPEN', &
'  statement and the CLOSE statement are file connection statements. The', &
'  INQUIRE statement is a file inquiry statement. The BACKSPACE, ENDFILE, and', &
'  REWIND statements are file positioning statements.', &
'', &
'  All input/output statements may refer to files that exist. An INQUIRE, OPEN,', &
'  CLOSE, WRITE, PRINT, REWIND, FLUSH, or ENDFILE statement also may refer to a', &
'  file that does not exist. Execution of a WRITE, PRINT, or ENDFILE statement', &
'  referring to a preconnected file that does not exist creates the file. This', &
'  file is a different file from one preconnected on any other image.', &
'', &
'  AT PROGRAM TERMINATION During the completion step of termination of', &
'  execution of a program, all units that are connected are closed. Each unit', &
'  is closed with status KEEP unless the file status prior to termination of', &
'  execution was SCRATCH, in which case the unit is closed with status DELETE.', &
'', &
'  The effect is as though a CLOSE statement without a STATUS= specifier were', &
'  executed on each connected unit.', &
'', &
'OPTIONS', &
'  No specifier shall appear more than once in a given close-spec-list.', &
'', &
'  UNIT=file-unit-number : A file-unit-number shall be specified in a close-', &
'  spec-list; if the optional characters UNIT= are omitted, the file-unit-', &
'  number shall be the first item in the close-spec-list.  IOSTAT=scalar-int-', &
'  variable : 0 means no error occurred IOMSG=iomsg-variable : Character', &
'  variable to hold message if an error occurred. ERR=label : The label used in', &
'  the ERR= specifier shall be the statement label of a branch target statement', &
'  that appears in the same scoping unit as the CLOSE statement. STATUS=scalar-', &
'  default-char-expr : The expression has a limited list of character values.', &
'  Any trailing blanks are ignored. The value specified is without regard to', &
'  case.', &
'', &
'      The scalar-default-char-expr shall evaluate to KEEP or DELETE. The', &
'      STATUS= specifier determines the disposition of the file that', &
'      is connected to the specified unit. KEEP shall not be specified', &
'      for a file whose status prior to execution of a CLOSE statement', &
'      is SCRATCH. If KEEP is specified for a file that exists, the file', &
'      continues to exist after the execution of a CLOSE statement. If KEEP', &
'      is specified for a file that does not exist, the file will not exist', &
'      after the execution of a CLOSE statement. If DELETE is specified,', &
'      the file will not exist after the execution of a CLOSE statement. If', &
'      this specifier is omitted, the default value is KEEP, unless the', &
'      file status prior to execution of the CLOSE statement is SCRATCH,', &
'      in which case the default value is DELETE.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'         program demo_close', &
'         implicit none', &
'         character(len=256) :: message', &
'         integer            :: ios', &
'            open (10, file=''employee.names'', action=''read'', &', &
'            & iostat=ios,iomsg=message)', &
'            if (ios < 0) then', &
'               ! perform error processing on the unit 10 file.', &
'               close (10, status=''keep'',iostat=ios,iomsg=message)', &
'               if(ios.ne.0)then', &
'                  write(*,''(*(a))'')''*demo_close* close error: '',trim(message)', &
'                  stop 1', &
'               endif', &
'            elseif (ios > 0) then', &
'               ! perform error processing on open', &
'               write(*,''(*(a))'')''*demo_close* open error: '',trim(message)', &
'               stop 2', &
'            endif', &
'         end program demo_close', &
'', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025                 close(7fortran)', &
'']

shortname="close"
call process()

case('61','cmplx')

textblock=[character(len=256) :: &
'', &
'cmplx(3fortran)                                               cmplx(3fortran)', &
'', &
'NAME', &
'  CMPLX(3) - [TYPE:CONVERSION] Conversion to a complex type', &
'', &
'SYNOPSIS', &
'  result = cmplx(x [,kind]) | cmplx(x [,y] [,kind])', &
'', &
'          elemental complex(kind=KIND) function cmplx( x, y, kind )', &
'', &
'           type(TYPE(kind=**)),intent(in)          :: x', &
'           type(TYPE(kind=**)),intent(in),optional :: y', &
'           integer(kind=**),intent(in),optional    :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  X may be integer, real, or complex.', &
'', &
'  o  Y may be integer or real. Y is allowed only if X is not complex.', &
'', &
'  o  KIND is a constant integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'  The type of the arguments does not affect the kind of the result except for', &
'  a complex X value.', &
'', &
'  o  if KIND is not present and X is complex the result is of the kind of X.', &
'', &
'  o  if KIND is not present and X is not complex the result if of default', &
'     complex kind.', &
'', &
'  NOTE: a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  The CMPLX(3) function converts numeric values to a complex value.', &
'', &
'  Even though constants can be used to define a complex variable using syntax', &
'  like', &
'', &
'           z = (1.23456789, 9.87654321)', &
'', &
'  this will not work for variables. So you cannot enter', &
'', &
'           z = (a, b) ! NO ! (unless a and b are constants, not variables)', &
'', &
'  so to construct a complex value using non-complex values you must use the', &
'  CMPLX(3) function:', &
'', &
'           z = cmplx(a, b)', &
'', &
'  or assign values separately to the imaginary and real components using the', &
'  %IM and %RE designators:', &
'', &
'           z%re = a', &
'           z%im = b', &
'', &
'  If X is complex Y is not allowed and CMPLX essentially returns the input', &
'  value except for an optional change of kind, which can be useful when', &
'  passing a value to a procedure that requires the arguments to have a', &
'  different kind (and does not return an altered value):', &
'', &
'           call something(cmplx(z,kind=real64))', &
'', &
'  would pass a copy of a value with kind=real64 even if z had a different kind', &
'', &
'  but otherwise is equivalent to a simple assign. So if z1 and z2 were', &
'  complex:', &
'', &
'           z2 = z1        ! equivalent statements', &
'           z2 = cmplx(z1)', &
'', &
'  If X is not complex X is only used to define the real component of the', &
'  result but Y is still optional -- the imaginary part of the result will just', &
'  be assigned a value of zero.', &
'', &
'  If Y is present it is converted to the imaginary component.', &
'', &
'  CMPLX(3) AND DOUBLE PRECISION', &
'', &
'  Primarily in order to maintain upward compatibility you need to be careful', &
'  when working with complex values of higher precision that the default.', &
'', &
'  It was necessary for Fortran to continue to specify that CMPLX(3) always', &
'  return a result of the default kind if the KIND option is absent, since that', &
'  is the behavior mandated by FORTRAN 77.', &
'', &
'  It might have been preferable to use the highest precision of the arguments', &
'  for determining the return kind, but that is not the case. So with arguments', &
'  with greater precision than default values you are required to use the KIND', &
'  argument or the greater precision values will be reduced to default', &
'  precision.', &
'', &
'  This means CMPLX(D1,D2), where D1 and D2 are doubleprecision, is treated as:', &
'', &
'           cmplx(sngl(d1), sngl(d2))', &
'', &
'  which looses precision.', &
'', &
'  So Fortran 90 extends the CMPLX(3) intrinsic by adding an extra argument', &
'  used to specify the desired kind of the complex result.', &
'', &
'           integer,parameter :: dp=kind(0.0d0)', &
'           complex(kind=dp) :: z8', &
'  ! wrong ways to specify constant values ! note this was stored with default', &
'  real precision !  z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0)', &
'  print *, ''NO, Z8='',z8,real(z8),aimag(z8)', &
'', &
'    z8 = cmplx(1.2345678901234567e0_dp, 1.2345678901234567e0_dp) ! again, note', &
'    output components are just real print *, ''NO, Z8='',z8,real(z8),aimag(z8) !', &
'    ! YES !  ! kind= makes it work z8 = cmplx(1.2345678901234567d0,', &
'    1.2345678901234567d0,kind=dp) print *, ''YES, Z8='',z8,real(z8),aimag(z8)', &
'', &
'  A more recent alternative to using CMPLX(3) is "F2018 component syntax"', &
'  where real and imaginary parts of a complex entity can be accessed', &
'  independently:', &
'', &
'      value%RE    ! %RE specifies the real part', &
'      or', &
'      value%IM    ! %IM specifies the imaginary part', &
'', &
'  Where the designator value is of course of complex type.', &
'', &
'  The type of a complex-part-designator is real, and its kind and shape are', &
'  those of the designator. That is, you retain the precision of the complex', &
'  value by default, unlike with CMPLX.', &
'', &
'  The following are examples of complex part designators:', &
'', &
'            impedance%re           !-- Same value as real(impedance)', &
'            fft%im                 !-- Same value as AIMAG(fft)', &
'            x%im = 0.0             !-- Sets the imaginary part of x to zero', &
'            x(1:2)%re=[10,20]      !-- even if x is an array', &
'', &
'  NOTE for I/O', &
'', &
'  Note that if format statements are specified a complex value is treated as', &
'  two real values.', &
'', &
'  For list-directed I/O (ie. using an asterisk for a format) and NAMELIST', &
'  output the values are expected to be delimited by "(" and ")" and of the', &
'  form "(real_part,imaginary_part)". For NAMELIST input parenthesized values', &
'  or lists of multiple real values are acceptable.', &
'', &
'OPTIONS', &
'  o  X : The value assigned to the real component of the result when X is not', &
'     complex.', &
'', &
'     If X is complex, the result is the same as if the real part of the input', &
'     was passed as X and the imaginary part as Y.', &
'', &
'             result = CMPLX (REAL (X), AIMAG (X), KIND).', &
'', &
'     That is, a complex X value is copied to the result value with a possible', &
'     change of kind.', &
'', &
'  o  Y : Y is only allowed if X is not complex. Its value is assigned to the', &
'     imaginary component of the result and defaults to a value of zero if', &
'     absent.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  The return value is of complex type, with magnitudes determined by the', &
'  values X and Y.', &
'', &
'  The common case when X is not complex is that the real component of the', &
'  result is assigned the value of X and the imaginary part is zero or the', &
'  value of Y if Y is present.', &
'', &
'  When X is complex Y is not allowed and the result is the same value as X', &
'  with a possible change of kind. That is, the real part is REAL(X, KIND) and', &
'  the imaginary part is REAL(Y, KIND).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_aimag', &
'      implicit none', &
'      integer,parameter :: dp=kind(0.0d0)', &
'      real(kind=dp)    :: precise', &
'      complex(kind=dp) :: z8', &
'      complex          :: z4, zthree(3)', &
'        precise=1.2345678901234567d0', &
'', &
'       ! basic', &
'        z4 = cmplx(-3)', &
'        print *, ''Z4='',z4', &
'        z4 = cmplx(1.23456789, 1.23456789)', &
'        print *, ''Z4='',z4', &
'        ! with a format treat a complex as two real values', &
'        print ''(1x,g0,1x,g0,1x,g0)'',''Z4='',z4', &
'', &
'       ! working with higher precision values', &
'        ! using kind=dp makes it keep DOUBLEPRECISION precision', &
'        ! otherwise the result would be of default kind', &
'        z8 = cmplx(precise, -precise )', &
'        print *, ''lost precision Z8='',z8', &
'        z8 = cmplx(precise, -precise ,kind=dp)', &
'        print *, ''kept precision Z8='',z8', &
'', &
'       ! assignment of constant values does not require cmplx(3)00', &
'        ! The following is intuitive and works without calling cmplx(3)', &
'        ! but does not work for variables just constants', &
'        z8 = (1.1111111111111111d0, 2.2222222222222222d0 )', &
'        print *, ''Z8 defined with constants='',z8', &
'', &
'       ! what happens when you assign a complex to a real?', &
'        precise=z8', &
'        print *, ''LHS='',precise,''RHS='',z8', &
'', &
'       ! elemental', &
'        zthree=cmplx([10,20,30],-1)', &
'        print *, ''zthree='',zthree', &
'', &
'       ! descriptors are an alternative', &
'        zthree(1:2)%re=[100,200]', &
'        print *, ''zthree='',zthree', &
'', &
'      end program demo_aimag', &
'', &
'  Results:', &
'', &
'       > Z4= (-3.000000,0.0000000E+00)', &
'       > Z4= (1.234568,1.234568)', &
'       > Z4= 1.234568 1.234568', &
'       > lost precision Z8= (1.23456788063049,-1.23456788063049)', &
'       > kept precision Z8= (1.23456789012346,-1.23456789012346)', &
'       > Z8 defined with constants= (1.11111111111111,2.22222222222222)', &
'       > LHS=   1.11111111111111      RHS= (1.11111111111111,2.22222222222222)', &
'       > zthree= (10.00000,-1.000000) (20.00000,-1.000000) (30.00000,-1.000000)', &
'       > zthree= (100.0000,-1.000000) (200.0000,-1.000000) (30.00000,-1.000000)', &
'', &
'STANDARD', &
'  FORTRAN 77, KIND added in Fortran 90.', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CONJG(3) - Complex conjugate function', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  Fortran has strong support for complex values, including many intrinsics', &
'  that take or produce complex values in addition to algebraic and logical', &
'  expressions:', &
'', &
'  ABS(3), ACOSH(3), ACOS(3), ASINH(3), ASIN(3), ATAN2(3), ATANH(3), ATAN(3),', &
'  COSH(3), COS(3), CO_SUM(3), DBLE(3), DOT_PRODUCT(3), EXP(3), INT(3),', &
'  IS_CONTIGUOUS(3), KIND(3), LOG(3), MATMUL(3), PRECISION(3), PRODUCT(3),', &
'  RANGE(3), RANK(3), SINH(3), SIN(3), SQRT(3), STORAGE_SIZE(3), SUM(3),', &
'  TANH(3), TAN(3), UNPACK(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 cmplx(3fortran)', &
'']

shortname="cmplx"
call process()

case('62','co_broadcast')

textblock=[character(len=256) :: &
'', &
'co_broadcast(3fortran)                                 co_broadcast(3fortran)', &
'', &
'NAME', &
'  CO_BROADCAST(3) - [COLLECTIVE] Copy a value to all images the current set of', &
'  images', &
'', &
'SYNOPSIS', &
'  call co_broadcast(a, source_image [,stat] [,errmsg] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_BROADCAST(3) copies the value of argument A on the image with image index', &
'  source_image to all images in the current team. A becomes defined as if by', &
'  intrinsic assignment. If the execution was successful and STAT is present,', &
'  it is assigned the value zero. If the execution failed, STAT gets assigned a', &
'  nonzero value and, if present, ERRMSG gets assigned a value describing the', &
'  occurred error.', &
'', &
'OPTIONS', &
'  o  A : INTENT(INOUT) argument; shall have the same dynamic type and type', &
'     parameters on all images of the current team. If it is an array, it shall', &
'     have the same shape on all images.', &
'', &
'  o  SOURCE_IMAGE : a scalar integer expression. It shall have the same the', &
'     same value on all images and refer to an image of the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_broadcast', &
'      implicit none', &
'      integer :: val(3)', &
'        if (this_image() == 1) then', &
'           val = [1, 5, 3]', &
'        endif', &
'        call co_broadcast (val, source_image=1)', &
'        print *, this_image(), ":", val', &
'      end program demo_co_broadcast', &
'', &
'STANDARD', &
'  Fortran xx', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_MIN(3), CO_SUM(3), CO_REDUCE(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          co_broadcast(3fortran)', &
'']

shortname="co_broadcast"
call process()

case('63','co_lbound')

textblock=[character(len=256) :: &
'', &
'co_lbound(3fortran)                                        co_lbound(3fortran)', &
'', &
'NAME', &
'  CO_LBOUND(3) - [COLLECTIVE] Lower codimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = co_lbound( coarray [,dim] [,kind] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_LBOUND(3) returns the lower bounds of a coarray, or a single lower', &
'  cobound along the DIM codimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RESULT', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  CO_UBOUND(3), LBOUND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                               February 18, 2023           co_lbound(3fortran)', &
'']

shortname="co_lbound"
call process()

case('64','co_max')

textblock=[character(len=256) :: &
'', &
'co_max(3fortran)                                             co_max(3fortran)', &
'', &
'NAME', &
'  CO_MAX(3) - [COLLECTIVE] Maximal value on the current set of images', &
'', &
'SYNOPSIS', &
'  call co_max(a, result_image [,stat] [,errmsg] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_MAX(3) determines element-wise the maximal value of A on all images of', &
'  the current team. If result_image is present, the maximum values are', &
'  returned in A on the specified image only and the value of A on the other', &
'  images become undefined. If result_image is not present, the value is', &
'  returned on all images. If the execution was successful and STAT is present,', &
'  it is assigned the value zero. If the execution failed, STAT gets assigned a', &
'  nonzero value and, if present, ERRMSG gets assigned a value describing the', &
'  occurred error.', &
'', &
'OPTIONS', &
'  o  A : shall be an integer, real or character variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_max', &
'      implicit none', &
'      integer :: val', &
'        val = this_image()', &
'        call co_max(val, result_image=1)', &
'        if (this_image() == 1) then', &
'          write(*,*) "Maximal value", val  ! prints num_images()', &
'        endif', &
'      end program demo_co_max', &
'', &
'  Results:', &
'', &
'       > Maximal value           2', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  CO_MIN(3), CO_SUM(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                co_max(3fortran)', &
'']

shortname="co_max"
call process()

case('65','co_min')

textblock=[character(len=256) :: &
'', &
'co_min(3fortran)                                             co_min(3fortran)', &
'', &
'NAME', &
'  CO_MIN(3) - [COLLECTIVE] Minimal value on the current set of images', &
'', &
'SYNOPSIS', &
'  call co_min(a, result_image [,stat] [,errmsg] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_MIN(3) determines element-wise the minimal value of A on all images of', &
'  the current team. If result_image is present, the minimal values are', &
'  returned in A on the specified image only and the value of A on the other', &
'  images become undefined. If result_image is not present, the value is', &
'  returned on all images. If the execution was successful and STAT is present,', &
'  it is assigned the value zero. If the execution failed, STAT gets assigned a', &
'  nonzero value and, if present, ERRMSG gets assigned a value describing the', &
'  occurred error.', &
'', &
'OPTIONS', &
'  o  A : shall be an integer, real or character variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_min', &
'      implicit none', &
'      integer :: val', &
'        val = this_image()', &
'        call co_min(val, result_image=1)', &
'        if (this_image() == 1) then', &
'          write(*,*) "Minimal value", val  ! prints 1', &
'        endif', &
'      end program demo_co_min', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_SUM(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                co_min(3fortran)', &
'']

shortname="co_min"
call process()

case('66','command_argument_count')

textblock=[character(len=256) :: &
'', &
'command_argument_count(3fortran)             command_argument_count(3fortran)', &
'', &
'NAME', &
'  COMMAND_ARGUMENT_COUNT(3) - [SYSTEM:COMMAND LINE] Get number of command line', &
'  arguments', &
'', &
'SYNOPSIS', &
'  result = command_argument_count()', &
'', &
'          integer function command_argument_count()', &
'', &
'CHARACTERISTICS', &
'  o  the result is of default integer scalar.', &
'', &
'DESCRIPTION', &
'  COMMAND_ARGUMENT_COUNT(3) returns the number of arguments passed on the', &
'  command line when the containing program was invoked.', &
'', &
'OPTIONS', &
'  None', &
'', &
'RESULT', &
'  The return value is of type default integer. It is the number of arguments', &
'  passed on the command line when the program was invoked.', &
'', &
'  If there are no command arguments available or if the processor does not', &
'  support command arguments, then the result has the value zero.', &
'', &
'  If the processor has a concept of a command name, the command name does not', &
'  count as one of the command arguments.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_command_argument_count', &
'      implicit none', &
'      integer :: count', &
'        count = command_argument_count()', &
'        print *, count', &
'      end program demo_command_argument_count', &
'', &
'  Sample output:', &
'', &
'        # the command verb does not count', &
'        ./test_command_argument_count', &
'            0', &
'        # quoted strings may count as one argument', &
'        ./test_command_argument_count count arguments', &
'            2', &
'        ./test_command_argument_count ''count arguments''', &
'            1', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  GET_COMMAND(3), GET_COMMAND_ARGUMENT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025command_argument_count(3fortran)', &
'']

shortname="command_argument_count"
call process()

case('67','comment')

textblock=[character(len=256) :: &
'', &
'comment(5fortran)                                           comment(5fortran)', &
'', &
'NAME', &
'  COMMENT(5) - [SYNTAX] code annotation', &
'', &
'SYNOPSIS', &
'  Fixed and Free comments', &
'', &
'         C fixed-format comment', &
'         ! free-format comment', &
'            ! free-format comment', &
'         CODE_LINE ! free-format comment', &
'', &
'DESCRIPTION', &
'  In free-format files The character "!" initiates a comment except when it', &
'  appears in a character context as part of a literal string.', &
'', &
'  The comment extends to the end of the line.', &
'', &
'  If the first nonblank character on a line is an "!", the line is a "comment', &
'  line". Lines containing only blanks or containing no characters are also', &
'  comment lines.', &
'', &
'  "comment lines" may appear anywhere. There are a few restrictions on', &
'  comments trailing statements or continued statements though.', &
'', &
'  Comments may appear anywhere in a program unit and may precede the first', &
'  statement of a program unit or follow the last statement of a program unit.', &
'', &
'  Comments have no effect on the interpretation of the program unit.', &
'', &
'  A continued line ending in an ampersand can additionally be followed by an', &
'  exclamation and remarks unless a literal string is being continued.', &
'', &
'  Comment lines cannot be continued with an ampersand. An ampersand appearing', &
'  in a comment has no special effect and is merely a regular character.', &
'', &
'  The standard does not restrict the number of consecutive comment lines.', &
'', &
'  FIXED-FORMAT SOURCE FILES', &
'', &
'  Additionally, in fixed-format source files a "C" in column 1 indicates the', &
'  remainder of the line is a comment. An asterisk "*" in column 1 beginning a', &
'  comment is a common extension as well.', &
'', &
'  There is a conflict in fixed-format files that can occur with the otherwise', &
'  universal rule that at exclamation outside of a literal string begins a', &
'  comment -- If the first non-blank character in a line is in column 6 in a', &
'  fixed-format file it is a continuation line, not a comment. This rule', &
'  includes an exclamation character as well.', &
'', &
'FREE FORM COMMENTARY', &
'  A comment is explanatory text embedded in program source intended to help', &
'  human readers understand it.', &
'', &
'  Code completely without comments is often hard to read, but code with too', &
'  many comments is also bad, especially if the comments are not kept up-to-', &
'  date with changes to the code.', &
'', &
'  Too much commenting may mean that the code is over-complicated.', &
'', &
'  A good rule is to comment everything that needs it but write code that', &
'  doesn''t need much of it.', &
'', &
'  Comments that explain WHY something is done and how the code relates to its', &
'  environment are useful.', &
'', &
'  A particularly irksome form of over-commenting explains exactly what each', &
'  statement does, even when it is obvious to any reasonably competant', &
'  programmer.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_comment', &
'      integer :: values(8)', &
'      character(len=:),allocatable :: string', &
'      character(len=1),parameter   :: dash=''-'',colon='':'',dot=''.''', &
'      real :: x=3.0, y=4.0', &
'        ! comments may appear on a continued line', &
'        ! blank lines are comment lines', &
'        call date_and_time(values=values)', &
'        associate( &', &
'', &
'         ! DATE', &
'         YR=>values(1),      & ! The year', &
'         MO=>values(2),      & ! The month', &
'         DY=>values(3),      & ! The day of the month', &
'', &
'         ! TIME', &
'         UTC=>values(4),     & ! Time difference with UTC in minutes', &
'         HR=>values(5),      & ! The hour of the day', &
'         MIN=>values(6),     & ! The minutes of the hour', &
'         SEC=>values(7),     & ! The seconds of the minute', &
'         MILLI=>values(8) )    ! The milliseconds of the second', &
'', &
'         write(*,''(*(g0))'')YR,dash,MO,dash,DY,''T'', &', &
'         & HR,colon,MIN,colon,SEC,dot,MILLI', &
'        end associate', &
'', &
'        string=''no comment allowed &', &
'           &on the end of a continued string &', &
'           ! keep going ...', &
'           & but comment lines are allowed between '' ! but can go on the end', &
'', &
'        ! the next exclamation is part of a literal string, and so has', &
'        ! nothing to do with comments', &
'        print *, ''Hello World! X='',x,''Y='',y', &
'', &
'      end program demo_comment', &
'', &
'  Results:', &
'', &
'    2024-10-13T0:7:25.283 Hello World! X= 4.59107416E-41 Y= 2.76724564E-36', &
'', &
'SEE ALSO', &
'  CONTINUATION(5),', &
'', &
'                               March 16, 2025               comment(5fortran)', &
'']

shortname="comment"
call process()

case('68','compiler_options')

textblock=[character(len=256) :: &
'', &
'compiler_options(3fortran)                         compiler_options(3fortran)', &
'', &
'NAME', &
'  COMPILER_OPTIONS(3) - [COMPILER:INQUIRY] Options passed to the compiler', &
'', &
'SYNOPSIS', &
'  result = compiler_options()', &
'', &
'          character(len=:) function compiler_options()', &
'', &
'CHARACTERISTICS', &
'  o  the return value is a default-kind character variable with system-', &
'     dependent length.', &
'', &
'DESCRIPTION', &
'  COMPILER_OPTIONS(3) returns a string with the options used for compiling.', &
'', &
'OPTIONS', &
'  None.', &
'', &
'RESULT', &
'  The result contains the compiler flags used to compile the file containing', &
'  the COMPILER_OPTIONS(3) call.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_options', &
'      implicit none', &
'        print ''(4a)'', &', &
'           ''This file was compiled by '', &', &
'           compiler_version(),           &', &
'           '' using the options '',      &', &
'           compiler_options()', &
'      end program demo_compiler_version', &
'', &
'  Results:', &
'', &
'       > This file was compiled by GCC version 10.3.0 using', &
'       > the options -I build/gfortran_2A42023B310FA28D', &
'       > -mtune=generic -march=x86-64 -auxbase-strip', &
'       > build/gfortran_2A42023B310FA28D/compiler_options/app_main.f90.o', &
'       > -g -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1', &
'       > -fcheck=bounds -fcheck=array-temps -fbacktrace', &
'       > -fcoarray=single -J build/gfortran_2A42023B310FA28D', &
'       > -fpre-include=/usr/include/finclude/math-vector-fortran.h', &
'', &
'       > This file was compiled by nvfortran 21.5-0 LLVM', &
'       > using the options app/main.f90 -c -Minform=inform', &
'       > -Mbackslash -Mbounds -Mchkptr -Mchkstk -traceback -module', &
'       > build/nvfortran_78229DCE997517A4 -Ibuild/nvfortran_78229DCE997517A4 -o', &
'       > build/nvfortran_78229DCE997517A4/compiler_options/app_main.f90.o', &
'', &
'       > This file was compiled by Intel(R) Fortran Intel(R) 64 Compiler Classic', &
'       > for applications running on Intel(R) 64, Version 2021.3.0 Build', &
'       > 20210609_000000 using the options -Ibuild/ifort_5C58216731706F11', &
'       > -c -warn all -check all -error-limit 1 -O0 -g -assume', &
'       > byterecl -traceback -module build/ifort_5C58216731706F11 -o', &
'       > build/ifort_5C58216731706F11/compiler_options/app_main.f90.o', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  COMPILER_VERSION(3), ISO_FORTRAN_ENV(7)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025      compiler_options(3fortran)', &
'']

shortname="compiler_options"
call process()

case('69','compiler_version')

textblock=[character(len=256) :: &
'', &
'compiler_version(3fortran)                         compiler_version(3fortran)', &
'', &
'NAME', &
'  COMPILER_VERSION(3) - [COMPILER:INQUIRY] Compiler version string', &
'', &
'SYNOPSIS', &
'  result = compiler_version()', &
'', &
'          character(len=:) function compiler_version()', &
'', &
'CHARACTERISTICS', &
'  o  The return value is a default-kind scalar character with system-dependent', &
'     length.', &
'', &
'DESCRIPTION', &
'  COMPILER_VERSION(3) returns a string containing the name and version of the', &
'  compiler.', &
'', &
'OPTIONS', &
'  None.', &
'', &
'RESULT', &
'  The return value contains the name of the compiler and its version number', &
'  used to compile the file containing the COMPILER_VERSION(3) call.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_version', &
'      use, intrinsic :: iso_fortran_env, only : compiler_options', &
'      implicit none', &
'        print ''(4a)'', &', &
'           ''This file was compiled by '', &', &
'           compiler_version(),           &', &
'           '' using the options '',      &', &
'           compiler_options()', &
'      end program demo_compiler_version', &
'', &
'  Results:', &
'', &
'       > This file was compiled by GCC version 10.3.0', &
'', &
'       > This file was compiled by Intel(R) Fortran Intel(R) 64 Compiler', &
'       > Classic for applications running on Intel(R) 64, Version 2021.3.0 Build', &
'       > 20210609_000000', &
'', &
'       > This file was compiled by nvfortran 21.5-0 LLVM', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  COMPILER_OPTIONS(3), ISO_FORTRAN_ENV(7)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025      compiler_version(3fortran)', &
'']

shortname="compiler_version"
call process()

case('70','conjg')

textblock=[character(len=256) :: &
'', &
'conjg(3fortran)                                               conjg(3fortran)', &
'', &
'NAME', &
'  CONJG(3) - [NUMERIC] Complex conjugate of a complex value', &
'', &
'SYNOPSIS', &
'  result = conjg(z)', &
'', &
'          elemental complex(kind=KIND) function conjg(z)', &
'', &
'           complex(kind=**),intent(in) :: z', &
'', &
'CHARACTERISTICS', &
'  o  Z is a complex value of any valid kind.', &
'', &
'  o  The returned value has the same complex type as the input.', &
'', &
'DESCRIPTION', &
'  CONJG(3) returns the complex conjugate of the complex value Z.', &
'', &
'  That is, If Z is the complex value (X, Y) then the result is (X, -Y).', &
'', &
'  In mathematics, the complex conjugate of a complex number is a value whose', &
'  real and imaginary part are equal parts are equal in magnitude to each other', &
'  but the Y value has opposite sign.', &
'', &
'  For matrices of complex numbers, CONJG(ARRAY) represents the element-by-', &
'  element conjugation of ARRAY; not the conjugate transpose of the ARRAY .', &
'', &
'OPTIONS', &
'  o  Z : The value to create the conjugate of.', &
'', &
'RESULT', &
'  Returns a value equal to the input value except the sign of the imaginary', &
'  component is the opposite of the input value.', &
'', &
'  That is, if Z has the value (X,Y), the result has the value (X, -Y).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_conjg', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      complex :: z = (2.0, 3.0)', &
'      complex(kind=real64) :: dz = (   &', &
'        &  1.2345678901234567_real64, -1.2345678901234567_real64)', &
'      complex :: arr(3,3)', &
'      integer :: i', &
'        ! basics', &
'         ! notice the sine of the imaginary component changes', &
'         print *, z, conjg(z)', &
'', &
'         ! any complex kind is supported. z is of default kind but', &
'         ! dz is kind=real64.', &
'         print *, dz', &
'         dz = conjg(dz)', &
'         print *, dz', &
'         print *', &
'', &
'         ! the function is elemental so it can take arrays', &
'         arr(1,:)=[(-1.0, 2.0),( 3.0, 4.0),( 5.0,-6.0)]', &
'         arr(2,:)=[( 7.0,-8.0),( 8.0, 9.0),( 9.0, 9.0)]', &
'         arr(3,:)=[( 1.0, 9.0),( 2.0, 0.0),(-3.0,-7.0)]', &
'', &
'         write(*,*)''original''', &
'         write(*,''(3("(",g8.2,",",g8.2,")",1x))'')(arr(i,:),i=1,3)', &
'         arr = conjg(arr)', &
'         write(*,*)''conjugate''', &
'         write(*,''(3("(",g8.2,",",g8.2,")",1x))'')(arr(i,:),i=1,3)', &
'', &
'      end program demo_conjg', &
'', &
'  Results:', &
'', &
'       >  (2.000000,3.000000) (2.000000,-3.000000)', &
'       >', &
'       >  (1.23456789012346,-1.23456789012346)', &
'       >  (1.23456789012346,1.23456789012346)', &
'       >', &
'       >  original', &
'       > (-1.0   , 2.0    ) ( 3.0    , 4.0    ) ( 5.0    ,-6.0    )', &
'       > ( 7.0   ,-8.0    ) ( 8.0    , 9.0    ) ( 9.0    , 9.0    )', &
'       > ( 1.0   , 9.0    ) ( 2.0    , 0.0    ) (-3.0    ,-7.0    )', &
'       >', &
'       >  conjugate', &
'       > (-1.0   ,-2.0    ) ( 3.0    ,-4.0    ) ( 5.0    , 6.0    )', &
'       > ( 7.0   , 8.0    ) ( 8.0    ,-9.0    ) ( 9.0    ,-9.0    )', &
'       > ( 1.0   ,-9.0    ) ( 2.0    , 0.0    ) (-3.0    , 7.0    )', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Complex conversion function', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  Fortran has strong support for complex values, including many intrinsics', &
'  that take or produce complex values in addition to algebraic and logical', &
'  expressions:', &
'', &
'  ABS(3), ACOSH(3), ACOS(3), ASINH(3), ASIN(3), ATAN2(3), ATANH(3), ATAN(3),', &
'  COSH(3), COS(3), CO_SUM(3), DBLE(3), DOT_PRODUCT(3), EXP(3), INT(3),', &
'  IS_CONTIGUOUS(3), KIND(3), LOG(3), MATMUL(3), PRECISION(3), PRODUCT(3),', &
'  RANGE(3), RANK(3), SINH(3), SIN(3), SQRT(3), STORAGE_SIZE(3), SUM(3),', &
'  TANH(3), TAN(3), UNPACK(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 conjg(3fortran)', &
'']

shortname="conjg"
call process()

case('71','continuation')

textblock=[character(len=256) :: &
'', &
'continuation(5fortran)                                 continuation(5fortran)', &
'', &
'NAME', &
'  CONTINUATION(5) - [FORTRAN] - the rules for free-format line continuation', &
'', &
'SYNOPSIS', &
'  general rule:', &
'', &
'        original long statement', &
'', &
'           becomes', &
'', &
'        original&', &
'        & long&', &
'        & statement', &
'', &
'DESCRIPTION', &
'  You may split almost all free-format Fortran statements into multiple lines', &
'  by inserting the sequence "&\n&", where "\n" represents a newline.  That is,', &
'  split the line into two lines and place an ampersand at the right end of the', &
'  first line and as the first (non-space) character in the second line.', &
'', &
'  You CANNOT split a comment or an INCLUDE pre-processor directive onto', &
'  multiple lines using this syntax.', &
'', &
'  The rule for commenting continued lines is simple, really. Comments can go', &
'  in the same places on continued lines as on non-continued lines accept they', &
'  cannot appear after the right-hand "&" when continuing a long string.', &
'', &
'  So applying the general rule the line', &
'', &
'       integer,save :: xx(2,3)= reshape([ 1,2,3,4,5,6 ],shape(xx),order=[2,1])', &
'', &
'  may be split into many lines by simple repeated application of the rule:', &
'', &
'         integer,save :: xx(2,3)= reshape([&', &
'         & 1, 2, 3,  &', &
'         & 4, 5, 6   &', &
'         &],shape(xx),order=[2,1])', &
'', &
'  Of course, when used for continuation the "&" is not part of the equivalent', &
'  concatenated statement.', &
'', &
'  That is basically it for the general rule, but there are a few variants and', &
'  details to cover.', &
'', &
'  When a line is split using the general rule any trailing spaces before the', &
'  amersand at the end of the line are included in the equivalent single-line', &
'  statement.', &
'', &
'  However, spaces before the ampersand beginning the second line are ignored.', &
'  So you can indent the lines beginning with an ampersand any way you like:', &
'', &
'         integer,save :: xx(2,3)= reshape([&', &
'              & 1, 2, 3, &', &
'              & 4, 5, 6  &', &
'         &],shape(xx),order=[2,1])', &
'', &
'  Now it ends up the leading ampersand is actually optional if not splitting a', &
'  lexical token or constant numeric or string value (which is generally not', &
'  recommended anyway). If not present the result is the same as if an', &
'  ampersand were inserted as the first character of the line -- so the leading', &
'  spaces are significant when the leading ampersand is absent. When not', &
'  splitting strings multiple spaces generally are treated the same as a single', &
'  space so this is equivalent to the previous example:', &
'', &
'         integer,save :: xx(2,3)= reshape([ &', &
'                1, 2, 3,                    &', &
'                4, 5, 6                     &', &
'         ],shape(xx),order=[2,1])', &
'', &
'COMMENTS ON COMMENTING CONTINUED LINES', &
'  First, note you cannot continue a comment onto another line. An "&" in a', &
'  comment is treated like any other character, with no special effect (Just', &
'  start an additional comment line if you want a comment to appear across', &
'  multiple lines).', &
'', &
'  That being said, comments themselves may occur as individual lines inbetween', &
'  sections of a continued statement, or after the ending ampersand IF NOT', &
'  CONTINUING A STRING CONSTANT.', &
'', &
'  So lets add an explanation about the continued line using in-line comments,', &
'  comment lines and blank lines:', &
'', &
'         integer,save :: xx(2,3)= reshape([& ! define array in row-column order', &
'', &
'            !===========!', &
'            & 1, 2, 3,  &   ! row 1', &
'            & 4, 5, 6   &   ! row 2', &
'            !===========!', &
'', &
'         ],shape(xx),order=[2,1])', &
'', &
'  So trailing comments are allowed on non-character continuations, and comment', &
'  lines and blank lines are always allowed.', &
'', &
'  Note no line shall contain a single "&" as the only nonblank character or as', &
'  the only nonblank character before an ! that initiates a comment.', &
'', &
'  you have to have the leading amersand on continued lines when splitting', &
'  quoted strings or lexical words or constant values.', &
'', &
'  But try to never split constants or lexical words!', &
'', &
'         character(len=*),parameter :: str1=''my first str'',str2=''my second str''', &
'', &
'  could be written as', &
'', &
'         char&', &
'         &acter(len=*), para&', &
'         &meter :: str1=''my fi&', &
'         &rst str'', str2=''my se&', &
'         &cond str''', &
'', &
'  where things were split in two in a haphazard way as long as no spaces are', &
'  introduced before the ending amersand and after the leading amersand that', &
'  would make the statement illegal if all appearing on one line (ignoring', &
'  length for the moment).', &
'', &
'  This is a more realistic example (a very long string):', &
'', &
'        character(len=*),parameter=''this is a really long string &', &
'          &that I needed to put onto several lines because it would be&', &
'          & so long if I left it on a single line that it might be longer&', &
'          & than allowed in older compilers and would certainly not fit &', &
'          &in my favorite 80-column&', &
'          & terminal window''', &
'', &
'HOW LONG YOU CAN CONTINUE', &
'  Since we are talking about very long lines, how long can a single statement', &
'  be? In the Fortran 95 standard, only a maximum of 39 continuation lines is', &
'  required to be conformant. In Fortran 2003 and Fortran 2008, at least 255 is', &
'  to be allowed. There is no limit specified in Fortran 2018. See your', &
'  compiler documentation to see if your compiler still has a limit, but it is', &
'  probably at least a few hundred lines.', &
'', &
'FIXED FORMAT AND INCLUDE FILES', &
'  NOTE: Skip this session if you do not need to deal with (typically old)', &
'  fixed-format Fortran files.', &
'', &
'  Fixed-format Fortran has a very different continuation rule where the first', &
'  line has nothing added to it except an optional zero in column six and all', &
'  continuations have a non-space non-zero character that is part of the', &
'  Fortran character set in column six. If a quoted string is broken the first', &
'  line acts as if padded with spaces out to column 72.', &
'', &
'  Even though the rules for continueing statements on multiple lines are so', &
'  different, source code can be formatted in a format that works in both free', &
'  and fixed-format files.', &
'', &
'  Other than being just a curiosity, this is useful if an INCLUDE file is', &
'  needed by both free and fixed-format files. (Note that INCLUDE statements', &
'  themselves are one of the few statements that cannot be split across', &
'  multiple lines!).', &
'', &
'  So here is how to make an INCLUDE file for both fixed and free-format files:', &
'', &
'  o  Conne statement labels to character positions 1 to 5 and statements to', &
'     character positions 7 to 72, which is a requirement of fixed-format.', &
'', &
'  o  Treat blanks as being significant, which they are in free-format.', &
'', &
'  o  Use only the exclamation mark (!) to indicate a comment, but do not start', &
'     the comment in character position 6.', &
'', &
'  o  For continued statements, place an ampersand (&) in both character', &
'     position 73 of a continued line and character position 6 of a', &
'     continuation line.', &
'', &
'  Why does this work?', &
'', &
'  If every line being continued has an ampersand in column 73 or further the', &
'  ampersand will be ignored by standard fixed-format Fortran.', &
'', &
'  Combined with the second ampersand always present and in column six for all', &
'  but the first line both rules for free and fixed source files are satisfied.', &
'', &
'  Fixed-format can use most printable characters in column 6 to indication', &
'  continuation. One of the allowed characters is "&", which is the one and', &
'  only character used by free-format. So using it obeys both rules.', &
'', &
'  Therefore the following is equivalent in fixed and free-format parsing:', &
'', &
'       >12345 continue', &
'       >      character(len=*),parameter :: string1="hello world",string2="hel&', &
'       >     &lo world"', &
'', &
'  Obviously, this is not compatible with extended length fixed-format source', &
'  files (which some compilers support as an extension) unless the ampersand is', &
'  shifted beyond the extended limit (which in standard fixed-format files', &
'  would be past column 72).', &
'', &
'  You may want to look for a compiler option to disable long-line warnings', &
'  when using characters past column 72.', &
'', &
'EXAMPLE', &
'  Example program', &
'', &
'      program demo_continuation', &
'      implicit none', &
'      integer :: point(3)', &
'      character(len=:),allocatable :: string', &
'', &
'      ! one statement using continuation:', &
'      integer,save :: xx(3,5)= reshape([& ! define in row-column order', &
'      !-------------------------!', &
'       1,    2,   3,   4,   5, &  ! row 1', &
'       10,  20,  30,  40,  50, &  ! row 2', &
'       11,  22,  33,  44,  55  &  ! row 3', &
'      !-------------------------!', &
'', &
'      ],shape(xx),order=[2,1])', &
'', &
'      ! print it in row-column order too', &
'       call print_matrix_int(''xx array:'',xx)', &
'       xx(3,5)= -1051', &
'       call print_matrix_int(''xx array:'',xx)', &
'', &
'      ! So this is OK:', &
'        POINT=[&   ! define a Point <X,Y,Z>', &
'        & 10, &    ! the X component', &
'        & 20, &    ! the Y component', &
'        & 30  ]    ! the Z component', &
'', &
'      ! because you can have comments after the ampersand when it is not', &
'      ! a string.', &
'      ! But this is not OK:', &
'      !   STRING=''&    ! create a sentence', &
'      !   & This&      ! first word', &
'      !   & is&        ! second word', &
'      !   & sentence&  ! third word', &
'      !   & a''               ! forth word (a comment here is OK)', &
'      !Because when continuing a string you cannot have a comment after the "&".', &
'      !', &
'      ! This is OK:', &
'        STRING=''&', &
'        ! create a sentence', &
'        & This&', &
'        ! first word', &
'        & is&', &
'        ! second word', &
'        & sentence&', &
'        ! third word', &
'        & a''       ! forth word (a comment here is OK)', &
'      ! because comment LINES can go anywhere in Fortran source files', &
'', &
'      ! Dusty corners', &
'        call splitting_a_token()', &
'        call longstring()', &
'      contains', &
'', &
'      subroutine splitting_a_token()', &
'', &
'      ! Often denoted by "e" in honor of Euler,', &
'      ! Napier''s constant is the base of the natural logarithm system.', &
'      real(kind=kind(0.0d0)),parameter :: &', &
'      & Napier_constant = 2.71828182845904523d0', &
'', &
'      ! without continuation', &
'      write(*,*)napier_constant', &
'', &
'      ! splitting a token the & is required', &
'      write(*,*)napier_&', &
'      &constant', &
'', &
'      ! the left-hand ampersand is required when splitting constants to,', &
'      ! including characters strings', &
'      write(*,*)''Expecting &', &
'               &the value'',2.71828182&', &
'               &845904523d0', &
'', &
'      !NOT ALLOWED <<<<<<', &
'      !write(*,*)napier_&', &
'      !constant', &
'      !>>>>>>>', &
'', &
'      ! splitting a token is not recommended as it complicates identifying', &
'      ! the use of a token name.', &
'', &
'      end subroutine splitting_a_token', &
'      Subroutine LongString()', &
'      ! Long strings:', &
'', &
'      Character (len=200) :: string1, String2', &
'      character(len=:), allocatable :: a,b,c, big', &
'', &
'        string1 = "A very long string that won''t fit on a single &', &
'                   &line can be made through proper continuation."', &
'', &
'        ! alternatives to continuation lines', &
'        string2 = "A very long string that won''t fit on a single " // &', &
'                  "line can be made through proper continuation " // &', &
'                  "and concatenation of multiple strings."', &
'        print *, "string1=",string1', &
'        print *, "string2=",string2', &
'', &
'        ! append multiple strings together to construct a long line', &
'        a=repeat(''A'',100)', &
'        b=repeat(''B'',100)', &
'        big=a//b', &
'        c=repeat(''C'',100)', &
'        big=a//c', &
'        big=big//"more at end"', &
'        print *, "big=",big', &
'', &
'      End Subroutine LongString', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      ! bonus points -- print an integer array in RC order with bells on.', &
'      ! ie. It calculates the width needed for the longest variable and', &
'      ! puts a frame around the array', &
'      implicit none', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      integer                     :: size_needed', &
'      character(len=:),allocatable :: biggest', &
'       write(*,*)trim(title)', &
'       biggest=''          ''  ! make buffer to write integer into', &
'       ! find how many characters to use for integers', &
'       size_needed=ceiling(log10(real(maxval(abs(arr)))))+2', &
'       write(biggest,''(i0)'')size_needed', &
'       ! use this format to write a row', &
'       biggest=''("   |",*(i''//trim(biggest)//'':," |"))''', &
'       ! print one row of array at a time', &
'       write(*,''(*(g0))'')&', &
'       &''   #'',(repeat(''-'',size_needed),''-#'',i=1,size(arr,dim=2))', &
'       do i=1,size(arr,dim=1)', &
'          write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'          write(*,''(" |")'')', &
'       enddo', &
'       write(*,''(*(g0))'')&', &
'       &''   #'',(repeat(''-'',size_needed),''-#'',i=1,size(arr,dim=2))', &
'      end subroutine print_matrix_int', &
'      end program demo_continuation', &
'', &
'  Results:', &
'', &
'       xx array:', &
'        #-----#-----#-----#-----#-----#', &
'        |   1 |   2 |   3 |   4 |   5 |', &
'        |  10 |  20 |  30 |  40 |  50 |', &
'        |  11 |  22 |  33 |  44 |  55 |', &
'        #-----#-----#-----#-----#-----#', &
'       xx array:', &
'        #-------#-------#-------#-------#-------#', &
'        |     1 |     2 |     3 |     4 |     5 |', &
'        |    10 |    20 |    30 |    40 |    50 |', &
'        |    11 |    22 |    33 |    44 | -1051 |', &
'        #-------#-------#-------#-------#-------#', &
'        2.7182818284590451', &
'        2.7182818284590451', &
'       Expecting the value   2.7182818284590451', &
'       string1=A very long string that won''t fit on a single \...', &
'       line can be made through proper continuation.', &
'       string2=A very long string that won''t fit on a single \...', &
'       line can be made through proper continuation and \...', &
'       concatenation of multiple strings.', &
'       big=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\...', &
'       AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCC\...', &
'       CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\...', &
'       CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCmore at end', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025          continuation(5fortran)', &
'']

shortname="continuation"
call process()

case('72','continue')

textblock=[character(len=256) :: &
'', &
'continue(7fortran)                                         continue(7fortran)', &
'', &
'NAME', &
'  CONTINUE(7) - [EXECUTION_CONTROL] execution of a CONTINUE statement has no', &
'  effect', &
'', &
'SYNOPSIS', &
'  [NNNNN] continue', &
'', &
'DESCRIPTION', &
'  It is generally very confusing to have executable statements on labeled', &
'  lines; a CONTINUE statement eliminates the ambiguities that arise in jumping', &
'  to an executable line. Specifically:', &
'', &
'  o  Execution of a CONTINUE statement has no effect.', &
'', &
'  o  Preferably no target of a transfer should be an executable statement.', &
'', &
'  o  Therefore, all numerically labeled executable lines should be a CONTINUE.', &
'', &
'  A CONTINUE statement is most often used as a target for transfer control', &
'  statements such as GOTO. That is, a numeric label is added to the line.', &
'', &
'  CONTINUE(7f) is rarely used in new code but was very commonly encountered in', &
'  older FORTRAN code before the advent of constructs like ENDDO, CYCLE, BLOCK,', &
'  and EXIT.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      >      program oldstyle', &
'      >      integer i,j', &
'      >      j=5', &
'      >      do 100 i=1,20', &
'      >        if(i.lt.5)goto 100', &
'      >        j=3', &
'      >100   write(*,*)''J='',j', &
'      >      end', &
'', &
'      program demo_continue', &
'      ! numbered targets should (almost?) always be a continue statement', &
'      ! with a unique label for each looping structure', &
'      integer :: i,j', &
'       j=5', &
'       do 100 i=1,20', &
'          if(i.lt.5)goto 50', &
'          j=3', &
'          50 continue', &
'          write(*,*)''J='',j', &
'       100 continue', &
'      end program demo_continue', &
'', &
'      program newer', &
'      implicit none', &
'      integer :: i,j', &
'        j=5', &
'        do i=1,20', &
'           if(i >= 5)then', &
'              j=3', &
'           endif', &
'           write(*,*)''J='',j', &
'        enddo', &
'      end program newer', &
'', &
'  Fortran statement descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              continue(7fortran)', &
'']

shortname="continue"
call process()

case('73','co_reduce')

textblock=[character(len=256) :: &
'', &
'co_reduce(3fortran)                                       co_reduce(3fortran)', &
'', &
'NAME', &
'  CO_REDUCE(3) - [COLLECTIVE] Reduction of values on the current set of images', &
'', &
'SYNOPSIS', &
'  call co_reduce(a, operation, result_image [,stat] [,errmsg] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_REDUCE(3) determines element-wise the reduction of the value of A on all', &
'  images of the current team. The pure function passed as OPERATION is used to', &
'  pairwise reduce the values of A by passing either the value of A of', &
'  different images or the result values of such a reduction as argument. If A', &
'  is an array, the reduction is done element wise. If result_image is present,', &
'  the result values are returned in A on the specified image only and the', &
'  value of A on the other images become undefined. If result_image is not', &
'  present, the value is returned on all images. If the execution was', &
'  successful and STAT is present, it is assigned the value zero. If the', &
'  execution failed, STAT gets assigned a nonzero value and, if present, ERRMSG', &
'  gets assigned a value describing the occurred error.', &
'', &
'OPTIONS', &
'  o  A : is an INTENT(INOUT) argument and shall be nonpolymorphic. If it is', &
'     allocatable, it shall be allocated; if it is a pointer, it shall be', &
'     associated. A shall have the same type and type parameters on all images', &
'     of the team; if it is an array, it shall have the same shape on all', &
'     images.', &
'', &
'  o  OPERATION : pure function with two scalar nonallocatable arguments, which', &
'     shall be nonpolymorphic and have the same type and type parameters as A.', &
'     The function shall return a nonallocatable scalar of the same type and', &
'     type parameters as A. The function shall be the same on all images and', &
'     with regards to the arguments mathematically commutative and associative.', &
'     Note that OPERATION may not be an elemental unless it is an intrinsic', &
'     function.', &
'', &
'  o  RESULT_IMAGE', &
'', &
'      : (optional) a scalar integer expression; if present, it shall have', &
'      the same the same value on all images and refer to an image of the', &
'      current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_reduce', &
'      implicit none', &
'      integer :: val', &
'', &
'        val = this_image()', &
'        call co_reduce(val, myprod, 1)', &
'        if (this_image() == 1) then', &
'           write(*,*) "Product value", val  ! prints num_images() factorial', &
'        endif', &
'', &
'      contains', &
'', &
'      pure function myprod(a, b)', &
'        integer, value :: a, b', &
'        integer :: myprod', &
'        myprod = a * b', &
'      end function myprod', &
'', &
'      end program demo_co_reduce', &
'', &
'  Results:', &
'', &
'       >  Product value          1', &
'', &
'NOTE', &
'  While the rules permit in principle an intrinsic function, none of the', &
'  intrinsics in the standard fulfill the criteria of having a specific', &
'  function, which takes two arguments of the same type and returning that type', &
'  as a result.', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  CO_MIN(3), CO_MAX(3), CO_SUM(3), CO_BROADCAST(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             co_reduce(3fortran)', &
'']

shortname="co_reduce"
call process()

case('74','cos')

textblock=[character(len=256) :: &
'', &
'cos(3fortran)                                                   cos(3fortran)', &
'', &
'NAME', &
'  COS(3) - [MATHEMATICS:TRIGONOMETRIC] Cosine function', &
'', &
'SYNOPSIS', &
'  result = cos(x)', &
'', &
'          elemental TYPE(kind=KIND) function cos(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real or complex of any valid kind.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  COS(3) computes the cosine of an angle X given the size of the angle in', &
'  radians.', &
'', &
'  The cosine of a real value is the ratio of the adjacent side to the', &
'  hypotenuse of a right-angled triangle.', &
'', &
'OPTIONS', &
'  o  X : The angle in radians when X is of type real. If X is of type complex,', &
'     its real part is regarded as a value in radians, often called the phase.', &
'', &
'RESULT', &
'  The return value is the cosine of X.', &
'', &
'  If X is type real, the return value lies in the range -1 <= COS(X) <= 1 .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cos', &
'      implicit none', &
'      real,parameter      :: PI=atan(1.0d0)*4.0d0', &
'      real                :: val', &
'      character,parameter  :: nl=NEW_LINE(''A'')', &
'        write(*,''(*(g0))'',advance=''no'') &', &
'', &
'      ''basics:'',                                          nl, &', &
'      '' COS(0.0) =       '', cos(0.0),                     nl, &', &
'      '' COS(PI) =        '', cos(PI),                      nl, &', &
'      '' '',                                                nl, &', &
'      ''X may be any real value'',                          nl, &', &
'      '' COS(222*PI) =    '', cos(222*PI),                  nl, &', &
'      '' COS(-333*PI) =           '', cos(-333*PI),                 nl, &', &
'      '' '',                                                nl, &', &
'      ''note: probably not exactly zero ....'',                     nl, &', &
'      '' COS(PI/2.0)=     '', cos(PI/2.0),                  nl, &', &
'      '' EPSILON=         '', epsilon(PI),                  nl, &', &
'      '' '',                                                nl, &', &
'      ''COS() is elemental'',                               nl, &', &
'      '' COS([0.0,PI/4,PI/2,PI*3/4,PI]) = '',               nl', &
'        write(*,''(*(1x,g0,1x))'') COS([0.0,PI/4,PI/2,PI*3/4,PI])', &
'', &
'        write(*,''(*(g0))'',advance=''no'') &', &
'      '' '',                                                nl, &', &
'      ''Law of Cosines:'',                                  nl, &', &
'      '' '',                                                nl, &', &
'      ''right triangle'',                                   nl, &', &
'      two_sides_and_degrees_between(3.0,4.0,90.0),          nl, &', &
'      ''equilateral'',                                      nl, &', &
'      two_sides_and_degrees_between(3.3,3.3,60.0),          nl, &', &
'      '' '',                                                nl, &', &
'      ''Dusty Corners:'',                                   nl, &', &
'      '' '',                                                nl, &', &
'      ''If very large, representable numbers are far apart'',  nl, &', &
'      ''so adding or subtracting a few radians can not even'', nl, &', &
'      ''change the value! Note the expected values here:'',    nl', &
'        val=0.0', &
'        call delta( val-2.0, val-1.0 )', &
'', &
'        write(*,''(a)'') ''but look at the same call when the values are huge;''', &
'        val=huge(0.0)/1000', &
'        call delta( val-2.0, val-1.0 )', &
'', &
'      contains', &
'', &
'      subroutine delta(A,B)', &
'      real(kind=kind(0.0)),intent(in) :: a,b', &
'      print ''(a,t30,g0)'' , &', &
'      '' A=                   '', A, &', &
'      '' B=                   '', B, &', &
'      '' B-A=                 '', B-A, &', &
'      '' COS(A*PI)=           '', cos(A*PI), &', &
'      '' COS(B*PI)=           '', cos(B*PI), &', &
'      '' spacing(A)=          '', spacing(A), &', &
'      '' COS((B-A)*PI)=               '', cos((B-A)*PI), &', &
'      '' COS(B*PI)-COS(A*PI)=   '', cos(B*PI)-cos(A*PI), &', &
'      repeat(''='',40)', &
'      end subroutine delta', &
'', &
'      function two_sides_and_degrees_between(a,b,X) result(str)', &
'      real,intent(in)             :: a,b,X', &
'      real                        :: c', &
'      real,parameter              :: PI = atan(1.0d0) * 4.0d0', &
'      real,parameter              :: degrees_to_radians = PI / 180.0', &
'      character,parameter         :: nl=NEW_LINE(''A'')', &
'      character(len=:),allocatable :: str', &
'      ! The law of cosines states that for a', &
'      ! triangle with sides of length a, b, and c', &
'      ! that if the angle X is formed by sides a and', &
'      ! b that the length of the third side c is', &
'      !', &
'        c = sqrt( a**2 + b**2 - 2*a*b*cos(degrees_to_radians*X) )', &
'        allocate( character(len=132) :: str )', &
'        write(str,''(*(g0))'')&', &
'        ''For sides A='',a,'', B='',b,'' and X='',x,'' degrees,'',nl,''side C='',c', &
'        str=trim(str)', &
'      !', &
'      !                       \', &
'      !                      / \', &
'      !                     / Y \', &
'      !                    /     \', &
'      !                   /       \', &
'      !                  /         \', &
'      !               b /           \ c', &
'      !                /             \', &
'      !               /               \', &
'      !              /                 \', &
'      !             /                   \', &
'      !            / X                 Z \', &
'      !           -------------------------', &
'      !                       a', &
'      end function two_sides_and_degrees_between', &
'      end program demo_cos', &
'', &
'  Results:', &
'', &
'       > basics:', &
'       >  COS(0.0) =        1.00000000', &
'       >  COS(PI) =         -1.00000000', &
'       >', &
'       > X may be any real value', &
'       >  COS(222*PI) =      1.00000000', &
'       >  COS(-333*PI) =     -1.00000000', &
'       >', &
'       > note: probably not exactly zero ....', &
'       >  COS(PI/2.0)=      -0.437113883E-7', &
'       >  EPSILON=          0.119209290E-6', &
'       >', &
'       > COS() is elemental', &
'       >  COS([0.0,PI/4,PI/2,PI*3/4,PI]) =', &
'       >  1.00000000  0.707106769  -0.437113883E-7  -0.707106769  -1.00000000', &
'       >', &
'       > Law of Cosines:', &
'       >', &
'       > right triangle', &
'       > For sides A=3.00000000, B=4.00000000 and X=90.0000000 degrees,', &
'       > side C=5.00000000', &
'       > equilateral', &
'       > For sides A=3.29999995, B=3.29999995 and X=60.0000000 degrees,', &
'       > side C=3.29999995', &
'       >', &
'       > Dusty Corners:', &
'       >', &
'       > If very large, representable numbers are far apart', &
'       > so adding or subtracting a few radians can not even', &
'       > change the value! Note the expected values here:', &
'       >  A=                         -2.00000000', &
'       >  B=                         -1.00000000', &
'       >  B-A=                       1.00000000', &
'       >  COS(A*PI)=                 1.00000000', &
'       >  COS(B*PI)=                 -1.00000000', &
'       >  spacing(A)=                0.238418579E-6', &
'       >  COS((B-A)*PI)=             -1.00000000', &
'       >  COS(B*PI)-COS(A*PI)=       -2.00000000', &
'       > ========================================', &
'       > but look at the same call when the values are huge;', &
'       >  A=                         0.340282343E+36', &
'       >  B=                         0.340282343E+36', &
'       >  B-A=                       0.00000000', &
'       >  COS(A*PI)=                 0.766595423', &
'       >  COS(B*PI)=                 0.766595423', &
'       >  spacing(A)=                0.396140813E+29', &
'       >  COS((B-A)*PI)=             1.00000000', &
'       >  COS(B*PI)-COS(A*PI)=       0.00000000', &
'       > ========================================', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  ACOS(3), SIN(3), TAN(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                   cos(3fortran)', &
'']

shortname="cos"
call process()

case('75','cosd')

textblock=[character(len=256) :: &
'', &
'cosd(3fortran)                                                 cosd(3fortran)', &
'', &
'NAME', &
'  COSD(3) - [MATHEMATICS:TRIGONOMETRIC] Degree cosine function', &
'', &
'SYNOPSIS', &
'  result = cosd(x)', &
'', &
'          elemental real(kind=KIND) function cosd(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real of any valid kind.', &
'', &
'  o  KIND may be any real kind.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  COSD(3) computes the cosine of an angle X given the size of the angle in', &
'  degrees.', &
'', &
'  The cosine is the ratio of the adjacent side to the hypotenuse of a right-', &
'  angled triangle.', &
'', &
'OPTIONS', &
'  o  X : The angle in degrees to compute the cosine of.', &
'', &
'RESULT', &
'  The return value is an approximation of the cosine of X.', &
'', &
'  The return value lies in the range', &
'', &
'       -1 \<= cosd(x) \<= 1', &
'', &
'EXAMPLES', &
'  cosd(180.0) has the value -1.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_cosd', &
'      implicit none', &
'      character(len=*),parameter :: g2=''(a,t20,g0)''', &
'        write(*,g2)''cosd(0.0)='',cosd(0.0)', &
'        write(*,g2)''cosd(180.0)='',cosd(180.0)', &
'        write(*,g2)''cosd(90.0d0)='',cosd(90.0d0)', &
'        write(*,g2)''cosd(360.0)='',cosd(360.0)', &
'        write(*,g2)''cosd(-360.0)='',cosd(-360.0)', &
'        write(*,g2)''cosd(-2000*180.0)='',cosd(-2000*180.0)', &
'        write(*,g2)''cosd(3000*180.0)='',cosd(3000*180.0)', &
'      end program demo_cosd', &
'', &
'  Results:', &
'', &
'       > cosd(0.0)=        1.00000000', &
'       > cosd(180.0)=      -1.00000000', &
'       > cosd(90.0d0)=     0.0000000000000000', &
'       > cosd(360.0)=      1.00000000', &
'       > cosd(-360.0)=     1.00000000', &
'       > cosd(-2000*180.0)= 1.00000000', &
'       > cosd(3000*180.0)=  1.00000000', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ACOSD(3), ACOS(3), SIND(3), TAND(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                  cosd(3fortran)', &
'']

shortname="cosd"
call process()

case('76','cosh')

textblock=[character(len=256) :: &
'', &
'cosh(3fortran)                                                 cosh(3fortran)', &
'', &
'NAME', &
'  COSH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic cosine function', &
'', &
'SYNOPSIS', &
'  result = cosh(x)', &
'', &
'          elemental TYPE(kind=KIND) function cosh(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex of any kind.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  COSH(3) computes the hyperbolic cosine of X.', &
'', &
'  If X is of type complex its imaginary part is regarded as a value in', &
'  radians.', &
'', &
'OPTIONS', &
'  o  X : the value to compute the hyperbolic cosine of', &
'', &
'RESULT', &
'  If X is complex, the imaginary part of the result is in radians.', &
'', &
'  If X is real, the return value has a lower bound of one, COSH(X) >= 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cosh', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 1.0_real64', &
'         write(*,*)''X='',x,''COSH(X=)'',cosh(x)', &
'      end program demo_cosh', &
'', &
'  Results:', &
'', &
'       >  X=   1.00000000000000      COSH(X=)  1.54308063481524', &
'', &
'STANDARD', &
'  FORTRAN 77 , for a complex argument - Fortran 2008', &
'', &
'SEE ALSO', &
'  Inverse function: ACOSH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                  cosh(3fortran)', &
'']

shortname="cosh"
call process()

case('77','cospi')

textblock=[character(len=256) :: &
'', &
'cospi(3fortran)                                               cospi(3fortran)', &
'', &
'NAME', &
'  COSPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular Cosine function', &
'', &
'SYNOPSIS', &
'  result = cospi(x)', &
'', &
'          elemental real(kind=KIND) function cospi(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real.', &
'', &
'  o  KIND may be any kind supported by the associated type of X.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  COSPI(3) computes the circular cosine of an angle X given the size of the', &
'  angle in half-revolutions.', &
'', &
'  The cosine of a real value is the ratio of the adjacent side to the', &
'  hypotenuse of a right-angled triangle.', &
'', &
'  COSPI(X) is approximately equal to COS(X*PI).', &
'', &
'OPTIONS', &
'  o  X : The angle in half-revolutions to compute the cosine of.', &
'', &
'RESULT', &
'  The return value is the approximate value of the cosine of X.', &
'', &
'  The return value lies in the range -1 <= COSPI(X) <= 1 .', &
'', &
'EXAMPLES', &
'  Example: COSPI(1.0) has the value -1.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_cos', &
'      implicit none', &
'      character(len=*),parameter :: g2=''(a,t21,*(g0,1x))''', &
'        write(*,g2) ''Basics:''', &
'        write(*,g2) ''COSpi(0)='',      cospi(0.0d0)', &
'        write(*,g2) ''COSpi(1)='',      cospi(1.0d0)', &
'        write(*,g2) ''COSpi(1/2)='',    cospi(1.0d0/2.0d0)', &
'        write(*,g2) ''COSpi(2)='',      cospi(2.0d0)', &
'        write(*,g2) ''COSpi(-2)='',     cospi(-2.0d0)', &
'        write(*,g2) ''COSpi(-2000)='',  cospi(-2000.0d0)', &
'        write(*,g2) ''COSpi(3000)='',   cospi(3000.0d0)', &
'        write(*,g2) ''Elemental:''', &
'        write(*,g2) ''COSpi([0,1/4,-1/4])='',COSpi([0.0,0.25,-0.25])', &
'      end program demo_cos', &
'', &
'  Results:', &
'', &
'       > Basics:', &
'       > COSpi(0)=          1.0000000000000000', &
'       > COSpi(1)=          -1.0000000000000000', &
'       > COSpi(1/2)=        0.61232339957367660E-16', &
'       > COSpi(2)=          1.0000000000000000', &
'       > COSpi(-2)=         1.0000000000000000', &
'       > COSpi(-2000)=      1.0000000000000000', &
'       > COSpi(3000)=       1.0000000000000000', &
'       > Elemental:', &
'       > COSpi([0,1/4,-1/4])=1.00000000 0.707106769 0.707106769', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ACOS(3), SIN(3), TAN(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                 cospi(3fortran)', &
'']

shortname="cospi"
call process()

case('78','co_sum')

textblock=[character(len=256) :: &
'', &
'co_sum(3fortran)                                             co_sum(3fortran)', &
'', &
'NAME', &
'  CO_SUM(3) - [COLLECTIVE] Sum of values on the current set of images', &
'', &
'SYNOPSIS', &
'  call co_sum(a, result_image [,stat] [,errmsg] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_SUM(3) sums up the values of each element of A on all images of the', &
'  current team.', &
'', &
'  If result_image is present, the summed-up values are returned in A on the', &
'  specified image only and the value of A on the other images become', &
'  undefined.', &
'', &
'  If result_image is not present, the value is returned on all images. If the', &
'  execution was successful and STAT is present, it is assigned the value zero.', &
'  If the execution failed, STAT gets assigned a nonzero value and, if present,', &
'  ERRMSG gets assigned a value describing the occurred error.', &
'', &
'OPTIONS', &
'  o  A : shall be an integer, real or complex variable, which has the same', &
'     type and type parameters on all images of the team.', &
'', &
'  o  RESULT_IMAGE : (optional) a scalar integer expression; if present, it', &
'     shall have the same the same value on all images and refer to an image of', &
'     the current team.', &
'', &
'  o  STAT : (optional) a scalar integer variable', &
'', &
'  o  ERRMSG : (optional) a scalar character variable', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_co_sum', &
'      implicit none', &
'      integer :: val', &
'        val = this_image()', &
'        call co_sum(val, result_image=1)', &
'        if (this_image() == 1) then', &
'           ! prints (n**2 + n)/2, with n = num_images()', &
'           write(*,*) "The sum is ", val', &
'        endif', &
'      end program demo_co_sum', &
'', &
'  Results:', &
'', &
'       > The sum is            1', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  CO_MAX(3), CO_MIN(3), CO_REDUCE(3), CO_BROADCAST(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                co_sum(3fortran)', &
'']

shortname="co_sum"
call process()

case('79','co_ubound')

textblock=[character(len=256) :: &
'', &
'co_ubound(3fortran)                                        co_ubound(3fortran)', &
'', &
'NAME', &
'  CO_UBOUND(3) - [COLLECTIVE] Upper codimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = co_ubound(coarray [,dim] [,kind] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  CO_UBOUND(3) returns the upper cobounds of a coarray, or a single upper', &
'  cobound along the DIM codimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RESULT', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  CO_LBOUND(3), LBOUND(3), UBOUND(3)', &
'', &
'  fortran-lang intrinsic descriptions', &
'', &
'                               February 18, 2023           co_ubound(3fortran)', &
'']

shortname="co_ubound"
call process()

case('80','count')

textblock=[character(len=256) :: &
'', &
'count(3fortran)                                               count(3fortran)', &
'', &
'NAME', &
'  COUNT(3) - [ARRAY:REDUCTION] Count true values in an array', &
'', &
'SYNOPSIS', &
'  result = count(mask [,dim] [,kind] )', &
'', &
'          integer(kind=KIND) function count(mask, dim, KIND )', &
'', &
'           logical(kind=**),intent(in) :: mask(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  MASK is a logical array of any shape and kind.', &
'', &
'  o  If DIM is present, the result is an array with the specified rank', &
'     removed.', &
'', &
'  o  KIND is a scalar integer constant expression valid as an integer kind', &
'', &
'  o  The return value is of default integer type unless KIND is specified to', &
'     declare the kind of the result.', &
'', &
'DESCRIPTION', &
'  COUNT(3) counts the number of .true. elements in a logical MASK, or, if the', &
'  DIM argument is supplied, counts the number of elements along each row of', &
'  the array in the DIM direction. If the array has zero size or all of the', &
'  elements of MASK are false, then the result is 0.', &
'', &
'OPTIONS', &
'  o  MASK : an array to count the number of .true. values in', &
'', &
'  o  DIM : specifies to remove this dimension from the result and produce an', &
'     array of counts of .true. values along the removed dimension. If not', &
'     present, the result is a scalar count of the true elements in MASK the', &
'     value must be in the range 1 <= dim <= n, where n is the rank(number of', &
'     dimensions) of MASK.', &
'', &
'     The corresponding actual argument shall not be an optional dummy', &
'     argument, a disassociated pointer, or an unallocated allocatable.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  The return value is the number of .true. values in MASK if DIM is not', &
'  present.', &
'', &
'  If DIM is present, the result is an array with a rank one less than the rank', &
'  of the input array MASK, and a size corresponding to the shape of ARRAY with', &
'  the DIM dimension removed, with the remaining elements containing the number', &
'  of .true. elements along the removed dimension.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_count', &
'      implicit none', &
'      character(len=*),parameter :: ints=''(*(i2,1x))''', &
'      ! two arrays and a mask all with the same shape', &
'      integer, dimension(2,3) :: a, b', &
'      logical, dimension(2,3) :: mymask', &
'      integer :: i', &
'      integer :: c(2,3,4)', &
'', &
'      print *,''the numeric arrays we will compare''', &
'      a = reshape( [ 1, 2, 3, 4, 5, 6 ], [ 2, 3 ])', &
'      b = reshape( [ 0, 7, 3, 4, 5, 8 ], [ 2, 3 ])', &
'      c = reshape( [( i,i=1,24)], [ 2, 3 ,4])', &
'      print ''(3i3)'', a(1,:)', &
'      print ''(3i3)'', a(2,:)', &
'      print *', &
'      print ''(3i3)'', b(1,:)', &
'      print ''(3i3)'', b(2,:)', &
'      !', &
'      ! basic calls', &
'      print *, ''count a few basic things creating a mask from an expression''', &
'      print *, ''count a>b'',count(a>b)', &
'      print *, ''count b<a'',count(a<b)', &
'      print *, ''count b==a'',count(a==b)', &
'      print *, ''check sum = '',count(a>b) + &', &
'                           & count(a<b) + &', &
'                           & count(a==b).eq.size(a)', &
'      !', &
'      ! The common usage is just getting a count, but if you want', &
'      ! to specify the DIM argument and get back reduced arrays', &
'      ! of counts this is easier to visualize if we look at a mask.', &
'      print *, ''make a mask identifying unequal elements ...''', &
'      mymask = a.ne.b', &
'      print *, ''the mask generated from a.ne.b''', &
'      print ''(3l3)'', mymask(1,:)', &
'      print ''(3l3)'', mymask(2,:)', &
'      !', &
'      print *,''count total and along rows and columns ...''', &
'      !', &
'      print ''(a)'', ''number of elements not equal''', &
'      print ''(a)'', ''(ie. total true elements in the mask)''', &
'      print ''(3i3)'', count(mymask)', &
'      !', &
'      print ''(a)'', ''count of elements not equal in each column''', &
'      print ''(a)'', ''(ie. total true elements in each column)''', &
'      print ''(3i3)'', count(mymask, dim=1)', &
'      !', &
'      print ''(a)'', ''count of elements not equal in each row''', &
'      print ''(a)'', ''(ie. total true elements in each row)''', &
'      print ''(3i3)'', count(mymask, dim=2)', &
'      !', &
'      ! working with rank=3 ...', &
'      print *, ''lets try this with c(2,3,4)''', &
'      print *,''  taking the result of the modulo   ''', &
'      print *,''   z=1    z=2      z=3      z=4   ''', &
'      print *,''  1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |''', &
'      print *,''  2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |''', &
'      print *,''                                  ''', &
'      print *,''  would result in the mask ..     ''', &
'      print *,''  F F T || F F F || F T F || F F F |''', &
'      print *,''  F F F || F T F || F F F || T F F |''', &
'      print *,''                                  ''', &
'      print *,'' the total number of .true.values is''', &
'      print ints, count(modulo(c,5).eq.0)', &
'      call printi(''counting up along a row and removing rows'',&', &
'      count(modulo(c,5).eq.0,dim=1))', &
'      call printi(''counting up along a column and removing columns'',&', &
'      count(modulo(c,5).eq.0,dim=2))', &
'      call printi(''counting up along a depth and removing depths'',&', &
'      count(modulo(c,5).eq.0,dim=3))', &
'      !', &
'      contains', &
'      !', &
'      ! CONVENIENCE ROUTINE FOR PRINTING SMALL INTEGER MATRICES', &
'      subroutine printi(title,arr)', &
'      implicit none', &
'      !', &
'      !@(#) print small 2d integer arrays in row-column format', &
'      !', &
'      character(len=*),parameter :: all=''(*(g0,1x))'' ! a handy format', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'        !', &
'        print all', &
'        print all, trim(title),'':('',shape(arr),'')''  ! print title', &
'        biggest=''          '' ! make buffer to write integer into', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'        !', &
'      end subroutine printi', &
'      end program demo_count', &
'', &
'  Results:', &
'', &
'       >   the numeric arrays we will compare', &
'       >    1  3  5', &
'       >    2  4  6', &
'       >', &
'       >    0  3  5', &
'       >    7  4  8', &
'       >   count a few basic things creating a mask from an expression', &
'       >   count a>b          1', &
'       >   count b<a          2', &
'       >   count b==a          3', &
'       >   check sum = T', &
'       >   make a mask identifying unequal elements ...', &
'       >   the mask generated from a.ne.b', &
'       >    T  F  F', &
'       >    T  F  T', &
'       >   count total and along rows and columns ...', &
'       >  number of elements not equal', &
'       >  (ie. total true elements in the mask)', &
'       >    3', &
'       >  count of elements not equal in each column', &
'       >  (ie. total true elements in each column)', &
'       >    2  0  1', &
'       >  count of elements not equal in each row', &
'       >  (ie. total true elements in each row)', &
'       >    1  2', &
'       >   lets try this with c(2,3,4)', &
'       >     taking the result of the modulo', &
'       >      z=1      z=2     z=3      z=4', &
'       >     1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |', &
'       >     2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |', &
'       >', &
'       >     would result in the mask ..', &
'       >     F F T || F F F || F T F || F F F |', &
'       >     F F F || F T F || F F F || T F F |', &
'       >', &
'       >    the total number of .true.values is', &
'       >   4', &
'       >', &
'       >  counting up along a row and removing rows :( 3 4 )', &
'       >   > [ 0, 0, 0, 1 ]', &
'       >   > [ 0, 1, 1, 0 ]', &
'       >   > [ 1, 0, 0, 0 ]', &
'       >', &
'       >  counting up along a column and removing columns :( 2 4 )', &
'       >   > [ 1, 0, 1, 0 ]', &
'       >   > [ 0, 1, 0, 1 ]', &
'       >', &
'       >  counting up along a depth and removing depths :( 2 3 )', &
'       >   > [ 0, 1, 1 ]', &
'       >   > [ 1, 1, 0 ]', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  o  ANY(3)', &
'', &
'  o  ALL(3)', &
'', &
'  o  SUM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 count(3fortran)', &
'']

shortname="count"
call process()

case('81','cpu_time')

textblock=[character(len=256) :: &
'', &
'cpu_time(3fortran)                                         cpu_time(3fortran)', &
'', &
'NAME', &
'  CPU_TIME(3) - [SYSTEM:TIME] Return CPU processor time used in seconds', &
'', &
'SYNOPSIS', &
'  call cpu_time(time)', &
'', &
'           subroutine cpu_time(time)', &
'', &
'            real,intent(out) :: time', &
'', &
'CHARACTERISTICS', &
'  o  TIME is a real of any kind', &
'', &
'DESCRIPTION', &
'  CPU_TIME(3) returns a real value representing the elapsed CPU time in', &
'  seconds. This is useful for testing segments of code to determine execution', &
'  time.', &
'', &
'  If no time source is available, TIME is set to a negative value.', &
'', &
'  The exact definition of time is left imprecise because of the variability in', &
'  what different processors are able to provide.', &
'', &
'  Note that TIME may contain a system dependent, arbitrary offset and may not', &
'  start with 0.0. For CPU_TIME(3) the absolute value is meaningless.  Only', &
'  differences between subsequent calls, as shown in the example below, should', &
'  be used.', &
'', &
'PARALLEL PROCESSING', &
'  Whether the value assigned is an approximation to the amount of time used by', &
'  the invoking image, or the amount of time used by the whole program, is', &
'  processor dependent.', &
'', &
'  A processor for which a single result is inadequate (for example, a parallel', &
'  processor) might choose to provide an additional version for which TIME is', &
'  an array.', &
'', &
'RESULT', &
'  o  TIME : is assigned a processor-dependent approximation to the processor', &
'     time in seconds. If the processor cannot return a meaningful time, a', &
'     processor-dependent negative value is returned.', &
'', &
'     : The start time is left imprecise because the purpose is to time', &
'     sections of code, as in the example. This might or might not include', &
'     system overhead time.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cpu_time', &
'      use, intrinsic :: iso_fortran_env, only : real32,real64,real128', &
'      implicit none', &
'      real :: start, finish', &
'      real(kind=real64) :: startd, finishd', &
'        !', &
'        call cpu_time(start)', &
'        call cpu_time(startd)', &
'        ! put code to time here', &
'        call cpu_time(finish)', &
'        call cpu_time(finishd)', &
'        !', &
'       ! writes processor time taken by the piece of code.', &
'', &
'       ! the accuracy of the clock and whether it includes system time', &
'       ! as well as user time is processor dependent. Accuracy up to', &
'       ! milliseconds is common but not guaranteed, and may be much', &
'       ! higher or lower', &
'        print ''("Processor Time = ",f6.3," seconds.")'',finish-start', &
'', &
'        ! see your specific compiler documentation for how to measure', &
'        ! parallel jobs and for the precision of the time returned', &
'        print ''("Processor Time = ",g0," seconds.")'',finish-start', &
'        print ''("Processor Time = ",g0," seconds.")'',finishd-startd', &
'      end program demo_cpu_time', &
'', &
'  Results:', &
'', &
'  The precision of the result, some aspects of what is returned, and what if', &
'  any options there are for parallel applications may very from system to', &
'  system. See compiler-specific for details.', &
'', &
'        > Processor Time =  0.000 seconds.', &
'        > Processor Time = .4000030E-05 seconds.', &
'        > Processor Time = .2000000000000265E-05 seconds.', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  SYSTEM_CLOCK(3), DATE_AND_TIME(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              cpu_time(3fortran)', &
'']

shortname="cpu_time"
call process()

case('82','cshift')

textblock=[character(len=256) :: &
'', &
'cshift(3fortran)                                             cshift(3fortran)', &
'', &
'NAME', &
'  CSHIFT(3) - [ARRAY:TRANSFORMATIONAL] Circular shift elements of an array', &
'', &
'SYNOPSIS', &
'  result = cshift(array, shift [,dim])', &
'', &
'         type(TYPE(kind=KIND)) function cshift(array, shift, dim )', &
'', &
'          type(TYPE(kind=KIND)),intent(in) :: array(..)', &
'          integer(kind=**),intent(in)  :: shift', &
'          integer(kind=**),intent(in)  :: dim', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY may be any type and rank', &
'', &
'  o  SHIFT an integer scalar if ARRAY has rank one. Otherwise, it shall be', &
'     scalar or of rank n-1 and of shape [d1, d2, ..., dDIM-1, dDIM+1,', &
'', &
'  o  DIM is an integer scalar with a value in the range 1 <= DIM <= n, where n', &
'     is the rank of ARRAY. If DIM is absent, it is as if it were present with', &
'     the value 1.', &
'', &
'  o  the result will automatically be of the same type, kind and shape as', &
'     ARRAY.', &
'', &
'  NOTE: :a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  CSHIFT(3) performs a circular shift on elements of ARRAY along the dimension', &
'  of DIM. If DIM is omitted it is taken to be 1. DIM is a scalar of type', &
'  integer in the range of 1 <= DIM <= N, where "n" is the rank of ARRAY.', &
'', &
'  If the rank of ARRAY is one, then all elements of ARRAY are shifted by SHIFT', &
'  places. If rank is greater than one, then all complete rank one sections of', &
'  ARRAY along the given dimension are shifted. Elements shifted out one end of', &
'  each rank one section are shifted back in the other end.', &
'', &
'OPTIONS', &
'  o  ARRAY : An array of any type which is to be shifted', &
'', &
'  o  SHIFT : the number of positions to circularly shift. A negative value', &
'     produces a right shift, a positive value produces a left shift.', &
'', &
'  o  DIM : the dimension along which to shift a multi-rank ARRAY.  Defaults to', &
'     1.', &
'', &
'RESULT', &
'  Returns an array of same type and rank as the ARRAY argument.', &
'', &
'  The rows of an array of rank two may all be shifted by the same amount or by', &
'  different amounts.', &
'', &
'  cshift', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_cshift', &
'      implicit none', &
'      integer, dimension(5)   :: i1', &
'      integer, dimension(3,4) :: a, b', &
'        !basics', &
'         i1=[10,20,30,40,50]', &
'         print *,''start with:''', &
'         print ''(1x,5i3)'', i1', &
'         print *,''shift -2''', &
'         print ''(1x,5i3)'', cshift(i1,-2)', &
'         print *,''shift +2''', &
'         print ''(1x,5i3)'', cshift(i1,+2)', &
'', &
'         print *,''start with a matrix''', &
'         a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], [ 3, 4 ])', &
'         print ''(4i3)'', a(1,:)', &
'         print ''(4i3)'', a(2,:)', &
'         print ''(4i3)'', a(3,:)', &
'         print *,''matrix shifted along rows, each by its own amount [-1,0,1]''', &
'         b = cshift(a, SHIFT=[1, 0, -1], DIM=2)', &
'         print *', &
'         print ''(4i3)'', b(1,:)', &
'         print ''(4i3)'', b(2,:)', &
'         print ''(4i3)'', b(3,:)', &
'      end program demo_cshift', &
'', &
'  Results:', &
'', &
'       >  start with:', &
'       >   10 20 30 40 50', &
'       >  shift -2', &
'       >   40 50 10 20 30', &
'       >  shift +2', &
'       >   30 40 50 10 20', &
'       >  start with a matrix', &
'       >   1  4  7 10', &
'       >   2  5  8 11', &
'       >   3  6  9 12', &
'       >  matrix shifted along rows, each by its own amount', &
'       >', &
'       >   4  7 10  1', &
'       >   2  5  8 11', &
'       >  12  3  6  9', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  EOSHIFT(3) - End-off shift elements of an array', &
'', &
'  o  SUM(3) - sum the elements of an array', &
'', &
'  o  PRODUCT(3) - Product of array elements', &
'', &
'  o  FINDLOC(3) - Location of first element of ARRAY identified by MASK along', &
'     dimension DIM having a value', &
'', &
'  o  MAXLOC(3) - Location of the maximum value within an array', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                cshift(3fortran)', &
'']

shortname="cshift"
call process()

case('83','c_sizeof')

textblock=[character(len=256) :: &
'', &
'c_sizeof(3fortran)                                         c_sizeof(3fortran)', &
'', &
'NAME', &
'  C_SIZEOF(3) - [ISO_C_BINDING] Size in bytes of an expression', &
'', &
'SYNOPSIS', &
'  result = c_sizeof(x)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  C_SIZEOF(3) calculates the number of bytes of storage the expression X', &
'  occupies.', &
'', &
'OPTIONS', &
'  o  X : The argument shall be an interoperable data entity.', &
'', &
'RESULT', &
'  The return value is of type integer and of the system-dependent kind csize_t', &
'  (from the iso_c_binding module). Its value is the number of bytes occupied', &
'  by the argument. If the argument has the pointer attribute, the number of', &
'  bytes of the storage area pointed to is returned. If the argument is of a', &
'  derived type with pointer or allocatable components, the return value does', &
'  not account for the sizes of the data pointed to by these components.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_c_sizeof', &
'      use iso_c_binding', &
'      implicit none', &
'      real(c_float) :: r, s(5)', &
'        print *, (c_sizeof(s)/c_sizeof(r) == 5)', &
'      end program demo_c_sizeof', &
'', &
'  Results:', &
'', &
'       >   T', &
'', &
'  The example will print .true. unless you are using a platform where default', &
'  real variables are unusually padded.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  STORAGE_SIZE(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              c_sizeof(3fortran)', &
'']

shortname="c_sizeof"
call process()

case('84','date_and_time')

textblock=[character(len=256) :: &
'', &
'date_and_time(3fortran)                               date_and_time(3fortran)', &
'', &
'NAME', &
'  DATE_AND_TIME(3) - [SYSTEM:TIME] Gets current date and time', &
'', &
'SYNOPSIS', &
'  subroutine date_and_time(date, time, zone, values)', &
'', &
'          character(len=8),intent(out),optional :: date', &
'          character(len=10),intent(out),optional :: time', &
'          character(len=5),intent(out),optional :: zone', &
'          integer,intent(out),optional :: values(8)', &
'', &
'CHARACTERISTICS', &
'  o  DATE, TIME, and ZONE are default character scalar types', &
'', &
'  o  VALUES is a rank-one array of type integer with a decimal exponent range', &
'     of at least four.', &
'', &
'DESCRIPTION', &
'  DATE_AND_TIME(3) gets the corresponding date and time information from the', &
'  real-time system clock.', &
'', &
'  Unavailable time and date character parameters return blanks.', &
'', &
'  Unavailable numeric parameters return -HUGE(VALUE).', &
'', &
'OPTIONS', &
'  o  DATE : A character string of default kind of the form CCYYMMDD, of length', &
'     8 or larger, where', &
'', &
'     o CCYY is the year in the Gregorian calendar', &
'', &
'     o MM is the month within the year', &
'', &
'     o DD is the day within the month.', &
'', &
'     The characters of this value are all decimal digits.', &
'', &
'     If there is no date available, DATE is assigned all blanks.', &
'', &
'  o  TIME : A character string of default kind of the form HHMMSS.SSS, of', &
'     length 10 or larger, where', &
'', &
'     o HH is the hour of the day,', &
'', &
'     o MM is the minutes of the hour,', &
'', &
'     o and SS.SSS is the seconds and milliseconds of the minute.', &
'', &
'     Except for the decimal point, the characters of this value shall all be', &
'     decimal digits.', &
'', &
'     If there is no clock available, TIME is assigned all blanks.', &
'', &
'  o  ZONE : A string of the form (+-)HHMM, of length 5 or larger, representing', &
'     the difference with respect to Coordinated Universal Time (UTC), where', &
'', &
'     o HH and MM are the time difference with respect to Coordinated', &
'       Universal Time (UTC) in hours and minutes, respectively.', &
'', &
'     The characters of this value following the sign character are all decimal', &
'     digits.', &
'', &
'     If this information is not available, ZONE is assigned all blanks.', &
'', &
'  o  VALUES : An array of at least eight elements. If there is no data', &
'     available for a value it is set to -HUGE(VALUES). Otherwise, it contains:', &
'', &
'     o VALUES(1) : The year, including the century.', &
'', &
'     o VALUES(2) : The month of the year', &
'', &
'     o VALUES(3) : The day of the month', &
'', &
'     o VALUES(4) : Time difference in minutes between the reported time and', &
'       UTC time.', &
'', &
'     o VALUES(5) : The hour of the day, in the range 0 to 23.', &
'', &
'     o VALUES(6) : The minutes of the hour, in the range 0 to 59', &
'', &
'     o VALUES(7) : The seconds of the minute, in the range 0 to 60', &
'', &
'     o VALUES(8) : The milliseconds of the second, in the range 0 to 999.', &
'', &
'  The date, clock, and time zone information might be available on some images', &
'  and not others. If the date, clock, or time zone information is available on', &
'  more than one image, it is processor dependent whether or not those images', &
'  share the same information.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_date_and_time', &
'        implicit none', &
'        character(len=8)     :: date', &
'        character(len=10)    :: time', &
'        character(len=5)     :: zone', &
'        integer, dimension(8) :: values', &
'', &
'        call date_and_time(date, time, zone, values)', &
'', &
'        ! using keyword arguments', &
'        call date_and_time(DATE=date, TIME=time, ZONE=zone)', &
'        print ''(*(g0))'',''DATE="'',date,''" TIME="'',time,''" ZONE="'',zone,''"''', &
'', &
'        call date_and_time(VALUES=values)', &
'        write (*, ''(i5,a)'') &', &
'         & values(1), '' - The year'', &', &
'         & values(2), '' - The month'', &', &
'         & values(3), '' - The day of the month'', &', &
'         & values(4), '' - Time difference with UTC in minutes'', &', &
'         & values(5), '' - The hour of the day'', &', &
'         & values(6), '' - The minutes of the hour'', &', &
'         & values(7), '' - The seconds of the minute'', &', &
'         & values(8), '' - The milliseconds of the second''', &
'', &
'        write (*, ''(a)'') iso_8601()', &
'      contains', &
'        function iso_8601()', &
'        ! return date using ISO-8601 format at a resolution of seconds', &
'        character(len=8)  :: dt', &
'        character(len=10) :: tm', &
'        character(len=5)  :: zone', &
'        character(len=25) :: iso_8601', &
'        call date_and_time(dt, tm, zone)', &
'           ISO_8601 = dt(1:4)//''-''//dt(5:6)//''-''//dt(7:8) &', &
'                    & //''T''//                                   &', &
'                    & tm(1:2)//'':''//tm(3:4)//'':''//tm(5:6) &', &
'                    & //zone(1:3)//'':''//zone(4:5)', &
'        end function iso_8601', &
'      end program demo_date_and_time', &
'', &
'  Results:', &
'', &
'       > DATE="20240426" TIME="111545.335" ZONE="-0400"', &
'       >  2024 - The year', &
'       >     4 - The month', &
'       >    26 - The day of the month', &
'       >  -240 - Time difference with UTC in minutes', &
'       >    11 - The hour of the day', &
'       >    15 - The minutes of the hour', &
'       >    45 - The seconds of the minute', &
'       >   335 - The milliseconds of the second', &
'       > 2024-04-26T11:15:45-04:00', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  These forms are compatible with the representations defined in ISO', &
'  8601:2004.', &
'', &
'  UTC is established by the International Bureau of Weights and Measures', &
'  (BIPM, i.e. Bureau International des Poids et Mesures) and the International', &
'  Earth Rotation Service (IERS).', &
'', &
'  CPU_TIME(3), SYSTEM_CLOCK(3)', &
'', &
'RESOURCES', &
'  date and time conversion, formatting and computation', &
'', &
'  o  M_time - https://github.com/urbanjost/M_time', &
'', &
'  o  fortran-datetime - https://github.com/dongli/fortran-datetime', &
'', &
'  o  datetime-fortran - https://github.com/wavebitscientific/datetime-fortran', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025         date_and_time(3fortran)', &
'']

shortname="date_and_time"
call process()

case('85','dble')

textblock=[character(len=256) :: &
'', &
'dble(3fortran)                                                 dble(3fortran)', &
'', &
'NAME', &
'  DBLE(3) - [TYPE:CONVERSION] Converstion to double precision real', &
'', &
'SYNOPSIS', &
'  result = dble(a)', &
'', &
'          elemental doubleprecision function dble(a)', &
'', &
'           doubleprecision :: dble', &
'           TYPE(kind=KIND),intent(in) :: a', &
'', &
'CHARACTERISTICS', &
'  o  A my be integer, real, complex, or a BOZ-literal-constant', &
'', &
'  o  the result is a doubleprecision real.', &
'', &
'DESCRIPTION', &
'  DBLE(3) Converts A to double precision real type.', &
'', &
'OPTIONS', &
'  o  A : a value to convert to a doubleprecision real.', &
'', &
'RESULT', &
'  The return value is of type doubleprecision. For complex input, the returned', &
'  value has the magnitude and sign of the real component of the input value.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dble', &
'      implicit none', &
'      real:: x = 2.18', &
'      integer :: i = 5', &
'      complex :: z = (2.3,1.14)', &
'        print *, dble(x), dble(i), dble(z)', &
'      end program demo_dble', &
'', &
'  Results:', &
'', &
'       > 2.1800000667572021  5.0000000000000000   2.2999999523162842', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Convert values to a complex type', &
'', &
'  o  INT(3) - Truncate towards zero and convert to integer', &
'', &
'  o  NINT(3) - Nearest whole number', &
'', &
'  o  OUT_OF_RANGE(3) - Whether a value cannot be converted safely.', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  dble(3fortran)', &
'']

shortname="dble"
call process()

case('86','deallocate')

textblock=[character(len=256) :: &
'', &
'deallocate(7fortran)                                     deallocate(7fortran)', &
'', &
'NAME', &
'  DEALLOCATE(7f) - [FORTRAN:STATEMENT] causes allocated variables and targets', &
'  to be deallocated', &
'', &
'SYNOPSIS', &
'  DEALLOCATE(allocate-object-list [,STAT=stat][,ERRMSG=errmsg] )', &
'', &
'DESCRIPTION', &
'  The DEALLOCATE statement causes allocatable variables to be deallocated; it', &
'  causes pointer targets to be deallocated and the pointers to be', &
'  disassociated.', &
'', &
'  An allocate-object shall not depend on the value, bounds, allocation status,', &
'  or association status of another allocate-object in the same DEALLOCATE', &
'  statement; it also shall not depend on the value of the stat-variable or', &
'  errmsg-variable in the same DEALLOCATE statement.', &
'', &
'  The status of objects that were not successfully allocated or deallocated', &
'  can be individually checked with the intrinsic functions ALLOCATED or', &
'  ASSOCIATED.', &
'', &
'OPTIONS', &
'  ALLOCATED-OBJECT-LIST : Each allocate-object is a nonprocedure pointer or an', &
'  allocatable variable.', &
'', &
'  STAT=STAT-VARIABLE : If the STAT= specifier appears, successful execution of', &
'  the ALLOCATE or DEALLOCATE statement causes the stat-variable to become', &
'  defined with a value of zero.', &
'', &
'  If an error condition occurs during execution of a DEALLOCATE statement that', &
'  does not contain the STAT= specifier, error termination is initiated.', &
'', &
'  ERRMSG=ERRMSG-VARIABLE : If an error condition occurs during execution of an', &
'  ALLOCATE or DEALLOCATE statement, the processor assigns an explanatory', &
'  message to errmsg-variable. If no such condition occurs, the processor does', &
'  not change the value of the errmsg-variable.', &
'', &
'  No dealloc-opt shall appear more than once in a given DEALLOCATE statement.', &
'', &
'  The errmsg-variable and stat-variable cannot be allocated or deallocated', &
'  elsewhere in the statement or otherwise depend of any allocatable object in', &
'  the statement.', &
'', &
'EXAMPLE', &
'  An example of a DEALLOCATE statement is:', &
'', &
'            DEALLOCATE (X, B)', &
'', &
'DEALLOCATION OF ALLOCATABLE VARIABLES', &
'  Deallocating an unallocated allocatable variable causes an error condition', &
'  in the DEALLOCATE statement. Deallocating an allocatable variable with the', &
'  TARGET attribute causes the pointer association status of any pointer', &
'  associated with it to become undefined.', &
'', &
'  When the execution of a procedure is terminated by execution of a RETURN or', &
'  END statement, an unsaved allocatable local variable of the procedure', &
'  retains its allocation and definition status if it is a function result', &
'  variable or a subobject thereof; otherwise, it is deallocated.', &
'', &
'  When a BLOCK construct terminates, an unsaved allocatable local variable of', &
'  the construct is deallocated.', &
'', &
'  If an executable construct references a function whose result is either', &
'  allocatable or a structure with a subobject that is allocatable, and the', &
'  function reference is executed, an allocatable result and any subobject that', &
'  is an allocated allocatable entity in the result returned by the function is', &
'  deallocated after execution of the innermost executable construct containing', &
'  the reference.', &
'', &
'  If a function whose result is either allocatable or a structure with an', &
'  allocatable subobject is referenced in the specification part of a scoping', &
'  unit or BLOCK construct, and the function reference is executed, an', &
'  allocatable result and any subobject that is an allocated allocatable entity', &
'  in the result returned by the function is deallocated before execution of', &
'  the executable constructs of the scoping unit or block.', &
'', &
'  When a procedure is invoked, any allocated allocatable object that is an', &
'  actual argument corresponding to an INTENT (OUT) allocatable dummy argument', &
'  is deallocated; any allocated allocatable object that is a subobject of an', &
'  actual argument corresponding to an INTENT (OUT) dummy argument is', &
'  deallocated.', &
'', &
'  When an intrinsic assignment statement (7.2.1.3) is executed, any noncoarray', &
'  allocated allocatable subobject of the variable is deallocated before the', &
'  assignment takes place.', &
'', &
'  When a variable of derived type is deallocated, any allocated allocatable', &
'  subobject is deallocated.', &
'', &
'  If an allocatable component is a subobject of a finalizable object, that', &
'  object is finalized before the component is automatically deallocated.', &
'', &
'  The effect of automatic deallocation is the same as that of a DEALLOCATE', &
'  statement without a dealloc-opt-list.', &
'', &
'  There is implicit synchronization of all images in association with each', &
'  DEALLOCATE statement that deallocates one or more coarrays. On each image,', &
'  execution of the segment (8.5.1) following the statement is delayed until', &
'  all other images have executed the same statement the same number of times.', &
'  If the coarray is a dummy argument, its ultimate argument (12.5.2.3) shall', &
'  be the same coarray on every image.', &
'', &
'  There is also an implicit synchronization of all images in association with', &
'  the deallocation of a coarray or coarray subcomponent caused by the', &
'  execution of a RETURN or END statement or the termination of a BLOCK', &
'  construct.', &
'', &
'  In the following example:', &
'', &
'        > SUBROUTINE PROCESS', &
'        >   REAL, ALLOCATABLE :: TEMP(:)', &
'        >', &
'        >   REAL, ALLOCATABLE, SAVE :: X(:)', &
'        >   ...', &
'        > END SUBROUTINE PROCESS', &
'', &
'  on return from subroutine PROCESS, the allocation status of X is preserved', &
'  because X has the SAVE attribute. TEMP does not have the SAVE attribute, so', &
'  it will be deallocated if it was allocated. On the next invocation of', &
'  PROCESS, TEMP will have an allocation status of unallocated.', &
'', &
'DEALLOCATION OF POINTER TARGETS', &
'  If a pointer appears in a DEALLOCATE statement, its association status shall', &
'  be defined. Deallocating a pointer that is disassociated or whose target was', &
'  not created by an ALLOCATE statement causes an error condition in the', &
'  DEALLOCATE statement. If a pointer is associated with an allocatable entity,', &
'  the pointer shall not be deallocated.', &
'', &
'  If a pointer appears in a DEALLOCATE statement, it shall be associated with', &
'  the whole of an object that was created by allocation. Deallocating a', &
'  pointer target causes the pointer association status of any other pointer', &
'  that is associated with the target or a portion of the target to become', &
'  undefined.', &
'', &
'  If an ALLOCATE or DEALLOCATE statement with a coarray allocate-object is', &
'  executed when one or more images has initiated termination of execution, the', &
'  stat-variable becomes defined with the processor-dependent positive integer', &
'  value of the constant STAT STOPPED IMAGE from the intrinsic module', &
'  ISO_FORTRAN_ENV (13.8.2). If any other error condition occurs during', &
'  execution of the ALLOCATE or DEALLOCATE statement, the stat-variable becomes', &
'  defined with a processor-dependent positive integer value different from', &
'  STAT STOPPED IMAGE. In either case, each allocate-object has a processor-', &
'  dependent status:', &
'', &
'  o  each allocate-object that was successfully allocated shall have an', &
'     allocation status of allocated or a pointer association status of', &
'     associated;', &
'', &
'  o  each allocate-object that was successfully deallocated shall have an', &
'     allocation status of unallocated or a pointer association status of', &
'     disassociated;', &
'', &
'  o  each allocate-object that was not successfully allocated or deallocated', &
'     shall retain its previous allocation status or pointer association', &
'     status.', &
'', &
'                               March 16, 2025            deallocate(7fortran)', &
'']

shortname="deallocate"
call process()

case('87','digits')

textblock=[character(len=256) :: &
'', &
'digits(3fortran)                                             digits(3fortran)', &
'', &
'NAME', &
'  DIGITS(3) - [MODEL:NUMERIC] Significant digits in the numeric model', &
'', &
'SYNOPSIS', &
'  result = digits(x)', &
'', &
'          integer function digits(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x(..)', &
'', &
'CHARACTERISTICS', &
'  o  X an integer or real scalar or array', &
'', &
'  o  The return value is an integer of default kind.', &
'', &
'DESCRIPTION', &
'  DIGITS(3) returns the number of significant digits of the internal model', &
'  representation of X. For example, on a system using a 32-bit floating point', &
'  representation, a default real number would likely return 24.', &
'', &
'OPTIONS', &
'  o  X : a value of the type and kind to query', &
'', &
'RESULT', &
'  The number of significant digits in a variable of the type and kind of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_digits', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0:,1x))''', &
'      integer                   :: i = 12345', &
'      real                      :: x = 3.143', &
'      doubleprecision           :: y = 2.33d0', &
'        print all, ''default integer:       '', digits(i)', &
'        print all, ''default real:          '', digits(x)', &
'        print all, ''default doubleprecision:'', digits(y)', &
'      end program demo_digits', &
'', &
'  Results:', &
'', &
'       > default integer:        31', &
'       > default real:           24', &
'       > default doubleprecision: 53', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                digits(3fortran)', &
'']

shortname="digits"
call process()

case('88','dim')

textblock=[character(len=256) :: &
'', &
'dim(3fortran)                                                   dim(3fortran)', &
'', &
'NAME', &
'  DIM(3) - [NUMERIC] Positive difference of X - Y', &
'', &
'SYNOPSIS', &
'  result = dim(x, y)', &
'', &
'          elemental TYPE(kind=KIND) function dim(x, y )', &
'', &
'           TYPE(kind=KIND),intent(in) :: x, y', &
'', &
'CHARACTERISTICS', &
'  o  X and Y may be any real or integer but of the same type and kind', &
'', &
'  o  the result is of the same type and kind as the arguments', &
'', &
'DESCRIPTION', &
'  DIM(3) returns the maximum of X - Y and zero. That is, it returns the', &
'  difference X - Y if the result is positive; otherwise it returns zero.  It', &
'  is equivalent to', &
'', &
'       max(0,x-y)', &
'', &
'OPTIONS', &
'  o  X : the subtrahend, ie. the number being subtracted from.', &
'', &
'  o  Y : the minuend; ie. the number being subtracted', &
'', &
'RESULT', &
'  Returns the difference X - Y or zero, whichever is larger.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dim', &
'      use, intrinsic :: iso_fortran_env, only : real64', &
'      implicit none', &
'      integer          :: i', &
'      real(kind=real64) :: x', &
'', &
'        ! basic usage', &
'         i = dim(4, 15)', &
'         x = dim(4.321_real64, 1.111_real64)', &
'         print *, i', &
'         print *, x', &
'', &
'        ! elemental', &
'         print *, dim([1,2,3],2)', &
'         print *, dim([1,2,3],[3,2,1])', &
'         print *, dim(-10,[0,-10,-20])', &
'', &
'      end program demo_dim', &
'', &
'  Results:', &
'', &
'       >           0', &
'       >    3.21000000000000', &
'       >           0           0           1', &
'       >           0           0           2', &
'       >           0           0          10', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  ABS(3) - Absolute value', &
'', &
'  o  AINT(3) - Truncate toward zero to a whole number', &
'', &
'  o  ANINT(3) - Real nearest whole number', &
'', &
'  o  CEILING(3) - Integer ceiling function', &
'', &
'  o  CONJG(3) - Complex conjugate of a complex value', &
'', &
'  o  DIM(3) - Positive difference of X - Y', &
'', &
'  o  DPROD(3) - Double precision real product', &
'', &
'  o  FLOOR(3) - Function to return largest integral value', &
'', &
'  o  MAX(3) - Maximum value of an argument list', &
'', &
'  o  MIN(3) - Minimum value of an argument list', &
'', &
'  o  MOD(3) - Remainder function', &
'', &
'  o  SIGN(3) - Sign copying function', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   dim(3fortran)', &
'']

shortname="dim"
call process()

case('89','dot_product')

textblock=[character(len=256) :: &
'', &
'dot_product(3fortran)                                   dot_product(3fortran)', &
'', &
'NAME', &
'  DOT_PRODUCT(3) - [ARRAY:TRANSFORMATIONAL] Dot product of two vectors', &
'', &
'SYNOPSIS', &
'  result = dot_product(vector_a, vector_b)', &
'', &
'          TYPE(kind=KIND) function dot_product(vector_a, vector_b)', &
'', &
'           TYPE(kind=KIND),intent(in) :: vector_a(:)', &
'           TYPE(kind=KIND),intent(in) :: vector_b(:)', &
'', &
'CHARACTERISTICS', &
'  o  VECTOR_A, VECTOR_B may be any numeric or logical type array of rank one', &
'     of the same size', &
'', &
'  o  the two vectors need not be of the same kind, but both must be logical or', &
'     numeric for any given call.', &
'', &
'  o  the result is the same type and kind of the vector that is the higher', &
'     type that the other vector is optionally promoted to if they differ.', &
'', &
'  The two vectors may be either numeric or logical and must be arrays of rank', &
'  one and of equal size.', &
'', &
'DESCRIPTION', &
'  DOT_PRODUCT(3) computes the dot product multiplication of two vectors', &
'  VECTOR_A and VECTOR_B.', &
'', &
'OPTIONS', &
'  o  VECTOR_A : A rank 1 vector of values', &
'', &
'  o  VECTOR_B : The type shall be numeric if VECTOR_A is of numeric type or', &
'     logical if vector_a is of type logical. vector_b shall be a rank-one', &
'     array of the same size as VECTOR_A.', &
'', &
'RESULT', &
'  If the arguments are numeric, the return value is a scalar of numeric type.', &
'  If the arguments are logical, the return value is .true. or .false..', &
'', &
'  If the vectors are integer or real, the result is', &
'', &
'          sum(vector_a*vector_b)', &
'', &
'  If the vectors are complex, the result is', &
'', &
'          sum(conjg(vector_a)*vector_b)', &
'', &
'  If the vectors have size zero, the result has the value zero.', &
'', &
'  If the vectors are logical, the result is', &
'', &
'          any(vector_a .and. vector_b)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dot_prod', &
'      implicit none', &
'         integer, dimension(3) :: a, b', &
'         a = [ 1, 2, 3 ]', &
'         b = [ 4, 5, 6 ]', &
'         print ''(3i3)'', a', &
'         print *', &
'         print ''(3i3)'', b', &
'         print *', &
'         print *, dot_product(a,b)', &
'      end program demo_dot_prod', &
'', &
'  Results:', &
'', &
'       >  1  2  3', &
'       >', &
'       >  4  5  6', &
'       >', &
'       >           32', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  SUM(3), CONJG(3), ANY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025           dot_product(3fortran)', &
'']

shortname="dot_product"
call process()

case('90','dprod')

textblock=[character(len=256) :: &
'', &
'dprod(3fortran)                                               dprod(3fortran)', &
'', &
'NAME', &
'  DPROD(3) - [NUMERIC] Double precision real product', &
'', &
'SYNOPSIS', &
'  result = dprod(x,y)', &
'', &
'          elemental function dprod(x,y)', &
'', &
'           real,intent(in) :: x', &
'           real,intent(in) :: y', &
'           doubleprecision :: dprod', &
'', &
'CHARACTERISTICS', &
'  o  X is a default real.', &
'', &
'  o  Y is a default real.', &
'', &
'  o  the result is a doubleprecision real.', &
'', &
'  The setting of compiler options specifying the size of a default real can', &
'  affect this function.', &
'', &
'DESCRIPTION', &
'  DPROD(3) produces a doubleprecision product of default real values X and Y.', &
'', &
'  That is, it is expected to convert the arguments to double precision before', &
'  multiplying, which a simple expression X*Y would not be required to do. This', &
'  can be significant in specialized computations requiring high precision.', &
'', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  product of X and Y. Note it is recommended in the standard that the', &
'  processor compute the product in double precision, rather than in single', &
'  precision then converted to double precision; but is only a recommendation.', &
'', &
'OPTIONS', &
'  o  X : the multiplier', &
'', &
'  o  Y : the multiplicand', &
'', &
'RESULT', &
'  The returned value of the product should have the same value as', &
'  DBLE(X)*DBLE(Y).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dprod', &
'      implicit none', &
'      integer,parameter :: dp=kind(0.0d0)', &
'      real :: x = 5.2', &
'      real :: y = 2.3', &
'      doubleprecision :: xx', &
'      real(kind=dp)   :: dd', &
'', &
'        print *,''algebraically 5.2 x 2.3 is exactly 11.96''', &
'        print *,''as floating point values results may differ slightly:''', &
'        ! basic usage', &
'        dd = dprod(x,y)', &
'        print *, ''compare dprod(xy)='',dd, &', &
'        & ''to x*y='',x*y, &', &
'        & ''to dble(x)*dble(y)='',dble(x)*dble(y)', &
'', &
'        print *,''test if an expected result is produced''', &
'        xx=-6.0d0', &
'        write(*,*)DPROD(-3.0, 2.0),xx', &
'        write(*,*)merge(''PASSED'',''FAILED'',DPROD(-3.0, 2.0) == xx)', &
'', &
'        print *,''elemental''', &
'        print *, dprod( [2.3,3.4,4.5], 10.0 )', &
'        print *, dprod( [2.3,3.4,4.5], [9.8,7.6,5.4] )', &
'', &
'      end program demo_dprod', &
'', &
'  Results: (this can vary between programming environments):', &
'', &
'       >  algebraically 5.2 x 2.3 is exactly 11.96', &
'       >  as floating point values results may differ slightly:', &
'       >  compare dprod(xy)=   11.9599993133545      to x*y=   11.96000', &
'       >  to dble(x)*dble(y)=  11.9599993133545', &
'       >  test if an expected result is produced', &
'       >   -6.00000000000000      -6.00000000000000', &
'       >  PASSED', &
'       >  elemental', &
'       >    22.9999995231628    34.0000009536743     45.0000000000000', &
'       >    22.5399999713898    25.8400004005432     24.3000004291534', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  DBLE(3) REAL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 dprod(3fortran)', &
'']

shortname="dprod"
call process()

case('91','dshiftl')

textblock=[character(len=256) :: &
'', &
'dshiftl(3fortran)                                           dshiftl(3fortran)', &
'', &
'NAME', &
'  DSHIFTL(3) - [BIT:COPY] Combined left shift of the bits of two integers', &
'', &
'SYNOPSIS', &
'  result = dshiftl(i, j, shift)', &
'', &
'          elemental integer(kind=KIND) function dshiftl(i, j, shift)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  the kind of I, J, and the return value are the same. An exception is that', &
'     one of I and J may be a BOZ literal constant (A BOZ literal constant is a', &
'     binary, octal or hex constant).', &
'', &
'  o  If either I or J is a BOZ-literal-constant (but not both), it is first', &
'     converted as if by the intrinsic function INT(3) to type integer with the', &
'     kind type parameter of the other.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  DSHIFTL(3) combines bits of I and J. The rightmost SHIFT bits of the result', &
'  are the leftmost SHIFT bits of J, and the remaining bits are the rightmost', &
'  BITSIZE(I)-SHIFT of I.', &
'', &
'  Hence DSHIFTL is designated as a "combined left shift", because it is like', &
'  we appended I and J together, shifted it SHIFT bits to the left, and then', &
'  kept the same number of bits as I or J had.', &
'', &
'  For example, for two 16-bit values if SHIFT=6', &
'', &
'           SHIFT=6', &
'           I =             1111111111111111', &
'           J =             0000000000000000', &
'           COMBINED        11111111111111110000000000000000', &
'           DROP LEFT BITS  11111111110000000000000000', &
'           KEEP LEFT 16    1111111111000000', &
'', &
'NOTE', &
'  This is equivalent to', &
'', &
'          ior( shiftl(i, shift), shiftr(j, bit_size(j) - shift) )', &
'', &
'  Also note that using this last representation of the operation is can be', &
'  derived that when both I and J have the same value as in', &
'', &
'           dshiftl(i, i, shift)', &
'', &
'  the result has the same value as a circular shift:', &
'', &
'           ishftc(i, shift)', &
'', &
'OPTIONS', &
'  o  I : used to define the left pattern of bits in the combined pattern', &
'', &
'  o  J : used for the right pattern of bits in the combined pattern', &
'', &
'  o  SHIFT : shall be nonnegative and less than or equal to the number of bits', &
'     in an integer input value (ie. the bit size of either one that is not a', &
'     BOZ literal constant).', &
'', &
'RESULT', &
'  The leftmost SHIFT bits of J are copied to the rightmost bits of the result,', &
'  and the remaining bits are the rightmost bits of I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dshiftl', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: i, j', &
'      integer            :: shift', &
'', &
'       ! basic usage', &
'        write(*,*) dshiftl (1, 2**30, 2) ! int32 values on little-endian => 5', &
'', &
'       ! print some simple calls as binary to better visual the results', &
'        i=-1', &
'        j=0', &
'        shift=5', &
'        call printit()', &
'', &
'        ! the leftmost SHIFT bits of J are copied to the rightmost result bits', &
'        j=int(b"11111000000000000000000000000000")', &
'        ! and the other bits are the rightmost bits of I', &
'        i=int(b"00000000000000000000000000000000")', &
'        call printit()', &
'', &
'        j=int(b"11111000000000000000000000000000")', &
'        i=int(b"00000111111111111111111111111111")', &
'        ! result should be all 1s', &
'        call printit()', &
'', &
'      contains', &
'      subroutine printit()', &
'        ! print i,j,shift and then i,j, and the result as binary values', &
'         write(*,''(*(g0))'')''I='',i,'' J='',j,'' SHIFT='',shift', &
'         write(*,''(b32.32)'') i,j, dshiftl (i, j, shift)', &
'      end subroutine printit', &
'', &
'      end program demo_dshiftl', &
'', &
'  Results:', &
'', &
'       >           5', &
'       > I=-1 J=0 SHIFT=5', &
'       > 11111111111111111111111111111111', &
'       > 00000000000000000000000000000000', &
'       > 11111111111111111111111111100000', &
'       > I=0 J=-134217728 SHIFT=5', &
'       > 00000000000000000000000000000000', &
'       > 11111000000000000000000000000000', &
'       > 00000000000000000000000000011111', &
'       > I=134217727 J=-134217728 SHIFT=5', &
'       > 00000111111111111111111111111111', &
'       > 11111000000000000000000000000000', &
'       > 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  DSHIFTR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               dshiftl(3fortran)', &
'']

shortname="dshiftl"
call process()

case('92','dshiftr')

textblock=[character(len=256) :: &
'', &
'dshiftr(3fortran)                                           dshiftr(3fortran)', &
'', &
'NAME', &
'  DSHIFTR(3) - [BIT:COPY] Combined right shift of the bits of two integers', &
'', &
'SYNOPSIS', &
'  result = dshiftr(i, j, shift)', &
'', &
'          elemental integer(kind=KIND) function dshiftr(i, j, shift)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any kind value for the integer type', &
'', &
'  o  the kind of I, J, and the return value are the same. An exception is that', &
'     one of I and J may be a BOZ literal constant (A BOZ literal constant is a', &
'     binary, octal or hex constant).', &
'', &
'  o  If either I or J is a BOZ-literal-constant, it is first converted as if', &
'     by the intrinsic function INT(3) to type integer with the kind type', &
'     parameter of the other.', &
'', &
'DESCRIPTION', &
'  DSHIFTR(3) combines bits of I and J. The leftmost SHIFT bits of the result', &
'  are the rightmost SHIFT bits of I, and the remaining bits are the leftmost', &
'  bits of J.', &
'', &
'  It may be thought of as appending the bits of I and J, dropping off the', &
'  SHIFT rightmost bits, and then retaining the same number of rightmost bits', &
'  as an input value, hence the name "combined right shift"...', &
'', &
'  Given two 16-bit values labeled alphabetically ...', &
'', &
'        i=ABCDEFGHIJKLMNOP', &
'        j=abcdefghijklmnop', &
'', &
'  Append them together', &
'', &
'        ABCDEFGHIJKLMNOPabcdefghijklmnop', &
'', &
'  Shift them N=6 bits to the right dropping off bits', &
'', &
'              ABCDEFGHIJKLMNOPabcdefghij', &
'', &
'  Keep the 16 right-most bits', &
'', &
'                        KLMNOPabcdefghij', &
'', &
'NOTE', &
'  DSHIFR(I,J,SHIFT) is equivalent to', &
'', &
'          ior(shiftl (i, bit_size(i) - shift), shiftr(j, shift) )', &
'', &
'  it can also be seen that if I and J have the same value', &
'', &
'          dshiftr( i, i, shift )', &
'', &
'  this has the same result as a negative circular shift', &
'', &
'          ishftc( i,  -shift ).', &
'', &
'OPTIONS', &
'  o  I : left value of the pair of values to be combine-shifted right', &
'', &
'  o  J : right value of the pair of values to be combine-shifted right', &
'', &
'  o  SHIFT : the shift value is non-negative and less than or equal to the', &
'     number of bits in an input value as can be computed by BIT_SIZE(3).', &
'', &
'RESULT', &
'  The result is a combined right shift of I and J that is the same as the bit', &
'  patterns of the inputs being combined left to right, dropping off SHIFT bits', &
'  on the right and then retaining the same number of bits as an input value', &
'  from the rightmost bits.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_dshiftr', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: i, j', &
'      integer            :: shift', &
'', &
'       ! basic usage', &
'        write(*,*) dshiftr (1, 2**30, 2)', &
'', &
'       ! print some calls as binary to better visualize the results', &
'        i=-1', &
'        j=0', &
'        shift=5', &
'', &
'        ! print values', &
'         write(*,''(*(g0))'')''I='',i,'' J='',j,'' SHIFT='',shift', &
'         write(*,''(b32.32)'') i,j, dshiftr (i, j, shift)', &
'', &
'       ! visualizing a "combined right shift" ...', &
'        i=int(b"00000000000000000000000000011111")', &
'        j=int(b"11111111111111111111111111100000")', &
'        ! appended together ( i//j )', &
'        ! 0000000000000000000000000001111111111111111111111111111111100000', &
'        ! shifted right SHIFT values dropping off shifted values', &
'        !      00000000000000000000000000011111111111111111111111111111111', &
'        ! keep enough rightmost bits to fill the kind', &
'        !                                 11111111111111111111111111111111', &
'        ! so the result should be all 1s bits ...', &
'', &
'         write(*,''(*(g0))'')''I='',i,'' J='',j,'' SHIFT='',shift', &
'         write(*,''(b32.32)'') i,j, dshiftr (i, j, shift)', &
'', &
'      end program demo_dshiftr', &
'', &
'  Results:', &
'', &
'       >    1342177280', &
'       >  I=-1 J=0 SHIFT=5', &
'       >  11111111111111111111111111111111', &
'       >  00000000000000000000000000000000', &
'       >  11111000000000000000000000000000', &
'       >  I=31 J=-32 SHIFT=5', &
'       >  00000000000000000000000000011111', &
'       >  11111111111111111111111111100000', &
'       >  11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  DSHIFTL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               dshiftr(3fortran)', &
'']

shortname="dshiftr"
call process()

case('93','endfile')

textblock=[character(len=256) :: &
'', &
'endfile(7fortran)                                           endfile(7fortran)', &
'', &
'NAME', &
'  ENDFILE(7) - [NUMERIC] Absolute value', &
'', &
'SYNOPSIS', &
'  endfile unit_number', &
'', &
'DESCRIPTION', &
'  An ENDFILE(7f) ends or truncates a file at the current record.', &
'', &
'  Execution of an ENDFILE(7F) statement for a file connected for SEQUENTIAL', &
'  ACCESS writes an endfile record as the next record of the file. The file is', &
'  then positioned after the endfile record, which becomes the last record of', &
'  the file.', &
'', &
'  o  SEQUENTIAL ACCESS : After execution of an ENDFILE(7F) statement for a', &
'     file connected for sequential access, a BACKSPACE(7F) or REWIND(7F)', &
'     statement shall be used to reposition the file prior to execution of any', &
'     data transfer input/output statement or ENDFILE(7F) statement.', &
'', &
'  o  DIRECT ACCESS : For a file connected for DIRECT ACCESS, only those', &
'     records before the endfile record are considered to have been written.', &
'     Thus, only those records or additional records subsequently written shall', &
'     be read during subsequent direct access connections to the file.', &
'', &
'  o  STREAM ACCESS : Execution of an ENDFILE(7F) statement for a file', &
'     connected for STREAM ACCESS causes the terminal point of the file to', &
'     become equal to the current file position. Only file storage units before', &
'     the current position are considered to have been written; thus only those', &
'     file storage units shall be subsequently read.  Subsequent stream output', &
'     statements may be used to write further data to the file.', &
'', &
'  Execution of an ENDFILE(7F) statement for a file that is connected but does', &
'  not exist creates the file; if the file is connected for sequential access,', &
'  it is created prior to writing the endfile record.', &
'', &
'OPTIONS', &
'  LUN', &
'    A unit number of a connected file', &
'', &
'EXAMPLES', &
'  An example of an ENDFILE(7f) statement is:', &
'', &
'         program demo_endfile', &
'         implicit none', &
'         integer :: lun, i, j, iostat', &
'         integer,parameter:: isz=10', &
'            !', &
'            ! create a little scratch file', &
'            open(newunit=lun,file=''_scr.txt'',        &', &
'            & form=''formatted'',              &', &
'            & action=''readwrite'')', &
'            write(lun,''(i0)'')(100+i,i=1,isz)', &
'            !', &
'            ! write end of file after reading half of file', &
'            rewind(lun)', &
'            write(*,*)''rewind and read'',isz/2,''lines''', &
'            read(lun,*)(j,i=1,isz/2)', &
'            endfile lun ! will truncate line at current position', &
'            !', &
'            ! NOTE: backspace before writing any addition lines', &
'            !       once an ENDFILE(7f) statement is executed', &
'            ! backspace(lun)', &
'            !', &
'            ! rewind and echo remaining file', &
'            rewind(lun)', &
'            j=0', &
'            do i=1,huge(0)-1', &
'               read(lun,*,iostat=iostat)j', &
'               if(iostat.ne.0)exit', &
'               write(*,*)i,j', &
'            enddo', &
'            write(*,*)''number of lines in file was '',isz,'', is now '',i-1', &
'            close(unit=lun,status=''delete'')', &
'         end program demo_endfile', &
'', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025               endfile(7fortran)', &
'']

shortname="endfile"
call process()

case('94','eoshift')

textblock=[character(len=256) :: &
'', &
'eoshift(3fortran)                                           eoshift(3fortran)', &
'', &
'NAME', &
'  EOSHIFT(3) - [ARRAY:TRANSFORMATIONAL] End-off shift of elements of an array', &
'', &
'SYNOPSIS', &
'  result = eoshift( array, shift [,boundary] [,dim] )', &
'', &
'        type(TYPE(kind=KIND)) function eoshift(array,shift,boundary,dim)', &
'', &
'         type(TYPE(kind=KIND)),intent(in) :: array(..)', &
'         integer(kind=**),intent(in)      :: shift(..)', &
'         type(TYPE(kind=KIND)),intent(in) :: boundary(..)', &
'         integer(kind=**),intent(in)      :: dim', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY an array of any type', &
'', &
'  o  SHIFT is an integer of any kind. It may be a scalar. If the rank of ARRAY', &
'     is greater than one, and DIM is specified it is the same shape as ARRAY', &
'     reduced by removing dimension DIM.', &
'', &
'  o  BOUNDARY May be a scalar of the same type and kind as ARRAY. It must be a', &
'     scalar when ARRAY has a rank of one. Otherwise, it may be an array of the', &
'     same shape as ARRAY reduced by dimension DIM. It may only be absent for', &
'     certain types, as described below.', &
'', &
'  o  DIM is an integer of any kind. It defaults to one.', &
'', &
'  o  the result has the same type, type parameters, and shape as ARRAY.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  The result is an array of same type, kind and rank as the ARRAY argument.', &
'', &
'DESCRIPTION', &
'  EOSHIFT(3) performs an end-off shift on elements of ARRAY along the', &
'  dimension of DIM.', &
'', &
'  Elements shifted out one end of each rank one section are dropped.', &
'', &
'  If BOUNDARY is present then the corresponding value from BOUNDARY is copied', &
'  back in the other end, else default values are used.', &
'', &
'OPTIONS', &
'  o  ARRAY : array of any type whose elements are to be shifted. If the rank', &
'     of ARRAY is one, then all elements of ARRAY are shifted by SHIFT places.', &
'     If rank is greater than one, then all complete rank one sections of ARRAY', &
'     along the given dimension are shifted.', &
'', &
'  o  SHIFT : the number of elements to shift. A negative value shifts to the', &
'     right, a positive value to the left of the vector(s) being shifted.', &
'', &
'  o  BOUNDARY : the value to use to fill in the elements vacated by the shift.', &
'     If BOUNDARY is not present then the following are copied in depending on', &
'     the type of ARRAY.', &
'', &
'         Array Type    | Boundary Value', &
'         -----------------------------------------------------', &
'         Numeric       | 0, 0.0, or (0.0, 0.0) of the type and kind of "array"', &
'         Logical       | .false.', &
'         Character(len)|  LEN blanks', &
'', &
'  These are the only types for which BOUNDARY may not be present. For these', &
'  types the kind is converted as neccessary to the kind of ARRAY.', &
'', &
'  o  DIM : DIM is in the range of', &
'', &
'     1 <= DIM <= n', &
'', &
'  where "N" is the rank of ARRAY. If DIM is omitted it is taken to be 1.', &
'', &
'RESULT', &
'  Returns an array of the same characteristics as the input with the specified', &
'  number of elements dropped off along the specified direction indicated,', &
'  backfilling the vacated elements with a value indicated by the BOUNDARY', &
'  value.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_eoshift', &
'      implicit none', &
'      integer, dimension(3,3) :: a', &
'      integer :: i', &
'', &
'        write(*,*)''original''', &
'        a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3, 3 ])', &
'        call printi(a)', &
'', &
'        write(*,*)''shift each row differently''', &
'        a = eoshift(a, SHIFT=[1, 2, -2], BOUNDARY=-5, DIM=2)', &
'        call printi(a)', &
'', &
'        write(*,*)''shift each column differently''', &
'        a = eoshift(a, SHIFT=[1, 2, -2], BOUNDARY=-5, DIM=1)', &
'        call printi(a)', &
'', &
'        write(*,*)''original''', &
'        call printi(reshape([(i,i=1,12)],[3,4]))', &
'        write(*,''(*(g0))'')''shift=+2,dim=1''', &
'        call printi(eoshift(reshape([(i,i=1,12)],[3,4]),+2,dim=1))', &
'        write(*,''(*(g0))'')''shift=+2,dim=2''', &
'        call printi(eoshift(reshape([(i,i=1,12)],[3,4]),+2,dim=2))', &
'        write(*,''(*(g0))'')''shift=-2,dim=1''', &
'        call printi(eoshift(reshape([(i,i=1,12)],[3,4]),-2,dim=1))', &
'        write(*,''(*(g0))'')''shift=-2,dim=2''', &
'        call printi(eoshift(reshape([(i,i=1,12)],[3,4]),-2,dim=2))', &
'      contains', &
'      subroutine printi(arr)', &
'      !@(#) print small 2d integer arrays in row-column format', &
'      integer,intent(in) :: arr(:,:)', &
'      integer           :: i', &
'      character(len=40)  :: biggest', &
'        write(biggest,''(*(g0))'')''(1x,*(i'',               &', &
'        & ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2, &', &
'        & '':,","))''', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest)arr(i,:)', &
'        enddo', &
'      end subroutine printi', &
'', &
'      end program demo_eoshift', &
'', &
'  Results:', &
'', &
'       >  original', &
'       >    1, 4,  7', &
'       >    2, 5,  8', &
'       >    3, 6,  9', &
'       >  shift each row differently', &
'       >    4, 7, -5', &
'       >    8, -5, -5', &
'       >   -5, -5,  3', &
'       >  shift each column differently', &
'       >    8, -5, -5', &
'       >   -5, -5, -5', &
'       >   -5, -5, -5', &
'       >  original', &
'       >     1,   4,   7,  10', &
'       >     2,   5,   8,  11', &
'       >     3,   6,   9,  12', &
'       > shift=+2,dim=1', &
'       >     3,   6,   9,  12', &
'       >     0,   0,   0,   0', &
'       >     0,   0,   0,   0', &
'       > shift=+2,dim=2', &
'       >     7,  10,   0,   0', &
'       >     8,  11,   0,   0', &
'       >     9,  12,   0,   0', &
'       > shift=-2,dim=1', &
'       >    0, 0,  0,  0', &
'       >    0, 0,  0,  0', &
'       >    1, 4,  7, 10', &
'       > shift=-2,dim=2', &
'       >    0, 0,  1,  4', &
'       >    0, 0,  2,  5', &
'       >    0, 0,  3,  6', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DSHIFTR(3), DSHIFTL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               eoshift(3fortran)', &
'']

shortname="eoshift"
call process()

case('95','epsilon')

textblock=[character(len=256) :: &
'', &
'epsilon(3fortran)                                           epsilon(3fortran)', &
'', &
'NAME', &
'  EPSILON(3) - [MODEL:NUMERIC] Epsilon function', &
'', &
'SYNOPSIS', &
'  result = epsilon(x)', &
'', &
'          real(kind=kind(x)) function epsilon(x)', &
'', &
'           real(kind=kind(x),intent(in) :: x(..)', &
'', &
'CHARACTERISTICS', &
'  o  X shall be of type real. It may be a scalar or an array.', &
'', &
'  o  the result is a scalar of the same type and kind type parameter as X.', &
'', &
'DESCRIPTION', &
'  EPSILON(3) returns the floating point relative accuracy. It is the nearly', &
'  negligible number relative to 1 such that 1+ LITTLE_NUMBER is not equal to', &
'  1; or more precisely', &
'', &
'        real( 1.0, kind(x)) + epsilon(x) /= real( 1.0, kind(x))', &
'', &
'  It may be thought of as the distance from 1.0 to the next largest floating', &
'  point number.', &
'', &
'  One use of EPSILON(3) is to select a delta value for algorithms that search', &
'  until the calculation is within delta of an estimate.', &
'', &
'  If delta is too small the algorithm might never halt, as a computation', &
'  summing values smaller than the decimal resolution of the data type does not', &
'  change.', &
'', &
'OPTIONS', &
'  o  X : The type shall be real.', &
'', &
'RESULT', &
'  The return value is of the same type as the argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_epsilon', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp) :: x = 3.143', &
'      real(kind=dp) :: y = 2.33d0', &
'', &
'        ! so if x is of type real32, epsilon(x) has the value 2**-23', &
'        print *, epsilon(x)', &
'        ! note just the type and kind of x matter, not the value', &
'        print *, epsilon(huge(x))', &
'        print *, epsilon(tiny(x))', &
'', &
'        ! the value changes with the kind of the real value though', &
'        print *, epsilon(y)', &
'', &
'        ! adding and subtracting epsilon(x) changes x', &
'        write(*,*)x == x + epsilon(x)', &
'        write(*,*)x == x - epsilon(x)', &
'', &
'        ! these next two comparisons will be .true. !', &
'        write(*,*)x == x + epsilon(x) * 0.999999', &
'        write(*,*)x == x - epsilon(x) * 0.999999', &
'', &
'        ! you can calculate epsilon(1.0d0)', &
'        write(*,*)my_dp_eps()', &
'', &
'      contains', &
'', &
'        function my_dp_eps()', &
'        ! calculate the epsilon value of a machine the hard way', &
'        real(kind=dp) :: t', &
'        real(kind=dp) :: my_dp_eps', &
'', &
'           ! starting with a value of 1, keep dividing the value', &
'           ! by 2 until no change is detected. Note that with', &
'           ! infinite precision this would be an infinite loop,', &
'           ! but floating point values in Fortran have a defined', &
'           ! and limited precision.', &
'           my_dp_eps = 1.0d0', &
'           SET_ST: do', &
'              my_dp_eps = my_dp_eps/2.0d0', &
'              t = 1.0d0 + my_dp_eps', &
'              if (t <= 1.0d0) exit', &
'           enddo SET_ST', &
'           my_dp_eps = 2.0d0*my_dp_eps', &
'', &
'        end function my_dp_eps', &
'      end program demo_epsilon', &
'', &
'  Results:', &
'', &
'       >    1.19209290E-07', &
'       >    1.19209290E-07', &
'       >    1.19209290E-07', &
'       >    2.2204460492503131E-016', &
'       >  F', &
'       >  F', &
'       >  T', &
'       >  T', &
'       >    2.2204460492503131E-016', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               epsilon(3fortran)', &
'']

shortname="epsilon"
call process()

case('96','erf')

textblock=[character(len=256) :: &
'', &
'erf(3fortran)                                                   erf(3fortran)', &
'', &
'NAME', &
'  ERF(3) - [MATHEMATICS] Error function', &
'', &
'SYNOPSIS', &
'  result = erf(x)', &
'', &
'          elemental real(kind=KIND) function erf(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real', &
'', &
'  o  The result is of the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  ERF(3) computes the error function of X, defined as', &
'', &
'  $$ \text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-T^2} dt. $$', &
'', &
'OPTIONS', &
'  o  X : The type shall be real.', &
'', &
'RESULT', &
'  The return value is of type real, of the same kind as X and lies in the', &
'  range -1 <= ERF(x) <= 1 .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erf', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.17_real64', &
'         write(*,*)x, erf(x)', &
'      end program demo_erf', &
'', &
'  Results:', &
'', &
'        >  0.17000000000000001       0.18999246120180879', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  ERFC(3), ERF_SCALED(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:error function', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                   erf(3fortran)', &
'']

shortname="erf"
call process()

case('97','erfc')

textblock=[character(len=256) :: &
'', &
'erfc(3fortran)                                                 erfc(3fortran)', &
'', &
'NAME', &
'  ERFC(3) - [MATHEMATICS] Complementary error function', &
'', &
'SYNOPSIS', &
'  result = erfc(x)', &
'', &
'          elemental real(kind=KIND) function erfc(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real and any valid kind', &
'', &
'  o  KIND is any value valid for type real', &
'', &
'  o  the result has the same characteristics as X', &
'', &
'DESCRIPTION', &
'  ERFC(3) computes the complementary error function of X. Simply put this is', &
'  equivalent to 1 - ERF(X), but ERFC is provided because of the extreme loss', &
'  of relative accuracy if ERF(X) is called for large X and the result is', &
'  subtracted from 1.', &
'', &
'  ERFC(X) is defined as', &
'', &
'  $$ \text{erfc}(x) = 1 - \text{erf}(x) = 1 - \frac{2}{\sqrt{\pi}}', &
'  \int_x^{\infty} e^{-t^2} dt. $$', &
'', &
'OPTIONS', &
'  o  X : The type shall be real.', &
'', &
'RESULT', &
'  The return value is of type real and of the same kind as X. It lies in the', &
'  range', &
'', &
'    0 <= erfc(x) <= 2.', &
'', &
'  and is a processor-dependent approximation to the complementary error', &
'  function of X ( 1-ERF(X) ).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erfc', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.17_real64', &
'        write(*,''(*(g0))'')''X='',x, '' ERFC(X)='',erfc(x)', &
'        write(*,''(*(g0))'')''equivalently 1-ERF(X)='',1-erf(x)', &
'      end program demo_erfc', &
'', &
'  Results:', &
'', &
'       > X=.1700000000000000 ERFC(X)=.8100075387981912', &
'       > equivalently 1-ERF(X)=.8100075387981912', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  ERF(3) ERF_SCALED(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:error function', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  erfc(3fortran)', &
'']

shortname="erfc"
call process()

case('98','erfc_scaled')

textblock=[character(len=256) :: &
'', &
'erfc_scaled(3fortran)                                   erfc_scaled(3fortran)', &
'', &
'NAME', &
'  ERFC_SCALED(3) - [MATHEMATICS] Scaled complementary error function', &
'', &
'SYNOPSIS', &
'  result = erfc_scaled(x)', &
'', &
'          elemental real(kind=KIND) function erfc_scaled(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real of any valid kind', &
'', &
'  o  KIND is any kind valid for a real type', &
'', &
'  o  the result has the same characteristics as X', &
'', &
'DESCRIPTION', &
'  ERFC_SCALED(3) computes the exponentially-scaled complementary error', &
'  function of X:', &
'', &
'  $$ e^{x^2} \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt. $$', &
'', &
'  erfc_scaled(x)=exp(x*x)erfc(x)', &
'', &
'  NOTE1', &
'', &
'  The complementary error function is asymptotic to exp(-X2)/(X/PI). As such', &
'  it underflows at approximately X >= 9 when using ISO/IEC/IEEE 60559:2011', &
'  single precision arithmetic. The exponentially-scaled complementary error', &
'  function is asymptotic to 1/(X PI). As such it does not underflow until X >', &
'  HUGE (X)/PI.', &
'', &
'OPTIONS', &
'  o  X the value to apply the ERFC function to', &
'', &
'RESULT', &
'  The approximation to the exponentially-scaled complementary error function', &
'  of X', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_erfc_scaled', &
'      implicit none', &
'      real(kind(0.0d0)) :: x = 0.17d0', &
'        x = erfc_scaled(x)', &
'        print *, x', &
'      end program demo_erfc_scaled', &
'', &
'  Results:', &
'', &
'       >   0.833758302149981', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  ERF(3), EXP(3), ERFC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025           erfc_scaled(3fortran)', &
'']

shortname="erfc_scaled"
call process()

case('99','event_query')

textblock=[character(len=256) :: &
'', &
'event_query(3fortran)                                   event_query(3fortran)', &
'', &
'NAME', &
'  EVENT_QUERY(3) - [COLLECTIVE] Query whether a coarray event has occurred', &
'', &
'SYNOPSIS', &
'  call event_query(event, count [,stat] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  EVENT_QUERY(3) assigns the number of events to COUNT which have been posted', &
'  to the EVENT variable and not yet been removed by calling EVENT_WAIT. When', &
'  STAT is present and the invocation was successful, it is assigned the value', &
'  0. If it is present and the invocation has failed, it is assigned a positive', &
'  value and COUNT is assigned the value -1.', &
'', &
'OPTIONS', &
'  o  EVENT : (intent(in)) Scalar of type event_type, defined in', &
'     iso_fortran_env; shall not be coindexed.', &
'', &
'  o  COUNT : (intent(out))Scalar integer with at least the precision of', &
'     default integer.', &
'', &
'  o  STAT : (OPTIONAL) Scalar default-kind integer variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_event_query', &
'      use iso_fortran_env', &
'      implicit none', &
'      type(event_type) :: event_value_has_been_set[*]', &
'      integer :: cnt', &
'        if (this_image() == 1) then', &
'           call event_query(event_value_has_been_set, cnt)', &
'           if (cnt > 0) write(*,*) "Value has been set"', &
'        elseif (this_image() == 2) then', &
'           event post(event_value_has_been_set[1])', &
'        endif', &
'      end program demo_event_query', &
'', &
'STANDARD', &
'  TS 18508', &
'', &
'SEE ALSO', &
'  o  co_broadcast(3) - Copy a value to all images the current set of images', &
'', &
'  o  co_lbound(3) - Lower codimension bounds of an array', &
'', &
'  o  co_max(3) - Maximal value on the current set of images', &
'', &
'  o  co_min(3) - Minimal value on the current set of images', &
'', &
'  o  co_reduce(3) - Reduction of values on the current set of images', &
'', &
'  o  co_sum(3) - Sum of values on the current set of images', &
'', &
'  o  co_ubound(3) - Upper codimension bounds of an array', &
'', &
'  o  event_query(3) - Query whether a coarray event has occurred', &
'', &
'  o  image_index(3) - Cosubscript to image index conversion', &
'', &
'  o  lcobound(3) - Lower codimension bounds of an array', &
'', &
'  o  num_images(3) - Number of images', &
'', &
'  o  this_image(3) - Cosubscript index of this image', &
'', &
'  o  ucobound(3) - Upper codimension bounds of an array', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025           event_query(3fortran)', &
'']

shortname="event_query"
call process()

case('100','execute_command_line')

textblock=[character(len=256) :: &
'', &
'execute_command_line(3fortran)                 execute_command_line(3fortran)', &
'', &
'NAME', &
'  EXECUTE_COMMAND_LINE(3) - [SYSTEM:PROCESSES] Execute a shell command', &
'', &
'SYNOPSIS', &
'  call execute_command_line( & & command [,wait] [,exitstat] [,cmdstat]', &
'  [,cmdmsg] )', &
'', &
'          subroutine execute_command_line(command,wait,exitstat,cmdstat,cmdmsg)', &
'', &
'           character(len=*),intent(in)             :: command', &
'           logical,intent(in),optional             :: wait', &
'           integer,intent(inout),optional          :: exitstat', &
'           integer,intent(inout),optional          :: cmdstat', &
'           character(len=*),intent(inout),optional :: cmdmsg', &
'', &
'CHARACTERISTICS', &
'  o  COMMAND is a default character scalar', &
'', &
'  o  WAIT is a default logical scalar.', &
'', &
'  o  EXITSTAT is an integer of the default kind. It must be of a kind with at', &
'     least a decimal exponent range of 9.', &
'', &
'  o  CMDSTAT is an integer of default kind. The kind of the variable must', &
'     support at least a decimal exponent range of four.', &
'', &
'  o  CMDMSG is a character scalar of the default kind.', &
'', &
'DESCRIPTION', &
'  For EXECUTE_COMMAND_LINE(3) the COMMAND argument is passed to the shell and', &
'  executed. (The shell is generally SH(1) on Unix systems, and cmd.exe on', &
'  Windows.) If WAIT is present and has the value .false., the execution of the', &
'  command is asynchronous if the system supports it; otherwise, the command is', &
'  executed synchronously.', &
'', &
'  The three last arguments allow the user to get status information. After', &
'  synchronous execution, EXITSTAT contains the integer exit code of the', &
'  command, as returned by SYSTEM. CMDSTAT is set to zero if the command line', &
'  was executed (whatever its exit status was). CMDMSG is assigned an error', &
'  message if an error has occurred.', &
'', &
'  Note that the system call need not be thread-safe. It is the responsibility', &
'  of the user to ensure that the system is not called concurrently if', &
'  required.', &
'', &
'  When the command is executed synchronously, EXECUTE_COMMAND_LINE returns', &
'  after the command line has completed execution. Otherwise,', &
'  EXECUTE_COMMAND_LINE returns without waiting.', &
'', &
'  Because this intrinsic is making a system call, it is very system dependent.', &
'  Its behavior with respect to signaling is processor dependent. In', &
'  particular, on POSIX-compliant systems, the SIGINT and SIGQUIT signals will', &
'  be ignored, and the SIGCHLD will be blocked. As such, if the parent process', &
'  is terminated, the child process might not be terminated alongside.', &
'', &
'  One of the most common causes of errors is that the program requested is not', &
'  in the search path. You should make sure that the program to be executed is', &
'  installed on your system and that it is in the system''s path when the', &
'  program calls it. You can check if it is installed by running it from the', &
'  command prompt. If it runs successfully from the command prompt, it means', &
'  that it is installed, and so you should next check that it is in the search', &
'  path when the program executes (usually this means checking the environment', &
'  variable PATH).', &
'', &
'OPTIONS', &
'  o  COMMAND : the command line to be executed. The interpretation is', &
'     programming-environment dependent.', &
'', &
'  o  WAIT : If WAIT is present with the value .false., and the processor', &
'     supports asynchronous execution of the command, the command is executed', &
'     asynchronously; otherwise it is executed synchronously.', &
'', &
'     When the command is executed synchronously, EXECUTE_COMMAND_LINE(3)', &
'     returns after the command line has completed execution. Otherwise,', &
'     EXECUTE_COMMAND_LINE(3) returns without waiting.', &
'', &
'  o  EXITSTAT : If the command is executed synchronously, it is assigned the', &
'     value of the processor-dependent exit status. Otherwise, the value of', &
'     EXITSTAT is unchanged.', &
'', &
'  o  CMDSTAT : If an error condition occurs and CMDSTAT is not present, error', &
'     termination of execution of the image is initiated.', &
'', &
'     It is assigned the value -1 if the processor does not support command', &
'     line execution, a processor-dependent positive value if an error', &
'     condition occurs, or the value -2 if no error condition occurs but WAIT', &
'     is present with the value false and the processor does not support', &
'     asynchronous execution. Otherwise it is assigned the value 0.', &
'', &
'  o  CMDMSG : If an error condition occurs, it is assigned a processor-', &
'     dependent explanatory message. Otherwise, it is unchanged.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_execute_command_line', &
'      implicit none', &
'      integer :: exitstat, cmdstat', &
'      character(len=256) :: cmdmsg', &
'', &
'        call execute_command_line( &', &
'        &  command  = "external_prog.exe", &', &
'        &  exitstat = exitstat,            &', &
'        &  cmdstat  = cmdstat,             &', &
'        &  cmdmsg   = cmdmsg)', &
'        print *, "Exit status of external_prog.exe was ", exitstat', &
'        if(cmdstat.ne.0)then', &
'           print *, ''<ERROR>''//trim(cmdmsg)', &
'        endif', &
'', &
'        ! if asynchronous exitstat and cmdstat may not be relied on', &
'        call execute_command_line("reindex_files.exe", wait=.false.)', &
'        print *, "Now hopefully reindexing files in the background"', &
'', &
'        if(cmd(''dir''))then', &
'           write(*,*)''OK''', &
'        else', &
'           stop 4', &
'        endif', &
'', &
'        ! might short-circuit or not if a command fails', &
'        if(all(cmd([character(len=80) :: ''date'',''time myprg'',''date''])))then', &
'            write(*,*)''good time''', &
'        else', &
'            write(*,*)''bad time''', &
'        endif', &
'', &
'        stop ''end of program''', &
'      contains', &
'', &
'      elemental impure function cmd(command)', &
'      ! a functional interface for calling system commands', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'      & stderr=>ERROR_UNIT, stdout=>OUTPUT_UNIT', &
'      character(len=*),intent(in) :: command', &
'      logical                    :: cmd', &
'      logical                    :: wait', &
'      integer                    :: exitstat', &
'      integer                    :: cmdstat', &
'      character(len=256)         :: cmdmsg', &
'        wait=.false.', &
'        exitstat=0', &
'        cmdstat=0', &
'        call execute_command_line(command=command,wait=wait, &', &
'        & exitstat=exitstat,cmdstat=cmdstat,cmdmsg=cmdmsg)', &
'        if(cmdstat.ne.0)then', &
'           flush(stdout)', &
'           write(stderr,''(a)'')trim(cmdmsg)', &
'           flush(stderr)', &
'        endif', &
'        if(exitstat.ne.0)then', &
'           flush(stdout)', &
'           write(stderr,''(*(g0))'')''exitstat='',exitstat,'':'',trim(command)', &
'           flush(stderr)', &
'        endif', &
'        cmd=merge(.true.,.false.,exitstat==0)', &
'      end function cmd', &
'', &
'      end program demo_execute_command_line', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  GET_ENVIRONMENT_VARIABLE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025  execute_command_line(3fortran)', &
'']

shortname="execute_command_line"
call process()

case('101','exit')

textblock=[character(len=256) :: &
'', &
'exit(7fortran)                                                 exit(7fortran)', &
'', &
'NAME', &
'  EXIT(7f) - [EXECUTION CONTROL] terminate do-loops and block constructs', &
'', &
'SYNOPSIS', &
'  EXIT [construct-name]', &
'', &
'DESCRIPTION', &
'  *exit statements can terminate do-loops but also can exit most named block', &
'  constructs. First ...', &
'', &
'  EXIT STATEMENTS CAN TERMINATE DO-LOOP CONSTRUCTS', &
'', &
'  The EXIT statement most commonly terminates a DO or DO WHILE loop.', &
'', &
'  The related CYCLE statement immediately begins the next loop cycle versus', &
'  terminating the loop.', &
'', &
'  An unnamed EXIT statement must be within a DO loop and if executed it exits', &
'  the innermost DO within which it appears, terminating that loop.', &
'', &
'  If it is desired to exit nested do-loops the do-loop must be labeled with a', &
'  name, which the EXIT then refers to.', &
'', &
'  The DO CONTROL VARIABLES RETAIN THEIR LAST VALUE. That is if a DO loop is', &
'  terminated by and EXIT any additional inner DO loops are also terminated,', &
'  but all DO LOOP control variables retain their last value; assuming they are', &
'  still in scope.', &
'', &
'WITH A CONSTRAINT NAME EXIT CAN TERMINATE MOST BLOCK CONSTRUCTS', &
'  Named EXIT statements can also complete execution of other (named) block', &
'  constructs(eg. a BLOCK construct, an ASSOCIATE construct, ...).', &
'', &
'  If a construct name appears on an EXIT, the EXIT statement must be within', &
'  that construct. That is, an EXIT jumps to the end of the associated', &
'  construct only from within that very same construct.', &
'', &
'  If a non-DO construct is terminated, any DO loops inside that construct are', &
'  of course also terminated.', &
'', &
'  That stipulated, an EXIT statement can appear in any of the following', &
'  constructs:', &
'', &
'  o  ASSOCIATE construct', &
'', &
'  o  BLOCK construct', &
'', &
'  o  IF construct', &
'', &
'  o  SELECT CASE construct', &
'', &
'  o  SELECT RANK construct', &
'', &
'  o  SELECT TYPE construct', &
'', &
'  o  DO construct', &
'', &
'  o  CHANGETEAM construct', &
'', &
'  o  CRITICAL construct', &
'', &
'  Note specifically what is missing -- WHERE and FORALL constructs cannot have', &
'  EXIT statements associated with them.', &
'', &
'  A few additional restrictions apply, primarily for potentially parallel', &
'  regions.', &
'', &
'  o  An EXIT statement cannot cannot terminate a DO CONCURRENT construct', &
'     because the execution order of the iterations is allowed to be', &
'     indeterminate -- so an exit would result in an unknown state.', &
'', &
'  o  For related reasons jumping out of a parallel region to the exit of', &
'     another block construct could skip steps that would leave a parallel', &
'     program in an unknown state. Therefore EXIT statements in a DO', &
'     CONCURRENT, CHANGE TEAM or CRITICAL construct cannot reference an outer', &
'     construct.', &
'', &
'  o  An exit from a CHANGE TEAM construct does not just resume execution after', &
'     the end of the construct. The effect is the same as transferring control', &
'     to the END TEAM statement, including that if that statement contains a', &
'     STAT= or ERRMSG= specifier, the STAT variable or ERRMSG variable becomes', &
'     defined.', &
'', &
'OPTIONS', &
'  CONSTRUCT-NAME (Optional for DO-LOOP exits) Is the name of the DO-LOOP or', &
'  block construct. Note the construct names must be unique within the same', &
'  scope.', &
'', &
'  Unnamed EXIT statements could introduce errors when loop nesting is', &
'  modified. Therefore names are strongly recommended accept perhaps where the', &
'  loop comprises only a few lines of code.', &
'', &
'EXAMPLES', &
'  Samples:', &
'', &
'        program demo_exit', &
'        implicit none', &
'        integer,parameter :: arbitrary_size=10', &
'        integer :: i, j, k, iarr(arbitrary_size)', &
'        integer :: iostat, lun', &
'        logical :: ok', &
'        character(len=80) :: line', &
'        character(len=*),parameter :: gen=''(*(g0:,1x))''', &
'        !', &
'        ! the basics', &
'        !', &
'        ! Note we will use the function irand(3f) contained in', &
'        ! the end of the code below to generate random whole numbers', &
'        !', &
'        !----------------------', &
'        ! EXIT an infinite loop', &
'        !----------------------', &
'           i=0', &
'           do', &
'             i=i+1', &
'             ! we will test on a random value to simulate an actual criteria', &
'             ! to meet that indicates the loop should be terminated', &
'             if(irand(-100,100).gt.95)exit', &
'           enddo', &
'           print gen, ''escaped infinite loop after only '',i,''tries''', &
'', &
'          ! a related common use is to read a file of unknown size', &
'          ! till an error or end-of-file, although READ does have', &
'          ! the options ERR=numeric-label and EOF=numeric-label.', &
'          ! INFINITE: do', &
'          !    read(*,''(a)'',iostat=iostat) line', &
'          !    if(iostat.ne.0)exit INFINITE', &
'          ! enddo INFINITE', &
'', &
'        ! Some argue that an infinite loop is never a good idea.', &
'        ! A common practice is to avoid even the possibility of an', &
'        ! infinite loop by putting a cap on the number of iterations', &
'        ! that should "never" occur, and then error processing', &
'        ! if the unexpected number of loops is inadvertently reached.', &
'        ! This technique can let your code gracefully handle being used with', &
'        ! problems bigger than it was intended for, or not loop infinitely', &
'        ! if some unexpected or incorrect input or condition is encountered.', &
'        ! It might make it stop unitentionally as well.', &
'          !', &
'           ! run a loop but quit as soon as 200 random integers are odd', &
'           j=0', &
'           ! fun facts: What are the odds of not getting 200 in 10000?', &
'           do i=1, 10000', &
'              k=irand(0,99)', &
'              if((k+1)/2 /= k/2)j=j+1 ! cheap integer math trick to tell if odd', &
'              if(j .ge. 200) exit', &
'           enddo', &
'           if(j.lt.200) then', &
'              print gen,''Oh no! Not enough odd samples. only found'',j', &
'              print gen,''That is REALLY unlikely.''', &
'              stop ''<ERROR> unexpectedly low number of odd values''', &
'           else', &
'              print gen,''only did I='',i,''passes to get 200 odd samples''', &
'           endif', &
'        ! ---------------------------', &
'        ! how to EXIT nested do-loops', &
'        ! ---------------------------', &
'          ! EXIT with no name only exits an innermost loop', &
'          ! so in the following k will be 3, as all passes of the', &
'          ! outer loop still occur', &
'           k=0', &
'           do i=1,3', &
'              do j=1,5', &
'                 exit', &
'              enddo', &
'              k=k+1', &
'           enddo', &
'           ! at the end of a completed loop the counter is end_limit+step so', &
'           ! you can tell if you exhausted the do loop or exited early:', &
'           print gen,''I='',i,''so '',&', &
'           & merge(''completed'',''exited   '',i.gt.3),'' outer loop''', &
'           print gen,''J='',j,''so '',&', &
'           & merge(''completed'',''exited   '',j.gt.5),'' inner loop''', &
'           print gen,''K='',k', &
'', &
'           ! COMMENTARY:', &
'           ! A labeled exit is less prone to error so generally worth the', &
'           ! additional verbosity even when just exiting an inner loop.', &
'           ! Without a label an EXIT is somewhat like saying "EXIT SOMEWHERE".', &
'', &
'        ! It is simple to EXIT nested loops from an inner loop.', &
'        ! Just use a construct name. Lets start with the nested loop above', &
'        ! that only repeatedly exited the inner loop and label the outer', &
'        ! loop "OUTER". Now our exit can explicity name what loop it wants', &
'        ! to exit ...', &
'', &
'           k=0', &
'           OUTER: do i=1,3', &
'              do j=1,5', &
'                 exit OUTER', &
'              enddo', &
'              k=k+1', &
'           enddo OUTER', &
'           if(i==1.and.j==1.and.k==0)then', &
'              print gen,''exited nested loops successfully as expected''', &
'           else', &
'              print gen,''something went wrong, i='',i,''j='',j,''k='',k', &
'           endif', &
'', &
'        ! ---------------------------------------', &
'        ! exits from non-DO-loop block constructs', &
'        ! ---------------------------------------', &
'        ! REMEMBER: non-DO-loop exits are always named', &
'', &
'        !----------------------------------------------------------------------', &
'        ! EXIT a BLOCK statement surrounding a loop to avoid the nefarious GOTO', &
'        !----------------------------------------------------------------------', &
'           ! look for a 5 in an array that should always have it', &
'           iarr=[(i,i=1,size(iarr))] ! fill array with 1 to N', &
'           LOOKFOR: block', &
'              do i=1,size(iarr)', &
'                ! when you find what you are looking for use an EXIT instead', &
'                ! of a GOTO , which follows much more restricted rules on', &
'                ! on where you can land, preventing the threat of spaghetti code', &
'                if(iarr(i).eq.5) exit LOOKFOR', &
'              enddo', &
'              write(*,*)''should not get here. iarr='',iarr', &
'              stop ''<INTERNAL ERROR> should never get here! is array too small?''', &
'           endblock LOOKFOR', &
'           print gen,''Good Found 5 at position I='',i,''so exited BLOCK construct''', &
'', &
'        !--------------', &
'        ! Dusty corners', &
'        !--------------', &
'', &
'        ! a block contained completely within a DO CONCURRENT can', &
'        ! be exited even though the DO CONCURRENT itself or an outer block', &
'        ! cannot be terminated from within a DO CONCURRENT', &
'        do concurrent (i = 1:10)', &
'           INCC:  block', &
'             real :: t', &
'            t = 0.0', &
'            if (t == 0.0) exit INCC', &
'            t= t+1.0', &
'            end block INCC', &
'        end do', &
'', &
'        ! The following example shows illegal EXIT statements in DO CONCURRENT', &
'        ! and CRITICAL:', &
'', &
'        ! can   t EXIT DO CONCURRENT or outer construct of a DO CONCURRENT', &
'        !x!N=4', &
'        !x!LOOP_1 : DO CONCURRENT (I = 1:N)', &
'        !x!  N = N + 1', &
'        !x!  IF (N > I) EXIT LOOP_1', &
'        !x!END DO LOOP_1', &
'', &
'        !x!LOOP_2 : DO I = 1, 15', &
'        !x!  CRITICAL', &
'        !x!    N = N + 1', &
'        !x!    IF (N > I) EXIT LOOP_2 ! cannott EXIT outer construct from inside', &
'        !x!  END CRITICAL             ! CHANGE TEAM, DO CONCURRENT, or CRITICAL', &
'        !x!END DO LOOP_2', &
'', &
'        ! this would fail', &
'        ! because the same construct name was used in the same scope:', &
'        !x! LEVELA block:', &
'        !x! exit LEVELA', &
'        !x! endblock LEVELA', &
'        !x!', &
'        !x! LEVELA block:', &
'        !x! exit LEVELA', &
'        !x! endblock LEVELA', &
'', &
'        contains', &
'        ! choose a value from range of integers inclusive randomly', &
'        function irand(first,last)', &
'        integer, allocatable :: seed(:)', &
'        integer,intent(in)   :: first,last', &
'        real                 :: rand_val', &
'        integer              :: irand', &
'           call random_number(rand_val)', &
'           irand = first + floor((last+1-first)*rand_val)', &
'        end function irand', &
'        end program demo_exit', &
'', &
'  Results:', &
'', &
'       > escaped infinite loop after only  71 tries', &
'       > only did I= 426 passes to get 200 odd samples', &
'       > I= 4 so  completed  outer loop', &
'       > J= 1 so  exited     inner loop', &
'       > K= 3', &
'       > exited nested loops successfully as expected', &
'       > Good Found 5 at position I= 5 so exited BLOCK construct', &
'', &
'SEE ALSO', &
'  o  CYCLE(3)', &
'', &
'  o  RETURN(3)', &
'', &
'  o  STOP(3)', &
'', &
'  o  DO(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  exit(7fortran)', &
'']

shortname="exit"
call process()

case('102','exp')

textblock=[character(len=256) :: &
'', &
'exp(3fortran)                                                   exp(3fortran)', &
'', &
'NAME', &
'  EXP(3) - [MATHEMATICS] Base-e exponential function', &
'', &
'SYNOPSIS', &
'  result = exp(x)', &
'', &
'          elemental TYPE(kind=KIND) function exp(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be real or complex of any kind.', &
'', &
'  o  The return value has the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  EXP(3) returns the value of e (the base of natural logarithms) raised to the', &
'  power of X.', &
'', &
'  "e" is also known as Euler''s constant.', &
'', &
'  If X is of type complex, its imaginary part is regarded as a value in', &
'  radians such that if (see Euler''s formula):', &
'', &
'         cx=(re,im)', &
'', &
'  then', &
'', &
'         exp(cx) = exp(re) * cmplx(cos(im),sin(im),kind=kind(cx))', &
'', &
'  Since EXP(3) is the inverse function of LOG(3) the maximum valid magnitude', &
'  of the real component of X is LOG(HUGE(X)).', &
'', &
'OPTIONS', &
'  o  X : The type shall be real or complex.', &
'', &
'RESULT', &
'  The value of the result is E**X where E is Euler''s constant.', &
'', &
'  If X is of type complex, its imaginary part is regarded as a value in', &
'  radians.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_exp', &
'      implicit none', &
'      real :: x, re, im', &
'      complex :: cx', &
'', &
'        x = 1.0', &
'        write(*,*)"Euler''s constant is approximately",exp(x)', &
'', &
'        !! complex values', &
'        ! given', &
'        re=3.0', &
'        im=4.0', &
'        cx=cmplx(re,im)', &
'', &
'        ! complex results from complex arguments are Related to Euler''s formula', &
'        write(*,*)''given the complex value '',cx', &
'        write(*,*)''exp(x) is'',exp(cx)', &
'        write(*,*)''is the same as'',exp(re)*cmplx(cos(im),sin(im),kind=kind(cx))', &
'', &
'        ! exp(3) is the inverse function of log(3) so', &
'        ! the real component of the input must be less than or equal to', &
'        write(*,*)''maximum real component'',log(huge(0.0))', &
'        ! or for double precision', &
'        write(*,*)''maximum doubleprecision component'',log(huge(0.0d0))', &
'', &
'        ! but since the imaginary component is passed to the cos(3) and sin(3)', &
'        ! functions the imaginary component can be any real value', &
'', &
'      end program demo_exp', &
'', &
'  Results:', &
'', &
'       >  Euler''s constant is approximately   2.71828175', &
'       >  given the complex value             (3.00000000,4.00000000)', &
'       >  exp(x) is          (-13.1287832,-15.2007847)', &
'       >  is the same as          (-13.1287832,-15.2007847)', &
'       >  maximum real component   88.7228394', &
'       >  maximum doubleprecision component   709.78271289338397', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  LOG(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:Exponential function', &
'', &
'  o  Wikipedia:Euler''s formula', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   exp(3fortran)', &
'']

shortname="exp"
call process()

case('103','exponent')

textblock=[character(len=256) :: &
'', &
'exponent(3fortran)                                         exponent(3fortran)', &
'', &
'NAME', &
'  EXPONENT(3) - [MODEL:COMPONENTS] Exponent of floating-point number', &
'', &
'SYNOPSIS', &
'  result = exponent(x)', &
'', &
'          elemental integer function exponent(x)', &
'', &
'           real(kind=**),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X shall be of type real of any valid kind', &
'', &
'  o  the result is a default integer type', &
'', &
'DESCRIPTION', &
'  EXPONENT(3) returns the value of the exponent part of X, provided the', &
'  exponent is within the range of default integers.', &
'', &
'OPTIONS', &
'  o  X : the value to query the exponent of', &
'', &
'RESULT', &
'  EXPONENT(3) returns the value of the exponent part of X', &
'', &
'  If X is zero the value returned is zero.', &
'', &
'  If X is an IEEE infinity or NaN, the result has the value HUGE(0).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_exponent', &
'      implicit none', &
'      real :: x = 1.0', &
'      integer :: i', &
'        i = exponent(x)', &
'        print *, i', &
'        print *, exponent(0.0)', &
'        print *, exponent([10.0,100.0,1000.0,-10000.0])', &
'        ! beware of overflow, it may occur silently', &
'        !print *, 2**[10.0,100.0,1000.0,-10000.0]', &
'        print *, exponent(huge(0.0))', &
'        print *, exponent(tiny(0.0))', &
'      end program demo_exponent', &
'', &
'  Results:', &
'', &
'       >           4           7          10          14', &
'       >         128', &
'       >        -125', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), FRACTION(3), HUGE(3), MAXEXPONENT(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              exponent(3fortran)', &
'']

shortname="exponent"
call process()

case('104','extends_type_of')

textblock=[character(len=256) :: &
'', &
'extends_type_of(3fortran)                           extends_type_of(3fortran)', &
'', &
'NAME', &
'  EXTENDS_TYPE_OF(3) - [STATE:INQUIRY] Determine if the dynamic type of A is', &
'  an extension of the dynamic type of MOLD.', &
'', &
'SYNOPSIS', &
'  result = extends_type_of(a, mold)', &
'', &
'          logical extends_type_of(a, mold)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: a', &
'           type(TYPE(kind=KIND)),intent(in) :: mold', &
'', &
'CHARACTERISTICS', &
'  -A shall be an object or pointer to an extensible declared type, or', &
'  unlimited polymorphic. If it is a polymorphic pointer, it shall not have an', &
'  undefined association status. -MOLE shall be an object or pointer to an', &
'  extensible declared type or unlimited polymorphic. If it is a polymorphic', &
'  pointer, it shall not have an undefined association status.', &
'', &
'  o  the result is a scalar default logical type.', &
'', &
'DESCRIPTION', &
'  EXTENDS_TYPE_OF(3) is .true. if and only if the dynamic type of A is or', &
'  could be (for unlimited polymorphic) an extension of the dynamic type of', &
'  MOLD.', &
'', &
'  NOTE1', &
'', &
'  The dynamic type of a disassociated pointer or unallocated allocatable', &
'  variable is its declared type.', &
'', &
'  NOTE2', &
'', &
'  The test performed by EXTENDS_TYPE_OF is not the same as the test performed', &
'  by the type guard CLASS IS. The test performed by EXTENDS_TYPE_OF does not', &
'  consider kind type parameters.', &
'', &
'OPTIONS', &
'  o  A : be an object of extensible declared type or unlimited polymorphic. If', &
'     it is a polymorphic pointer, it shall not have an undefined association', &
'     status.', &
'', &
'  o  MOLD : be an object of extensible declared type or unlimited polymorphic.', &
'     If it is a polymorphic pointer, it shall not have an undefined', &
'     association status.', &
'', &
'RESULT', &
'  If MOLD is unlimited polymorphic and is either a disassociated pointer or', &
'  unallocated allocatable variable, the result is true.', &
'', &
'  Otherwise if A is unlimited polymorphic and is either a disassociated', &
'  pointer or unallocated allocatable variable, the result is false.', &
'', &
'  Otherwise the result is true if and only if the dynamic type of A', &
'', &
'  if the dynamic type of A or MOLD is extensible, the result is true if and', &
'  only if the dynamic type of A is an extension type of the dynamic type of', &
'  MOLD; otherwise the result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'       ! program demo_extends_type_of', &
'       module M_demo_extends_type_of', &
'       implicit none', &
'       private', &
'', &
'       type nothing', &
'       end type nothing', &
'', &
'       type, extends(nothing) :: dot', &
'         real :: x=0', &
'         real :: y=0', &
'       end type dot', &
'', &
'       type, extends(dot) :: point', &
'         real :: z=0', &
'       end type point', &
'', &
'       type something_else', &
'       end type something_else', &
'', &
'       public :: nothing', &
'       public :: dot', &
'       public :: point', &
'       public :: something_else', &
'', &
'       end module M_demo_extends_type_of', &
'', &
'       program demo_extends_type_of', &
'       use M_demo_extends_type_of, only : nothing, dot, point, something_else', &
'       implicit none', &
'       type(nothing) :: grandpa', &
'       type(dot) :: dad', &
'       type(point) :: me', &
'       type(something_else) :: alien', &
'', &
'        write(*,*)''these should all be true''', &
'        write(*,*)extends_type_of(me,grandpa),''I am descended from Grandpa''', &
'        write(*,*)extends_type_of(dad,grandpa),''Dad is descended from Grandpa''', &
'        write(*,*)extends_type_of(me,dad),''Dad is my ancestor''', &
'', &
'        write(*,*)''is an object an extension of itself?''', &
'        write(*,*)extends_type_of(grandpa,grandpa) ,''self-propagating!''', &
'        write(*,*)extends_type_of(dad,dad) ,''clone!''', &
'', &
'        write(*,*)'' you did not father your grandfather''', &
'        write(*,*)extends_type_of(grandpa,dad),''no paradox here''', &
'', &
'        write(*,*)extends_type_of(dad,me),''no paradox here''', &
'        write(*,*)extends_type_of(grandpa,me),''no relation whatsoever''', &
'        write(*,*)extends_type_of(grandpa,alien),''no relation''', &
'        write(*,*)extends_type_of(me,alien),''not what everyone thinks''', &
'', &
'        call pointers()', &
'        contains', &
'', &
'        subroutine pointers()', &
'        ! Given the declarations and assignments', &
'        type t1', &
'        real c', &
'        end type', &
'        type, extends(t1) :: t2', &
'        end type', &
'        class(t1), pointer :: p, q', &
'           allocate (p)', &
'           allocate (t2 :: q)', &
'           ! the result of EXTENDS_TYPE_OF (P, Q) will be false, and the result', &
'           ! of EXTENDS_TYPE_OF (Q, P) will be true.', &
'           write(*,*)''(P,Q)'',extends_type_of(p,q),"mind your P''s and Q''s"', &
'           write(*,*)''(Q,P)'',extends_type_of(q,p)', &
'        end subroutine pointers', &
'', &
'       end program demo_extends_type_of', &
'', &
'  Results:', &
'', &
'       > these should all be true', &
'       > T I am descended from Grandpa', &
'       > T Dad is descended from Grandpa', &
'       > T Dad is my ancestor', &
'       > is an object an extension of itself?', &
'       > T self-propagating!', &
'       > T clone!', &
'       >  you did not father your grandfather', &
'       > F no paradox here', &
'       > F no paradox here', &
'       > F no relation whatsoever', &
'       > F no relation', &
'       > F not what everyone thinks', &
'       > (P,Q) F mind your P''s and Q''s', &
'       > (Q,P) T', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  SAME_TYPE_AS(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025       extends_type_of(3fortran)', &
'']

shortname="extends_type_of"
call process()

case('105','findloc')

textblock=[character(len=256) :: &
'', &
'findloc(3fortran)                                           findloc(3fortran)', &
'', &
'NAME', &
'  FINDLOC(3) - [ARRAY:LOCATION] Location of first element of ARRAY identified', &
'  by MASK along dimension DIM matching a target value', &
'', &
'SYNOPSIS', &
'  Syntax:', &
'', &
'         result = findloc (array, value, dim [,mask] [,kind] [,back])', &
'           or', &
'         result = findloc (array, value [,mask] [,kind] [,back])', &
'', &
'          function findloc (array, value, dim, mask, kind, back)', &
'', &
'           type(TYPE(kind=KIND)),intent(in)     :: array(..)', &
'           type(TYPE(kind=KIND)),intent(in)     :: value', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'           integer(kind=**),intent(in),optional :: kind', &
'           logical(kind=**),intent(in),optional :: back', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY is an array of any intrinsic type.', &
'', &
'  o  VALUE shall be scalar but in type conformance with ARRAY, as specified', &
'     for the operator == or the operator .EQV..', &
'', &
'  o  DIM an integer corresponding to a dimension of ARRAY. The corresponding', &
'     actual argument shall not be an optional dummy argument.', &
'', &
'  o  MASK is logical and shall be conformable with ARRAY.', &
'', &
'  o  KIND a scalar integer initialization expression (ie. a constant)', &
'', &
'  o  BACK a logical scalar.', &
'', &
'  o  the result is integer of default kind or kind KIND if the KIND argument', &
'     is present. If DIM does not appear, the result is an array of rank one', &
'     and of size equal to the rank of ARRAY; otherwise, the result is an array', &
'     of the same rank and shape as ARRAY reduced by the dimension DIM.', &
'', &
'  NOTE: a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  FINDLOC(3) returns the location of the first element of ARRAY identified by', &
'  MASK along dimension DIM having a value equal to VALUE.', &
'', &
'  If both ARRAY and VALUE are of type logical, the comparison is performed', &
'  with the .EQV. operator; otherwise, the comparison is performed with the ==', &
'  operator. If the value of the comparison is .true., that element of ARRAY', &
'  matches VALUE.', &
'', &
'  If only one element matches VALUE, that element''s subscripts are returned.', &
'  Otherwise, if more than one element matches VALUE and BACK is absent or', &
'  present with the value .false., the element whose subscripts are returned is', &
'  the first such element, taken in array element order. If BACK is present', &
'  with the value .true., the element whose subscripts are returned is the last', &
'  such element, taken in array element order.', &
'', &
'OPTIONS', &
'  o  ARRAY : shall be an array of intrinsic type.', &
'', &
'  o  VALUE : shall be scalar and in type conformance with ARRAY.', &
'', &
'  o  DIM : shall be an integer scalar with a value in the range 1 <= DIM <= n,', &
'     where n is the rank of ARRAY. The corresponding actual argument shall not', &
'     be an optional dummy argument.', &
'', &
'  o  MASK : (optional) shall be of type logical and shall be conformable with', &
'     ARRAY.', &
'', &
'  o  KIND : (optional) shall be a scalar integer initialization expression.', &
'', &
'  o  BACK : (optional) shall be a logical scalar.', &
'', &
'RESULT', &
'  KIND is present, the kind type parameter is that specified by the value of', &
'  KIND; otherwise the kind type parameter is that of default integer type. If', &
'  DIM does not appear, the result is an array of rank one and of size equal to', &
'  the rank of ARRAY; otherwise, the result is of rank n - 1 and shape', &
'', &
'        [d1, d2, . . ., dDIM-1, dDIM+1, . . ., dn ]', &
'', &
'  where', &
'', &
'        [d1, d2, . . ., dn ]', &
'', &
'  is the shape of ARRAY.', &
'', &
'RESULT', &
'  o  CASE (I): The result of FINDLOC (ARRAY, VALUE) is a rank-one array whose', &
'     element values are the values of the subscripts of an element of ARRAY', &
'     whose value matches VALUE. If there is such a value, the ith subscript', &
'     returned lies in the range 1 to ei, where ei is the extent of the ith', &
'     dimension of ARRAY. If no elements match VALUE or ARRAY has size zero,', &
'     all elements of the result are zero.', &
'', &
'  o  CASE (II): the result of FINDLOC (ARRAY, VALUE, MASK = MASK) is a rank-', &
'     one array whose element values are the values of the subscripts of an', &
'     element of ARRAY, corresponding to a true element of MASK, whose value', &
'     matches VALUE. If there is such a value, the ith subscript returned lies', &
'     in the range 1 to ei, where ei is the extent of the ith dimension of', &
'     ARRAY. If no elements match VALUE, ARRAY has size zero, or every element', &
'     of MASK has the value false, all elements of the result are zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_findloc', &
'      logical,parameter :: T=.true., F=.false.', &
'      integer,allocatable :: ibox(:,:)', &
'      logical,allocatable :: mask(:,:)', &
'       ! basics', &
'        ! the first element matching the value is returned AS AN ARRAY', &
'        call printi(''== 6'',findloc ([2, 6, 4, 6], value = 6))', &
'        call printi(''== 6'',findloc ([2, 6, 4, 6], value = 6,back=.true.))', &
'        ! the first element matching the value is returned AS A SCALAR', &
'        call printi(''== 6'',findloc ([2, 6, 4, 6], value = 6,dim=1))', &
'        call printi(''== 6'',findloc ([2, 6, 4, 6], value = 6,back=.true.,dim=1))', &
'', &
'        ibox=reshape([ 0,-5,  7, 7, &', &
'                       3, 4, -1, 2, &', &
'                       1, 5,  6, 7] ,shape=[3,4],order=[2,1])', &
'', &
'        mask=reshape([ T, T, F, T, &', &
'                       T, T, F, T, &', &
'                       T, T, F, T] ,shape=[3,4],order=[2,1])', &
'', &
'        call printi(''array is'', ibox )', &
'        call printl(''mask  is'', mask )', &
'        print *, ''so for == 7 and back=.false.''', &
'        call printi(''so for == 7 the address of the element is'', &', &
'                & findloc (ibox, 7, mask = mask) )', &
'        print *, ''so for == 7 and back=.true.''', &
'        call printi(''so for == 7 the address of the element is'', &', &
'                & findloc (ibox, 7, mask = mask, back=.true.) )', &
'', &
'        print *,''This is independent of declared lower bounds for the array''', &
'', &
'        print *, '' using dim=N''', &
'        ibox=reshape([ 1,  2, -9,  &', &
'                       2,  2,  6 ] ,shape=[2,3],order=[2,1])', &
'', &
'        call printi(''array is'', ibox )', &
'        ! has the value [2, 1, 0] and', &
'        call printi('''',findloc (ibox, value = 2, dim = 1) )', &
'        ! has the value [2, 1].', &
'        call printi('''',findloc (ibox, value = 2, dim = 2) )', &
'      contains', &
'      ! GENERIC ROUTINES TO PRINT MATRICES', &
'      subroutine printl(title,a)', &
'      implicit none', &
'      !@(#) print small 2d logical scalar, vector, matrix in row-column format', &
'      character(len=*),intent(in)  :: title', &
'      logical,intent(in)          :: a(..)', &
'', &
'      character(len=*),parameter   :: row=''(" > [ ",*(l1:,","))''', &
'      character(len=*),parameter   :: all=''(" ",*(g0,1x))''', &
'      logical,allocatable         :: b(:,:)', &
'      integer                     :: i', &
'        write(*,all,advance=''no'')trim(title)', &
'        ! copy everything to a matrix to keep code simple', &
'        select rank(a)', &
'        rank (0); write(*,''(a)'')'' (a scalar)''; b=reshape([a],[1,1])', &
'        rank (1); write(*,''(a)'')'' (a vector)''; b=reshape(a,[size(a),1])', &
'        rank (2); write(*,''(a)'')'' (a matrix)''; b=a', &
'        rank default; stop ''*printl* unexpected rank''', &
'        end select', &
'        do i=1,size(b,dim=1)', &
'           write(*,fmt=row,advance=''no'')b(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'        write(*,all) ''>shape='',shape(a),'',rank='',rank(a),'',size='',size(a)', &
'        write(*,*)', &
'      end subroutine printl', &
'', &
'      subroutine printi(title,a)', &
'      implicit none', &
'      !@(#) print small 2d integer scalar, vector, matrix in row-column format', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: a(..)', &
'      character(len=*),parameter   :: all=''(" ",*(g0,1x))''', &
'      character(len=20)           :: row', &
'      integer,allocatable         :: b(:,:)', &
'      integer                     :: i', &
'        write(*,all,advance=''no'')trim(title)', &
'        ! copy everything to a matrix to keep code simple', &
'        select rank(a)', &
'        rank (0); write(*,''(a)'')'' (a scalar)''; b=reshape([a],[1,1])', &
'        rank (1); write(*,''(a)'')'' (a vector)''; b=reshape(a,[size(a),1])', &
'        rank (2); write(*,''(a)'')'' (a matrix)''; b=a', &
'        rank default; stop ''*printi* unexpected rank''', &
'        end select', &
'        ! find how many characters to use for integers', &
'        write(row,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(b))))))+2', &
'        ! use this format to write a row', &
'        row=''(" > [",*(i''//trim(row)//'':,","))''', &
'        do i=1,size(b,dim=1)', &
'           write(*,fmt=row,advance=''no'')b(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'        write(*,all) ''>shape='',shape(a),'',rank='',rank(a),'',size='',size(a)', &
'        write(*,*)', &
'      end subroutine printi', &
'      end program demo_findloc', &
'', &
'  Results:', &
'', &
'       >  == 6 (a vector)', &
'       >  > [  2 ]', &
'       >  >shape= 1 ,rank= 1 ,size= 1', &
'       >', &
'       >  == 6 (a vector)', &
'       >  > [  4 ]', &
'       >  >shape= 1 ,rank= 1 ,size= 1', &
'       >', &
'       >  == 6 (a scalar)', &
'       >  > [  2 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  == 6 (a scalar)', &
'       >  > [  4 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  array is  (a matrix)', &
'       >  > [  0, -5,  7,  7 ]', &
'       >  > [  3,  4, -1,  2 ]', &
'       >  > [  1,  5,  6,  7 ]', &
'       >  >shape= 3 4 ,rank= 2 ,size= 12', &
'       >', &
'       >  mask is  (a matrix)', &
'       >  > [ T,T,F,T ]', &
'       >  > [ T,T,F,T ]', &
'       >  > [ T,T,F,T ]', &
'       >  >shape= 3 4 ,rank= 2 ,size= 12', &
'       >', &
'       >  so for == 7 and back=.false.', &
'       >  so for == 7 the address of the element is  (a vector)', &
'       >  > [  1 ]', &
'       >  > [  4 ]', &
'       >  >shape= 2 ,rank= 1 ,size= 2', &
'       >', &
'       >  so for == 7 and back=.true.', &
'       >  so for == 7 the address of the element is  (a vector)', &
'       >  > [  3 ]', &
'       >  > [  4 ]', &
'       >  >shape= 2 ,rank= 1 ,size= 2', &
'       >', &
'       >  This is independent of declared lower bounds for the array', &
'       >   using dim=N', &
'       >  array is  (a matrix)', &
'       >  > [  1,  2, -9 ]', &
'       >  > [  2,  2,  6 ]', &
'       >  >shape= 2 3 ,rank= 2 ,size= 6', &
'       >', &
'       >    (a vector)', &
'       >  > [  2 ]', &
'       >  > [  1 ]', &
'       >  > [  0 ]', &
'       >  >shape= 3 ,rank= 1 ,size= 3', &
'       >', &
'       >    (a vector)', &
'       >  > [  2 ]', &
'       >  > [  1 ]', &
'       >  >shape= 2 ,rank= 1 ,size= 2', &
'       >', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  MAXLOC(3) - Location of the maximum value within an array', &
'', &
'  o  MINLOC(3) - Location of the minimum value within an array', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               findloc(3fortran)', &
'']

shortname="findloc"
call process()

case('106','floor')

textblock=[character(len=256) :: &
'', &
'floor(3fortran)                                               floor(3fortran)', &
'', &
'NAME', &
'  FLOOR(3) - [NUMERIC] Function to return largest integral value not greater', &
'  than argument', &
'', &
'SYNOPSIS', &
'  result = floor(a [,kind])', &
'', &
'          elemental integer(kind=KIND) function floor( a ,kind )', &
'', &
'           real(kind=**),intent(in) :: a', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  A is a real of any kind', &
'', &
'  o  KIND is any valid value for type integer.', &
'', &
'  o  the result is an integer of the specified or default kind', &
'', &
'DESCRIPTION', &
'  FLOOR(3) returns the greatest integer less than or equal to A.', &
'', &
'  In other words, it picks the whole number at or to the left of the value on', &
'  the number line.', &
'', &
'  This means care has to be taken that the magnitude of the real value A does', &
'  not exceed the range of the output value, as the range of values supported', &
'  by real values is typically larger than the range for integers.', &
'', &
'OPTIONS', &
'  o  A : The value to operate on. Valid values are restricted by the size of', &
'     the returned integer kind to the range -HUGE(INT(A,KIND=KIND))-1 to', &
'     HUGE(INT(A),KIND=KIND).', &
'', &
'  o  KIND : A scalar integer constant initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RESULT', &
'  The return value is of type integer(kind) if KIND is present and of default-', &
'  kind integer otherwise.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'  If in range for the kind of the result the result is the whole number at or', &
'  to the left of the input value on the number line.', &
'', &
'  If A is positive the result is the value with the fractional part removed.', &
'', &
'  If A is negative, it is the whole number at or to the left of the input', &
'  value.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_floor', &
'      implicit none', &
'      real :: x = 63.29', &
'      real :: y = -63.59', &
'         print *, x, floor(x)', &
'         print *, y, floor(y)', &
'        ! elemental', &
'        print *,floor([ &', &
'        &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'        &  0.0,   &', &
'        &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'        ! note even a small deviation from the whole number changes the result', &
'        print *,      [2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)]', &
'        print *,floor([2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)])', &
'', &
'        ! A=Nan, Infinity or huge(0_KIND)-1 < A > huge(0_KIND) is undefined', &
'      end program demo_floor', &
'', &
'  Results:', &
'', &
'       >     63.29000            63', &
'       >    -63.59000           -64', &
'       >           -3         -3         -3         -2         -2         -1', &
'       >           -1          0          0          1          1          2', &
'       >            2          2          2', &
'       >     2.000000     2.000000      2.000000', &
'       >            2          1          1', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  CEILING(3), NINT(3), AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 floor(3fortran)', &
'']

shortname="floor"
call process()

case('107','flush')

textblock=[character(len=256) :: &
'', &
'flush(7fortran)                                               flush(7fortran)', &
'', &
'NAME', &
'  flush(7f) - [IO] flush I/O buffers of specified files', &
'', &
'SYNOPSIS', &
'  flush file-unit-number', &
'  flush([UNIT=]file_unit_number,[iostat=i],[iomsg=str],[err=label_number])', &
'', &
'DESCRIPTION', &
'  I/O statements can buffer output before delivering it to the host system in', &
'  order to minimize the overhead of system calls. Use FLUSH(7F) to deliver any', &
'  such pending I/O for the identified file to the host system.', &
'', &
'  This is generally not required accept to ensure critical information is', &
'  displayed or written as reliably as possible or to synchronise data from', &
'  different units going to the same device. Do not arbitrarily flush all I/O', &
'  operations or programs using large amounts of I/O might experience', &
'  significant performance degradation, particularly if the I/O is to a block-', &
'  oriented device.', &
'', &
'  Note execution of a FLUSH(7F) statement performs a wait operation for all', &
'  pending asynchronous data transfer operations for the specified unit.', &
'', &
'  More generally execution of a FLUSH(7F) statement causes data written to an', &
'  external file not only to be available to other processes, causes data', &
'  placed in an external file by means other than Fortran to be available to a', &
'  READ(7F) statement; but these actions are processor dependent.', &
'', &
'  Execution of a FLUSH(7F) statement for a file that is connected but does not', &
'  exist is permitted and has no effect on any file.', &
'', &
'  A FLUSH(7F) statement has no effect on file position.', &
'', &
'OPTIONS', &
'  UNIT : A file-unit-number is required; if the optional characters "UNIT="', &
'  are omitted, the unit-number must be the first item in the FLUSH(7)', &
'  statement.', &
'', &
'RETURNS', &
'  IOSTAT : status variable. It is set to a processor-dependent positive value', &
'  if an error occurs, to zero if the flush operation was successful, or to a', &
'  processor-dependent negative value if the flush operation is not supported', &
'  for the unit specified. IOMSG : character variable holding error description', &
'  when iostat is not zero. ERR : The numeric line label of a target statement', &
'  in the same scope as the FLUSH(7F) statement.', &
'', &
'  NOTE From the Fortran standard:', &
'', &
'       Because the Fortran standard does not specify the mechanism of file', &
'       storage, the exact meaning of the flush operation is not precisely', &
'       defined. It is expected that the flush operation will make all data', &
'       written to a file available to other processes or devices, or make data', &
'       recently added to a file by other processes or devices available to', &
'       the program via a subsequent read operation. This is commonly called', &
'       flushing input/output buffers.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'         program demo_flush', &
'         use, intrinsic :: iso_fortran_env, only : &', &
'         & stderr=>ERROR_UNIT, &', &
'         & stdin=>INPUT_UNIT,  &', &
'         & stdout=>OUTPUT_UNIT', &
'         implicit none', &
'         integer :: iostat', &
'         character(len=255) :: iomsg', &
'            flush (stderr, iostat=iostat, iomsg=iomsg)', &
'            if(iostat.ne.0)then', &
'               write(*,*)''ERROR:''//trim(iomsg)', &
'               error stop 1', &
'            endif', &
'            flush (stdout, err = 999 )', &
'            stop', &
'            999 continue', &
'            stop 10', &
'         end program demo_flush', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 flush(7fortran)', &
'']

shortname="flush"
call process()

case('108','fraction')

textblock=[character(len=256) :: &
'', &
'fraction(3fortran)                                         fraction(3fortran)', &
'', &
'NAME', &
'  FRACTION(3) - [MODEL:COMPONENTS] Fractional part of the model representation', &
'', &
'SYNOPSIS', &
'  result = fraction(x)', &
'', &
'          elemental real(kind=KIND) function fraction(x)', &
'', &
'           real(kind=KIND),intent(in) :: fraction', &
'', &
'CHARACTERISTICS', &
'  o  X is of type real', &
'', &
'  o  The result has the same characteristics as the argument.', &
'', &
'DESCRIPTION', &
'  FRACTION(3) returns the fractional part of the model representation of X.', &
'', &
'OPTIONS', &
'  o  X : The value to interrogate', &
'', &
'RESULT', &
'  The fractional part of the model representation of X is returned; it is', &
'', &
'         x * real(radix(x))**(-exponent(x))', &
'', &
'  If X has the value zero, the result is zero.', &
'', &
'  If X is an IEEE NaN, the result is that NaN.', &
'', &
'  If X is an IEEE infinity, the result is an IEEE NaN.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_fraction', &
'      implicit none', &
'      real :: x', &
'        x = 178.1387e-4', &
'        print *, fraction(x), x * real(radix(x))**(-exponent(x))', &
'        x = 10.0', &
'        print *, fraction(x)', &
'        print *, fraction(x) * 2**4', &
'      end program demo_fraction', &
'', &
'  Results:', &
'', &
'       >   0.570043862     0.570043862', &
'       >   0.625000000', &
'       >    10.0000000', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), HUGE(3), MAXEXPONENT(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              fraction(3fortran)', &
'']

shortname="fraction"
call process()

case('109','gamma')

textblock=[character(len=256) :: &
'', &
'gamma(3fortran)                                               gamma(3fortran)', &
'', &
'NAME', &
'  GAMMA(3) - [MATHEMATICS] Gamma function, which yields factorials for', &
'  positive whole numbers', &
'', &
'SYNOPSIS', &
'  result = gamma(x)', &
'', &
'          elemental real(kind=**) function gamma( x)', &
'', &
'           type(real,kind=**),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is a real value of any available KIND', &
'', &
'  o  returns a real value with the same kind as X.', &
'', &
'DESCRIPTION', &
'  GAMMA(X) computes Gamma of X. For positive whole number values of N the', &
'  Gamma function can be used to calculate factorials, as (N-1)! ==', &
'  GAMMA(REAL(N)). That is', &
'', &
'      n! == gamma(real(n+1))', &
'', &
'  $$ \GAMMA(x) = \int_0**\infty t**{x-1}{\mathrm{e}}**{-T}\,{\mathrm{d}}t $$', &
'', &
'OPTIONS', &
'  o  X : Shall be of type real and neither zero nor a negative integer.', &
'', &
'RESULT', &
'  The return value is of type real of the same kind as x. The result has a', &
'  value equal to a processor-dependent approximation to the gamma function of', &
'  X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_gamma', &
'      use, intrinsic :: iso_fortran_env, only : wp=>real64, int64', &
'      implicit none', &
'      real :: x, xa(4)', &
'      integer :: i, j', &
'', &
'        ! basic usage', &
'        x = gamma(1.0)', &
'        write(*,*)''gamma(1.0)='',x', &
'', &
'        ! elemental', &
'        xa=gamma([1.0,2.0,3.0,4.0])', &
'        write(*,*)xa', &
'        write(*,*)', &
'', &
'        ! gamma() is related to the factorial function', &
'        do i = 1, 171', &
'           ! check value is not too big for default integer type', &
'           if (factorial(i)  <=  huge(0)) then', &
'              write(*,*) i, nint(factorial(i)), ''integer''', &
'           elseif (factorial(i)  <=  huge(0_int64)) then', &
'              write(*,*) i, nint(factorial(i),kind=int64),''integer(kind=int64)''', &
'           else', &
'              write(*,*) i, factorial(i) , ''user factorial function''', &
'              write(*,*) i, product([(real(j, kind=wp), j=1, i)]), ''product''', &
'              write(*,*) i, gamma(real(i + 1, kind=wp)), ''gamma directly''', &
'           endif', &
'        enddo', &
'', &
'      contains', &
'      function factorial(i) result(f)', &
'      !  GAMMA(X) computes Gamma of X. For positive whole number values of N the', &
'      !  Gamma function can be used to calculate factorials, as (N-1)! ==', &
'      !  GAMMA(REAL(N)). That is', &
'      !', &
'      !      n! == gamma(real(n+1))', &
'      !', &
'      integer, intent(in) :: i', &
'      real(kind=wp) :: f', &
'        if (i  <=  0) then', &
'           write(*,''(*(g0))'') ''<ERROR> gamma(3) function value '', i, '' <= 0''', &
'           stop ''<STOP> bad value in gamma function''', &
'        endif', &
'        f = anint(gamma(real(i + 1,kind=wp)))', &
'      end function factorial', &
'', &
'      end program demo_gamma', &
'', &
'  Results:', &
'', &
'       >  gamma(1.0)=  1.00000000', &
'       >    1.00000000      1.00000000       2.00000000       6.00000000', &
'       >', &
'       >           1           1 integer', &
'       >           2           2 integer', &
'       >           3           6 integer', &
'       >           4          24 integer', &
'       >           5         120 integer', &
'       >           6         720 integer', &
'       >           7        5040 integer', &
'       >           8       40320 integer', &
'       >           9      362880 integer', &
'       >          10     3628800 integer', &
'       >          11    39916800 integer', &
'       >          12   479001600 integer', &
'       >          13           6227020800 integer(kind=int64)', &
'       >          14          87178291200 integer(kind=int64)', &
'       >          15        1307674368000 integer(kind=int64)', &
'       >          16       20922789888000 integer(kind=int64)', &
'       >          17      355687428096000 integer(kind=int64)', &
'       >          18     6402373705728001 integer(kind=int64)', &
'       >          19   121645100408832000 integer(kind=int64)', &
'       >          20  2432902008176640000 integer(kind=int64)', &
'       >          21   5.1090942171709440E+019 user factorial function', &
'       >          21   5.1090942171709440E+019 product', &
'       >          21   5.1090942171709440E+019 gamma directly', &
'       >           :', &
'       >           :', &
'       >           :', &
'       >         170   7.2574156153079990E+306 user factorial function', &
'       >         170   7.2574156153079940E+306 product', &
'       >         170   7.2574156153079990E+306 gamma directly', &
'       >         171                  Infinity user factorial function', &
'       >         171                  Infinity product', &
'       >         171                  Infinity gamma directly', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  Logarithm of the Gamma function: LOG_GAMMA(3)', &
'', &
'RESOURCES', &
'  Wikipedia: Gamma_function', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                 gamma(3fortran)', &
'']

shortname="gamma"
call process()

case('110','get_command')

textblock=[character(len=256) :: &
'', &
'get_command(3fortran)                                   get_command(3fortran)', &
'', &
'NAME', &
'  GET_COMMAND(3) - [SYSTEM:COMMAND LINE] Get the entire command line', &
'  invocation', &
'', &
'SYNOPSIS', &
'  call get_command([command] [,length] [,status] [,errmsg])', &
'', &
'          subroutine get_command( command ,length ,status, errmsg )', &
'', &
'           character(len=*),intent(out),optional   :: command', &
'           integer(kind=**),intent(out),optional   :: length', &
'           integer(kind=**),intent(out),optional   :: status', &
'           character(len=*),intent(inout),optional :: errmsg', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type meeting', &
'     the conditions described herein.', &
'', &
'  o  COMMAND and ERRMSG are scalar character variables of default kind.', &
'', &
'  o  LENGTH and STATUS are scalar integer with a decimal exponent range of at', &
'     least four.', &
'', &
'DESCRIPTION', &
'  GET_COMMAND(3) retrieves the entire command line that was used to invoke the', &
'  program.', &
'', &
'  Note that what is typed on the command line is often processed by a shell.', &
'  The shell typically processes special characters and white space before', &
'  passing it to the program. The processing can typically be turned off by', &
'  turning off globbing or quoting the command line arguments and/or changing', &
'  the default field separators, but this should rarely be necessary.', &
'', &
'RESULT', &
'  o  COMMAND : If COMMAND is present, the entire command line that was used to', &
'     invoke the program is stored into it. If the command cannot be', &
'     determined, COMMAND is assigned all blanks.', &
'', &
'  o  LENGTH : If LENGTH is present, it is assigned the length of the command', &
'     line. It is system-dependent as to whether trailing blanks will be', &
'     counted. : If the command length cannot be determined, a length of 0 is', &
'     assigned.', &
'', &
'  o  STATUS : If STATUS is present, it is assigned 0 upon success of the', &
'     command, -1 if COMMAND is too short to store the command line, or a', &
'     positive value in case of an error.', &
'', &
'  o  ERRMSG : It is assigned a processor-dependent explanatory message if the', &
'     command retrieval fails. Otherwise, it is unchanged.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_get_command', &
'      implicit none', &
'      integer                     :: command_line_length', &
'      character(len=:),allocatable :: command_line', &
'        ! get command line length', &
'        call get_command(length=command_line_length)', &
'        ! allocate string big enough to hold command line', &
'        allocate(character(len=command_line_length) :: command_line)', &
'        ! get command line as a string', &
'        call get_command(command=command_line)', &
'        ! trim leading spaces just in case', &
'        command_line=adjustl(command_line)', &
'        write(*,''("OUTPUT:",a)'')command_line', &
'      end program demo_get_command', &
'', &
'  Results:', &
'', &
'          # note that shell expansion removes some of the whitespace', &
'          # without quotes', &
'          ./test_get_command  arguments    on command   line to   echo', &
'', &
'          OUTPUT:./test_get_command arguments on command line to echo', &
'', &
'          # using the bash shell with single quotes', &
'          ./test_get_command  ''arguments  *><`~[]!{}?"\''| ''', &
'', &
'          OUTPUT:./test_get_command arguments  *><`~[]!{}?"''|', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  GET_COMMAND_ARGUMENT(3), COMMAND_ARGUMENT_COUNT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025           get_command(3fortran)', &
'']

shortname="get_command"
call process()

case('111','get_command_argument')

textblock=[character(len=256) :: &
'', &
'get_command_argument(3fortran)                 get_command_argument(3fortran)', &
'', &
'NAME', &
'  GET_COMMAND_ARGUMENT(3) - [SYSTEM:COMMAND LINE] Get command line arguments', &
'', &
'SYNOPSIS', &
'  call get_command_argument(number [,value] [,length] & & [,status] [,errmsg])', &
'', &
'        subroutine get_command_argument( number, value, length, &', &
'        & status ,errmsg)', &
'', &
'         integer(kind=**),intent(in)             :: number', &
'         character(len=*),intent(out),optional   :: value', &
'         integer(kind=**),intent(out),optional   :: length', &
'         integer(kind=**),intent(out),optional   :: status', &
'         character(len=*),intent(inout),optional :: errmsg', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type meeting', &
'     the conditions described herein.', &
'', &
'  o  NUMBER, LENGTH, and STATUS are scalar integer with a decimal exponent', &
'     range of at least four.', &
'', &
'  o  VALUE and ERRMSG are scalar character variables of default kind.', &
'', &
'DESCRIPTION', &
'  GET_COMMAND_ARGUMENT(3) retrieves or queries the n-th argument that was', &
'  passed on the command line to the current program execution.', &
'', &
'  There is not anything specifically stated about what an argument is but in', &
'  practice the arguments are strings split on whitespace unless the arguments', &
'  are quoted. IFS values (Internal Field Separators) used by common shells are', &
'  typically ignored and unquoted whitespace is almost always the separator.', &
'', &
'  Shells have often expanded command arguments and spell characters before', &
'  passing them to the program, so the strings read are often not exactly what', &
'  the user typed on the command line.', &
'', &
'OPTIONS', &
'  o  NUMBER : is a non-negative number indicating which argument of the', &
'     current program command line is to be retrieved or queried. : If NUMBER =', &
'     0, the argument pointed to is set to the name of the program (on systems', &
'     that support this feature). : if the processor does not have such a', &
'     concept as a command name the value of command argument 0 is processor', &
'     dependent. : For values from 1 to the number of arguments passed to the', &
'     program a value is returned in an order determined by the processor.', &
'     Conventionally they are returned consecutively as they appear on the', &
'     command line from left to right.', &
'', &
'RESULT', &
'  o  VALUE : The VALUE argument holds the command line argument. If VALUE can', &
'     not hold the argument, it is truncated to fit the length of VALUE. : If', &
'     there are less than NUMBER arguments specified at the command line or if', &
'     the argument specified does not exist for other reasons, VALUE will be', &
'     filled with blanks.', &
'', &
'  o  LENGTH : The LENGTH argument contains the length of the n-th command line', &
'     argument. The length of VALUE has no effect on this value, It is the', &
'     length required to hold all the significant characters of the argument', &
'     regardless of how much storage is provided by VALUE.', &
'', &
'  o  STATUS : If the argument retrieval fails, STATUS is a positive number; if', &
'     VALUE contains a truncated command line argument, STATUS is -1; and', &
'     otherwise the STATUS is zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_get_command_argument', &
'      implicit none', &
'      character(len=255)          :: progname', &
'      integer                     :: count, i, argument_length, istat', &
'      character(len=:),allocatable :: arg', &
'', &
'       ! command name assuming it is less than 255 characters in length', &
'       call get_command_argument (0, progname, status=istat)', &
'       if (istat == 0) then', &
'          print *, "The program''s name is " // trim (progname)', &
'       else', &
'          print *, "Could not get the program''s name " // trim (progname)', &
'       endif', &
'', &
'       ! get number of arguments', &
'       count = command_argument_count()', &
'       write(*,*)''The number of arguments is '',count', &
'', &
'       !', &
'       ! allocate string array big enough to hold command line', &
'       ! argument strings and related information', &
'       !', &
'       do i=1,count', &
'          call get_command_argument(number=i,length=argument_length)', &
'          if(allocated(arg))deallocate(arg)', &
'          allocate(character(len=argument_length) :: arg)', &
'          call get_command_argument(i, arg,status=istat)', &
'          ! show the results', &
'          write (*,''(i3.3,1x,i0.5,1x,i0.5,1x,"[",a,"]")'') &', &
'          & i,istat,argument_length,arg', &
'       enddo', &
'', &
'      end program demo_get_command_argument', &
'', &
'  Results:', &
'', &
'      ./demo_get_command_argument a  test ''of getting  arguments '' " leading"', &
'', &
'       > The program''s name is ./demo_get_command_argument', &
'       > The number of arguments is           4', &
'       >001 00000 00001 [a]', &
'       >002 00000 00004 [test]', &
'       >003 00000 00022 [of getting  arguments ]', &
'       >004 00000 00008 [ leading]', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  GET_COMMAND(3), COMMAND_ARGUMENT_COUNT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025  get_command_argument(3fortran)', &
'']

shortname="get_command_argument"
call process()

case('112','get_environment_variable')

textblock=[character(len=256) :: &
'', &
'get_environment_variable(3fortran)         get_environment_variable(3fortran)', &
'', &
'NAME', &
'  GET_ENVIRONMENT_VARIABLE(3) - [SYSTEM:ENVIRONMENT] Retrieve the value of an', &
'  environment variable', &
'', &
'SYNOPSIS', &
'  call get_environment_variable(name [,value] [,length] & & [,status]', &
'  [,trim_name] [,errmsg] )', &
'', &
'          subroutine character(len=*) get_environment_variable( &', &
'          & name, value, length, status, trim_name, errmsg )', &
'', &
'           character(len=*),intent(in) :: name', &
'           character(len=*),intent(out),optional   :: value', &
'           integer(kind=**),intent(out),optional   :: length', &
'           integer(kind=**),intent(out),optional   :: status', &
'           logical,intent(out),optional            :: trim_name', &
'           character(len=*),intent(inout),optional :: errmsg', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type meeting', &
'     the conditions described herein.', &
'', &
'  o  NAME, VALUE, and ERRMSG are a scalar character of default kind.', &
'', &
'  o  LENGTH and STATUS are integer scalars with a decimal exponent range of at', &
'     least four.', &
'', &
'  o  TRIM_NAME is a scalar of type logical and of default kind.', &
'', &
'DESCRIPTION', &
'  GET_ENVIRONMENT_VARIABLE(3) retrieves the VALUE of the environment variable', &
'  NAME.', &
'', &
'  Note that GET_ENVIRONMENT_VARIABLE(3) need not be thread-safe. It is the', &
'  responsibility of the user to ensure that the environment is not being', &
'  updated concurrently.', &
'', &
'  When running in parallel be aware it is processor dependent whether an', &
'  environment variable that exists on an image also exists on another image,', &
'  and if it does exist on both images whether the values are the same or', &
'  different.', &
'', &
'OPTIONS', &
'  o  NAME : The name of the environment variable to query. The interpretation', &
'     of case is processor dependent.', &
'', &
'RESULT', &
'  o  VALUE : The value of the environment variable being queried. If VALUE is', &
'     not large enough to hold the data, it is truncated. If the variable NAME', &
'     is not set or has no value, or the processor does not support environment', &
'     variables VALUE will be filled with blanks.', &
'', &
'  o  LENGTH : This argument contains the length needed to store the', &
'     environment variable name. It is zero if the environment variable is not', &
'     set.', &
'', &
'  o  STATUS : Returns', &
'', &
'     o -1 if value is present but too short to fit in the provided variable.', &
'', &
'     o 1 if the environment variable does not exist', &
'', &
'     o 2 if the processor does not support environment variables', &
'', &
'     o and 0 in all other cases.', &
'', &
'  o  TRIM_NAME : If present and set to .false. the trailing blanks in name are', &
'     significant; otherwise, they are not considered part of the environment', &
'     variable name.', &
'', &
'  o  ERRMSG : is assigned a processor-dependent explanatory message if the', &
'     optional argument STATUS is, or would be if present, assigned a positive', &
'     value. Otherwise, it is unchanged.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_getenv', &
'      implicit none', &
'      character(len=:),allocatable :: homedir', &
'      character(len=:),allocatable :: var', &
'', &
'          var=''HOME''', &
'          homedir=get_env(var)', &
'          write (*,''(a,"=""",a,"""")'')var,homedir', &
'', &
'      contains', &
'', &
'      function get_env(name,default) result(value)', &
'      ! a function that makes calling get_environment_variable(3) simple', &
'      use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT', &
'      implicit none', &
'      character(len=*),intent(in)         :: name', &
'      character(len=*),intent(in),optional :: default', &
'      character(len=:),allocatable        :: value', &
'      integer                             :: howbig', &
'      integer                             :: stat', &
'      integer                             :: length', &
'        length=0', &
'        value=''''', &
'        if(name.ne.'''')then', &
'           call get_environment_variable( name, &', &
'           & length=howbig,status=stat,trim_name=.true.)', &
'           select case (stat)', &
'           case (1)', &
'            write(stderr,*) &', &
'            & name, " is not defined in the environment. Strange..."', &
'            value=''''', &
'           case (2)', &
'            write(stderr,*) &', &
'            & "This processor does not support environment variables. Boooh!"', &
'            value=''''', &
'           case default', &
'            ! make string of sufficient size to hold value', &
'            if(allocated(value))deallocate(value)', &
'            allocate(character(len=max(howbig,1)) :: value)', &
'            ! get value', &
'            call get_environment_variable( &', &
'            & name,value,status=stat,trim_name=.true.)', &
'            if(stat.ne.0)value=''''', &
'           end select', &
'        endif', &
'        if(value.eq.''''.and.present(default))value=default', &
'      end function get_env', &
'', &
'      end program demo_getenv', &
'', &
'  Typical Results:', &
'', &
'       >  HOME="/home/urbanjs"', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  GET_COMMAND_ARGUMENT(3), GET_COMMAND(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 20get_environment_variable(3fortran)', &
'']

shortname="get_environment_variable"
call process()

case('113','huge')

textblock=[character(len=256) :: &
'', &
'huge(3fortran)                                                 huge(3fortran)', &
'', &
'NAME', &
'  HUGE(3) - [MODEL:NUMERIC] Largest number of a type and kind', &
'', &
'SYNOPSIS', &
'  result = huge(x)', &
'', &
'          TYPE(kind=KIND) function huge(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x(..)', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real or integer scalar or array and any kind.', &
'', &
'  o  The result will be a scalar of the same type and kind as the input X', &
'', &
'DESCRIPTION', &
'  HUGE(3) returns the largest number that is not an overflow for the kind and', &
'  type of X.', &
'', &
'OPTIONS', &
'  o  X : X is an arbitrary value which is used merely to determine what kind', &
'     and type of scalar is being queried. It need not be defined, as only its', &
'     characteristics are used.', &
'', &
'RESULT', &
'  The result is the largest value supported by the specified type and kind.', &
'', &
'  Note the result is as the same kind as the input to ensure the returned', &
'  value does not overflow. Any assignment of the result to a variable requires', &
'  the variable must be able to hold the value as well. For example:', &
'', &
'          real :: r', &
'          r=huge(0.0d0)', &
'', &
'  where R is single-precision would almost certainly result in overflow.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_huge', &
'      implicit none', &
'      character(len=*),parameter :: f=''(i2,1x,2(i11,1x),f14.0:,1x,l1,1x,a)''', &
'      integer                   :: i, j, k, biggest', &
'      real                      :: v, w', &
'      doubleprecision           :: tally', &
'        ! basic', &
'        print *, huge(0), huge(0.0), huge(0.0d0)', &
'        print *, tiny(0.0), tiny(0.0d0)', &
'', &
'        tally=0.0d0', &
'        ! note subtracting one because counter is the end value+1 on exit', &
'        do i=0,huge(0)-1', &
'           tally=tally+i', &
'        enddo', &
'        write(*,*)''tally='',tally', &
'', &
'        ! advanced', &
'        biggest=huge(0)', &
'        ! be careful of overflow when using integers in computation', &
'        do i=1,14', &
'           j=6**i   ! Danger, Danger', &
'           w=6**i   ! Danger, Danger', &
'           v=6.0**i', &
'           k=v      ! Danger, Danger', &
'', &
'           if(v.gt.biggest)then', &
'              write(*,f) i, j, k, v, v.eq.w, ''wrong j and k and w''', &
'           else', &
'              write(*,f) i, j, k, v, v.eq.w', &
'           endif', &
'        enddo', &
'        ! a simple check of the product of two 32-bit integers', &
'        print *,checkprod([2,4,5,8],[10000,20000,3000000,400000000])', &
'', &
'      contains', &
'      impure elemental function checkprod(i,j) result(ij32)', &
'      ! checkprod(3f) - check for overflow when multiplying 32-bit integers', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      integer(kind=int32),intent(in)  :: i, j', &
'      integer(kind=int64)            :: ij64', &
'      integer(kind=int32)            :: ij32', &
'      integer,parameter              :: toobig=huge(0_int32)', &
'      character(len=80)              :: message', &
'        ij64=int(i,kind=int64)*int(j,kind=int64)', &
'        if(ij64.gt.toobig)then', &
'           write(message,''(*(g0))'')&', &
'           & ''<ERROR>checkprod(3f):'',i,''*'',j,''='',ij64,''>'',toobig', &
'           stop message', &
'        else', &
'           ij32=ij64', &
'        endif', &
'      end function checkprod', &
'      end program demo_huge', &
'', &
'  Results:', &
'', &
'       >   2147483647  3.40282347E+38   1.7976931348623157E+308', &
'       >    1.17549435E-38   2.2250738585072014E-308', &
'       >  tally=   2.3058430049858406E+018', &
'       >  1          6           6             6. T', &
'       >  2         36          36            36. T', &
'       >  3        216         216           216. T', &
'       >  4       1296        1296          1296. T', &
'       >  5       7776        7776          7776. T', &
'       >  6      46656       46656         46656. T', &
'       >  7     279936      279936        279936. T', &
'       >  8    1679616     1679616       1679616. T', &
'       >  9    10077696    10077696     10077696. T', &
'       > 10    60466176    60466176     60466176. T', &
'       > 11   362797056   362797056    362797056. T', &
'       > 12 -2118184960 -2147483648    2176782336. F wrong j and k and w', &
'       > 13   175792128 -2147483648   13060694016. F wrong j and k and w', &
'       > 14  1054752768 -2147483648   78364164096. F wrong j and k and w', &
'       > STOP <ERROR>checkprod(3f):8*400000000=3200000000>2147483647', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  huge(3fortran)', &
'']

shortname="huge"
call process()

case('114','hypot')

textblock=[character(len=256) :: &
'', &
'hypot(3fortran)                                               hypot(3fortran)', &
'', &
'NAME', &
'  HYPOT(3) - [MATHEMATICS] Returns the Euclidean distance - the distance', &
'  between a point and the origin.', &
'', &
'SYNOPSIS', &
'  result = hypot(x, y)', &
'', &
'          elemental real(kind=KIND) function hypot(x,y)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'           real(kind=KIND),intent(in) :: y', &
'', &
'CHARACTERISTICS', &
'  o  X,Y and the result shall all be real and of the same KIND.', &
'', &
'DESCRIPTION', &
'  In mathematics, the Euclidean distance between two points in Euclidean space', &
'  is the length of a line segment between two points.', &
'', &
'  HYPOT(X,Y) returns the special case of the Euclidean distance between the', &
'  point <X,Y> and the origin. It is equal to', &
'', &
'      sqrt(x**2+y**2)', &
'', &
'  without undue underflow or overflow.', &
'', &
'OPTIONS', &
'  o  X : the x value of the point of interest', &
'', &
'  o  Y : the y value of the point of interest', &
'', &
'RESULT', &
'  The result is the positive magnitude of the distance of the point <X,Y> from', &
'  the origin <0.0,0.0> .', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_hypot', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real32) :: x, y', &
'      real(kind=real32),allocatable :: xs(:), ys(:)', &
'      integer :: i', &
'      character(len=*),parameter :: f=''(a,/,SP,*(3x,g0,1x,g0:,/))''', &
'', &
'        x = 1.e0_real32', &
'        y = 0.5e0_real32', &
'', &
'        write(*,*)', &
'        write(*,''(*(g0))'')''point <'',x,'','',y,''> is '',hypot(x,y)', &
'        write(*,''(*(g0))'')''units away from the origin''', &
'        write(*,*)', &
'', &
'        ! elemental', &
'        xs=[  x,  x**2,  x*10.0,  x*15.0, -x**2  ]', &
'        ys=[  y,  y**2, -y*20.0,  y**2,   -y**2  ]', &
'', &
'        write(*,f)"the points",(xs(i),ys(i),i=1,size(xs))', &
'        write(*,f)"have distances from the origin of ",hypot(xs,ys)', &
'        write(*,f)"the closest is",minval(hypot(xs,ys))', &
'', &
'      end program demo_hypot', &
'', &
'  Results:', &
'', &
'       >', &
'       > point <1.00000000,0.500000000> is 1.11803401', &
'       > units away from the origin', &
'       >', &
'       > the points', &
'       >    +1.00000000 +0.500000000', &
'       >    +1.00000000 +0.250000000', &
'       >    +10.0000000 -10.0000000', &
'       >    +15.0000000 +0.250000000', &
'       >    -1.00000000 -0.250000000', &
'       > have distances from the origin of', &
'       >    +1.11803401 +1.03077638', &
'       >    +14.1421356 +15.0020828', &
'       >    +1.03077638', &
'       > the closest is', &
'       >    +1.03077638', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  o  exp(3) - Base-e exponential function', &
'', &
'  o  gamma(3) - Gamma function, which yields factorials for positive whole', &
'     numbers', &
'', &
'  o  log(3) - Natural logarithm', &
'', &
'  o  log10(3) - Base 10 or common logarithm', &
'', &
'  o  log_gamma(3) - Logarithm of the absolute value of the Gamma function', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 hypot(3fortran)', &
'']

shortname="hypot"
call process()

case('115','iachar')

textblock=[character(len=256) :: &
'', &
'iachar(3fortran)                                             iachar(3fortran)', &
'', &
'NAME', &
'  IACHAR(3) - [CHARACTER:CONVERSION] Return integer ASCII code of a character', &
'', &
'SYNOPSIS', &
'  result = iachar(c [,kind])', &
'', &
'          elemental integer(kind=KIND) function iachar(c,kind)', &
'', &
'           character(len=1),intent(in) :: c', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  C is a single character', &
'', &
'  o  The return value is of type integer and of kind KIND. If KIND is absent,', &
'     the return value is of default integer kind.', &
'', &
'  NOTE: : a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  IACHAR(3) returns the code for the ASCII character in the first character', &
'  position of C.', &
'', &
'OPTIONS', &
'  o  C : A character to determine the ASCII code of. A common extension is to', &
'     allow strings but all but the first character is then ignored.', &
'', &
'  o  KIND : A constant initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  the result is the position of the character C in the ASCII collating', &
'  sequence. It is nonnegative and less than or equal to 127.', &
'', &
'  By ASCII, it is meant that C is in the collating sequence defined by the', &
'  codes specified in ISO/IEC 646:1991 (International Reference Version).', &
'', &
'  The value of the result is processor dependent if C is not in the ASCII', &
'  collating sequence.', &
'', &
'  The results are consistent with the LGE(3), LGT(3), LLE(3), and LLT(3)', &
'  comparison functions. For example, if LLE(C, D) is true, IACHAR(C) <= IACHAR', &
'  (D) is true where C and D are any two characters representable by the', &
'  processor.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iachar', &
'      implicit none', &
'        ! basic usage', &
'         ! just does a string one character long', &
'         write(*,*)iachar(''A'')', &
'         ! elemental: can do an array of letters', &
'         write(*,*)iachar([''A'',''Z'',''a'',''z''])', &
'', &
'        ! convert all characters to lowercase', &
'         write(*,''(a)'')lower(''abcdefg ABCDEFG'')', &
'      contains', &
'      !', &
'      pure elemental function lower(str) result (string)', &
'      ! Changes a string to lowercase', &
'      character(*), intent(In)    :: str', &
'      character(len(str))         :: string', &
'      integer                     :: i', &
'        string = str', &
'        ! step thru each letter in the string in specified range', &
'        do i = 1, len(str)', &
'           select case (str(i:i))', &
'           case (''A'':''Z'') ! change letter to miniscule', &
'              string(i:i) = char(iachar(str(i:i))+32)', &
'           case default', &
'           end select', &
'        end do', &
'      end function lower', &
'      !', &
'      end program demo_iachar', &
'', &
'  Results:', &
'', &
'       > 65', &
'       > 65         90          97         122', &
'       > abcdefg abcdefg', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  ACHAR(3), CHAR(3), ICHAR(3)', &
'', &
'  See ICHAR(3) in particular for a discussion of converting between numerical', &
'  values and formatted string representations.', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                iachar(3fortran)', &
'']

shortname="iachar"
call process()

case('116','iall')

textblock=[character(len=256) :: &
'', &
'iall(3fortran)                                                 iall(3fortran)', &
'', &
'NAME', &
'  IALL(3) - [BIT:LOGICAL] Bitwise and of array elements', &
'', &
'SYNOPSIS', &
'  result = iall(array [,mask]) | iall(array ,dim [,mask])', &
'', &
'          integer(kind=KIND) function iall(array,dim,mask)', &
'', &
'           integer(kind=KIND),intent(in)        :: array(*)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(*)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  ARRAY must be an integer array', &
'', &
'  o  MASK is a logical array that conforms to ARRAY of any logical kind.', &
'', &
'  o  DIM may be of any integer kind.', &
'', &
'  o  The result will by of the same type and kind as ARRAY.', &
'', &
'DESCRIPTION', &
'  IALL(3) reduces with a bitwise and the elements of ARRAY along dimension DIM', &
'  if the corresponding element in MASK is .true..', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array of type integer', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : (Optional) shall be of type logical and either be a scalar or an', &
'     array of the same shape as ARRAY.', &
'', &
'RESULT', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise all of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iall', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'       & int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int8) :: a(2)', &
'', &
'        a(1) = int(b''00100100'')', &
'        a(2) = int(b''01101010'')', &
'', &
'        print ''(b8.8)'', iall(a)', &
'', &
'      end program demo_iall', &
'', &
'  Results:', &
'', &
'       > 00100000', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  IANY(3), IPARITY(3), IAND(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  iall(3fortran)', &
'']

shortname="iall"
call process()

case('117','iand')

textblock=[character(len=256) :: &
'', &
'iand(3fortran)                                                 iand(3fortran)', &
'', &
'NAME', &
'  IAND(3) - [BIT:LOGICAL] Bitwise logical AND', &
'', &
'SYNOPSIS', &
'  result = iand(i, j)', &
'', &
'          elemental integer(kind=KIND) function iand(i,j)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=KIND),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I, J and the result shall have the same integer type and kind, with the', &
'     exception that one of I or J may be a BOZ constant.', &
'', &
'DESCRIPTION', &
'  IAND(3) returns the bitwise logical AND of two values.', &
'', &
'OPTIONS', &
'  o  I : one of the pair of values to compare the bits of', &
'', &
'  o  J : one of the pair of values to compare the bits of', &
'', &
'  If either I or J is a BOZ-literal-constant, it is first converted as if by', &
'  the intrinsic function INT(3) to type integer with the kind type parameter', &
'  of the other.', &
'', &
'RESULT', &
'  The result has the value obtained by combining I and I bit-by-bit according', &
'  to the following table:', &
'', &
'         I  |  J  |  IAND (I, J)', &
'  ----------------------------', &
'', &
'    1 |  1  |   1', &
'', &
'    1 |  0  |   0', &
'', &
'    0 |  1  |   0', &
'', &
'    0 |  0  |   0', &
'', &
'  So if both the bit in I and J are on the resulting bit is on (a one); else', &
'  the resulting bit is off (a zero).', &
'', &
'  This is commonly called the "bitwise logical AND" of the two values.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iand', &
'      implicit none', &
'      integer :: a, b', &
'       data a / z''f'' /, b / z''3'' /', &
'       write (*,*) ''a='',a,'' b='',b,''iand(a,b)='',iand(a, b)', &
'       write (*,''(b32.32)'') a,b,iand(a,b)', &
'      end program demo_iand', &
'', &
'  Results:', &
'', &
'       >  a= 15  b= 3 iand(a,b)= 3', &
'       > 00000000000000000000000000001111', &
'       > 00000000000000000000000000000011', &
'       > 00000000000000000000000000000011', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  BTEST(3), IBCLR(3), IBITS(3), IBSET(3), IEOR(3), IOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  iand(3fortran)', &
'']

shortname="iand"
call process()

case('118','iany')

textblock=[character(len=256) :: &
'', &
'iany(3fortran)                                                 iany(3fortran)', &
'', &
'NAME', &
'  IANY(3) - [BIT:LOGICAL] Bitwise OR of array elements', &
'', &
'SYNOPSIS', &
'  result = iany(array [,mask]) | iany(array ,dim [,mask])', &
'', &
'          integer(kind=KIND) function iany(array,dim,mask)', &
'', &
'           integer(kind=KIND),intent(in)        :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY is an integer array', &
'', &
'  o  DIM may be of any integer kind.', &
'', &
'  o  MASK is a logical array that conforms to ARRAY', &
'', &
'  o  The result will by of the same type and kind as ARRAY. It is scalar if', &
'     DIM does not appear or is 1. Otherwise, it is the shape and rank of array', &
'     reduced by the dimension DIM.', &
'', &
'  note a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  IANY(3) reduces with bitwise OR (inclusive OR) the elements of ARRAY along', &
'  dimension DIM if the corresponding element in MASK is .true..', &
'', &
'OPTIONS', &
'  o  ARRAY : an array of elements to selectively OR based on the mask.', &
'', &
'  o  DIM : a value in the range from 1 TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : a logical scalar; or an array of the same shape as ARRAY.', &
'', &
'RESULT', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise or of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iany', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'       & int8, int16, int32, int64', &
'      implicit none', &
'      logical,parameter :: T=.true., F=.false.', &
'      integer(kind=int8) :: a(3)', &
'        a(1) = int(b''00100100'',int8)', &
'        a(2) = int(b''01101010'',int8)', &
'        a(3) = int(b''10101010'',int8)', &
'        write(*,*)''A=''', &
'        print ''(1x,b8.8)'', a', &
'        print *', &
'        write(*,*)''IANY(A)=''', &
'        print ''(1x,b8.8)'', iany(a)', &
'        print *', &
'        write(*,*)''IANY(A) with a mask''', &
'        print ''(1x,b8.8)'', iany(a,mask=[T,F,T])', &
'        print *', &
'        write(*,*)''should match ''', &
'        print ''(1x,b8.8)'', iany([a(1),a(3)])', &
'        print *', &
'        write(*,*)''does it?''', &
'        write(*,*)iany(a,[T,F,T]) == iany([a(1),a(3)])', &
'      end program demo_iany', &
'', &
'  Results:', &
'', &
'       > A=', &
'       > 00100100', &
'       > 01101010', &
'       > 10101010', &
'       >', &
'       > IANY(A)=', &
'       > 11101110', &
'       >', &
'       > IANY(A) with a mask', &
'       > 10101110', &
'       >', &
'       > should match', &
'       > 10101110', &
'       >', &
'       > does it?', &
'       > T', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  IPARITY(3), IALL(3), IOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  iany(3fortran)', &
'']

shortname="iany"
call process()

case('119','ibclr')

textblock=[character(len=256) :: &
'', &
'ibclr(3fortran)                                               ibclr(3fortran)', &
'', &
'NAME', &
'  IBCLR(3) - [BIT:SET] Clear a bit', &
'', &
'SYNOPSIS', &
'  result = ibclr(i, pos)', &
'', &
'          elemental integer(kind=KIND) function ibclr(i,pos)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: pos', &
'', &
'CHARACTERISTICS', &
'  o  I shall be type integer.', &
'', &
'  o  POS shall be type integer.', &
'', &
'  o  The return value is of the same kind as I.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  IBCLR(3) returns the value of I with the bit at position POS set to zero.', &
'', &
'OPTIONS', &
'  o  I : The initial value to be modified', &
'', &
'  o  POS : The position of the bit to change in the input value. A value of', &
'     zero refers to the right-most bit. The value of POS must be nonnegative', &
'     and less than (BIT_SIZE(I)).', &
'', &
'RESULT', &
'  The returned value has the same bit sequence as I except the designated bit', &
'  is unconditionally set to 0', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ibclr', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: i', &
'       ! basic usage', &
'        print *,ibclr (16, 1), '' ==> ibclr(16,1) has the value 15''', &
'', &
'        ! it is easier to see using binary representation', &
'        i=int(b''0000000000111111'',kind=int16)', &
'        write(*,''(b16.16,1x,i0)'') ibclr(i,3), ibclr(i,3)', &
'', &
'       ! elemental', &
'        print *,''an array of initial values may be given as well''', &
'        print *,ibclr(i=[7,4096,9], pos=2)', &
'        print *', &
'        print *,''a list of positions results in multiple returned values''', &
'        print *,''not multiple bits set in one value, as the routine is  ''', &
'        print *,''a scalar function; calling it elementally essentially  ''', &
'        print *,''calls it multiple times.                              ''', &
'        write(*,''(b16.16)'') ibclr(i=-1_int16, pos=[1,2,3,4])', &
'', &
'        ! both may be arrays if of the same size', &
'', &
'      end program demo_ibclr', &
'', &
'  Results:', &
'', &
'       >          16  ==> ibclr(16,1) has the value 15', &
'       > 0000000000110111 55', &
'       >  an array of initial values may be given as well', &
'       >           3        4096           9', &
'       >', &
'       >  a list of positions results in multiple returned values', &
'       >  not multiple bits set in one value, as the routine is', &
'       >  a scalar function; calling it elementally essentially', &
'       >  calls it multiple times.', &
'       > 1111111111111101', &
'       > 1111111111111011', &
'       > 1111111111110111', &
'       > 1111111111101111', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  BTEST(3), IAND(3), IBITS(3), IBSET(3), IEOR(3), IOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 ibclr(3fortran)', &
'']

shortname="ibclr"
call process()

case('120','ibits')

textblock=[character(len=256) :: &
'', &
'ibits(3fortran)                                               ibits(3fortran)', &
'', &
'NAME', &
'  IBITS(3) - [BIT:COPY] Extraction of a subset of bits', &
'', &
'SYNOPSIS', &
'  result = ibits(i, pos, len)', &
'', &
'          elemental integer(kind=KIND) function ibits(i,pos,len)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: pos', &
'           integer(kind=**),intent(in) :: len', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported integer kind', &
'', &
'  o  I may be any supported integer kind as well', &
'', &
'  o  the return value will be the same kind as I', &
'', &
'DESCRIPTION', &
'  IBITS(3) extracts a field of bits from I, starting from bit position POS and', &
'  extending left for a total of LEN bits.', &
'', &
'  The result is then right-justified and the remaining left-most bits in the', &
'  result are zeroed.', &
'', &
'  The position POS is calculated assuming the right-most bit is zero and the', &
'  positions increment to the left.', &
'', &
'OPTIONS', &
'  o  I : The value to extract bits from', &
'', &
'  o  POS : The position of the bit to start copying at. POS is non-negative.', &
'', &
'  o  LEN : the number of bits to copy from I. It must be non-negative.', &
'', &
'  POS + LEN shall be less than or equal to BIT_SIZE(I).', &
'', &
'RESULT', &
'  The return value is composed of the selected bits right-justified, left-', &
'  padded with zeros.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ibits', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: i,j', &
'       ! basic usage', &
'        print *,ibits (14, 1, 3) ! should be seven', &
'        print *,ibits(-1,10,3)   ! and so is this', &
'        ! it is easier to see using binary representation', &
'        i=int(b''0101010101011101'',kind=int16)', &
'        write(*,''(b16.16,1x,i0)'') ibits(i,3,3), ibits(i,3,3)', &
'', &
'       ! we can illustrate this as', &
'        !        #-- position 15', &
'        !        |              #-- position 0', &
'        !        |   <-- +len   |', &
'        !        V              V', &
'        !        5432109876543210', &
'        i =int(b''1111111111111111'',kind=int16)', &
'        !          ^^^^', &
'        j=ibits(i,10,4) ! start at 10th from left and proceed', &
'                        ! left for a total of 4 characters', &
'        write(*,''(a,b16.16)'')''j='',j', &
'       ! lets do something less ambiguous', &
'        i =int(b''0010011000000000'',kind=int16)', &
'        j=ibits(i,9,5)', &
'        write(*,''(a,b16.16)'')''j='',j', &
'      end program demo_ibits', &
'', &
'  Results:', &
'', &
'       > 7', &
'       > 7', &
'       > 0000000000000011 3', &
'       > j=0000000000001111', &
'       > j=0000000000010011', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  BTEST(3), IAND(3), IBCLR(3), IBSET(3), IEOR(3), IOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 ibits(3fortran)', &
'']

shortname="ibits"
call process()

case('121','ibset')

textblock=[character(len=256) :: &
'', &
'ibset(3fortran)                                               ibset(3fortran)', &
'', &
'NAME', &
'  IBSET(3) - [BIT:SET] Set a bit to one in an integer value', &
'', &
'SYNOPSIS', &
'  result = ibset(i, pos)', &
'', &
'          elemental integer(kind=KIND) function ibset(i,pos)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: pos', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  The return value is of the same kind as I. Otherwise, any integer kinds', &
'     are allowed.', &
'', &
'DESCRIPTION', &
'  IBSET(3) returns the value of I with the bit at position POS set to one.', &
'', &
'OPTIONS', &
'  o  I : The initial value to be modified', &
'', &
'  o  POS : The position of the bit to change in the input value. A value of', &
'     zero refers to the right-most bit. The value of POS must be nonnegative', &
'     and less than (BIT_SIZE(I)).', &
'', &
'RESULT', &
'  The returned value has the same bit sequence as I except the designated bit', &
'  is unconditionally set to 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ibset', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: i', &
'       ! basic usage', &
'        print *,ibset (12, 1), ''ibset(12,1) has the value 14''', &
'', &
'        ! it is easier to see using binary representation', &
'        i=int(b''0000000000000110'',kind=int16)', &
'        write(*,''(b16.16,1x,i0,1x,i0)'') ibset(i,12), ibset(i,12), i', &
'', &
'       ! elemental', &
'        print *,''an array of initial values may be given as well''', &
'        print *,ibset(i=[0,4096], pos=2)', &
'        print *', &
'        print *,''a list of positions results in multiple returned values''', &
'        print *,''not multiple bits set in one value, as the routine is  ''', &
'        print *,''a scalar function; calling it elementally essentially  ''', &
'        print *,''calls it multiple times.                              ''', &
'        write(*,''(b16.16)'') ibset(i=0, pos=[1,2,3,4])', &
'', &
'        ! both may be arrays if of the same size', &
'', &
'      end program demo_ibset', &
'', &
'  Results:', &
'', &
'       >          14 ibset(12,1) has the value 14', &
'       > 0001000000000110 4102 6', &
'       >  an array of initial values may be given as well', &
'       >           4        4100', &
'       >', &
'       >  a list of positions results in multiple returned values', &
'       >  not multiple bits set in one value, as the routine is', &
'       >  a scalar function; calling it elementally essentially', &
'       >  calls it multiple times.', &
'       > 0000000000000010', &
'       > 0000000000000100', &
'       > 0000000000001000', &
'       > 0000000000010000', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  IBCLR(3)', &
'', &
'  BTEST(3), IAND(3), IBITS(3), IEOR(3), IOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 ibset(3fortran)', &
'']

shortname="ibset"
call process()

case('122','ichar')

textblock=[character(len=256) :: &
'', &
'ichar(3fortran)                                               ichar(3fortran)', &
'', &
'NAME', &
'  ICHAR(3) - [CHARACTER:CONVERSION] Character-to-integer code conversion', &
'  function', &
'', &
'SYNOPSIS', &
'  result = ichar(c [,kind])', &
'', &
'          elemental integer(kind=KIND) function ichar(c,KIND)', &
'', &
'           character(len=1,kind=**),intent(in) :: c', &
'           integer,intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  C is a scalar character', &
'', &
'  o  KIND is a constant integer initialization expression indicating the kind', &
'     parameter of the result.', &
'', &
'  o  The return value is of type integer and of kind KIND. If KIND is absent,', &
'     the return value is of default integer kind.', &
'', &
'DESCRIPTION', &
'  ICHAR(3) returns the code for the character in the system''s native character', &
'  set. The correspondence between characters and their codes is not', &
'  necessarily the same across different Fortran implementations. For example,', &
'  a platform using EBCDIC would return different values than an ASCII', &
'  platform.', &
'', &
'  See IACHAR(3) for specifically working with the ASCII character set.', &
'', &
'OPTIONS', &
'  o  C : The input character to determine the decimal code of. The range of', &
'     values capable of representation is processor-dependent.', &
'', &
'  o  KIND : indicates the kind parameter of the result. If KIND is absent, the', &
'     return value is of default integer kind.', &
'', &
'RESULT', &
'  The code in the system default character set for the character being queried', &
'  is returned.', &
'', &
'  The result is the position of C in the processor collating sequence', &
'  associated with the kind type parameter of C.', &
'', &
'  it is nonnegative and less than n, where n is the number of characters in', &
'  the collating sequence.', &
'', &
'  The kind type parameter of the result shall specify an integer kind that is', &
'  capable of representing n.', &
'', &
'  For any characters C and D capable of representation in the processor, C <=', &
'  D is true if and only if ICHAR (C) <= ICHAR (D) is true and C == D is true', &
'  if and only if ICHAR (C) == ICHAR (D) is true.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ichar', &
'      use,intrinsic :: iso_fortran_env, only : b=>int8', &
'      implicit none', &
'      integer,parameter  :: bytes=80', &
'      character         :: string*(bytes),lets((bytes))*1', &
'      integer(kind=b)   :: ilets(bytes)', &
'      equivalence (string,lets)', &
'      equivalence (string,ilets)', &
'        write(*,*)ichar([''a'',''z'',''A'',''Z''])', &
'        string=''Do unto others''', &
'        associate (a=>ichar(lets))', &
'         ilets=merge(a-32,a,a>=97.and.a<=122) ! uppercase', &
'         write(*,*)string', &
'         ilets=merge(a+32,a,a>=65.and.a<=90)  ! lowercase', &
'         write(*,*)string', &
'        end associate', &
'      end program demo_ichar', &
'', &
'  Results:', &
'', &
'         >          97         122          65          90', &
'         > DO UNTO OTHERS', &
'         > do unto others', &
'', &
'STANDARD', &
'  Fortran 95, with KIND argument -Fortran 2003', &
'', &
'SEE ALSO', &
'  ACHAR(3), CHAR(3), IACHAR(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 ichar(3fortran)', &
'']

shortname="ichar"
call process()

case('123','ieor')

textblock=[character(len=256) :: &
'', &
'ieor(3fortran)                                                 ieor(3fortran)', &
'', &
'NAME', &
'  IEOR(3) - [BIT:LOGICAL] Bitwise exclusive OR', &
'', &
'SYNOPSIS', &
'  result = ieor(i, j)', &
'', &
'          elemental integer(kind=**) function ieor(i,j)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I, J and the result must be of the same integer kind.', &
'', &
'  o  An exception is that one of I and J may be a BOZ literal constant', &
'', &
'DESCRIPTION', &
'  IEOR(3) returns a bitwise exclusive-OR of I and J.', &
'', &
'  An exclusive OR or "exclusive disjunction" is a logical operation that is', &
'  true if and only if its arguments differ. In this case a one-bit and a zero-', &
'  bit substitute for true and false.', &
'', &
'  This is often represented with the notation "XOR", for "eXclusive OR".', &
'', &
'  An alternate way to view the process is that the result has the value', &
'  obtained by combining I and J bit-by-bit according to the following table:', &
'', &
'       >  I | J |IEOR (I, J)', &
'       >  --#---#-----------', &
'       >  1 | 1 |  0', &
'       >  1 | 0 |  1', &
'       >  0 | 1 |  1', &
'       >  0 | 0 |  0', &
'', &
'OPTIONS', &
'  o  I : the first of the two values to XOR', &
'', &
'  o  J : the second of the two values to XOR', &
'', &
'  If either I or J is a boz-literal-constant, it is first converted as if by', &
'  the intrinsic function INT to type integer with the kind type parameter of', &
'  the other.', &
'', &
'RESULT', &
'  If a bit is different at the same location in I and J the corresponding bit', &
'  in the result is 1, otherwise it is 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ieor', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: i,j', &
'       ! basic usage', &
'        print *,ieor (16, 1), '' ==> ieor(16,1) has the value 17''', &
'', &
'        ! it is easier to see using binary representation', &
'        i=int(b''0000000000111111'',kind=int16)', &
'        j=int(b''0000001111110000'',kind=int16)', &
'        write(*,''(a,b16.16,1x,i0)'')''i=     '',i, i', &
'        write(*,''(a,b16.16,1x,i0)'')''j=     '',j, j', &
'        write(*,''(a,b16.16,1x,i0)'')''result='',ieor(i,j), ieor(i,j)', &
'', &
'       ! elemental', &
'        print *,''arguments may be arrays. If both are arrays they ''', &
'        print *,''must have the same shape.                       ''', &
'        print *,ieor(i=[7,4096,9], j=2)', &
'', &
'        ! both may be arrays if of the same size', &
'', &
'      end program demo_ieor', &
'', &
'  Results:', &
'', &
'       >          17  ==> ieor(16,1) has the value 17', &
'       > i=    0000000000111111 63', &
'       > j=    0000001111110000 1008', &
'       > result=0000001111001111 975', &
'       >  arguments may be arrays. If both are arrays they', &
'       >  must have the same shape.', &
'       >           5        4098          11', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  BTEST(3), IAND(3), IBCLR(3), IBITS(3), IBSET(3), IEOR(3), IOR(3), MVBITS(3),', &
'  NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  ieor(3fortran)', &
'']

shortname="ieor"
call process()

case('124','if')

textblock=[character(len=256) :: &
'', &
'if(7fortran)                                                     if(7fortran)', &
'', &
'NAME', &
'  if(7f) - [EXECUTION CONTROL] selects a block based on a sequence of logical', &
'  expressions.', &
'', &
'SYNOPSIS', &
'  Syntax:', &
'', &
'          [if_construct_name:] IF (scalar-logical-expr) THEN', &
'             block', &
'          ELSEIF (scalar-logical-expr) THEN [if_construct_name]', &
'             block', &
'          ELSE [if_construct_name]', &
'             block', &
'          ENDIF [if_construct_name]', &
'', &
'  or', &
'', &
'          IF (scalar-logical-expression) action-statement', &
'', &
'DESCRIPTION', &
'  The IF construct selects for execution at most one of its constituent', &
'  blocks. The selection is based on a sequence of logical expressions.', &
'', &
'  If an if-construct-name is specified, both the IF and ENDIF must use that', &
'  same name. If an ELSE or ELSEIF uses an if-construct-name it must be the', &
'  same as the one specified on the corresponding IF/ENDIF.', &
'', &
'EXECUTION OF AN IF CONSTRUCT', &
'  If there is an ELSE statement in the construct it acts as a default if all', &
'  the preceding conditionals on the IF or ELSEIF where false, ensuring exactly', &
'  one of the blocks in the construct is executed. The scalar logical', &
'  expressions are evaluated in the order of their appearance in the construct', &
'  until a true value is found or an ELSE statement or ENDIF statement is', &
'  encountered. IF an ELSE statement is found, the block immediately following', &
'  is executed and this completes the execution of the construct. That is, an', &
'  ELSE should follow any ELSEIF statements. The scalar logical expressions in', &
'  any remaining ELSEIF statements of the IF construct are not evaluated. If', &
'  none of the evaluated expressions is true and there is no ELSE statement,', &
'  the execution of the construct is completed without the execution of any', &
'  block within the construct.', &
'', &
'  It is permissible to branch to an ENDIF statement only from within its IF', &
'  construct. Execution of an ENDIF statement has no effect.', &
'', &
'STANDALONE IF', &
'  The IF statement controls the execution of a single action statement based', &
'  on a single logical expression.', &
'', &
'  The action-stmt in the if-stmt shall not be an end-function-stmt, end-mp-', &
'  subprogram-stmt, end-program-stmt, end-subroutine-stmt, or if-stmt.', &
'', &
'  Execution of an IF statement causes evaluation of the scalar logical', &
'  expression. If the value of the expression is true, the action statement is', &
'  executed. If the value is false, the action statement is not executed and', &
'  execution continues.', &
'', &
'  The execution of a function reference in the scalar logical expression may', &
'  affect entities in the action statement. That is, if values are changed by', &
'  the functions used in the logical expressions the selected block will use', &
'  those values. It is generally a bad idea to use functions changing the', &
'  values, but what would you expect this to produce?', &
'', &
'  Calling a function with side-effects on I;', &
'', &
'             program change', &
'             i=1', &
'             if(increment(i).gt.10)then', &
'                write(*,*)''IF'',i', &
'             elseif(increment(i).ge.20)then', &
'                write(*,*)''ELSEIF'',i', &
'             else', &
'                write(*,*)''ELSE'',i', &
'             endif', &
'             contains', &
'             function increment(i)', &
'                write(*,*)''INC'',i', &
'                increment=i*5', &
'                i=i+3', &
'                write(*,*)''INC'',i', &
'             end function increment', &
'             end program change', &
'', &
'  Result:', &
'', &
'          > INC           1', &
'          > INC           4', &
'          > INC           4', &
'          > INC           7', &
'          > ELSEIF           7', &
'', &
'  An example of an IF statement is:', &
'', &
'            IF (A > 0.0) A = LOG (A)', &
'', &
'EXAMPLES', &
'  Sample IF constructs:', &
'', &
'         program demo_if', &
'         implicit none', &
'         character(len=:),allocatable :: cvar', &
'         logical :: PROP=.false.', &
'         real :: a, b, c, d', &
'         integer :: case=0', &
'         integer :: i, j, k', &
'         logical :: nextprop=.true.', &
'          !', &
'          ! basic IF', &
'          !', &
'          cvar=''NO''', &
'          if (cvar == ''RESET'') then', &
'             i = 0; j = 0; k = 0', &
'          endif', &
'          !', &
'          ! labeled and nested IF constructs', &
'          !', &
'          OUTER: if (case.eq.0)then', &
'             PROOF_DONE: if (PROP) then', &
'                write (3, ''(''''QED'''')'')', &
'                exit OUTER', &
'             else', &
'                PROP = nextprop', &
'             endif PROOF_DONE', &
'             write(*,*)''END OF PROOF_DONE''', &
'          else OUTER', &
'                  write(*,*)''else outer''', &
'          endif OUTER', &
'          !', &
'          ! if-elseif-endif', &
'          !', &
'          if (a > 0) then', &
'             b = c/a', &
'             if (b > 0) then', &
'                d = 1.0', &
'             endif', &
'          elseif (c > 0) then', &
'             b = a/c', &
'             d = -1.0', &
'          else', &
'             b = abs (max (a, c))', &
'             d = 0', &
'          endif', &
'          !', &
'         end program demo_if', &
'', &
'SEE ALSO', &
'  o  DO(3) - construct', &
'', &
'  o  IF(3) - selects a block based on a sequence of logical expressions.', &
'', &
'  o  CYCLE(3) - construct', &
'', &
'  o  EXIT(3) - statement', &
'', &
'  o  ASSOCIATE(3) - associate construct', &
'', &
'  o  BLOCK(3) - construct', &
'', &
'  o  GOTO(3) - jump to target line', &
'', &
'  o  SELECT(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  CASE(3) - select a block based on the value of an expression (a case)', &
'', &
'  o  ENDSELECT(3) - select a block based on the value of an expression (a', &
'     case)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                    if(7fortran)', &
'']

shortname="if"
call process()

case('125','image_index')

textblock=[character(len=256) :: &
'', &
'image_index(3fortran)                                   image_index(3fortran)', &
'', &
'NAME', &
'  IMAGE_INDEX(3) - [COLLECTIVE] Cosubscript to image index conversion', &
'', &
'SYNOPSIS', &
'  result = image_index(coarray, sub)', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  IMAGE_INDEX(3) returns the image index belonging to a cosubscript.', &
'', &
'OPTIONS', &
'  o  COARRAY : Coarray of any type.', &
'', &
'  o  SUB : default integer rank-1 array of a size equal to the corank of', &
'     COARRAY.', &
'', &
'RESULT', &
'  Scalar default integer with the value of the image index which corresponds', &
'  to the cosubscripts. For invalid cosubscripts the result is zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo image_index', &
'      implicit none', &
'      integer :: array[2,-1:4,8,*]', &
'        ! Writes  28 (or 0 if there are fewer than 28 images)', &
'        write (*,*) image_index(array, [2,0,3,1])', &
'      end demo image_index', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  THIS_IMAGE(3), NUM_IMAGES(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025           image_index(3fortran)', &
'']

shortname="image_index"
call process()

case('126','implicit')

textblock=[character(len=256) :: &
'', &
'implicit(7fortran)                                         implicit(7fortran)', &
'', &
'NAME', &
'  IMPLICIT(7f) - [STATEMENT] specify default type associated to a starting', &
'  letter or disallow implicit typing', &
'', &
'SYNOPSIS', &
'  implicit [NONE]|[declaration-type-spec (letter-spec-list)]', &
'', &
'DESCRIPTION', &
'  Determine default mapping between the first letter of a data entity and a', &
'  type. The default is the equivalent of the statement', &
'', &
'           implicit real(a-h,o-z),integer(i-n)', &
'', &
'  Compiler switches often allow the default to be the commonly recommended', &
'', &
'           implicit none ! require all variables to have type statements', &
'', &
'  This requires that the procedures be written using "strong typing"; where', &
'  every variable subsequently has to be defined in a type declaration', &
'  statement.', &
'', &
'  If implicit typing is turned off you do not need to know all the scoping', &
'  rules for implicit typing, which by itself is a significant reason for', &
'  turning it off.', &
'', &
'  When a large number of variable names are used with strong typing a', &
'  significant number of lines of code need added to declare the variables; but', &
'  strong typing is still almost universally recommended where terseness is not', &
'  critical (as is sometimes the case in interactive usage or quick', &
'  prototyping).', &
'', &
'  Every data entity has a type (INTEGER, REAL, CHARACTER, ...). If a type is', &
'  not explicitly assigned to a variable or function it will (by default) be', &
'  assigned one according to the following rule -- the type is INTEGER if the', &
'  name starts with the letters from I to N (the first two letters of the word', &
'  "integer"); otherwise it defaults to REAL.', &
'', &
'  The IMPLICIT statement allows the default rule to be changed or set to null.', &
'', &
'  To turn off implicit typing enter one and only one IMPLICIT statement in the', &
'  scoping unit', &
'', &
'       implicit none ! Disable all implicit typing', &
'', &
'  Each data entity will now require having a type declared explicitly', &
'  (INTEGER, REAL, DOUBLE, COMPLEX, ...).', &
'', &
'  The statement must appear after any USE statements and before any type', &
'  declarations, including PARAMETER statements (which must know the rules to', &
'  determine what type names are that have not been explicitly declared).', &
'', &
'  In most new code implicit typing is turned off either with an "IMPLICIT', &
'  NONE" or sometimes by a compiler switch. On the other hand, the majority of', &
'  pre-fortran90 code depends on implicit defaults.', &
'', &
'  Each prefix letter may have the type assigned to it declared only once in a', &
'  unit.', &
'', &
'  As previously stated, the default rule, expressed as an IMPLICIT statement', &
'  is', &
'', &
'           implicit real(a-h,o-z),integer(i-n)', &
'', &
'  To make the default for all names be a DOUBLEPRECISION type one could enter', &
'', &
'           implicit doubleprecision (a-z)', &
'', &
'  NOTE: The standard does not require constants to be affected, so a type', &
'  suffix is required for most constants. That is, even if A is implicitly', &
'  double-precision', &
'', &
'          A=123456789.01234 ! only retains the precision of a default REAL', &
'', &
'            A=123456789.01234D0 ! precision of a double will be retained', &
'', &
'  In another unit one might specify (multiple statements and compound', &
'  statements are allowed, as illustrated):', &
'', &
'           implicit complex (c), doubleprecision (d)', &
'           implicit integer (i)', &
'           implicit logical (l)', &
'           implicit real (r)', &
'           implicit character(len=8) (a,b,e-h,j,k,m-q,s-z)', &
'', &
'  There is no way to make some letters default to no type and others have a', &
'  default. Either nothing has a default type or everything does. You can', &
'  however make a default be a user-defined null type.', &
'', &
'           subroutine sub1()', &
'           ! cannot do a "implicit none" on just some letters.', &
'           ! and a type is required so', &
'           ! implicit (a-h)  ! NOTE: NOT ALLOWED. TYPE IS REQUIRE0', &
'           ! but you can make the default an user-defined type ...', &
'           ! notice the (incidently empty) type is defined below', &
'           ! the implicit statement', &
'           implicit nil(a-h) ! or implicit type(nil) (a)', &
'           !', &
'           type nil', &
'           end type nil', &
'           type(nil) :: anull', &
'           end subroutine sub1', &
'', &
'  The default for an internal or module procedure is the mapping in the host', &
'  scoping unit. That is, a single "IMPLICIT NONE" in the global top section of', &
'  a module makes the default be "IMPLICIT NONE" in any contained procedure.', &
'', &
'  Explicitly setting a variable type always overides the default so any data', &
'  entity that is not explicitly declared by a type declaration statement, is', &
'  not an intrinsic function, and is not accessed by use or host association is', &
'  declared implicitly to be of the type (and type parameters) mapped from the', &
'  first letter of its name, provided the mapping is not null. But anything', &
'  accessed by a USE statement retains the type it had in the scoping unit in', &
'  which it was declared.', &
'', &
'  This means the mapping may be to a derived type that is inaccessible in the', &
'  local scope if the derived type is accessible in the host scoping unit. That', &
'  is, if you import the variable "FRED" of type "GOO" from a module; "FRED" is', &
'  of type "GOO" even if type "GOO" is private in the module defining "FRED".', &
'  That is, variable "FRED" retains the type "GOO" even if you cannot declare', &
'  variables of type "GOO" in the current scoping unit.', &
'', &
'  So the data entity is treated as if it were declared in an explicit type', &
'  declaration in the outermost scoping unit in which it appears. An explicit', &
'  type specification in a FUNCTION statement overrides an IMPLICIT statement', &
'  for the name of the result variable of that function subprogram.', &
'', &
'OPTIONS', &
'  NONE', &
'    Turns off implicit typing. Recommended. It must follow USE statements but', &
'    be before any variable', &
'', &
'    declarations, including PARAMETER statements.', &
'      When used there shall be no other IMPLICIT statements in the scoping', &
'      unit.', &
'', &
'  TYPE() letter-spec', &
'    is (letter-or-range[,letter-or-range] [,letter-or-range] ) If the minus', &
'    and second letter appear, the second letter shall follow the first letter', &
'    alphabetically.  A letter-spec consisting of two letter s separated by a', &
'    minus is equivalent to writing a list containing all of the letters in', &
'    alphabetical order in the alphabetic sequence from the first letter', &
'    through the second letter. For example, A-C is equivalent to A, B, C. The', &
'    same letter shall not appear as a single letter, or be included in a range', &
'    of letters, more than once in all of the IMPLICIT statements in a scoping', &
'    unit.', &
'', &
'EXAMPLE', &
'  The following are examples of the use of IMPLICIT statements:', &
'', &
'             module example_module', &
'                implicit none', &
'                ...', &
'                interface', &
'                   function fun (i)    ! not all data entities need to', &
'                      integer fun      ! be declared explicitly, so I', &
'                   end function fun    ! does not need declared', &
'                end interface', &
'             contains', &
'                function jfun (j)      ! all data entities need to', &
'                   integer jfun, j     ! be declared explicitly.', &
'                   ...', &
'                end function jfun', &
'             end module example_module', &
'', &
'             subroutine sub', &
'                implicit complex (c)', &
'                CM = (3.0, 2.0)      ! CM is implicitly declared COMPLEX', &
'                ...', &
'             contains', &
'                subroutine sub1', &
'                   IMPLICIT INTEGER (A, C)', &
'                   C = (0.0, 0.0) ! C is host associated and of', &
'                                  ! type complex', &
'                   Z = 1.0        ! Z is implicitly declared REAL', &
'                   A = 2          ! A is implicitly declared INTEGER', &
'                   CC = 1         ! CC is implicitly declared INTEGER', &
'                   ...', &
'                end subroutine sub1', &
'                subroutine sub2', &
'                   Z = 2.0         ! Z is implicitly declared REAL and', &
'                                   ! is different from the variable of', &
'                                   ! the same name in SUB1', &
'                   ...', &
'                end subroutine sub2', &
'                subroutine sub3', &
'                   USE EXAMPLE_MODULE ! Accesses integer function FUN', &
'                                       ! by use association', &
'                   Q = FUN (K)         ! Q is implicitly declared REAL and', &
'                   ...                 ! K is implicitly declared INTEGER', &
'                end subroutine sub3', &
'             end subroutine sub', &
'', &
'  The following is an example of a mapping to a derived type that is', &
'  inaccessible in the local scope:', &
'', &
'                   program main', &
'                     implicit type(blob) (a)', &
'                     type blob', &
'                       integer :: i', &
'                     end type blob', &
'                     type(blob) :: b', &
'                     call steve', &
'                   contains', &
'                     subroutine steve', &
'                       integer :: blob', &
'                       !..', &
'                       aa = b', &
'                       !..', &
'                     end subroutine steve', &
'                   end program main', &
'', &
'  In the subroutine STEVE(), it is not possible to explicitly declare a', &
'  variable to be of type BLOB because BLOB has been given a different meaning,', &
'  but implicit mapping for the letter A still maps to type BLOB, so AA is of', &
'  type BLOB.', &
'', &
'        program demo_implicit', &
'        ! everything accessed via USE already has a type and comes', &
'        ! before an implicit statement; but implicit rules are not', &
'        ! inherited from modules', &
'        use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT', &
'        !', &
'        ! the implicit statement must come before other declarations', &
'        ! in new code using this turns on strong typing (that is,every', &
'        ! variable has to have its type declared in a statement). This', &
'        ! is generally highly recommended for new code.', &
'        implicit none', &
'        ! it is still a convention used by many programmers to reserve', &
'        ! starting letters of I to N for integers.', &
'        integer    :: i, j, k', &
'        type(real) :: x,y,z', &
'        intrinsic sin,cos ! intrinsic types are already specified', &
'        integer,external :: zzz ! but external functions need declared', &
'                                ! if they do not have an interface', &
'        call sub1()', &
'        call sub2()', &
'        contains', &
'        subroutine sub1()', &
'        ! the implicit none above became the default for contained', &
'        ! procedures so no reason to repeat it. So only required once', &
'        ! in main procedure or once in top of a module to change the', &
'        ! default of all procedures defined after a CONTAINS statement', &
'        integer :: i=10,j=20', &
'           write(*,*)''I='',i,''J='',j', &
'        end subroutine sub1', &
'        subroutine sub2()', &
'        ! a contained subroutine can override the default created in the', &
'        ! containing scope though', &
'        implicit complex(a-z)', &
'           A=(10,20)', &
'           write(*,*)''A='',a', &
'        end subroutine sub2', &
'        end', &
'        integer function zzz()', &
'            zzz=1234', &
'        end function zzz', &
'        !end program demo_implicit', &
'', &
'  Results:', &
'', &
'       >  I=         10 J=          20', &
'       >  A=            (10.0000000,20.0000000)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              implicit(7fortran)', &
'']

shortname="implicit"
call process()

case('127','include')

textblock=[character(len=256) :: &
'', &
'include(7fortran)                                           include(7fortran)', &
'', &
'NAME', &
'  include(7f) - [PREPROCESS] blending source text', &
'', &
'SYNOPSIS', &
'  INCLUDE char-literal-constant', &
'', &
'DESCRIPTION', &
'  Additional text may be incorporated into the source text of a program unit', &
'  during processing. This is accomplished with the INCLUDE line, which', &
'  typically has the form', &
'', &
'            INCLUDE "filename"', &
'', &
'  An INCLUDE line is not a Fortran statement. It is processed at compilation.', &
'  The effect of the INCLUDE line is as if the referenced source text', &
'  physically replaced the INCLUDE line prior to program processing. Included', &
'  text may contain almost any source text, including additional INCLUDE lines;', &
'  such nested INCLUDE lines are similarly replaced with the specified source', &
'  text. The maximum depth of nesting of any nested INCLUDE lines is processor', &
'  dependent. Inclusion of the source text referenced by an INCLUDE line shall', &
'  not, at any level of nesting, result in inclusion of the same source text', &
'  (ie. it cannot be recursive).', &
'', &
'  The exceptions on what can be included in an INCLUDE file are that the first', &
'  included statement line cannot be a continuation line and the last included', &
'  statement line cannot be continued.', &
'', &
'  The interpretation of char-literal-constant is processor dependent.', &
'', &
'  It is generally implemented as a filename containing text to be included,', &
'  but could be interpreted as a URL or a system command that generates text or', &
'  a database query, or a list of files, for example.  That being said, all', &
'  current implementations appear to at least treat it as a simple filename.', &
'', &
'  Where the compiler searches for the filename is implementation-dependent.', &
'  All current implementations appear to at least search for the file in the', &
'  same directory as the file containing the INCLUDE statement if it is not a', &
'  complete filepath specification. It is common but not required that other', &
'  directories are searched as specified with the common -I switch found on', &
'  most compiler commands.', &
'', &
'  The char-literal-constant shall not have a kind type parameter value that is', &
'  a named-constant. That is, it must be a quoted string. It cannot be', &
'  something like', &
'', &
'             character(len=*),parameter :: filename=''willnotwork.inc''', &
'             include filename', &
'', &
'  An INCLUDE line shall appear on a single source line where a statement may', &
'  appear (many compilers support an extension allowing continuation lines to', &
'  be supported); it must be the only nonblank text on the line other than an', &
'  optional trailing comment (no statement label is allowed).  So here are some', &
'  bad ideas', &
'', &
'             INCLUDE "filename";I=10 ! NO: multiple statements on line', &
'             100 INCLUDE ''filename''  ! NO: statement label not allowed', &
'             ! continuation often works but is non-standard', &
'             INCLUDE &', &
'             & ''filename''', &
'             INCLUDE ''file&', &
'             &name''', &
'', &
'  PREPROCESSING Note that an INCLUDE line is generally processed after any', &
'  preprocessor so the INCLUDE file should not include preprocessor directives', &
'  such as cpp(1) or fpp(1) directives. If that is required you probably need', &
'  to use an equivalent preprocessor directive such as a cpp(1) "#include"', &
'  directive instead of a Fortran INCLUDE.', &
'', &
'  SUMMARY So it is a de-facto standard that an INCLUDE at least supports a', &
'  simple filename pointing to a file in the directory where the file', &
'  containing the INCLUDE file resides or a full path name in single or double', &
'  quotes.', &
'', &
'  An INCLUDE statement was a common way to ensure a COMMONBLOCK was declared', &
'  the same in multiple files (at least if every file with the INCLUDE was', &
'  recompiled). It should generally be avoided and a MODULE should be used', &
'  instead of a COMMONBLOCK in the vast majority of cases in new code.', &
'', &
'  RULES FOR FIXED AND FREE FILE FORMAT PORTABILITY If the code in your', &
'  "include file" needs read by both old fixed-format files and free-format', &
'  files it is not necessary to maintain two copies of the file.', &
'', &
'  Observing the following rules allows included code to be used with either', &
'  free or fixed source forms.', &
'', &
'    o  Confine statement labels to character positions 1 to 5 and statements', &
'       to character positions 7 to 72', &
'', &
'    o  Treat blanks as being significant.', &
'', &
'    o  Use only the exclamation mark (!) to indicate a comment, but do not', &
'       start the comment in character position 6.', &
'', &
'    o  For continued statements, place an ampersand (&) in both character', &
'       position 73 of a continued line and character position 6 of a', &
'       continuation line.', &
'', &
'EXAMPLE', &
'  Sample program:', &
'', &
'  In this example, the same code for the function subr is used to build a', &
'  32-bit and 64-bit version that are then merged into a generic name', &
'', &
'  Given the file "subr.inc":', &
'', &
'        function subr(val)', &
'        ! trivial function. What to note is', &
'        ! all the kinds are specified via "WP"', &
'        real(kind=wp) :: subr', &
'        real(kind=wp),intent(in) :: val', &
'           subr=sqrt(val*3.0_wp)', &
'        end function subr', &
'', &
'  and we will throw in a few other files to do simple includes with as well.', &
'', &
'  declarations.inc', &
'', &
'      integer :: i,j,k', &
'', &
'  somecode.inc', &
'', &
'      write(*,*)''Hello World!''', &
'', &
'  somemorecode.inc', &
'', &
'      subroutine another()', &
'      write(*,*)''Hello World!''', &
'      end subroutine another', &
'', &
'      !program show_include', &
'      ! define wp to be single precision', &
'      ! and include file', &
'      module single', &
'      integer,parameter :: wp=kind(0.0)', &
'      contains', &
'      include "subr.inc"', &
'      end module single', &
'', &
'      module double', &
'      ! define wp to be double precision', &
'      ! and include file', &
'      integer,parameter :: wp=kind(0.0d0)', &
'      contains', &
'      include "subr.inc"', &
'      end module double', &
'', &
'      module merge', &
'      ! so:    module single contains a 32-bit subr() procedure', &
'      ! while: module single contains a 64-bit subr() procedure', &
'      ! make a generic subr() from the two versions', &
'      use single, only : subs=>subr', &
'      use double, only : subd=>subr', &
'      interface subr', &
'        module procedure subs', &
'        module procedure subd', &
'      end interface', &
'', &
'      end module merge', &
'', &
'      program show_include', &
'      use merge, only : subr', &
'      implicit none', &
'      include "declarations.inc"', &
'        write(*,*)''Hello World!''', &
'        write(*,*)subr(10.0)', &
'        write(*,*)subr(20.0d0)', &
'      include "somecode.inc"', &
'      contains', &
'      include "somemorecode.inc"', &
'      end program show_include', &
'', &
'                               March 16, 2025               include(7fortran)', &
'']

shortname="include"
call process()

case('128','index')

textblock=[character(len=256) :: &
'', &
'index(3fortran)                                               index(3fortran)', &
'', &
'NAME', &
'  INDEX(3) - [CHARACTER:SEARCH] Position of a substring within a string', &
'', &
'SYNOPSIS', &
'  result = index( string, substring [,back] [,kind] )', &
'', &
'       elemental integer(kind=KIND) function index(string,substring,back,kind)', &
'', &
'       character(len=*,kind=KIND),intent(in) :: string', &
'       character(len=*,kind=KIND),intent(in) :: substring', &
'       logical(kind=**),intent(in),optional :: back', &
'       integer(kind=**),intent(in),optional :: kind', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a character variable of any kind', &
'', &
'  o  SUBSTRING is a character variable of the same kind as STRING', &
'', &
'  o  BACK is a logical variable of any supported kind', &
'', &
'  o  KIND is a scalar integer constant expression.', &
'', &
'DESCRIPTION', &
'  INDEX(3) returns the position of the start of the leftmost or rightmost', &
'  occurrence of string SUBSTRING in STRING, counting from one. If SUBSTRING is', &
'  not present in STRING, zero is returned.', &
'', &
'OPTIONS', &
'  o  STRING : string to be searched for a match', &
'', &
'  o  SUBSTRING : string to attempt to locate in STRING', &
'', &
'  o  BACK : If the BACK argument is present and true, the return value is the', &
'     start of the rightmost occurrence rather than the leftmost.', &
'', &
'  o  KIND : if KIND is present, the kind type parameter is that specified by', &
'     the value of KIND; otherwise the kind type parameter is that of default', &
'     integer type.', &
'', &
'RESULT', &
'  The result is the starting position of the first substring SUBSTRING found', &
'  in STRING.', &
'', &
'  If the length of SUBSTRING is longer than STRING the result is zero.', &
'', &
'  If the substring is not found the result is zero.', &
'', &
'  If BACK is .true. the greatest starting position is returned (that is, the', &
'  position of the right-most match). Otherwise, the smallest position starting', &
'  a match (ie. the left-most match) is returned.', &
'', &
'  The position returned is measured from the left with the first character of', &
'  STRING being position one.', &
'', &
'  Otherwise, if no match is found zero is returned.', &
'', &
'EXAMPLES', &
'  Example program', &
'', &
'      program demo_index', &
'      implicit none', &
'      character(len=*),parameter :: str=&', &
'        ''Search this string for this expression''', &
'        !1234567890123456789012345678901234567890', &
'        write(*,*)&', &
'           index(str,''this'').eq.8,            &', &
'           ! return value is counted from the left end even if BACK=.TRUE.', &
'           index(str,''this'',back=.true.).eq.24, &', &
'           ! INDEX is case-sensitive', &
'           index(str,''This'').eq.0', &
'      end program demo_index', &
'', &
'  Expected Results:', &
'', &
'       > T T T', &
'', &
'STANDARD', &
'  FORTRAN 77 , with KIND argument Fortran 2003', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                 index(3fortran)', &
'']

shortname="index"
call process()

case('129','inquire')

textblock=[character(len=256) :: &
'', &
'inquire(7fortran)                                           inquire(7fortran)', &
'', &
'NAME', &
'  inquire(7f) - [FILE_INQUIRE] File inquiry statement', &
'', &
'SYNOPSIS', &
'  INQUIRE([UNIT=file_unit_number]|[FILE=file_name_expr],', &
'', &
'         ACCESS = scalar_default_char_variable,', &
'         ACTION = scalar_default_char_variable,', &
'         ASYNCHRONOUS = scalar_default_char_variable,', &
'         DIRECT = scalar_default_char_variable,', &
'', &
'         BLANK = scalar_default_char_variable,', &
'         DECIMAL = scalar_default_char_variable,', &
'         DELIM = scalar_default_char_variable,', &
'         ENCODING = scalar_default_char_variable,', &
'         PAD = scalar_default_char_variable,', &
'         SIGN = scalar_default_char_variable,', &
'', &
'         ERR = label,', &
'         IOMSG = iomsg_variable,', &
'         IOSTAT = scalar_int_variable,', &
'', &
'         EXIST = scalar_logical_variable,', &
'         FORM = scalar_default_char_variable,', &
'         FORMATTED = scalar_default_char_variable,', &
'         ID = scalar_int_expr,', &
'         NAME = scalar_default_char_variable,', &
'         NAMED = scalar_logical_variable,', &
'         NEXTREC = scalar_int_variable,', &
'         NUMBER = scalar_int_variable,', &
'         OPENED = scalar_logical_variable,', &
'         PENDING = scalar_logical_variable,', &
'         POS = scalar_int_variable,', &
'         POSITION = scalar_default_char_variable,', &
'         READ = scalar_default_char_variable,', &
'         READWRITE = scalar_default_char_variable,', &
'         RECL = scalar_int_variable,', &
'         ROUND = scalar_default_char_variable,', &
'         SEQUENTIAL = scalar_default_char_variable,', &
'         SIZE = scalar_int_variable,', &
'         STREAM = scalar_default_char_variable,', &
'         UNFORMATTED = scalar_default_char_variable,', &
'         WRITE = scalar_default_char_variable )', &
'', &
'          or', &
'', &
'         INQUIRE(IOLENGTH=scalar_int_variable) output_item_list', &
'', &
'DESCRIPTION', &
'  The INQUIRE statement may be used to inquire about properties of a', &
'  particular named file or of the connection to a particular unit. There are', &
'  three forms of the INQUIRE statement:', &
'', &
'    o  inquire by file, which uses the FILE= specifier', &
'', &
'    o  inquire by unit, which uses the UNIT= specifier', &
'', &
'    o  inquire by output list, which uses only the IOLENGTH= specifier.', &
'', &
'  All specifier value assignments are performed according to the rules for', &
'  assignment statements.', &
'', &
'  For inquiry by unit, the unit specified need not exist or be connected to a', &
'  file. If it is connected to a file, the inquiry is being made about the', &
'  connection and about the file connected.', &
'', &
'  An INQUIRE statement may be executed before, while, or after a file is', &
'  connected to a unit. All values assigned by an INQUIRE statement are those', &
'  that are current at the time the statement is executed.', &
'', &
'ERROR PROCESSING', &
'  If an error condition occurs during execution of an INQUIRE statement, all', &
'  of the inquiry specifier variables become undefined, except for variables in', &
'  the IOSTAT= and IOMSG= specifiers (if any).', &
'', &
'  The IOSTAT=, ERR=, and IOMSG= specifiers are described in 9.11.', &
'', &
'OPTIONS', &
'  Unless constrained, the following inquiry specifiers may be used in either', &
'  of the inquire by file or inquire by unit forms of the INQUIRE statement.', &
'', &
'  o  No specifier shall appear more than once in a given inquire_spec_list.', &
'', &
'  o  An inquire_spec_list shall contain one FILE= specifier or one UNIT=', &
'     specifier, but not both.', &
'', &
'  o  In the inquire by unit form of the INQUIRE statement, if the optional', &
'     characters UNIT= are omitted, the file_unit-number shall be the first', &
'     item in the inquire_spec_list.', &
'', &
'  o  If an ID= specifier appears in an inquire_spec_list, a PENDING= specifier', &
'     shall also appear.', &
'', &
'  o  The label in the ERR= specifier shall be the statement label of a branch', &
'     target statement that appears in the same scoping unit as the INQUIRE', &
'     statement.', &
'', &
'  If file_unit-number identifies an internal unit, an error condition occurs.', &
'', &
'  When a returned value of a specifier other than the NAME= specifier is of', &
'  type character, the value returned is in upper case.', &
'', &
'  The specifier that receives the returned value is a a default scalar', &
'  variable.', &
'', &
'INPUTS', &
'FILE', &
'  The value of the file_name_expr in the FILE= specifier specifies the name of', &
'  the file being inquired about. The named file need not exist or be connected', &
'  to a unit. The value of the file_name_expr shall be of a form acceptable to', &
'  the processor as a file name. Any trailing blanks are ignored. The', &
'  interpretation of case is processor dependent.', &
'', &
'UNIT', &
'OUTPUTS', &
'ACCESS', &
'  SEQUENTIAL if the connection is for sequential access', &
'', &
'  DIRECT', &
'    if the connection is for direct access', &
'', &
'  STREAM', &
'    if the connection is for stream access.', &
'', &
'  UNDEFINED', &
'    If there is no connection,', &
'', &
'ACTION', &
'  READ', &
'    the connection is for input only,', &
'', &
'  WRITE', &
'    the connection is for output only', &
'', &
'  READWRITE', &
'    the connection is for both input and output.', &
'', &
'  UNDEFINED', &
'    if there is no connection,', &
'', &
'ASYNCHRONOUS', &
'  YES', &
'    if the connection allows asynchronous input/output', &
'', &
'  NO', &
'    if the connection does not allow asynchronous input/output.', &
'', &
'  UNDEFINED', &
'    If there is no connection', &
'', &
'BLANK', &
'  ZERO', &
'    blanks are interpreted as zeros on input', &
'', &
'  NULL', &
'    blanks are interpreted as a null on input', &
'', &
'  UNDEFINED', &
'    no connection or the connection is not for formatted input/output', &
'', &
'DECIMAL', &
'  COMMA', &
'    treat a comma as the separator between mantissa and decimal', &
'', &
'  POINT', &
'    use a decimal point as the separator', &
'', &
'DELIM', &
'  APOSTROPHE,', &
'    the delimiter mode in effect for a connection for', &
'', &
'  QUOTE,', &
'    formatted input/output.', &
'', &
'   NONE', &
'  UNDEFINED', &
'    no connection or the connection is not for formatted input/output', &
'', &
'DIRECT', &
'  YES', &
'    if DIRECT is included in the set of allowed access methods for the file', &
'', &
'  NO', &
'    if DIRECT is not included in the set of allowed access methods for the', &
'    file', &
'', &
'  UNKNOWN', &
'    if the processor is unable to determine whether DIRECT is included in the', &
'    set of allowed access methods for the file.', &
'', &
'ENCODING', &
'  UTF-8', &
'    if the connection is for formatted input/output with an encoding form of', &
'    UTF-8', &
'', &
'  UNDEFINED', &
'    the connection is for unformatted input/output.', &
'', &
'  If there is no connection,', &
'', &
'  UTF-8', &
'    if the processor is able to determine that the encoding form of the file', &
'    is UTF-8', &
'', &
'  UNKNOWN', &
'    if the processor is unable to determine the encoding form of the file', &
'', &
'   NOTE', &
'  The value assigned may be something other than UTF-8, UNDEFINED, or UNKNOWN', &
'  if the processor supports other specific encoding forms (e.g. UTF-16BE).', &
'', &
'EXIST', &
'  .true. if there exists a file with the specified name if inquire is by', &
'  FILE=filename statement or if by UNIT=number and the specified unit exists.', &
'', &
'  .false. otherwise, false is assigned.', &
'', &
'FORM', &
'  FORMATTED if the connection is for formatted input/output, UNFORMATTED if', &
'  the connection is for unformatted input/output. UNDEFINED If there is no', &
'  connection', &
'', &
'FORMATTED', &
'  YES if FORMATTED is included in the set of allowed forms for the file NO if', &
'  FORMATTED is not included in the set of allowed forms for the file UNKNOWN', &
'  if the processor is unable to determine whether FORMATTED is included in the', &
'  set of allowed forms for the file.', &
'', &
'ID', &
'  The value of the expression specified in the ID= specifier shall be the', &
'  identifier of a pending data transfer operation for the specified unit.', &
'  This specifier interacts with the PENDING= specifier.', &
'', &
'NAME', &
'  The scalar_default_char_variable in the NAME= specifier is assigned the', &
'  value of the name of the file if the file has a name; otherwise, it becomes', &
'  undefined.', &
'', &
'   NOTE', &
'  If this specifier appears in an INQUIRE by file statement, its value is not', &
'  necessarily the same as the name given in the FILE= specifier. However, the', &
'  value returned shall be suitable for use as the value of the file_name_expr', &
'  in the FILE= specifier in an OPEN statement.', &
'', &
'  The processor may return a file name qualified by a user identification,', &
'  device, directory, or other relevant information.', &
'', &
'  The case of the characters assigned to scalar_default_char_variable is', &
'  processor dependent.', &
'', &
'NAMED', &
'  The scalar_logical_variable in the NAMED= specifier is assigned the value', &
'  true if the file has a name; otherwise, it is assigned the value false.', &
'', &
'NEXTREC', &
'  The scalar_int_variable in the NEXTREC= specifier is assigned the value n +', &
'  1, where n is the record number of the last record read from or written to', &
'  the connection for direct access. If there is a connection but no records', &
'  have been read or written since the connection, the scalar_int_variable is', &
'  assigned the value 1. If there is no connection, the connection is not for', &
'  direct access, or the position is indeterminate because of a previous error', &
'  condition, the scalar_int_variable becomes undefined. If there are pending', &
'  data transfer operations for the specified unit, the value assigned is', &
'  computed as if all the pending data transfers had already completed.', &
'', &
'NUMBER', &
'  The scalar_int_variable in the NUMBER= specifier is assigned the value of', &
'  the external unit number of the unit that is connected to the file.  If', &
'  there is no unit connected to the file, the value -1 is assigned.', &
'', &
'OPENED', &
'  .true. if the file specified is connected to a unit .false. otherwise', &
'', &
'PAD', &
'  YES, corresponding to the pad mode in effect for a connection. NO', &
'', &
'UNDEFINED', &
'  If there is no connection or if the connection is not for formatted', &
'  input/output,', &
'', &
'PENDING', &
'  The PENDING= specifier is used to determine whether previously pending', &
'  asynchronous data transfers are complete. A data transfer operation is', &
'  previously pending if it is pending at the beginning of execution of the', &
'  INQUIRE statement.', &
'', &
'  If an ID= specifier appears and the specified data transfer operation is', &
'  complete, then the variable specified in the PENDING= specifier is assigned', &
'  the value false and the INQUIRE statement performs the wait operation for', &
'  the specified data transfer.', &
'', &
'  If the ID= specifier is omitted and all previously pending data transfer', &
'  operations for the specified unit are complete, then the variable specified', &
'  in the PENDING= specifier is assigned the value false and the INQUIRE', &
'  statement performs wait operations for all previously pending data transfers', &
'  for the specified unit.', &
'', &
'  In all other cases, the variable specified in the PENDING= specifier is', &
'  assigned the value true and no wait operations are performed; in this case', &
'  the previously pending data transfers remain pending after the execution of', &
'  the INQUIRE statement.', &
'', &
'         NOTE:', &
'         The processor has considerable flexibility in defining when', &
'         it considers a transfer to be complete. Any of the following', &
'         approaches could be used:', &
'', &
'            o The INQUIRE statement could consider an asynchronous data', &
'              transfer to be incomplete until after', &
'              the corresponding wait operation. In this case PENDING=', &
'              would always return true unless there were no previously', &
'              pending data transfers for the unit.', &
'', &
'            o The INQUIRE statement could wait for all specified data', &
'              transfers to complete and then always return', &
'              false for PENDING=.', &
'', &
'            o The INQUIRE statement could actually test the state of the', &
'              specified data transfer operations.', &
'', &
'POS', &
'  The scalar_int_variable in the POS= specifier is assigned the number of the', &
'  file storage unit immediately following the current position of a file', &
'  connected for stream access. If the file is positioned at its terminal', &
'  position, the variable is assigned a value one greater than the number of', &
'  the highest-numbered file storage unit in the file. If the file is not', &
'  connected for stream access or if the position of the file is indeterminate', &
'  because of previous error conditions, the variable becomes undefined.', &
'', &
'POSITION', &
'  The scalar_default_char_variable in the POSITION= specifier is assigned the', &
'  value REWIND if the connection was opened for positioning at its initial', &
'  point, APPEND if the connection was opened for positioning before its', &
'  endfile record or at its terminal point, and ASIS if the connection was', &
'  opened without changing its position. If there is no connection or if the', &
'  file is connected for direct access, the scalar_default_char_variable is', &
'  assigned the value UNDEFINED. If the file has been repositioned since the', &
'  connection, the scalar_default_char_variable is assigned a processor-', &
'  dependent value, which shall not be REWIND unless the file is positioned at', &
'  its initial point and shall not be APPEND unless the file is positioned so', &
'  that its endfile record is the next record or at its terminal point if it', &
'  has no endfile record.', &
'', &
'READ', &
'  The scalar_default_char_variable in the READ= specifier is assigned the', &
'  value YES if READ is included in the set of allowed actions for the file, NO', &
'  if READ is not included in the set of allowed actions for the file, and', &
'  UNKNOWN if the processor is unable to determine whether READ is included in', &
'  the set of allowed actions for the file.', &
'', &
'READWRITE', &
'  The scalar_default_char_variable in the READWRITE= specifier is assigned the', &
'  value YES if READWRITE is included in the set of allowed actions for the', &
'  file, NO if READWRITE is not included in the set of allowed actions for the', &
'  file, and UNKNOWN if the processor is unable to determine whether READWRITE', &
'  is included in the set of allowed actions for the file.', &
'', &
'RECL', &
'  The scalar_int_variable in the RECL= specifier is assigned the value of the', &
'  record length of a connection for direct access, or the value of the maximum', &
'  record length of a connection for sequential access. If the connection is', &
'  for formatted input/output, the length is the number of characters for all', &
'  records that contain only characters of default kind.  If the connection is', &
'  for unformatted input/output, the length is measured in file storage units.', &
'  If there is no connection, or if the connection is for stream access, the', &
'  scalar_int_variable becomes undefined.', &
'', &
'ROUND', &
'  The scalar_default_char_variable in the ROUND= specifier is assigned the', &
'  value UP, DOWN, ZERO, NEAREST, COMPATIBLE, or PROCESSOR DEFINED,', &
'  corresponding to the I/O rounding mode in effect for a connection for', &
'  formatted input/output. If there is no connection or if the connection is', &
'  not for formatted input/output, the scalar_default_char_variable is assigned', &
'  the value UNDEFINED. The processor shall return the value PROCESSOR DEFINED', &
'  only if the behavior of the current I/O rounding mode is different from that', &
'  of the UP, DOWN, ZERO, NEAREST, and COMPATIBLE modes.', &
'', &
'SEQUENTIAL', &
'  The scalar_default_char_variable in the SEQUENTIAL= specifier is assigned', &
'  the value YES if SEQUENTIAL is included in the set of allowed access methods', &
'  for the file, NO if SEQUENTIAL is not included in the set of allowed access', &
'  methods for the file, and UNKNOWN if the processor is unable to determine', &
'  whether SEQUENTIAL is included in the set of allowed access methods for the', &
'  file.', &
'', &
'SIGN', &
'  The scalar_default_char_variable in the SIGN= specifier is assigned the', &
'  value PLUS, SUPPRESS, or PROCESSOR DEFINED, corresponding to the sign mode', &
'  in effect for a connection for formatted input/output. If there is no', &
'  connection, or if the connection is not for formatted input/output, the', &
'  scalar_default_char_variable is assigned the value UNDEFINED.', &
'', &
'SIZE', &
'  The scalar_int_variable in the SIZE= specifier is assigned the size of the', &
'  file in file storage units. If the file size cannot be determined, the', &
'  variable is assigned the value -1.', &
'', &
'  For a file that may be connected for stream access, the file size is the', &
'  number of the highest-numbered file storage unit in the file.', &
'', &
'  For a file that may be connected for sequential or direct access, the file', &
'  size may be different from the number of storage units implied by the data', &
'  in the records; the exact relationship is processor-dependent.', &
'', &
'STREAM', &
'  The scalar_default_char_variable in the STREAM= specifier is assigned the', &
'  value YES if STREAM is included in the set of allowed access methods for the', &
'  file, NO if STREAM is not included in the set of allowed access methods for', &
'  the file, and UNKNOWN if the processor is unable to determine whether STREAM', &
'  is included in the set of allowed access methods for the file.', &
'', &
'UNFORMATTED', &
'  The scalar_default_char_variable in the UNFORMATTED= specifier is assigned', &
'  the value YES if UNFORMATTED is included in the set of allowed forms for the', &
'  file, NO if UNFORMATTED is not included in the set of allowed forms for the', &
'  file, and UNKNOWN if the processor is unable to determine whether', &
'  UNFORMATTED is included in the set of allowed forms for the file.', &
'', &
'WRITE', &
'  The scalar_default_char_variable in the WRITE= specifier is assigned the', &
'  value YES if WRITE is included in the set of allowed actions for the file,', &
'  NO if WRITE is not included in the set of allowed actions for the file, and', &
'  UNKNOWN if the processor is unable to determine whether WRITE is included in', &
'  the set of allowed actions for the file.', &
'', &
'INQUIRE BY OUTPUT LIST', &
'  The scalar_int_variable in the IOLENGTH= specifier is assigned the', &
'  processor-dependent number of file storage units that would be required to', &
'  store the data of the output list in an unformatted file. The value shall be', &
'  suitable as a RECL= specifier in an OPEN statement that connects a file for', &
'  unformatted direct access when there are input/output statements with the', &
'  same input/output list.', &
'', &
'  The output list in an INQUIRE statement shall not contain any derived-type', &
'  list items that require a defined input/output procedure as described in', &
'  subclause 9.6.3. If a derived-type list item appears in the output list, the', &
'  value returned for the IOLENGTH= specifier assumes that no defined', &
'  input/output procedure will be invoked.', &
'', &
'EXAMPLES', &
'  Examples of INQUIRE statements are:', &
'', &
'          INQUIRE (IOLENGTH = IOL) A (1:N)', &
'          INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &', &
'             FORM = CHAR_VAR, IOSTAT = IOS)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_inquire', &
'      implicit none', &
'      integer :: lun=40', &
'      integer :: iostat', &
'        write(*,*)''is it open or predefined?''', &
'        call print_inquire(lun,'''')', &
'        write(*,*)''what are the defaults?''', &
'        open(unit=lun)', &
'        call print_inquire(lun,'''')', &
'        close(unit=lun,status=''delete'',iostat=iostat)', &
'      contains', &
'      subroutine print_inquire(lun_in,filename)', &
'', &
'      ! @(#) print_inquire(3f) print INQUIRE of file by name/number', &
'', &
'      integer,intent(in),optional          ::  lun_in', &
'      character(len=*),intent(in),optional  :: filename', &
'      integer                              ::  iostat', &
'      character(len=256)                   ::  message', &
'      character(len=:),allocatable         ::  filename_', &
'      integer                              ::  lun', &
'      ! STATUS=NEW|REPLACE|OLD|SCRATCH|UNKNOWN', &
'      ! SEQUENTIAL | DIRECT | STREAM | UNDEFINED', &
'      character(len=20)  ::  access       ;  namelist/inquire/access', &
'      character(len=20)  ::  asynchronous  ;  namelist/inquire/asynchronous', &
'      character(len=20)  ::  blank        ;  namelist/inquire/blank', &
'      character(len=20)  ::  decimal      ;  namelist/inquire/decimal', &
'      character(len=20)  ::  delim        ;  namelist/inquire/delim', &
'      character(len=20)  ::  direct       ;  namelist/inquire/direct', &
'      character(len=20)  ::  encoding     ;  namelist/inquire/encoding', &
'      !  FORMATTED   | UNFORMATTED', &
'      character(len=20)  ::  form         ;  namelist/inquire/form', &
'      character(len=20)  ::  formatted    ;  namelist/inquire/formatted', &
'      character(len=20)  ::  unformatted   ;  namelist/inquire/unformatted', &
'      character(len=20)  ::  name         ;  namelist/inquire/name', &
'      character(len=20)  ::  pad          ;  namelist/inquire/pad', &
'      !  ASIS       |  REWIND       |  APPEND', &
'      character(len=20)  ::  position     ;  namelist/inquire/position', &
'      !  READ       |  WRITE        |  READWRITE', &
'      character(len=20)  ::  action       ;  namelist/inquire/action', &
'      character(len=20)  ::  read         ;  namelist/inquire/read', &
'      character(len=20)  ::  readwrite    ;  namelist/inquire/readwrite', &
'      character(len=20)  ::  write        ;  namelist/inquire/write', &
'      character(len=20)  ::  round        ;  namelist/inquire/round', &
'      character(len=20)  ::  sequential    ;  namelist/inquire/sequential', &
'      character(len=20)  ::  sign         ;  namelist/inquire/sign', &
'      character(len=20)  ::  stream       ;  namelist/inquire/stream', &
'      integer           ::  id            ;  namelist/inquire/id', &
'      integer           ::  nextrec       ;  namelist/inquire/nextrec', &
'      integer           ::  number        ;  namelist/inquire/number', &
'      integer           ::  pos           ;  namelist/inquire/pos', &
'      integer           ::  recl          ;  namelist/inquire/recl', &
'      integer           ::  size          ;  namelist/inquire/size', &
'      logical           ::  exist         ;  namelist/inquire/exist', &
'      logical           ::  named         ;  namelist/inquire/named', &
'      logical           ::  opened        ;  namelist/inquire/opened', &
'      logical           ::  pending       ;  namelist/inquire/pending', &
'', &
'        if(present(filename))then', &
'           filename_ =filename', &
'        else', &
'           filename_ =''''', &
'        endif', &
'        lun=merge(lun_in,-1,present(lun_in))', &
'        ! exist, opened, and named always become defined', &
'        ! unless an error condition occurs.', &
'        if(filename_  == ''''.and.lun /= -1)then', &
'          write(*,*)''*print_inquire* checking unit'',lun', &
'          inquire(unit=lun,recl=recl,nextrec=nextrec,pos=pos,size=size,      &', &
'          & position=position,name=name,form=form,formatted=formatted,       &', &
'          & unformatted=unformatted,access=access,sequential=sequential,     &', &
'          & direct=direct,stream=stream,action=action,read=read,write=write, &', &
'          & readwrite=readwrite,sign=sign,round=round,blank=blank,           &', &
'          & decimal=decimal,delim=delim,encoding=encoding,pad=pad,           &', &
'          & named=named,opened=opened,exist=exist,number=number,             &', &
'          !bug & pending=pending,                                            &', &
'          & asynchronous=asynchronous,                                       &', &
'          & iostat=iostat,err=999,iomsg=message)', &
'        elseif(filename_  /= '''')then', &
'          write(*,*)''*print_inquire* checking file:''//filename_', &
'          inquire(file=filename_,                                            &', &
'          & recl=recl,nextrec=nextrec,pos=pos,                               &', &
'          & size=size,position=position,name=name,                           &', &
'          & form=form,formatted=formatted,unformatted=unformatted,           &', &
'          & access=access,sequential=sequential,direct=direct,stream=stream, &', &
'          & action=action,read=read,write=write,readwrite=readwrite,         &', &
'          & sign=sign,round=round,blank=blank,decimal=decimal,delim=delim,   &', &
'          & encoding=encoding,pad=pad,named=named,opened=opened,exist=exist, &', &
'          & number=number,pending=pending,asynchronous=asynchronous,         &', &
'          & iostat=iostat,err=999,iomsg=message)', &
'        else', &
'           write(*,*) &', &
'           & ''*print_inquire* must specify either filename or unit number''', &
'        endif', &
'        write(*,nml=inquire,delim=''none'')', &
'        return', &
'      999   continue', &
'        write(*,*)''*print_inquire* bad inquire''', &
'      !  If an error condition occurs during execution of an INQUIRE statement,', &
'      !  all of the inquiry identifiers except iostat become undefined.', &
'        write(*,*) ''*print_inquire* inquire call failed,iostat='',iostat, &', &
'        & ''message='',message', &
'      end subroutine print_inquire', &
'      end program demo_inquire', &
'', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025               inquire(7fortran)', &
'']

shortname="inquire"
call process()

case('130','int')

textblock=[character(len=256) :: &
'', &
'int(3fortran)                                                   int(3fortran)', &
'', &
'NAME', &
'  INT(3) - [TYPE:CONVERSION] Truncate towards zero and convert to integer', &
'', &
'SYNOPSIS', &
'  result = int(a [,kind])', &
'', &
'          elemental integer(kind=KIND) function int(a, KIND )', &
'', &
'           TYPE(kind=**),intent(in) :: a', &
'           integer,optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  A shall be of type integer, real, or complex, or a boz-literal-constant.', &
'', &
'  o  KIND shall be a scalar integer constant expression.', &
'', &
'DESCRIPTION', &
'  INT(3) truncates towards zero and return an integer.', &
'', &
'OPTIONS', &
'  o  A : is the value to truncate towards zero', &
'', &
'  o  KIND : indicates the kind parameter of the result. If not present the', &
'     returned type is that of default integer type.', &
'', &
'RESULT', &
'  returns an integer variable applying the following rules:', &
'', &
'  CASE:', &
'', &
'  1.  If A is of type integer, INT(a) = a', &
'', &
'  2.  If A is of type real and |A| < 1, INT(A) equals 0. If |A| >= 1, then', &
'      INT(A) equals the integer whose magnitude does not exceed A and whose', &
'      sign is the same as the sign of A.', &
'', &
'  3.  If A is of type complex, rule 2 is applied to the real part of A.', &
'', &
'  4.  If a is a boz-literal constant, it is treated as an integer with the', &
'      kind specified.', &
'', &
'      The interpretation of a bit sequence whose most significant bit is 1 is', &
'      processor dependent.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_int', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer :: i = 42', &
'      complex :: z = (-3.7, 1.0)', &
'      real :: x=-10.5, y=10.5', &
'', &
'        print *, int(x), int(y)', &
'', &
'        print *, int(i)', &
'', &
'        print *, int(z), int(z,8)', &
'        ! elemental', &
'        print *, int([-10.9,-10.5,-10.3,10.3,10.5,10.9])', &
'        ! note int(3) truncates towards zero', &
'', &
'        ! CAUTION:', &
'        ! a number bigger than a default integer can represent', &
'        ! produces an incorrect result and is not required to', &
'        ! be detected by the program.', &
'        x=real(huge(0))+1000.0', &
'        print *, int(x),x', &
'        ! using a larger kind', &
'        print *, int(x,kind=int64),x', &
'', &
'        print *, int(&', &
'        & B"111111111111111111111111111111111111111111111111111111111111111",&', &
'        & kind=int64)', &
'        print *, int(O"777777777777777777777",kind=int64)', &
'        print *, int(Z"7FFFFFFFFFFFFFFF",kind=int64)', &
'', &
'        ! elemental', &
'        print *', &
'        print *,int([ &', &
'        &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &', &
'        &  0.0,   &', &
'        &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])', &
'', &
'      end program demo_int', &
'', &
'  Results:', &
'', &
'       >         -10   10', &
'       >          42', &
'       >          -3  -3', &
'       >         -10  -10  -10   10   10  10', &
'       >  -2147483648  2.14748467E+09', &
'       >   2147484672  2.14748467E+09', &
'       >   9223372036854775807', &
'       >   9223372036854775807', &
'       >   9223372036854775807', &
'       >', &
'       >  -2         -2          -2          -2          -1', &
'       >  -1          0           0           0           1', &
'       >   1          2           2           2           2', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), NINT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   int(3fortran)', &
'']

shortname="int"
call process()

case('131','ior')

textblock=[character(len=256) :: &
'', &
'ior(3fortran)                                                   ior(3fortran)', &
'', &
'NAME', &
'  IOR(3) - [BIT:LOGICAL] Bitwise logical inclusive OR', &
'', &
'SYNOPSIS', &
'  result = ior(i, j)', &
'', &
'          elemental integer(kind=KIND) function ior(i,j)', &
'', &
'           integer(kind=KIND ,intent(in) :: i', &
'           integer(kind=KIND ,intent(in) :: j', &
'', &
'CHARACTERISTICS', &
'  o  I, J and the result shall have the same integer type and kind, with the', &
'     exception that one of I or J may be a BOZ constant.', &
'', &
'DESCRIPTION', &
'  IOR(3) returns the bit-wise Boolean inclusive-or of I and J.', &
'', &
'OPTIONS', &
'  o  I : one of the pair of values to compare the bits of', &
'', &
'  o  J : one of the pair of values to compare the bits of', &
'', &
'  If either I or J is a BOZ-literal-constant, it is first converted as if by', &
'  the intrinsic function INT(3) to type integer with the kind type parameter', &
'  of the other.', &
'', &
'RESULT', &
'  The result has the value obtained by combining I and J bit-by-bit according', &
'  to the following table:', &
'', &
'               I   J   IOR (I, J)', &
'               1   1        1', &
'               1   0        1', &
'               0   1        1', &
'               0   0        0', &
'', &
'  Where if the bit is set in either input value, it is set in the result.', &
'  Otherwise the result bit is zero.', &
'', &
'  This is commonly called the "bitwise logical inclusive OR" of the two', &
'  values.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ior', &
'      implicit none', &
'      integer :: i, j, k', &
'        i=53       ! i=00110101 binary (lowest order byte)', &
'        j=45       ! j=00101101 binary (lowest order byte)', &
'        k=ior(i,j) ! k=00111101 binary (lowest order byte), k=61 decimal', &
'        write(*,''(i8,1x,b8.8)'')i,i,j,j,k,k', &
'      end program demo_ior', &
'', &
'  Results:', &
'', &
'        > 53 00110101', &
'        > 45 00101101', &
'        > 61 00111101', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  BTEST(3), IAND(3), IBCLR(3), IBITS(3), IBSET(3), IEOR(3), MVBITS(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   ior(3fortran)', &
'']

shortname="ior"
call process()

case('132','iparity')

textblock=[character(len=256) :: &
'', &
'iparity(3fortran)                                           iparity(3fortran)', &
'', &
'NAME', &
'  IPARITY(3) - [BIT:LOGICAL] Bitwise exclusive OR of array elements', &
'', &
'SYNOPSIS', &
'  result = iparity( array [,mask] ) | iparity( array, dim [,mask] )', &
'', &
'          integer(kind=KIND) function iparity(array, dim, mask )', &
'', &
'           integer(kind=KIND),intent(in) :: array(..)', &
'           logical(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'  o  ARRAY - An integer array.', &
'', &
'     o DIM - an integer scalar from 1 to the rank of ARRAY', &
'', &
'     o MASK - logical conformable with ARRAY.', &
'', &
'DESCRIPTION', &
'  IPARITY(3) reduces with bitwise xor (exclusive or) the elements of ARRAY', &
'  along dimension DIM if the corresponding element in MASK is .true..', &
'', &
'OPTIONS', &
'  o  ARRAY : an array of integer values', &
'', &
'  o  DIM : a value from 1 to the rank of ARRAY.', &
'', &
'  o  MASK : a logical mask either a scalar or an array of the same shape as', &
'     ARRAY.', &
'', &
'RESULT', &
'  The result is of the same type as ARRAY.', &
'', &
'  If DIM is absent, a scalar with the bitwise xor of all elements in ARRAY is', &
'  returned. Otherwise, an array of rank N-1, where N equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'  Case (i) : The result of IPARITY (ARRAY) has a value equal to the bitwise', &
'  exclusive OR of all the elements of ARRAY. If ARRAY has size zero the result', &
'  has the value zero.', &
'', &
'  Case (ii) : The result of IPARITY (ARRAY, MASK=MASK) has a value equal to', &
'  that of', &
'', &
'            IPARITY (PACK (ARRAY, MASK)).', &
'', &
'  Case (iii) : The result of IPARITY (ARRAY, DIM=DIM [, MASK=MASK]) has a', &
'  value equal to that of IPARITY (ARRAY [, MASK=MASK]) if ARRAY has rank one.', &
'', &
'      Otherwise, an array of values reduced along the dimension', &
'      DIM is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iparity', &
'      implicit none', &
'      integer, dimension(2) :: a', &
'       a(1) = int(b''00100100'')', &
'       a(2) = int(b''01101010'')', &
'       print ''(b8.8)'', iparity(a)', &
'      end program demo_iparity', &
'', &
'  Results:', &
'', &
'       > 01001110', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  IANY(3), IALL(3), IEOR(3), PARITY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025               iparity(3fortran)', &
'']

shortname="iparity"
call process()

case('133','is_contiguous')

textblock=[character(len=256) :: &
'', &
'is_contiguous(3fortran)                               is_contiguous(3fortran)', &
'', &
'NAME', &
'  IS_CONTIGUOUS(3) - [ARRAY:INQUIRY] Test if object is contiguous', &
'', &
'SYNOPSIS', &
'  result = is_contiguous(array)', &
'', &
'          logical function is_contiguous(array)', &
'', &
'           type(TYPE(kind=**)),intent(in) :: array', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  ARRAY may be of any type. It shall be an array or assumed-rank. If it is', &
'     a pointer it shall be associated.', &
'', &
'  o  the result is a default logical scalar', &
'', &
'DESCRIPTION', &
'  IS_CONTIGUOUS(3) returns .true. if and only if an object is contiguous.', &
'', &
'  An object is contiguous if it is', &
'', &
'  o  (1) an object with the CONTIGUOUS attribute,', &
'', &
'  o  (2) a nonpointer whole array that is not assumed-shape,', &
'', &
'  o  (3) an assumed-shape array that is argument associated with an array that', &
'     is contiguous,', &
'', &
'  o  (4) an array allocated by an ALLOCATE statement,', &
'', &
'  o  (5) a pointer associated with a contiguous target, or', &
'', &
'  o  (6) a nonzero-sized array section provided that', &
'', &
'     o (A) its base object is contiguous,', &
'', &
'     o (B) it does not have a vector subscript,', &
'', &
'     o (C) the elements of the section, in array element order, are a subset', &
'       of the base object elements that are consecutive in array element', &
'       order,', &
'', &
'     o (D) if the array is of type character and a substring-range appears,', &
'       the substring-range specifies all of the characters of the parent-', &
'       string,', &
'', &
'     o (E) only its final part-ref has nonzero rank, and', &
'', &
'     o (F) it is not the real or imaginary part of an array of type complex.', &
'', &
'  An object is not contiguous if it is an array subobject, and', &
'', &
'  o  the object has two or more elements,', &
'', &
'  o  the elements of the object in array element order are not consecutive in', &
'     the elements of the base object,', &
'', &
'  o  the object is not of type character with length zero, and', &
'', &
'  o  the object is not of a derived type that has no ultimate components other', &
'     than zero-sized arrays and', &
'', &
'  o  characters with length zero.', &
'', &
'  It is processor-dependent whether any other object is contiguous.', &
'', &
'OPTIONS', &
'  o  ARRAY : An array of any type to be tested for being contiguous. If it is', &
'     a pointer it shall be associated.', &
'', &
'RESULT', &
'  The result has the value .true. if ARRAY is contiguous, and .false.', &
'  otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_is_contiguous', &
'      implicit none', &
'      intrinsic is_contiguous', &
'      real, DIMENSION (1000, 1000), TARGET :: A', &
'      real, DIMENSION (:, :), POINTER      :: IN, OUT', &
'        IN => A              ! Associate IN with target A', &
'        OUT => A(1:1000:2,:) ! Associate OUT with subset of target A', &
'        !', &
'        write(*,*)''IN is '',IS_CONTIGUOUS(IN)', &
'        write(*,*)''OUT is '',IS_CONTIGUOUS(OUT)', &
'        !', &
'      end program demo_is_contiguous', &
'', &
'  Results:', &
'', &
'       > IN is  T', &
'       > OUT is  F', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  o  allocated(3) - Allocation status of an allocatable entity', &
'', &
'  o  is_contiguous(3) - Test if object is contiguous', &
'', &
'  o  lbound(3) - Lower dimension bounds of an array', &
'', &
'  o  rank(3) - Rank of a data object', &
'', &
'  o  shape(3) - Determine the shape of an array or scalar', &
'', &
'  o  size(3) - Determine the size of an array or extent of one dimension', &
'', &
'  o  ubound(3) - Upper dimension bounds of an array', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025         is_contiguous(3fortran)', &
'']

shortname="is_contiguous"
call process()

case('134','ishft')

textblock=[character(len=256) :: &
'', &
'ishft(3fortran)                                               ishft(3fortran)', &
'', &
'NAME', &
'  ISHFT(3) - [BIT:SHIFT] Logical shift of bits in an integer', &
'', &
'SYNOPSIS', &
'  result = ishftc( i, shift )', &
'', &
'          elemental integer(kind=KIND) function ishft(i, shift )', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer of any kind. the kind for I dictates the kind of the', &
'     returned value.', &
'', &
'  o  SHIFT is an integer of any kind.', &
'', &
'DESCRIPTION', &
'  ISHFT(3) returns a value corresponding to I with all of the bits shifted', &
'  SHIFT places left or right as specified by the sign and magnitude of SHIFT.', &
'', &
'  Bits shifted out from the left end or right end are lost; zeros are shifted', &
'  in from the opposite end.', &
'', &
'OPTIONS', &
'  o  I : The value specifying the pattern of bits to shift', &
'', &
'  o  SHIFT : A value of SHIFT greater than zero corresponds to a left shift, a', &
'     value of zero corresponds to no shift, and a value less than zero', &
'     corresponds to a right shift.', &
'', &
'     If the absolute value of SHIFT is greater than BIT_SIZE(I), the value is', &
'     undefined.', &
'', &
'RESULT', &
'  The result has the value obtained by shifting the bits of I by SHIFT', &
'  positions.', &
'', &
'  1.  If SHIFT is positive, the shift is to the left', &
'', &
'  2.  if SHIFT is negative, the shift is to the right', &
'', &
'  3.  if SHIFT is zero, no shift is performed.', &
'', &
'  Bits shifted out from the left or from the right, as appropriate, are lost.', &
'  Zeros are shifted in from the opposite end.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ishft', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: shift', &
'      character(len=*),parameter :: g=''(b32.32,1x,i0)''', &
'', &
'        write(*,*) ishft(3, 1),'' <== typically should have the value 6''', &
'', &
'        shift=4', &
'        write(*,g) ishft(huge(0),shift), shift', &
'        shift=0', &
'        write(*,g) ishft(huge(0),shift), shift', &
'        shift=-4', &
'        write(*,g) ishft(huge(0),shift), shift', &
'      end program demo_ishft', &
'', &
'  Results:', &
'', &
'      >             6  <== typically should have the value 6', &
'      >   11111111111111111111111111110000 4', &
'      >   01111111111111111111111111111111 0', &
'      >   00000111111111111111111111111111 -4', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ISHFTC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 ishft(3fortran)', &
'']

shortname="ishft"
call process()

case('135','ishftc')

textblock=[character(len=256) :: &
'', &
'ishftc(3fortran)                                             ishftc(3fortran)', &
'', &
'NAME', &
'  ISHFTC(3) - [BIT:SHIFT] Shift rightmost bits circularly, AKA. a logical', &
'  shift', &
'', &
'SYNOPSIS', &
'  result = ishftc( i, shift [,size] )', &
'', &
'          elemental integer(kind=KIND) function ishftc(i, shift, size)', &
'', &
'           integer(kind=KIND),intent(in)        :: i', &
'           integer(kind=**),intent(in)          :: shift', &
'           integer(kind=**),intent(in),optional :: size', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I may be an integer of any kind', &
'', &
'  o  SHIFT and SIZE may be integers of any kind', &
'', &
'  o  the kind for I dictates the kind of the returned value.', &
'', &
'DESCRIPTION', &
'  ISHFTC(3) circularly shifts just the specified rightmost bits of an integer.', &
'', &
'  ISHFTC(3) returns a value corresponding to I with the rightmost SIZE bits', &
'  shifted circularly SHIFT places; that is, bits shifted out one end of the', &
'  section are shifted into the opposite end of the section.', &
'', &
'  A value of SHIFT greater than zero corresponds to a left shift, a value of', &
'  zero corresponds to no shift, and a value less than zero corresponds to a', &
'  right shift.', &
'', &
'OPTIONS', &
'  o  I : The value specifying the pattern of bits to shift', &
'', &
'  o  SHIFT : If SHIFT is positive, the shift is to the left; if SHIFT is', &
'     negative, the shift is to the right; and if SHIFT is zero, no shift is', &
'     performed.', &
'', &
'     The absolute value of SHIFT must be less than SIZE (simply put, the', &
'     number of positions to shift must be less than or equal to the number of', &
'     bits specified to be shifted).', &
'', &
'  o  SIZE : The value must be greater than zero and less than or equal to', &
'     BIT_SIZE(i).', &
'', &
'     The default if BIT_SIZE(I) is absent is to circularly shift the entire', &
'     value I.', &
'', &
'RESULT', &
'  The result characteristics (kind, shape, size, rank, ...) are the same as I.', &
'', &
'  The result has the value obtained by shifting the SIZE rightmost bits of I', &
'  circularly by SHIFT positions.', &
'', &
'  No bits are lost.', &
'', &
'  The unshifted bits are unaltered.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_ishftc', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: i', &
'      character(len=*),parameter :: g=''(b32.32,1x,i0)''', &
'       ! basics', &
'        write(*,*) ishftc(3, 1),'' <== typically should have the value 6''', &
'', &
'        print *, ''lets start with this:''', &
'        write(*,''(b32.32)'')huge(0)', &
'        print *, ''shift the value by various amounts, negative and positive''', &
'        do i= -bit_size(0), bit_size(0), 8', &
'           write(*,g) ishftc(huge(0),i), i', &
'        enddo', &
'       print *,''elemental''', &
'       i=huge(0)', &
'       write(*,*)ishftc(i,[2,3,4,5])', &
'       write(*,*)ishftc([2**1,2**3,-2**7],3)', &
'       print *,''note the arrays have to conform when elemental''', &
'       write(*,*)ishftc([2**1,2**3,-2**7],[5,20,0])', &
'', &
'      end program demo_ishftc', &
'', &
'  Results:', &
'', &
'       >           6  <== typically should have the value 6', &
'       >  lets start with this:', &
'       > 01111111111111111111111111111111', &
'       >  shift the value by various amounts, negative and positive', &
'       > 01111111111111111111111111111111 -32', &
'       > 11111111111111111111111101111111 -24', &
'       > 11111111111111110111111111111111 -16', &
'       > 11111111011111111111111111111111 -8', &
'       > 01111111111111111111111111111111 0', &
'       > 11111111111111111111111101111111 8', &
'       > 11111111111111110111111111111111 16', &
'       > 11111111011111111111111111111111 24', &
'       > 01111111111111111111111111111111 32', &
'       >  elemental', &
'       >          -3          -5          -9         -17', &
'       >          16          64       -1017', &
'       >  note the arrays have to conform when elemental', &
'       >          64     8388608        -128', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  ISHFT(3) - Logical shift of bits in an integer', &
'', &
'  o  SHIFTA(3) - Right shift with fill', &
'', &
'  o  SHIFTL(3) - Shift bits left', &
'', &
'  o  SHIFTR(3) - Combined right shift of the bits of two int...', &
'', &
'  o  DSHIFTL(3) - Combined left shift of the bits of two inte...', &
'', &
'  o  DSHIFTR(3) - Combined right shift of the bits of two int...', &
'', &
'  o  CSHIFT(3) - Circular shift elements of an array', &
'', &
'  o  EOSHIFT(3) - End-off shift elements of an array', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                ishftc(3fortran)', &
'']

shortname="ishftc"
call process()

case('136','is_iostat_end')

textblock=[character(len=256) :: &
'', &
'is_iostat_end(3fortran)                               is_iostat_end(3fortran)', &
'', &
'NAME', &
'  IS_IOSTAT_END(3) - [STATE:INQUIRY] Test for end-of-file value', &
'', &
'SYNOPSIS', &
'  result = is_iostat_end(i)', &
'', &
'          elemental logical function is_iostat_end(i)', &
'', &
'           integer,intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I is integer of any kind', &
'', &
'  o  the return value is a default logical', &
'', &
'DESCRIPTION', &
'  IS_IOSTAT_END(3) tests whether a variable (assumed returned as a status from', &
'  an I/O statement) has the "end of file" I/O status value.', &
'', &
'  The function is equivalent to comparing the variable with the IOSTAT_END', &
'  parameter of the intrinsic module ISO_FORTRAN_ENV.', &
'', &
'OPTIONS', &
'  o  I : An integer status value to test if indicating end of file.', &
'', &
'RESULT', &
'  returns .true. if and only ifI has the value which indicates an end of file', &
'  condition for IOSTAT= specifiers, and is .false. otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_iostat', &
'      implicit none', &
'      integer,parameter  :: wp=kind(0.0d0)', &
'      real(kind=wp)     :: value', &
'      integer           :: iostat', &
'      integer           :: lun', &
'      character(len=256) :: message', &
'        ! make a scratch input file for demonstration purposes', &
'        call makefile(lun)', &
'        write(*,*)''Begin entering numeric values, one per line''', &
'        do', &
'           read(lun,*,iostat=iostat,iomsg=message)value', &
'           if(iostat.eq.0)then', &
'              write(*,*)''VALUE='',value', &
'           elseif( is_iostat_end(iostat) ) then', &
'              stop ''end of file. Goodbye!''', &
'           else', &
'              write(*,*)''ERROR:'',iostat,trim(message)', &
'              exit', &
'           endif', &
'           !', &
'        enddo', &
'      contains', &
'      subroutine makefile(lun)', &
'      ! make a scratch file just for demonstration purposes', &
'      integer :: lun', &
'      integer :: i', &
'      character(len=255),parameter  :: fakefile(*)=[character(len=255) :: &', &
'', &
'      ''3.141592653589793238462643383279502884197169399375105820974944592307 &', &
'       &/ pi'', &', &
'', &
'      ''0.577215664901532860606512090082402431042 &', &
'       &/ The Euler-Mascheroni constant (Gamma)'', &', &
'', &
'      ''2.71828182845904523536028747135266249775724709369995 &', &
'       &/ Napier''''s constant "e"&', &
'       & is the base of the natural logarithm system,&', &
'       & named in honor of Euler '', &', &
'', &
'      ''1.6180339887498948482045868 &', &
'       &/ Golden_Ratio'', &', &
'', &
'      ''1 / unity'', &', &
'      '''']', &
'      !''/ end of data'']', &
'', &
'        open(newunit=lun,status=''replace'',file=''data.txt'',action=''readwrite'')', &
'        write(lun,''(a)'')(trim(fakefile(i)),i=1,size(fakefile))', &
'        rewind(lun)', &
'      end subroutine makefile', &
'      end program demo_iostat', &
'', &
'  Results:', &
'', &
'       >  Begin entering numeric values, one per line', &
'       >  VALUE=   3.1415926535897931', &
'       >  VALUE=  0.57721566490153287', &
'       >  VALUE=   2.7182818284590451', &
'       >  VALUE=   1.6180339887498949', &
'       >  VALUE=   1.0000000000000000', &
'       >  STOP end of file. Goodbye!', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  o  associated(3) - Association status of a pointer or pointer/target pair', &
'', &
'  o  extends_type_of(3) - Determine if the dynamic type of A is an extension', &
'     of the dynamic type of MOLD.', &
'', &
'  o  is_iostat_end(3) - Test for end-of-file value', &
'', &
'  o  is_iostat_eor(3) - Test for end-of-record value', &
'', &
'  o  present(3) - Determine whether an optional dummy argument is specified', &
'', &
'  o  same_type_as(3) - Query dynamic types for equality', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025         is_iostat_end(3fortran)', &
'']

shortname="is_iostat_end"
call process()

case('137','is_iostat_eor')

textblock=[character(len=256) :: &
'', &
'is_iostat_eor(3fortran)                               is_iostat_eor(3fortran)', &
'', &
'NAME', &
'  IS_IOSTAT_EOR(3) - [STATE:INQUIRY] Test for end-of-record value', &
'', &
'SYNOPSIS', &
'  result = is_iostat_eor(i)', &
'', &
'          elemental integer function is_iostat_eor(i)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I is integer of any kind', &
'', &
'  o  the return value is a default logical', &
'', &
'DESCRIPTION', &
'  IS_IOSTAT_EOR(3) tests whether a variable has the value of the I/O status', &
'  "end of record". The function is equivalent to comparing the variable with', &
'  the IOSTAT_EOR parameter of the intrinsic module ISO_FORTRAN_ENV.', &
'', &
'OPTIONS', &
'  o  I : The value to test as indicating "end of record".', &
'', &
'RESULT', &
'  Returns .true. if and only if I has the value which indicates an end-of-', &
'  record condition for iostat= specifiers, and is .false.  otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_is_iostat_eor', &
'      use iso_fortran_env, only : iostat_eor', &
'      implicit none', &
'      integer :: inums(5), lun, ios', &
'', &
'       ! create a test file to read from', &
'        open(newunit=lun, form=''formatted'',status=''scratch'',action=''readwrite'')', &
'        write(lun, ''(a)'')     &', &
'        ''10   20   30'',       &', &
'        ''40   50   60  70'',  &', &
'        ''80   90'',          &', &
'        ''100'',              &', &
'        ''110 120 130'',        &', &
'        ''140''', &
'        rewind(lun)', &
'', &
'        do', &
'           read(lun, *, iostat=ios) inums', &
'           write(*,*)''iostat='',ios', &
'           if(is_iostat_eor(ios)) then', &
'              inums=-huge(0)', &
'              print *, ''end of record''', &
'           elseif(is_iostat_end(ios)) then', &
'              print *,''end of file''', &
'              inums=-huge(0)', &
'              exit', &
'           elseif(ios.ne.0)then', &
'              print *,''I/O error'',ios', &
'              inums=-huge(0)', &
'              exit', &
'           else', &
'              write(*,''(*(g0,1x))'')''inums='',inums', &
'           endif', &
'        enddo', &
'', &
'        close(lun,iostat=ios,status=''delete'')', &
'', &
'      end program demo_is_iostat_eor', &
'', &
'  Results:', &
'', &
'       >  iostat=          0', &
'       > inums= 10 20 30 40 50', &
'       >  iostat=          0', &
'       > inums= 80 90 100 110 120', &
'       >  iostat=         -1', &
'       >  end of file', &
'', &
'  Note: the list-directed read starts on a new line with each read, and that', &
'  the read values should not portably be used if IOSTAT is not zero.', &
'', &
'  Format descriptors, Stream I/O and non-advancing I/O and reads into strings', &
'  that can then be parsed or read multiple times give full control of what is', &
'  read. List-directed I/O is generally more appropriate for interactive I/O.', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  o  associated(3) - Association status of a pointer or pointer/target pair', &
'', &
'  o  extends_type_of(3) - Determine if the dynamic type of A is an extension', &
'     of the dynamic type of MOLD.', &
'', &
'  o  is_iostat_end(3) - Test for end-of-file value', &
'', &
'  o  is_iostat_eor(3) - Test for end-of-record value', &
'', &
'  o  present(3) - Determine whether an optional dummy argument is specified', &
'', &
'  o  same_type_as(3) - Query dynamic types for equality', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025         is_iostat_eor(3fortran)', &
'']

shortname="is_iostat_eor"
call process()

case('138','kind')

textblock=[character(len=256) :: &
'', &
'kind(3fortran)                                                 kind(3fortran)', &
'', &
'NAME', &
'  KIND(3) - [KIND:INQUIRY] Query kind of an entity', &
'', &
'SYNOPSIS', &
'  result = kind(x)', &
'', &
'          integer function kind(x)', &
'', &
'           type(TYPE(kind=**)),intent(in) :: x(..)', &
'', &
'CHARACTERISTICS', &
'  o  X may be of any intrinsic type. It may be a scalar or an array.', &
'', &
'  o  the result is a default integer scalar', &
'', &
'DESCRIPTION', &
'  KIND(X)(3) returns the kind value of the entity X.', &
'', &
'OPTIONS', &
'  o  X : Value to query the kind of.', &
'', &
'RESULT', &
'  The return value indicates the kind of the argument X.', &
'', &
'  Note that kinds are processor-dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_kind', &
'      implicit none', &
'      integer,parameter :: dc = kind('' '')', &
'      integer,parameter :: dl = kind(.true.)', &
'', &
'        print *, "The default character kind is ", dc', &
'        print *, "The default logical kind is ", dl', &
'', &
'      end program demo_kind', &
'', &
'  Results:', &
'', &
'       > The default character kind is            1', &
'       > The default logical kind is            4', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - test if object is contiguous', &
'', &
'  o  LBOUND(3) - Lower dimension bounds of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  SHAPE(3) - Determine the shape of an array', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  UBOUND(3) - Upper dimension bounds of an array', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  kind(3fortran)', &
'']

shortname="kind"
call process()

case('139','lbound')

textblock=[character(len=256) :: &
'', &
'lbound(3fortran)                                             lbound(3fortran)', &
'', &
'NAME', &
'  LBOUND(3) - [ARRAY:INQUIRY] Lower dimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = lbound(array [,dim] [,kind] )', &
'', &
'          elemental TYPE(kind=KIND) function lbound(array,dim,kind)', &
'', &
'           TYPE(kind=KIND),intent(in)           :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           integer(kind=**),intent(in),optional :: kind', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY shall be assumed-rank or an array, of any type. It cannot be an', &
'     unallocated allocatable array or a pointer that is not associated.', &
'', &
'  o  DIM shall be a scalar integer. The corresponding actual argument shall', &
'     not be an optional dummy argument, a disassociated pointer, or an', &
'     unallocated allocatable.', &
'', &
'  o  KIND an integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'  o  The return value is of type integer and of kind KIND. If KIND is absent,', &
'     the return value is of default integer kind. The result is scalar if DIM', &
'     is present; otherwise, the result is an array of rank one and size n,', &
'     where n is the rank of ARRAY.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  LBOUND(3) returns the lower bounds of an array, or a single lower bound', &
'  along the DIM dimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array, of any type.', &
'', &
'  o  DIM : Shall be a scalar integer. If DIM is absent, the result is an array', &
'     of the upper bounds of ARRAY.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  If DIM is absent, the result is an array of the lower bounds of ARRAY.', &
'', &
'  If DIM is present, the result is a scalar corresponding to the lower bound', &
'  of the array along that dimension. If ARRAY is an expression rather than a', &
'  whole array or array structure component, or if it has a zero extent along', &
'  the relevant dimension, the lower bound is taken to be', &
'', &
'  1.', &
'', &
'  NOTE1', &
'', &
'  If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it', &
'  cannot satisfy the requirement 1 <= DIM <= 0.', &
'', &
'EXAMPLES', &
'  Note that this function should not be used on assumed-size arrays or in any', &
'  function without an explicit interface. Errors can occur if there is no', &
'  interface defined.', &
'', &
'  Sample program', &
'', &
'      ! program demo_lbound', &
'      module m_bounds', &
'      implicit none', &
'       contains', &
'         subroutine msub(arr)', &
'            !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array', &
'            integer,intent(in) :: arr(:)', &
'            write(*,*)''MSUB: LOWER='',lbound(arr), &', &
'            & ''UPPER='',ubound(arr), &', &
'            & ''SIZE='',size(arr)', &
'         end subroutine msub', &
'       end module m_bounds', &
'', &
'       program demo_lbound', &
'       use m_bounds, only : msub', &
'       implicit none', &
'       interface', &
'         subroutine esub(arr)', &
'         integer,intent(in) :: arr(:)', &
'         end subroutine esub', &
'       end interface', &
'       integer :: arr(-10:10)', &
'         write(*,*)''MAIN: LOWER='',lbound(arr), &', &
'         & ''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'         call csub()', &
'         call msub(arr)', &
'         call esub(arr)', &
'       contains', &
'      subroutine csub', &
'        write(*,*)''CSUB: LOWER='',lbound(arr), &', &
'        & ''UPPER='',ubound(arr), &', &
'        & ''SIZE='',size(arr)', &
'      end subroutine csub', &
'      end', &
'', &
'       subroutine esub(arr)', &
'       implicit none', &
'       integer,intent(in) :: arr(:)', &
'         ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE', &
'         ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)', &
'         write(*,*)''ESUB: LOWER='',lbound(arr), &', &
'         & ''UPPER='',ubound(arr), &', &
'         & ''SIZE='',size(arr)', &
'       end subroutine esub', &
'', &
'      !end program demo_lbound', &
'', &
'  Results:', &
'', &
'       >  MAIN: LOWER=        -10 UPPER=          10 SIZE=          21', &
'       >  CSUB: LOWER=        -10 UPPER=          10 SIZE=          21', &
'       >  MSUB: LOWER=          1 UPPER=          21 SIZE=          21', &
'       >  ESUB: LOWER=          1 UPPER=          21 SIZE=          21', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  Array inquiry:', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  SHAPE(3) - Determine the shape of an array', &
'', &
'  o  UBOUND(3) - Upper dimension bounds of an array', &
'', &
'  CO_UBOUND(3), CO_LBOUND(3)', &
'', &
'  State Inquiry:', &
'', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - Test if object is contiguous', &
'', &
'  Kind Inquiry:', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Bit Inquiry:', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                lbound(3fortran)', &
'']

shortname="lbound"
call process()

case('140','lcobound')

textblock=[character(len=256) :: &
'', &
'lcobound(3fortran)                                         lcobound(3fortran)', &
'', &
'NAME', &
'  LCOBOUND(3) - [COLLECTIVE] Lower codimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = lcobound( coarray [,dim] [,kind] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  LCOBOUND(3) returns the lower bounds of a coarray, or a single lower cobound', &
'  along the DIM codimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RESULT', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  UCOBOUND(3), LBOUND(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              lcobound(3fortran)', &
'']

shortname="lcobound"
call process()

case('141','leadz')

textblock=[character(len=256) :: &
'', &
'leadz(3fortran)                                               leadz(3fortran)', &
'', &
'NAME', &
'  LEADZ(3) - [BIT:COUNT] Number of leading zero bits of an integer', &
'', &
'SYNOPSIS', &
'  result = leadz(i)', &
'', &
'          elemental integer function leadz(i)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I may be an integer of any kind.', &
'', &
'  o  the return value is a default integer type.', &
'', &
'DESCRIPTION', &
'  LEADZ(3) returns the number of leading zero bits of an integer.', &
'', &
'OPTIONS', &
'  o  I : integer to count the leading zero bits of.', &
'', &
'RESULT', &
'  The number of leading zero bits, taking into account the kind of the input', &
'  value. If all the bits of I are zero, the result value is BIT_SIZE(I).', &
'', &
'  The result may also be thought of as BIT_SIZE(I)-1-K where K is the position', &
'  of the leftmost 1 bit in the input I. Positions are from 0 to bit-size(),', &
'  with 0 at the right-most bit.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_leadz', &
'      implicit none', &
'      integer :: value, i', &
'      character(len=80) :: f', &
'', &
'       ! make a format statement for writing a value as a bit string', &
'       write(f,''("(b",i0,".",i0,")")'')bit_size(value),bit_size(value)', &
'', &
'       ! show output for various integer values', &
'       value=0', &
'       do i=-150, 150, 50', &
'          value=i', &
'          write (*,''("LEADING ZERO BITS=",i3)'',advance=''no'') leadz(value)', &
'          write (*,''(" OF VALUE ")'',advance=''no'')', &
'          write(*,f,advance=''no'') value', &
'          write(*,''(*(1x,g0))'') "AKA",value', &
'       enddo', &
'       ! Notes:', &
'       ! for two''s-complements programming environments a negative non-zero', &
'       ! integer value will always start with a 1 and a positive value with 0', &
'       ! as the first bit is the sign bit. Such platforms are very common.', &
'      end program demo_leadz', &
'', &
'  Results:', &
'', &
'       > LEADING ZERO BITS= 0 OF VALUE 11111111111111111111111101101010 AKA -150', &
'       > LEADING ZERO BITS= 0 OF VALUE 11111111111111111111111110011100 AKA -100', &
'       > LEADING ZERO BITS= 0 OF VALUE 11111111111111111111111111001110 AKA -50', &
'       > LEADING ZERO BITS=32 OF VALUE 00000000000000000000000000000000 AKA 0', &
'       > LEADING ZERO BITS=26 OF VALUE 00000000000000000000000000110010 AKA 50', &
'       > LEADING ZERO BITS=25 OF VALUE 00000000000000000000000001100100 AKA 100', &
'       > LEADING ZERO BITS=24 OF VALUE 00000000000000000000000010010110 AKA 150', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BIT_SIZE(3), POPCNT(3), POPPAR(3), TRAILZ(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 leadz(3fortran)', &
'']

shortname="leadz"
call process()

case('142','len')

textblock=[character(len=256) :: &
'', &
'len(3fortran)                                                   len(3fortran)', &
'', &
'NAME', &
'  LEN(3) - [CHARACTER:INQUIRY] Length of a character entity', &
'', &
'SYNOPSIS', &
'  result = len(string [,kind])', &
'', &
'          integer(kind=KIND) function len(string,KIND)', &
'', &
'           character(len=*),intent(in) :: string(..)', &
'           integer,optional,intent(in) :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a scalar or array character variable', &
'', &
'  o  KIND is a scalar integer constant expression.', &
'', &
'  o  the returned value is the same integer kind as the KIND argument, or of', &
'     the default integer kind if KIND is not specified.', &
'', &
'DESCRIPTION', &
'  LEN(3) returns the length of a character string.', &
'', &
'  If STRING is an array, the length of a single element of STRING is returned,', &
'  as all elements of an array are the same length.', &
'', &
'  Note that STRING need not be defined when this intrinsic is invoked, as only', &
'  the length (not the content) of STRING is needed.', &
'', &
'OPTIONS', &
'  o  STRING : A scalar or array string to return the length of. If it is an', &
'     unallocated allocatable variable or a pointer that is not associated, its', &
'     length type parameter shall not be deferred.', &
'', &
'  o  KIND : A constant indicating the kind parameter of the result.', &
'', &
'RESULT', &
'  The result has a value equal to the number of characters in STRING if it is', &
'  scalar or in an element of STRING if it is an array.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_len', &
'      implicit none', &
'', &
'      ! fixed length', &
'      character(len=40) :: string', &
'      ! allocatable length', &
'      character(len=:),allocatable :: astring', &
'      character(len=:),allocatable :: many_strings(:)', &
'      integer :: ii', &
'       ! BASIC USAGE', &
'        ii=len(string)', &
'        write(*,*)''length ='',ii', &
'', &
'       ! ALLOCATABLE VARIABLE LENGTH CAN CHANGE', &
'       ! the allocatable string length will be the length of RHS expression', &
'        astring='' How long is this allocatable string? ''', &
'        write(*,*)astring, '' LEN='', len(astring)', &
'       ! print underline', &
'        write(*,*) repeat(''='',len(astring))', &
'       ! assign new value to astring and length changes', &
'        astring=''New allocatable string''', &
'        write(*,*)astring, '' LEN='', len(astring)', &
'       ! print underline', &
'        write(*,*) repeat(''='',len(astring))', &
'', &
'       ! THE STRING LENGTH WILL BE CONSTANT FOR A FIXED-LENGTH VARIABLE', &
'        string='' How long is this fixed string? ''', &
'        write(*,*)string,'' LEN='',len(string)', &
'        string=''New fixed string ''', &
'        write(*,*)string,'' LEN='',len(string)', &
'', &
'       ! ALL STRINGS IN AN ARRAY ARE THE SAME LENGTH', &
'       ! a scalar is returned for an array, as all values in a Fortran', &
'       ! character array must be of the same length.', &
'        many_strings = [ character(len=7) :: ''Tom'', ''Dick'', ''Harry'' ]', &
'        write(*,*)''length of ALL elements of array='',len(many_strings)', &
'', &
'       ! NAME%LEN IS ESSENTIALLY THE SAME AS LEN(NAME)', &
'       ! you can also query the length (and other attributes) of a string', &
'       ! using a "type parameter inquiry" (available since fortran 2018)', &
'        write(*,*)''length from type parameter inquiry='',string%len', &
'       ! %len is equivalent to a call to LEN() except the kind of the integer', &
'       ! value returned is always of default kind.', &
'', &
'       ! LOOK AT HOW A PASSED STRING CAN BE USED ...', &
'        call passed('' how long? '')', &
'', &
'      contains', &
'', &
'        subroutine passed(str)', &
'        character(len=*),intent(in)  :: str', &
'        ! the length of str can be used in the definitions of variables', &
'           ! you can query the length of the passed variable', &
'           write(*,*)''length of passed value is '', LEN(str)', &
'        end subroutine passed', &
'', &
'      end program demo_len', &
'', &
'  Results:', &
'', &
'       >  length =         40', &
'       >   How long is this allocatable string?  LEN=         38', &
'       >  ======================================', &
'       >  New allocatable string LEN=         22', &
'       >  ======================', &
'       >   How long is this fixed string?         LEN=          40', &
'       >  New fixed string                        LEN=          40', &
'       >  length of ALL elements of array=          7', &
'       >  length from type parameter inquiry=         40', &
'       >  length of passed value is          11', &
'', &
'STANDARD', &
'  FORTRAN 77 ; with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  len_trim(3), adjustr(3), trim(3), and adjustl(3) are related routines that', &
'  allow you to deal with leading and trailing blanks.', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   len(3fortran)', &
'']

shortname="len"
call process()

case('143','len_trim')

textblock=[character(len=256) :: &
'', &
'len_trim(3fortran)                                         len_trim(3fortran)', &
'', &
'NAME', &
'  LEN_TRIM(3) - [CHARACTER:INQUIRY] Character length without trailing blank', &
'  characters', &
'', &
'SYNOPSIS', &
'  result = len_trim(string [,kind])', &
'', &
'        elemental integer(kind=KIND) function len_trim(string,KIND)', &
'', &
'         character(len=*),intent(in) :: string', &
'         integer(kind=KIND),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  STRING is of type character', &
'', &
'  o  KIND is a scalar integer constant expression specifying the kind of the', &
'     returned value.', &
'', &
'  o  The return value is of type integer and of kind KIND. If KIND is absent,', &
'     the return value is of default integer kind.', &
'', &
'DESCRIPTION', &
'  LEN_TRIM(3) returns the length of a character string, ignoring any trailing', &
'  blanks.', &
'', &
'OPTIONS', &
'  o  STRING : The input string whose length is to be measured.', &
'', &
'  o  KIND : Indicates the kind parameter of the result.', &
'', &
'RESULT', &
'  The result equals the number of characters remaining after any trailing', &
'  blanks in STRING are removed.', &
'', &
'  If the input argument is of zero length or all blanks the result is zero.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_len_trim', &
'      implicit none', &
'      character(len=:),allocatable :: string', &
'      integer :: i', &
'      ! basic usage', &
'        string=" how long is this string?     "', &
'        write(*,*) string', &
'        write(*,*)''UNTRIMMED LENGTH='',len(string)', &
'        write(*,*)''TRIMMED LENGTH='',len_trim(string)', &
'', &
'        ! print string, then print substring of string', &
'        string=''xxxxx  ''', &
'        write(*,*)string,string,string', &
'        i=len_trim(string)', &
'        write(*,*)string(:i),string(:i),string(:i)', &
'        !', &
'       ! elemental example', &
'        ELE:block', &
'        ! an array of strings may be used', &
'        character(len=:),allocatable :: tablet(:)', &
'        tablet=[character(len=256) :: &', &
'        & '' how long is this string?    '',&', &
'        & ''and this one?'']', &
'           write(*,*)''UNTRIMMED LENGTH=  '',len(tablet)', &
'           write(*,*)''TRIMMED LENGTH=   '',len_trim(tablet)', &
'           write(*,*)''SUM TRIMMED LENGTH='',sum(len_trim(tablet))', &
'        endblock ELE', &
'        !', &
'      end program demo_len_trim', &
'', &
'  Results:', &
'', &
'       >   how long is this string?', &
'       >  UNTRIMMED LENGTH=          30', &
'       >  TRIMMED LENGTH=          25', &
'       >  xxxxx   xxxxx   xxxxx', &
'       >  xxxxxxxxxxxxxxx', &
'       >  UNTRIMMED LENGTH=           256', &
'       >  TRIMMED LENGTH=              25          13', &
'       >  SUM TRIMMED LENGTH=          38', &
'', &
'STANDARD', &
'  Fortran 95 . KIND argument added with Fortran 2003.', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: REPEAT(3), LEN(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              len_trim(3fortran)', &
'']

shortname="len_trim"
call process()

case('144','lge')

textblock=[character(len=256) :: &
'', &
'lge(3fortran)                                                   lge(3fortran)', &
'', &
'NAME', &
'  LGE(3) - [CHARACTER:COMPARE] ASCII Lexical greater than or equal', &
'', &
'SYNOPSIS', &
'  result = lge(string_a, stringb)', &
'', &
'          elemental logical function lge(string_a, string_b)', &
'', &
'           character(len=*),intent(in) :: string_a', &
'           character(len=*),intent(in) :: string_b', &
'', &
'CHARACTERISTICS', &
'  o  STRING_A is default character or an ASCII character string', &
'', &
'  o  STRING_B is the same type and kind as STRING_A', &
'', &
'  o  the result is a default logical', &
'', &
'DESCRIPTION', &
'  LGE(3) determines whether one string is lexically greater than or equal to', &
'  another string, where the two strings are interpreted as containing ASCII', &
'  character codes. If STRING_A and STRING_B are not the same length, the', &
'  shorter is compared as if spaces were appended to it to form a value that', &
'  has the same length as the longer.', &
'', &
'  The lexical comparison intrinsics LGE(3), LGT(3), LLE(3), and LLT(3) differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and .lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'OPTIONS', &
'  o  STRING_A : string to be tested', &
'', &
'  o  STRING_B : string to compare to STRING_A', &
'', &
'RESULT', &
'  Returns .true. if string_a >= string_b, and .false. otherwise, based on the', &
'  ASCII collating sequence.', &
'', &
'  If both input arguments are null strings, .true. is always returned.', &
'', &
'  If either string contains a character not in the ASCII character set, the', &
'  result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lge', &
'      implicit none', &
'      integer :: i', &
'        print *,''the ASCII collating sequence for printable characters''', &
'        write(*,''(1x,19a)'')(char(i),i=32,126) ! ASCII order', &
'        write(*,*) lge(''abc'',''ABC'')               ! [T] lowercase is > uppercase', &
'        write(*,*) lge(''abc'',''abc  '')             ! [T] trailing spaces', &
'        ! If both strings are of zero length the result is true', &
'        write(*,*) lge('''','''')                     ! [T]', &
'        write(*,*) lge('''',''a'')            ! [F] the null string is padded', &
'        write(*,*) lge(''a'','''')            ! [T]', &
'        ! elemental', &
'        write(*,*) lge(''abc'',[''abc'',''123''])   ! [T T]    scalar and array', &
'        write(*,*) lge([''cba'', ''123''],''abc'')  ! [T F]', &
'        write(*,*) lge([''abc'',''123''],[''cba'',''123'']) ! [F T]  both arrays', &
'      end program demo_lge', &
'', &
'  Results:', &
'', &
'       >  the ASCII collating sequence for printable characters', &
'       >   !"#$%&''()*+,-./012', &
'       >  3456789:;<=>?@ABCDE', &
'       >  FGHIJKLMNOPQRSTUVWX', &
'       >  YZ[\]^_`abcdefghijk', &
'       >  lmnopqrstuvwxyz{|}~', &
'       >  T', &
'       >  T', &
'       >  T', &
'       >  F', &
'       >  T', &
'       >  T T', &
'       >  T F', &
'       >  F T', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  LGT(3), LLE(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   lge(3fortran)', &
'']

shortname="lge"
call process()

case('145','lgt')

textblock=[character(len=256) :: &
'', &
'lgt(3fortran)                                                   lgt(3fortran)', &
'', &
'NAME', &
'  LGT(3) - [CHARACTER:COMPARE] ASCII Lexical greater than', &
'', &
'SYNOPSIS', &
'  result = lgt(string_a, string_b)', &
'', &
'           elemental logical function lgt(string_a, string_b)', &
'', &
'            character(len=*),intent(in) :: string_a', &
'            character(len=*),intent(in) :: string_b', &
'', &
'CHARACTERISTICS', &
'  o  STRING_A is default character or an ASCII character string', &
'', &
'  o  STRING_B is the same type and kind as STRING_A', &
'', &
'  o  the result is a default logical', &
'', &
'DESCRIPTION', &
'  LGT(3) determines whether one string is lexically greater than another', &
'  string, where the two strings are interpreted as containing ASCII character', &
'  codes. If the String A and String B are not the same length, the shorter is', &
'  compared as if spaces were appended to it to form a value that has the same', &
'  length as the longer.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and .lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'OPTIONS', &
'  o  STRING_A : string to be tested', &
'', &
'  o  STRING_B : string to compare to STRING_A', &
'', &
'RESULT', &
'  Returns .true. if string_a > string_b, and .false. otherwise, based on the', &
'  ASCII ordering.', &
'', &
'  If both input arguments are null strings, .false. is returned.', &
'', &
'  If either string contains a character not in the ASCII character set, the', &
'  result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lgt', &
'      implicit none', &
'      integer :: i', &
'        print *,''the ASCII collating sequence for printable characters''', &
'        write(*,''(1x,19a)'')(char(i),i=32,126)', &
'', &
'        write(*,*) lgt(''abc'',''ABC'')              ! [T] lowercase is > uppercase', &
'        write(*,*) lgt(''abc'',''abc  '')            ! [F] trailing spaces', &
'', &
'        ! If both strings are of zero length the result is false.', &
'        write(*,*) lgt('''','''')                    ! [F]', &
'        write(*,*) lgt('''',''a'')           ! [F] the null string is padded', &
'        write(*,*) lgt(''a'','''')           ! [T]', &
'        write(*,*) lgt(''abc'',[''abc'',''123''])  ! [F T]  scalar and array', &
'        write(*,*) lgt([''cba'', ''123''],''abc'') ! [T F]', &
'        write(*,*) lgt([''abc'',''123''],[''cba'',''123'']) ! [F F]  both arrays', &
'      end program demo_lgt', &
'', &
'  Results:', &
'', &
'       >  the ASCII collating sequence for printable characters', &
'       >   !"#$%&''()*+,-./012', &
'       >  3456789:;<=>?@ABCDE', &
'       >  FGHIJKLMNOPQRSTUVWX', &
'       >  YZ[\]^_`abcdefghijk', &
'       >  lmnopqrstuvwxyz{|}~', &
'       >  T', &
'       >  F', &
'       >  F', &
'       >  F', &
'       >  T', &
'       >  F T', &
'       >  T F', &
'       >  F F', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  LGE(3), LLE(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   lgt(3fortran)', &
'']

shortname="lgt"
call process()

case('146','lle')

textblock=[character(len=256) :: &
'', &
'lle(3fortran)                                                   lle(3fortran)', &
'', &
'NAME', &
'  LLE(3) - [CHARACTER:COMPARE] ASCII Lexical less than or equal', &
'', &
'SYNOPSIS', &
'  result = lle(string_a, stringb)', &
'', &
'           elemental logical function lle(string_a, string_b)', &
'', &
'            character(len=*),intent(in) :: string_a', &
'            character(len=*),intent(in) :: string_b', &
'', &
'CHARACTERISTICS', &
'  o  STRING_A is default character or an ASCII character string', &
'', &
'  o  STRING_B is the same type and kind as STRING_A', &
'', &
'  o  the result is a default logical', &
'', &
'DESCRIPTION', &
'  LLE(3) determines whether one string is lexically less than or equal to', &
'  another string, where the two strings are interpreted as containing ASCII', &
'  character codes.', &
'', &
'  If STRING_A and STRING_B are not the same length, the shorter is compared as', &
'  if spaces were appended to it to form a value that has the same length as', &
'  the longer.', &
'', &
'  Leading spaces are significant.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and .lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas LLE(3) always uses the ASCII ordering.', &
'', &
'OPTIONS', &
'  o  STRING_A : string to be tested', &
'', &
'  o  STRING_B : string to compare to STRING_A', &
'', &
'RESULT', &
'  Returns .true. if STRING_A <= STRING_B, and .false. otherwise, based on the', &
'  ASCII collating sequence.', &
'', &
'  If both input arguments are null strings, .true. is always returned.', &
'', &
'  If either string contains a character not in the ASCII character set, the', &
'  result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_lle', &
'      implicit none', &
'      integer :: i', &
'        print *,''the ASCII collating sequence for printable characters''', &
'        write(*,''(1x,19a)'')(char(i),i=32,126)', &
'       ! basics', &
'', &
'        print *,''case matters''', &
'        write(*,*) lle(''abc'',''ABC'')           ! F lowercase is > uppercase', &
'', &
'        print *,''a space is the lowest printable character''', &
'        write(*,*) lle(''abcd'',''abc'')          ! F  d > space', &
'        write(*,*) lle(''abc'',''abcd'')          ! T  space < d', &
'', &
'        print *,''leading spaces matter, trailing spaces do not''', &
'        write(*,*) lle(''abc'',''abc  '')         ! T trailing spaces', &
'        write(*,*) lle(''abc'','' abc'')          ! F leading spaces are significant', &
'', &
'        print *,''even null strings are padded and compared''', &
'        ! If both strings are of zero length the result is true.', &
'        write(*,*) lle('''','''')                 ! T', &
'        write(*,*) lle('''',''a'')        ! T the null string is padded', &
'        write(*,*) lle(''a'','''')        ! F', &
'        print *,''elemental''', &
'        write(*,*) lle(''abc'',[''abc'',''123''])  ! [T,F] scalar and array', &
'        write(*,*) lle([''cba'', ''123''],''abc'') ! [F,T]', &
'        ! per the rules for elemental procedures arrays must be the same size', &
'        write(*,*) lle([''abc'',''123''],[''cba'',''123'']) ! [T,T] both arrays', &
'      end program demo_lle', &
'', &
'  Results:', &
'', &
'       >  the ASCII collating sequence for printable characters', &
'       >   !"#$%&''()*+,-./012', &
'       >  3456789:;<=>?@ABCDE', &
'       >  FGHIJKLMNOPQRSTUVWX', &
'       >  YZ[\]^_`abcdefghijk', &
'       >  lmnopqrstuvwxyz{|}~', &
'       >  case matters', &
'       >  F', &
'       >  a space is the lowest printable character', &
'       >  F', &
'       >  T', &
'       >  leading spaces matter, trailing spaces do not', &
'       >  T', &
'       >  F', &
'       >  even null strings are padded and compared', &
'       >  T', &
'       >  T', &
'       >  F', &
'       >  elemental', &
'       >  T F', &
'       >  F T', &
'       >  T T', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  LGE(3), LGT(3), LLT(3)', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3),', &
'', &
'  SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   lle(3fortran)', &
'']

shortname="lle"
call process()

case('147','llt')

textblock=[character(len=256) :: &
'', &
'llt(3fortran)                                                   llt(3fortran)', &
'', &
'NAME', &
'  LLT(3) - [CHARACTER:COMPARE] ASCII Lexical less than', &
'', &
'SYNOPSIS', &
'  result = llt(string_a, stringb)', &
'', &
'           elemental logical function llt(string_a, string_b)', &
'', &
'            character(len=*),intent(in) :: string_a', &
'            character(len=*),intent(in) :: string_b', &
'', &
'CHARACTERISTICS', &
'  o  STRING_A is default character or an ASCII character string', &
'', &
'  o  STRING_B is the same type and kind as STRING_A', &
'', &
'  o  the result is a default logical', &
'', &
'DESCRIPTION', &
'  LLT(3) determines whether one string is lexically less than another string,', &
'  where the two strings are interpreted as containing ASCII character codes.', &
'  If the STRING_A and STRING_B are not the same length, the shorter is', &
'  compared as if spaces were appended to it to form a value that has the same', &
'  length as the longer.', &
'', &
'  In general, the lexical comparison intrinsics LGE, LGT, LLE, and LLT differ', &
'  from the corresponding intrinsic operators .ge., .gt., .le., and .lt., in', &
'  that the latter use the processor''s character ordering (which is not ASCII', &
'  on some targets), whereas the former always use the ASCII ordering.', &
'', &
'OPTIONS', &
'  o  STRING_A : string to be tested', &
'', &
'  o  STRING_B : string to compare to STRING_A', &
'', &
'RESULT', &
'  Returns .true. if string_a < string_b, and .false. otherwise, based on the', &
'  ASCII collating sequence.', &
'', &
'  If both input arguments are null strings, .false. is always returned.', &
'', &
'  If either string contains a character not in the ASCII character set, the', &
'  result is processor dependent.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_llt', &
'      implicit none', &
'      integer :: i', &
'', &
'        print *,''the ASCII collating sequence for printable characters''', &
'        write(*,''(1x,19a)'')(char(i),i=32,126) ! ASCII order', &
'', &
'       ! basics', &
'        print *,''case matters''', &
'        write(*,*) llt(''abc'',''ABC'')               ! [F] lowercase is > uppercase', &
'        write(*,*) llt(''abc'',''abc  '')             ! [F] trailing spaces', &
'        ! If both strings are of zero length the result is false.', &
'        write(*,*) llt('''','''')                     ! [F]', &
'        write(*,*) llt('''',''a'')            ! [T] the null string is padded', &
'        write(*,*) llt(''a'','''')            ! [F]', &
'        print *,''elemental''', &
'        write(*,*) llt(''abc'',[''abc'',''123''])   ! [F F]    scalar and array', &
'        write(*,*) llt([''cba'', ''123''],''abc'')  ! [F T]', &
'        write(*,*) llt([''abc'',''123''],[''cba'',''123'']) ! [T F]  both arrays', &
'      end program demo_llt', &
'', &
'  Results:', &
'', &
'       >  the ASCII collating sequence for printable characters', &
'       >   !"#$%&''()*+,-./012', &
'       >  3456789:;<=>?@ABCDE', &
'       >  FGHIJKLMNOPQRSTUVWX', &
'       >  YZ[\]^_`abcdefghijk', &
'       >  lmnopqrstuvwxyz{|}~', &
'       >  case matters', &
'       >  F', &
'       >  F', &
'       >  F', &
'       >  T', &
'       >  F', &
'       >  elemental', &
'       >  F F', &
'       >  F T', &
'       >  T F', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  LGE(3), LGT(3), LLE(3))', &
'', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   llt(3fortran)', &
'']

shortname="llt"
call process()

case('148','log10')

textblock=[character(len=256) :: &
'', &
'log10(3fortran)                                               log10(3fortran)', &
'', &
'NAME', &
'  LOG10(3) - [MATHEMATICS] Base 10 or common logarithm', &
'', &
'SYNOPSIS', &
'  result = log10(x)', &
'', &
'          elemental real(kind=KIND) function log10(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any kind of real value', &
'', &
'  o  the result is the same type and characteristics as X.', &
'', &
'DESCRIPTION', &
'  LOG10(3) computes the base 10 logarithm of X. This is generally called the', &
'  "common logarithm".', &
'', &
'OPTIONS', &
'  o  X : A real value > 0 to take the log of.', &
'', &
'RESULT', &
'  The logarithm to base 10 of X', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log10', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 10.0_real64', &
'', &
'        x = log10(x)', &
'        write(*,''(*(g0))'')''log10('',x,'') is '',log10(x)', &
'', &
'        ! elemental', &
'        write(*, *)log10([1.0, 10.0, 100.0, 1000.0, 10000.0, &', &
'                          & 100000.0, 1000000.0, 10000000.0])', &
'', &
'      end program demo_log10', &
'', &
'  Results:', &
'', &
'       > log10(1.000000000000000) is .000000000000000', &
'       >   0.0000000E+00   1.000000      2.000000       3.000000       4.000000', &
'       >    5.000000      6.000000       7.000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  exp(3) - Base-e exponential function', &
'', &
'  o  gamma(3) - Gamma function, which yields factorials for positive whole', &
'     numbers', &
'', &
'  o  hypot(3) - Returns the Euclidean distance - the distance between a point', &
'     and the origin.', &
'', &
'  o  log(3) - Natural logarithm', &
'', &
'  o  log_gamma(3) - Logarithm of the absolute value of the Gamma function', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                 log10(3fortran)', &
'']

shortname="log10"
call process()

case('149','log')

textblock=[character(len=256) :: &
'', &
'log(3fortran)                                                   log(3fortran)', &
'', &
'NAME', &
'  LOG(3) - [MATHEMATICS] Natural logarithm', &
'', &
'SYNOPSIS', &
'  result = log(x)', &
'', &
'        elemental TYPE(kind=KIND) function log(x)', &
'', &
'         TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real or complex kind.', &
'', &
'  o  the result is the same type and characteristics as X.', &
'', &
'DESCRIPTION', &
'  LOG(3) computes the natural logarithm of X, i.e. the logarithm to the base', &
'  "e".', &
'', &
'OPTIONS', &
'  o  X : The value to compute the natural log of. If X is real, its value', &
'     shall be greater than zero. If X is complex, its value shall not be zero.', &
'', &
'RESULT', &
'  The natural logarithm of X. If X is the complex value (R,I) , the imaginary', &
'  part "i" is in the range', &
'', &
'         -PI < i <= PI', &
'', &
'  If the real part of X is less than zero and the imaginary part of X is zero,', &
'  then the imaginary part of the result is approximately PI if the imaginary', &
'  part of PI is positive real zero or the processor does not distinguish', &
'  between positive and negative real zero, and approximately -PI if the', &
'  imaginary part of X is negative real zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log', &
'      implicit none', &
'       real(kind(0.0d0)) :: x = 2.71828182845904518d0', &
'       complex :: z = (1.0, 2.0)', &
'       write(*,*)x, log(x)    ! will yield (approximately) 1', &
'       write(*,*)z, log(z)', &
'      end program demo_log', &
'', &
'  Results:', &
'', &
'       >    2.7182818284590451        1.0000000000000000', &
'       > (1.00000000,2.00000000) (0.804718971,1.10714877)', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  log10(3) - Base 10 or common logarithm', &
'', &
'  o  exp(3) - Base-e exponential function', &
'', &
'  o  hypot(3) - Returns the Euclidean distance - the distance between a point', &
'     and the origin.', &
'', &
'  o  gamma(3) - Gamma function, which yields factorials for positive whole', &
'     numbers', &
'', &
'  o  log_gamma(3) - Logarithm of the absolute value of the Gamma function', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   log(3fortran)', &
'']

shortname="log"
call process()

case('150','log_gamma')

textblock=[character(len=256) :: &
'', &
'log_gamma(3fortran)                                       log_gamma(3fortran)', &
'', &
'NAME', &
'  LOG_GAMMA(3) - [MATHEMATICS] Logarithm of the absolute value of the Gamma', &
'  function', &
'', &
'SYNOPSIS', &
'  result = log_gamma(x)', &
'', &
'          elemental real(kind=KIND) function log_gamma(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real type', &
'', &
'  o  the return value is of same type and kind as X.', &
'', &
'DESCRIPTION', &
'  LOG_GAMMA(3) computes the natural logarithm of the absolute value of the', &
'  Gamma function.', &
'', &
'OPTIONS', &
'  o  X : neither negative nor zero value to render the result for.', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  natural logarithm of the absolute value of the gamma function of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_log_gamma', &
'      implicit none', &
'      real :: x = 1.0', &
'        write(*,*)x,log_gamma(x) ! returns 0.0', &
'        write(*,*)x,log_gamma(3.0) ! returns 0.693 (approximately)', &
'      end program demo_log_gamma', &
'', &
'  Results:', &
'', &
'       >    1.000000     0.0000000E+00', &
'       >    1.000000     0.6931472', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  Gamma function: GAMMA(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             log_gamma(3fortran)', &
'']

shortname="log_gamma"
call process()

case('151','logical')

textblock=[character(len=256) :: &
'', &
'logical(3fortran)                                           logical(3fortran)', &
'', &
'NAME', &
'  LOGICAL(3) - [TYPE:CONVERSION] Conversion between kinds of logical values', &
'', &
'SYNOPSIS', &
'  result = logical(l [,kind])', &
'', &
'          elemental logical(kind=KIND) function logical(l,KIND)', &
'', &
'           logical(kind=**),intent(in) :: l', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  L is of type logical', &
'', &
'  o  KIND shall be a scalar integer constant expression. If KIND is present,', &
'     the kind type parameter of the result is that specified by the value of', &
'     KIND; otherwise, the kind type parameter is that of default logical.', &
'', &
'DESCRIPTION', &
'  LOGICAL(3) converts one kind of logical variable to another.', &
'', &
'OPTIONS', &
'  o  L : The logical value to produce a copy of with kind KIND', &
'', &
'  o  KIND : indicates the kind parameter of the result. If not present, the', &
'     default kind is returned.', &
'', &
'RESULT', &
'  The return value is a logical value equal to L, with a kind corresponding to', &
'  KIND, or of the default logical kind if KIND is not given.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_logical', &
'      use iso_fortran_env, only : logical_kinds', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      use,intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      character(len=*),parameter :: g=''(*(g0))''', &
'      integer :: i, i1, i2', &
'      logical :: l1, l2', &
'       !', &
'       ! list kind values supported on this platform', &
'       !', &
'        do i =1, size(logical_kinds)', &
'           write(*,''(*(g0))'')''integer,parameter :: boolean'', &', &
'           & logical_kinds(i),''='', logical_kinds(i)', &
'        enddo', &
'       ! for performance and storage purposes you generally want', &
'       ! to use the smallest storage size supported when using', &
'       ! large arrays, but some existing routines may require', &
'       ! the default kind. LOGICAL(3f) can change the kind of', &
'       ! the variables.', &
'       !', &
'       ! But converting a logical to an integer is not done', &
'       ! with LOGICAL(3f); but can be down with MERGE(3f).', &
'       !', &
'        l1=.true.', &
'        l2=.false.', &
'        i1=merge(0,1,l1)', &
'        i2=merge(0,1,l2)', &
'        write(*,g)''L1='',l1,'' L2='',l2,'' I1='',i1,'' I2='',i2', &
'       !', &
'       ! show type and kind of default logicals', &
'        call showme(.true.)', &
'        call showme(l1)', &
'       ! show logical() changing type and kind', &
'        call showme(logical(l1))', &
'       ! you may have to delete unsupported kinds from this example', &
'', &
'       ! this is probably the default', &
'        call showme(logical(l1,kind=4))', &
'       ! note how showme shows different kinds are being passed to it', &
'        call showme(logical(l1,kind=8))', &
'        call showme(logical(l1,kind=2))', &
'       ! this is probably the smallest storage size supported', &
'       ! on this platform; but kind values are platform-specific', &
'        call showme(logical(l1,kind=1))', &
'      contains', &
'      subroutine showme(val)', &
'      ! @(#) showme(3f) - display type and kind of intrinsic value', &
'      class(*),intent(in) :: val', &
'        select type(val)', &
'           type is (integer(kind=int8))', &
'             write(*,''("integer(kind=int8) ",i0)'') val', &
'           type is (integer(kind=int16))', &
'              write(*,''("integer(kind=int16) ",i0)'') val', &
'           type is (integer(kind=int32))', &
'              write(*,''("integer(kind=int32) ",i0)'') val', &
'           type is (integer(kind=int64))', &
'              write(*,''("integer(kind=int64) ",i0)'') val', &
'           type is (real(kind=real32))', &
'              write(*,''("real(kind=real32) ",1pg0)'') val', &
'           type is (real(kind=real64))', &
'              write(*,''("real(kind=real64) ",1pg0)'') val', &
'           type is (real(kind=real128))', &
'             write(*,''("real(kind=real128) ",1pg0)'') val', &
'           type is (logical(kind=1))', &
'                 write(*,''("logical(kind=1) ",l1,a,i0)'') val, &', &
'             & ''storage='',storage_size(val)', &
'           type is (logical(kind=2))', &
'                 write(*,''("logical(kind=2) ",l1,a,i0)'') val, &', &
'             & ''storage='',storage_size(val)', &
'           type is (logical(kind=4))', &
'                 write(*,''("logical(kind=4) ",l1,a,i0)'') val, &', &
'             & ''storage='',storage_size(val)', &
'           type is (logical(kind=8))', &
'                 write(*,''("logical(kind=8) ",l1,a,i0)'') val, &', &
'             & ''storage='',storage_size(val)', &
'           type is (character(len=*))', &
'               write(*,''("character ",a)'') trim(val)', &
'           type is (complex)', &
'                        write(*,''("","(",1pg0,",",1pg0,")")'') val', &
'           class default', &
'           stop ''crud. showme() does not know about this type''', &
'        end select', &
'      end subroutine showme', &
'      end program demo_logical', &
'', &
'  Results:', &
'', &
'       > integer,parameter :: boolean1=1', &
'       > integer,parameter :: boolean2=2', &
'       > integer,parameter :: boolean4=4', &
'       > integer,parameter :: boolean8=8', &
'       > integer,parameter :: boolean16=16', &
'       > L1=T L2=F I1=0 I2=1', &
'       > logical(kind=4) Tstorage=32', &
'       > logical(kind=4) Tstorage=32', &
'       > logical(kind=4) Tstorage=32', &
'       > logical(kind=1) Tstorage=8', &
'       > logical(kind=2) Tstorage=16', &
'       > logical(kind=4) Tstorage=32', &
'', &
'STANDARD', &
'  Fortran 95 , related ISO_FORTRAN_ENV module - fortran 2009', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Conversion to a complex type', &
'', &
'  o  DBLE(3) - Converstion to double precision real', &
'', &
'  o  INT(3) - Truncate towards zero and convert to integer', &
'', &
'  o  NINT(3) - Nearest whole number', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  o  OUT_OF_RANGE(3) - Whether a numeric value can be converted safely to', &
'     another type', &
'', &
'  o  TRANSFER(3) - Transfer bit patterns', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               logical(3fortran)', &
'']

shortname="logical"
call process()

case('152','maskl')

textblock=[character(len=256) :: &
'', &
'maskl(3fortran)                                               maskl(3fortran)', &
'', &
'NAME', &
'  MASKL(3) - [BIT:SET] Generates a left justified mask', &
'', &
'SYNOPSIS', &
'  result = maskl( i [,kind] )', &
'', &
'          elemental integer(kind=KIND) function maskl(i,KIND)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer', &
'', &
'  o  KIND Shall be a scalar constant expression of type integer whose value is', &
'     a supported integer kind.', &
'', &
'  o  The result is an integer of the same kind as I unless KIND is present,', &
'     which is then used to specify the kind of the result.', &
'', &
'DESCRIPTION', &
'  MASKL(3) has its leftmost I bits set to 1, and the remaining bits set to', &
'', &
'  0.', &
'', &
'OPTIONS', &
'  o  I : the number of left-most bits to set in the integer result. It must be', &
'     from 0 to the number of bits for the kind of the result. The default kind', &
'     of the result is the same as I unless the result size is specified by', &
'     KIND. That is, these Fortran statements must be .true. :', &
'', &
'        i >= 0 .and. i < bitsize(i) ! if KIND is not specified', &
'        i >= 0 .and. i < bitsize(0_KIND) ! if KIND is specified', &
'', &
'  o  KIND : designates the kind of the integer result.', &
'', &
'RESULT', &
'  The leftmost I bits of the output integer are set to 1 and the other bits', &
'  are set to 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_maskl', &
'      implicit none', &
'      integer :: i', &
'       ! basics', &
'        i=3', &
'        write(*,''(i0,1x,b0)'') i, maskl(i)', &
'', &
'       ! elemental', &
'        write(*,''(*(i11,1x,b0.32,1x,/))'') maskl([(i,i,i=0,bit_size(0),4)])', &
'      end program demo_maskl', &
'', &
'  Results:', &
'', &
'       > 3 11100000000000000000000000000000', &
'       >          0 00000000000000000000000000000000', &
'       >  -268435456 11110000000000000000000000000000', &
'       >   -16777216 11111111000000000000000000000000', &
'       >    -1048576 11111111111100000000000000000000', &
'       >      -65536 11111111111111110000000000000000', &
'       >       -4096 11111111111111111111000000000000', &
'       >       -256 11111111111111111111111100000000', &
'       >        -16 11111111111111111111111111110000', &
'       >         -1 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  MASKR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 maskl(3fortran)', &
'']

shortname="maskl"
call process()

case('153','maskr')

textblock=[character(len=256) :: &
'', &
'maskr(3fortran)                                               maskr(3fortran)', &
'', &
'NAME', &
'  MASKR(3) - [BIT:SET] Generates a right-justified mask', &
'', &
'SYNOPSIS', &
'  result = maskr( i [,kind] )', &
'', &
'          elemental integer(kind=KIND) function maskr(i,KIND)', &
'', &
'           integer(kind=**),intent(in) :: i', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer', &
'', &
'  o  KIND Shall be a scalar constant expression of type integer whose value is', &
'     a supported integer kind.', &
'', &
'  o  The result is an integer of the same kind as I unless KIND is present,', &
'     which is then used to specify the kind of the result.', &
'', &
'DESCRIPTION', &
'  MASKR(3) generates an integer with its rightmost I bits set to 1, and the', &
'  remaining bits set to 0.', &
'', &
'OPTIONS', &
'  o  I : the number of right-most bits to set in the integer result. It must', &
'     be from 0 to the number of bits for the kind of the result. The default', &
'     kind of the result is the same as I unless the result size is specified', &
'     by KIND. That is, these Fortran statements must be .true. :', &
'', &
'        i >= 0 .and. i < bitsize(i) ! if KIND is not specified', &
'        i >= 0 .and. i < bitsize(0_KIND) ! if KIND is specified', &
'', &
'  o  KIND : designates the kind of the integer result.', &
'', &
'RESULT', &
'  The rightmost I bits of the output integer are set to 1 and the other bits', &
'  are set to 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_maskr', &
'      implicit none', &
'      integer :: i', &
'', &
'       ! basics', &
'        print *,''basics''', &
'        write(*,''(i0,t5,b32.32)'') 1, maskr(1)', &
'        write(*,''(i0,t5,b32.32)'') 5,  maskr(5)', &
'        write(*,''(i0,t5,b32.32)'') 11, maskr(11)', &
'        print *,"should be equivalent on two''s-complement processors"', &
'        write(*,''(i0,t5,b32.32)'') 1,  shiftr(-1,bit_size(0)-1)', &
'        write(*,''(i0,t5,b32.32)'') 5,  shiftr(-1,bit_size(0)-5)', &
'        write(*,''(i0,t5,b32.32)'') 11, shiftr(-1,bit_size(0)-11)', &
'', &
'       ! elemental', &
'        print *,''elemental ''', &
'        print *,''(array argument accepted like called with each element)''', &
'        write(*,''(*(i11,1x,b0.32,1x,/))'') maskr([(i,i,i=0,bit_size(0),4)])', &
'', &
'      end program demo_maskr', &
'', &
'  Results:', &
'', &
'       >   basics', &
'       >  1   00000000000000000000000000000001', &
'       >  5   00000000000000000000000000011111', &
'       >  11  00000000000000000000011111111111', &
'       >   should be equivalent on two''s-complement processors', &
'       >  1   00000000000000000000000000000001', &
'       >  5   00000000000000000000000000011111', &
'       >  11  00000000000000000000011111111111', &
'       >   elemental', &
'       >   (array argument accepted like called with each element)', &
'       >           0 00000000000000000000000000000000', &
'       >          15 00000000000000000000000000001111', &
'       >         255 00000000000000000000000011111111', &
'       >        4095 00000000000000000000111111111111', &
'       >       65535 00000000000000001111111111111111', &
'       >      1048575 00000000000011111111111111111111', &
'       >     16777215 00000000111111111111111111111111', &
'       >    268435455 00001111111111111111111111111111', &
'       >          -1 11111111111111111111111111111111', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  MASKL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 maskr(3fortran)', &
'']

shortname="maskr"
call process()

case('154','matmul')

textblock=[character(len=256) :: &
'', &
'matmul(3fortran)                                             matmul(3fortran)', &
'', &
'NAME', &
'  MATMUL(3) - [ARRAY:TRANSFORMATIONAL] Numeric or logical matrix', &
'  multiplication', &
'', &
'SYNOPSIS', &
'  result = matmul(matrix_a,matrix_b)', &
'', &
'          function matmul(matrix_a, matrix_b)', &
'', &
'           type(TYPE1(kind=**))      :: matrix_a(..)', &
'           type(TYPE2(kind=**))      :: matrix_b(..)', &
'           type(TYPE(kind=PROMOTED)) :: matmul(..)', &
'', &
'CHARACTERISTICS', &
'  o  MATRIX_A is a numeric (integer, real, or complex ) or logical array of', &
'     rank one two.', &
'', &
'  o  MATRIX_B is a numeric (integer, real, or complex ) or logical array of', &
'     rank one two.', &
'', &
'  o  At least one argument must be rank two.', &
'', &
'  o  the size of the first dimension of MATRIX_B must equal the size of the', &
'     last dimension of MATRIX_A.', &
'', &
'  o  the type of the result is the same as if an element of each argument had', &
'     been multiplied as a RHS expression (that is, if the arguments are not of', &
'     the same type the result follows the same rules of promotion as a simple', &
'     scalar multiplication of the two types would produce)', &
'', &
'  o  If one argument is logical, both must be logical. For logicals the', &
'     resulting type is as if the .and. operator has been used on elements from', &
'     the arrays.', &
'', &
'  o  The shape of the result depends on the shapes of the arguments as', &
'     described below.', &
'', &
'DESCRIPTION', &
'  MATMUL(3) performs a matrix multiplication on numeric or logical arguments.', &
'', &
'OPTIONS', &
'  o  MATRIX_A : A numeric or logical array with a rank of one or two.', &
'', &
'  o  MATRIX_B : A numeric or logical array with a rank of one or two. The last', &
'     dimension of MATRIX_A and the first dimension of MATRIX_B must be equal.', &
'', &
'     Note that MATRIX_A and MATRIX_B may be different numeric types.', &
'', &
'RESULT', &
'NUMERIC ARGUMENTS', &
'  If MATRIX_A and MATRIX_B are numeric the result is an array containing the', &
'  conventional matrix product of MATRIX_A and MATRIX_B.', &
'', &
'  First, for the numeric expression C=MATMUL(A,B)', &
'', &
'  o  Any vector A(N) is treated as a row vector A(1,N).', &
'', &
'  o  Any vector B(N) is treated as a column vector B(N,1).', &
'', &
'SHAPE AND RANK', &
'  The shape of the result can then be determined as the number of rows of the', &
'  first matrix and the number of columns of the second; but if any argument is', &
'  of rank one (a vector) the result is also rank one.  Conversely when both', &
'  arguments are of rank two, the result has a rank of two. That is ...', &
'', &
'  o  If MATRIX_A has shape [n,m] and MATRIX_B has shape [m,k], the result has', &
'     shape [n,k].', &
'', &
'  o  If MATRIX_A has shape [m] and MATRIX_B has shape [m,k], the result has', &
'     shape [k].', &
'', &
'  o  If MATRIX_A has shape [n,m] and MATRIX_B has shape [m], the result has', &
'     shape [n].', &
'', &
'VALUES', &
'  Then element C(I,J) of the product is obtained by multiplying term-by-term', &
'  the entries of the ith row of A and the jth column of B, and summing these', &
'  products. In other words, C(I,J) is the dot product of the ith row of A and', &
'  the jth column of B.', &
'', &
'LOGICAL ARGUMENTS', &
'VALUES', &
'  If MATRIX_A and MATRIX_B are of type logical, the array elements of the', &
'  result are instead:', &
'', &
'       Value_of_Element (i,j) = &', &
'       ANY( (row_i_of_MATRIX_A) .AND. (column_j_of_MATRIX_B) )', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_matmul', &
'      implicit none', &
'      integer :: a(2,3), b(3,2), c(2), d(3), e(2,2), f(3), g(2), v1(4),v2(4)', &
'        a = reshape([1, 2, 3, 4, 5, 6], [2, 3])', &
'        b = reshape([10, 20, 30, 40, 50, 60], [3, 2])', &
'        c = [1, 2]', &
'        d = [1, 2, 3]', &
'        e = matmul(a, b)', &
'        f = matmul(c,a)', &
'        g = matmul(a,d)', &
'', &
'        call print_matrix_int(''A is '',a)', &
'        call print_matrix_int(''B is '',b)', &
'        call print_vector_int(''C is '',c)', &
'        call print_vector_int(''D is '',d)', &
'        call print_matrix_int(''E is matmul(A,B)'',e)', &
'        call print_vector_int(''F is matmul(C,A)'',f)', &
'        call print_vector_int(''G is matmul(A,D)'',g)', &
'', &
'        ! look at argument shapes when one is a vector', &
'        write(*,''(" > shape")'')', &
'        ! at least one argument must be of rank two', &
'        ! so for two vectors at least one must be reshaped', &
'        v1=[11,22,33,44]', &
'        v2=[10,20,30,40]', &
'', &
'        ! these return a vector C(1:1)', &
'        ! treat A(1:n) as A(1:1,1:n)', &
'        call print_vector_int(''Cd is a vector (not a scalar)'',&', &
'        & matmul(reshape(v1,[1,size(v1)]),v2))', &
'        ! or treat B(1:m) as B(1:m,1:1)', &
'        call print_vector_int(''cD is a vector too'',&', &
'        & matmul(v1,reshape(v2,[size(v2),1])))', &
'', &
'        ! or treat A(1:n) as A(1:1,1:n) and B(1:m) as B(1:m,1:1)', &
'        ! but note this returns a matrix C(1:1,1:1) not a vector!', &
'        call print_matrix_int(''CD is a matrix'',matmul(&', &
'        & reshape(v1,[1,size(v1)]), &', &
'        & reshape(v2,[size(v2),1])))', &
'', &
'      contains', &
'', &
'      ! CONVENIENCE ROUTINES TO PRINT IN ROW-COLUMN ORDER', &
'      subroutine print_vector_int(title,arr)', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:)', &
'        call print_matrix_int(title,reshape(arr,[1,shape(arr)]))', &
'      end subroutine print_vector_int', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      !@(#) print small 2d integer arrays in row-column format', &
'      character(len=*),parameter :: all=''(" > ",*(g0,1x))'' ! a handy format', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'', &
'        print all', &
'        print all, trim(title)', &
'        biggest=''          '' ! make buffer to write integer into', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_matmul', &
'', &
'  Results:', &
'', &
'         >', &
'         > A is', &
'         > [  1,  3,  5 ]', &
'         > [  2,  4,  6 ]', &
'         >', &
'         > B is', &
'         > [  10,  40 ]', &
'         > [  20,  50 ]', &
'         > [  30,  60 ]', &
'         >', &
'         > C is', &
'         > [  1,  2 ]', &
'         >', &
'         > D is', &
'         > [  1,  2,  3 ]', &
'         >', &
'         > E is matmul(A,B)', &
'         > [  220,  490 ]', &
'         > [  280,  640 ]', &
'         >', &
'         > F is matmul(C,A)', &
'         > [   5,  11,  17 ]', &
'         >', &
'         > G is matmul(A,D)', &
'         > [  22,  28 ]', &
'         > shape', &
'         >', &
'         > Cd is a vector (not a scalar)', &
'         > [  3300 ]', &
'         >', &
'         > cD is a vector too', &
'         > [  3300 ]', &
'         >', &
'         > CD is a matrix', &
'         > [  3300 ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  PRODUCT(3), TRANSPOSE(3)', &
'', &
'RESOURCES', &
'  o  Matrix multiplication : Wikipedia', &
'', &
'  o  The Winograd variant of Strassen''s matrix-matrix multiply algorithm may', &
'     be of interest for optimizing multiplication of very large matrices. See', &
'', &
'         "GEMMW: A portable level 3 BLAS Winograd variant of Strassen''s', &
'         matrix-matrix multiply algorithm",', &
'', &
'         Douglas, C. C., Heroux, M., Slishman, G., and Smith, R. M.,', &
'         Journal of Computational Physics,', &
'         Vol. 110, No. 1, January 1994, pages 1-10.', &
'', &
'  The numerical instabilities of Strassen''s method for matrix multiplication', &
'  requires special processing.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                matmul(3fortran)', &
'']

shortname="matmul"
call process()

case('155','max')

textblock=[character(len=256) :: &
'', &
'max(3fortran)                                                   max(3fortran)', &
'', &
'NAME', &
'  MAX(3) - [NUMERIC] Maximum value of an argument list', &
'', &
'SYNOPSIS', &
'  result = max(a1, a2, a3, ...)', &
'', &
'          elemental TYPE(kind=KIND) function max(a1, a2, a3, ... )', &
'', &
'           TYPE(kind=KIND,intent(in),optional :: a1', &
'           TYPE(kind=KIND,intent(in),optional :: a2', &
'           TYPE(kind=KIND,intent(in),optional :: a3', &
'                     :', &
'                     :', &
'', &
'CHARACTERISTICS', &
'  o  A3, A3, A4, ... must be of the same type and kind as A1', &
'', &
'  o  the arguments may (all) be integer, real or character', &
'', &
'  o  there must be at least two arguments', &
'', &
'  o  the length of a character result is the length of the longest argument', &
'', &
'  o  the type and kind of the result is the same as those of the arguments', &
'', &
'DESCRIPTION', &
'  MAX(3) returns the argument with the largest (most positive) value.', &
'', &
'  For arguments of character type, the result is as if the arguments had been', &
'  successively compared with the intrinsic operational operators, taking into', &
'  account the collating sequence of the character kind.', &
'', &
'  The returned selected character argument is padded with blanks as needed on', &
'  the right to the same length of the longest argument.', &
'', &
'  It is unusual for a Fortran intrinsic to take an arbitrary number of', &
'  options, and in addition MAX(3) is elemental, meaning any number of', &
'  arguments may be arrays as long as they are of the same shape.', &
'', &
'  The examples contain such cases as examples to clarify the resulting', &
'  behavior for those not familiar with calling a "scalar" function elementally', &
'  with arrays.', &
'', &
'  See maxval(3) for simply getting the max value of an array.', &
'', &
'OPTIONS', &
'  o  A1 : The first argument determines the type and kind of the returned', &
'     value, and of any remaining arguments as well.', &
'', &
'  o  A2,A3,... : the remaining arguments of the set of values to search for a', &
'     maximum in.', &
'', &
'     : There must be at least two arguments to MAX(3).', &
'', &
'RESULT', &
'  The return value corresponds to an array of the same shape of any array', &
'  argument, or a scalar if all arguments are scalar.', &
'', &
'  The returned value when any argument is an array will be an array of the', &
'  same shape where each element is the maximum value occurring at that', &
'  location, treating all the scalar values as arrays of that same shape with', &
'  all elements set to the scalar value.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_max', &
'      implicit none', &
'      real :: arr1(4)= [10.0,11.0,30.0,-100.0]', &
'      real :: arr2(5)= [20.0,21.0,32.0,-200.0,2200.0]', &
'      integer :: box(3,4)= reshape([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6],shape(box))', &
'', &
'       ! basic usage', &
'        ! this is simple enough when all arguments are scalar', &
'', &
'        ! the most positive value is returned, not the one with the', &
'        ! largest magnitude', &
'        write(*,*)''scalars:'',max(10.0,11.0,30.0,-100.0)', &
'        write(*,*)''scalars:'',max(-22222.0,-0.0001)', &
'', &
'        ! strings do not need to be of the same length', &
'        write(*,*)''characters:'',max(''the'',''words'',''order'')', &
'', &
'        ! leading spaces are significant; everyone is padded on the right', &
'        ! to the length of the longest argument', &
'        write(*,*)''characters:'',max(''c'',''bb'',''a'')', &
'        write(*,*)''characters:'',max('' c'',''b'',''a'')', &
'', &
'       ! elemental', &
'        ! there must be at least two arguments, so even if A1 is an array', &
'        ! max(A1) is not valid. See MAXVAL(3) and/or MAXLOC(3) instead.', &
'', &
'        ! strings in a single array do need to be of the same length', &
'        ! but the different objects can still be of different lengths.', &
'        write(*,"(*(''""'',a,''""'':,1x))")MAX([''A'',''Z''],[''BB'',''Y ''])', &
'        ! note the result is now an array with the max of every element', &
'        ! position, as can be illustrated numerically as well:', &
'        write(*,''(a,*(i3,1x))'')''box=        '',box', &
'        write(*,''(a,*(i3,1x))'')''box**2='',sign(1,box)*box**2', &
'        write(*,''(a,*(i3,1x))'')''max '',max(box,sign(1,box)*box**2)', &
'', &
'        ! Remember if any argument is an array by the definition of an', &
'        ! elemental function all the array arguments must be the same shape.', &
'', &
'        ! to find the single largest value of multiple arrays you could', &
'        ! use something like', &
'        !    MAXVAL([arr1, arr2])', &
'        ! or probably better (more likely to avoid creating a large temp array)', &
'        !    max(maxval(arr1),maxval(arr2))', &
'        ! instead', &
'', &
'        ! so this returns an array of the same shape as any input array', &
'        ! where each result is the maximum that occurs at that position.', &
'        write(*,*)max(arr1,arr2(1:4))', &
'        ! this returns an array just like BOX  except all values less than', &
'        ! zero are set to zero:', &
'        write(*,*)max(box,0)', &
'        ! When mixing arrays and scalars you can think of the scalars', &
'        ! as being a copy of one of the arrays with all values set to', &
'        ! the scalar value.', &
'', &
'      end program demo_max', &
'', &
'  Results:', &
'', &
'       >   scalars:   30.00000', &
'       >   scalars: -9.9999997E-05', &
'       >   characters:words', &
'       >   characters:c', &
'       >   characters:b', &
'       >  "BB" "Z "', &
'       >  box=   -6  -5  -4  -3  -2  -1   1   2   3   4   5   6', &
'       >  box**2=-36 -25 -16  -9  -4  -1   1   4   9  16  25  36', &
'       >  max    -6  -5  -4  -3  -2  -1   1   4   9  16  25  36', &
'       >  20.00000  21.00000  32.00000 -100.0000', &
'       >  0  0 0  0  0  0', &
'       >  1  2 3  4  5  6', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  MAXLOC(3), MINLOC(3), MAXVAL(3), MINVAL(3), MIN(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   max(3fortran)', &
'']

shortname="max"
call process()

case('156','maxexponent')

textblock=[character(len=256) :: &
'', &
'maxexponent(3fortran)                                   maxexponent(3fortran)', &
'', &
'NAME', &
'  MAXEXPONENT(3) - [MODEL:NUMERIC] Maximum exponent of a real kind', &
'', &
'SYNOPSIS', &
'  result = maxexponent(x)', &
'', &
'          elemental integer function maxexponent(x)', &
'', &
'           real(kind=**),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is a real scalar or array of any real kind', &
'', &
'  o  the result is a default integer scalar', &
'', &
'DESCRIPTION', &
'  MAXEXPONENT(3) returns the maximum exponent in the model of the type of X.', &
'', &
'OPTIONS', &
'  o  X : A value used to select the kind of real to return a value for.', &
'', &
'RESULT', &
'  The value returned is the maximum exponent for the kind of the value queried', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_maxexponent', &
'      use, intrinsic :: iso_fortran_env, only : real32,real64,real128', &
'      implicit none', &
'      character(len=*),parameter :: g=''(*(g0,1x))''', &
'        print  g,  minexponent(0.0_real32),   maxexponent(0.0_real32)', &
'        print  g,  minexponent(0.0_real64),   maxexponent(0.0_real64)', &
'        print  g,  minexponent(0.0_real128),  maxexponent(0.0_real128)', &
'      end program demo_maxexponent', &
'', &
'  Results:', &
'', &
'       >  -125 128', &
'       >  -1021 1024', &
'       >  -16381 16384', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MINEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025           maxexponent(3fortran)', &
'']

shortname="maxexponent"
call process()

case('157','maxloc')

textblock=[character(len=256) :: &
'', &
'maxloc(3fortran)                                             maxloc(3fortran)', &
'', &
'NAME', &
'  MAXLOC(3) - [ARRAY:LOCATION] Location of the maximum value within an array', &
'', &
'SYNOPSIS', &
'  result = maxloc(array [,mask]) | maxloc(array [,dim] [,mask])', &
'', &
'          NUMERIC function maxloc(array, dim, mask)', &
'', &
'           NUMERIC,intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  NUMERIC designates any intrinsic numeric type and kind.', &
'', &
'DESCRIPTION', &
'  MAXLOC(3) determines the location of the element in the array with the', &
'  maximum value, or, if the DIM argument is supplied, determines the locations', &
'  of the maximum element along each row of the array in the DIM direction.', &
'', &
'  If MASK is present, only the elements for which MASK is .true. are', &
'  considered. If more than one element in the array has the maximum value, the', &
'  location returned is that of the first such element in array element order.', &
'', &
'  If the array has zero size, or all of the elements of MASK are .false., then', &
'  the result is an array of zeroes. Similarly, if DIM is supplied and all of', &
'  the elements of MASK along a given row are zero, the result value for that', &
'  row is zero.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : Shall be an array of type logical, and conformable with ARRAY.', &
'', &
'RESULT', &
'  If DIM is absent, the result is a rank-one array with a length equal to the', &
'  rank of ARRAY. If DIM is present, the result is an array with a rank one', &
'  less than the rank of ARRAY, and a size corresponding to the size of ARRAY', &
'  with the DIM dimension removed. If DIM is present and ARRAY has a rank of', &
'  one, the result is a scalar. In all cases, the result is of default integer', &
'  type.', &
'', &
'  The value returned is reference to the offset from the beginning of the', &
'  array, not necessarily the subscript value if the array subscripts do not', &
'  start with one.', &
'', &
'EXAMPLES', &
'  sample program', &
'', &
'      program demo_maxloc', &
'      implicit none', &
'      integer     :: ii', &
'      integer,save :: i(-3:3)=[(abs(abs(ii)-50),ii=-3,3)]', &
'      integer,save :: ints(3,5)= reshape([&', &
'        1,  2,  3,  4,  5, &', &
'        10, 20, 30, 40, 50, &', &
'        11, 22, 33, 44, 55  &', &
'      ],shape(ints),order=[2,1])', &
'', &
'         write(*,*) maxloc(ints)', &
'         write(*,*) maxloc(ints,dim=1)', &
'         write(*,*) maxloc(ints,dim=2)', &
'         ! when array bounds do not start with one remember MAXLOC(3) returns', &
'         ! the offset relative to the lower bound-1 of the location of the', &
'         ! maximum value, not the subscript of the maximum value. When the', &
'         ! lower bound of the array is one, these values are the same. In', &
'         ! other words, MAXLOC(3) returns the subscript of the value assuming', &
'         ! the first subscript of the array is one no matter what the lower', &
'         ! bound of the subscript actually is.', &
'         write(*,''(g0,1x,g0)'') (ii,i(ii),ii=lbound(i,dim=1),ubound(i,dim=1))', &
'         write(*,*)maxloc(i)', &
'', &
'      end program demo_maxloc', &
'', &
'  Results:', &
'', &
'       >     3      5', &
'       >     3      3       3       3       3', &
'       >     5      5       5', &
'       >  -3 47', &
'       >  -2 48', &
'       >  -1 49', &
'       >  0 50', &
'       >  1 49', &
'       >  2 48', &
'       >  3 47', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  FINDLOC(3) - Location of first element of ARRAY identified by MASK along', &
'     dimension DIM matching a target', &
'', &
'  o  MINLOC(3) - Location of the minimum value within an array', &
'', &
'  o  MAXVAL(3)', &
'', &
'  o  MINVAL(3)', &
'', &
'  o  MAX(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                maxloc(3fortran)', &
'']

shortname="maxloc"
call process()

case('158','maxval')

textblock=[character(len=256) :: &
'', &
'maxval(3fortran)                                             maxval(3fortran)', &
'', &
'NAME', &
'  MAXVAL(3) - [ARRAY:REDUCTION] Determines the maximum value in an array or', &
'  row', &
'', &
'SYNOPSIS', &
'  result = maxval(array [,mask]) | maxval(array [,dim] [,mask])', &
'', &
'          NUMERIC function maxval(array ,dim, mask)', &
'', &
'           NUMERIC,intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  NUMERIC designates any numeric type and kind.', &
'', &
'DESCRIPTION', &
'  MAXVAL(3) determines the maximum value of the elements in an array value,', &
'  or, if the DIM argument is supplied, determines the maximum value along each', &
'  row of the array in the DIM direction. If MASK is present, only the elements', &
'  for which MASK is .true. are considered.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : (Optional) Shall be an array of type logical, and conformable with', &
'     ARRAY.', &
'', &
'RESULT', &
'  If DIM is absent, or if ARRAY has a rank of one, the result is a scalar.  If', &
'  DIM is present, the result is an array with a rank one less than the rank of', &
'  ARRAY, and a size corresponding to the size of ARRAY with the DIM dimension', &
'  removed. In all cases, the result is of the same type and kind as ARRAY.', &
'', &
'  If the considered array has zero size then the result is the most negative', &
'  number of the type and kind of ARRAY if ARRAY is numeric, or a string of', &
'  nulls if ARRAY is of ASCII character type. or equal to CHAR(0, KIND(ARRAY))', &
'  otherwise.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_maxval', &
'      implicit none', &
'      integer,save :: ints(3,5)= reshape([&', &
'        1,  2,  3,  4,  5, &', &
'       10, 20, 30, 40, 50, &', &
'       11, 22, 33, 44, 55  &', &
'      ],shape(ints),order=[2,1])', &
'      character(len=:),allocatable :: strs(:)', &
'      integer :: i', &
'      character(len=*),parameter :: gen=''(*(g0,1x))''', &
'      character(len=*),parameter :: ind=''(3x,*(g0,1x))''', &
'', &
'        print gen,''Given the array''', &
'        write(*,''(1x,*(g4.4,1x))'') &', &
'        & (ints(i,:),new_line(''a''),i=1,size(ints,dim=1))', &
'        print gen,''Basics:''', &
'        print ind, ''biggest value in array''', &
'        print ind, maxval(ints)', &
'        print ind, ''biggest value in each column''', &
'        print ind, maxval(ints,dim=1)', &
'        print ind, ''biggest value in each row''', &
'        print ind,  maxval(ints,dim=2)', &
'', &
'        print gen,''With a mask:''', &
'        print ind, '' find biggest number less than 30 with mask''', &
'        print ind, maxval(ints,mask=ints.lt.30)', &
'', &
'        print gen,''If zero size considered:''', &
'        print ind, ''if zero size numeric array''', &
'        print ind, maxval([integer :: ]),''and -huge(0) is'',-huge(0),&', &
'        & ''(often not the same!)''', &
'        print ind, ''if zero-size character array all nulls''', &
'        strs=[character(len=5)::]', &
'        strs=maxval(strs)', &
'        print ind, ichar([(strs(i),i=1,len(strs))])', &
'        print ind, ''if everything is false,''', &
'        print ind, ''same as zero-size array for each subarray''', &
'        print ind, maxval(ints,mask=.false.)', &
'        print ind, maxval(ints,mask=.false.,dim=1)', &
'      end program demo_maxval', &
'', &
'  Results:', &
'', &
'       > Given the array:', &
'       >    1, 2,  3,  4,  5, &', &
'       >   10, 20, 30, 40, 50, &', &
'       >   11, 22, 33, 44, 55  &', &
'       > biggest value in array', &
'       > 55', &
'       > biggest value in each column', &
'       > 11 22 33 44 55', &
'       > biggest value in each row', &
'       > 5 50 55', &
'       > find biggest number less than 30 with mask', &
'       > 22', &
'       > if zero size numeric array', &
'       > -2147483648 and -huge(0) is -2147483647 (often not the same!)', &
'       > if zero-size character array all nulls', &
'       > 0 0 0 0 0', &
'       > if everything is false, same as zero-size array', &
'       > -2147483648', &
'       > -2147483648 -2147483648 -2147483648 -2147483648 -2147483648', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MINVAL(3), MINLOC(3), MAXLOC(3), MIN(3) MAX(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                maxval(3fortran)', &
'']

shortname="maxval"
call process()

case('159','merge')

textblock=[character(len=256) :: &
'', &
'merge(3fortran)                                               merge(3fortran)', &
'', &
'NAME', &
'  MERGE(3) - [ARRAY:CONSTRUCTION] Merge variables', &
'', &
'SYNOPSIS', &
'  result = merge(tsource, fsource, mask)', &
'', &
'          elemental type(TYPE(kind=KIND)) function merge(tsource,fsource,mask)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: tsource', &
'           type(TYPE(kind=KIND)),intent(in) :: fsource', &
'           logical(kind=**),intent(in)      :: mask', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  TSOURCE May be of any type, including user-defined.', &
'', &
'  o  FSOURCE Shall be of the same type and type parameters as TSOURCE.', &
'', &
'  o  MASK shall be of type logical.', &
'', &
'  o  The result will by of the same type and type parameters as TSOURCE.', &
'', &
'DESCRIPTION', &
'  The elemental function MERGE(3) selects values from two arrays or scalars', &
'  according to a logical mask. The result is equal to an element of TSOURCE', &
'  where the corresponding element of MASK is .true., or an element of FSOURCE', &
'  when it is .false. .', &
'', &
'  Multi-dimensional arrays are supported.', &
'', &
'  Note that argument expressions to MERGE(3) are not required to be short-', &
'  circuited so (as an example) if the array X contains zero values in the', &
'  statement below the standard does not prevent floating point divide by zero', &
'  being generated; as 1.0/X may be evaluated for all values of X before the', &
'  mask is used to select which value to retain:', &
'', &
'           y = merge( 1.0/x, 0.0, x /= 0.0 )', &
'', &
'  Note the compiler is also free to short-circuit or to generate an infinity', &
'  so this may work in many programming environments but is not recommended.', &
'', &
'  For cases like this one may instead use masked assignment via the WHERE', &
'  construct:', &
'', &
'           where(x .ne. 0.0)', &
'              y = 1.0/x', &
'           elsewhere', &
'              y = 0.0', &
'           endwhere', &
'', &
'  instead of the more obscure', &
'', &
'           merge(1.0/merge(x,1.0,x /= 0.0), 0.0, x /= 0.0)', &
'', &
'OPTIONS', &
'  o  TSOURCE : May be of any type, including user-defined.', &
'', &
'  o  FSOURCE : Shall be of the same type and type parameters as TSOURCE.', &
'', &
'  o  MASK : Shall be of type logical.', &
'', &
'  Note that (currently) character values must be of the same length.', &
'', &
'RESULT', &
'  The result is built from an element of TSOURCE if MASK is .true. and from', &
'  FSOURCE otherwise.', &
'', &
'  Because TSOURCE and FSOURCE are required to have the same type and type', &
'  parameters (for both the declared and dynamic types), the result is', &
'  polymorphic if and only if both TSOURCE and FSOURCE are polymorphic.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_merge', &
'      implicit none', &
'      integer :: tvals(2,3), fvals(2,3), answer(2,3)', &
'      logical :: mask(2,3)', &
'      integer :: i', &
'      integer :: k', &
'      logical :: chooseleft', &
'', &
'        ! Works with scalars', &
'        k=5', &
'        write(*,*)merge (1.0, 0.0, k > 0)', &
'        k=-2', &
'        write(*,*)merge (1.0, 0.0, k > 0)', &
'', &
'        ! set up some simple arrays that all conform to the', &
'        ! same shape', &
'        tvals(1,:)=[  10, -60,  50 ]', &
'        tvals(2,:)=[ -20,  40, -60 ]', &
'', &
'        fvals(1,:)=[ 0, 3, 2 ]', &
'        fvals(2,:)=[ 7, 4, 8 ]', &
'', &
'        mask(1,:)=[ .true.,  .false., .true. ]', &
'        mask(2,:)=[ .false., .false., .true. ]', &
'', &
'        ! lets use the mask of specific values', &
'        write(*,*)''mask of logicals''', &
'        answer=merge( tvals, fvals, mask )', &
'        call printme()', &
'', &
'        ! more typically the mask is an expression', &
'        write(*, *)''highest values''', &
'        answer=merge( tvals, fvals, tvals > fvals )', &
'        call printme()', &
'', &
'        write(*, *)''lowest values''', &
'        answer=merge( tvals, fvals, tvals < fvals )', &
'        call printme()', &
'', &
'        write(*, *)''zero out negative values''', &
'        answer=merge( 0, tvals, tvals < 0)', &
'        call printme()', &
'', &
'        write(*, *)''binary choice''', &
'        chooseleft=.false.', &
'        write(*, ''(3i4)'')merge([1,2,3],[10,20,30],chooseleft)', &
'        chooseleft=.true.', &
'        write(*, ''(3i4)'')merge([1,2,3],[10,20,30],chooseleft)', &
'', &
'      contains', &
'', &
'      subroutine printme()', &
'           write(*, ''(3i4)'')(answer(i, :), i=1, size(answer, dim=1))', &
'      end subroutine printme', &
'', &
'      end program demo_merge', &
'', &
'  Results:', &
'', &
'       >    1.00000000', &
'       >    0.00000000', &
'       >  mask of logicals', &
'       >   10  3  50', &
'       >    7  4 -60', &
'       >  highest values', &
'       >   10  3  50', &
'       >    7  40   8', &
'       >  lowest values', &
'       >    0 -60   2', &
'       >  -20  4 -60', &
'       >  zero out negative values', &
'       >   10  0  50', &
'       >    0  40   0', &
'       >  binary choice', &
'       >   10  20  30', &
'       >    1  2   3', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  PACK(3) packs an array into an array of rank one', &
'', &
'  o  SPREAD(3) is used to add a dimension and replicate data', &
'', &
'  o  UNPACK(3) scatters the elements of a vector', &
'', &
'  o  TRANSPOSE(3) - Transpose an array of rank two', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 merge(3fortran)', &
'']

shortname="merge"
call process()

case('160','merge_bits')

textblock=[character(len=256) :: &
'', &
'merge_bits(3fortran)                                     merge_bits(3fortran)', &
'', &
'NAME', &
'  MERGE_BITS(3) - [BIT:COPY] Merge bits using a mask', &
'', &
'SYNOPSIS', &
'  result = merge_bits(i, j, mask)', &
'', &
'          elemental integer(kind=KIND) function merge_bits(i,j,mask)', &
'', &
'           integer(kind=KIND), intent(in) :: i, j, mask', &
'', &
'CHARACTERISTICS', &
'  o  the result and all input values have the same integer type and KIND with', &
'     the exception that the mask and either I or J may be a BOZ constant.', &
'', &
'DESCRIPTION', &
'  A common graphics operation in Ternary Raster Operations is to combine bits', &
'  from two different sources, generally referred to as bit-blending.', &
'  MERGE_BITS(3) performs a masked bit-blend of I and J using the bits of the', &
'  MASK value to determine which of the input values to copy bits from.', &
'', &
'  Specifically, The k-th bit of the result is equal to the k-th bit of I if', &
'  the k-th bit of MASK is 1; it is equal to the k-th bit of J otherwise (so', &
'  all three input values must have the same number of bits).', &
'', &
'  The resulting value is the same as would result from', &
'', &
'         ior (iand (i, mask),iand (j, not (mask)))', &
'', &
'  An exception to all values being of the same integer type is that I or J', &
'  and/or the mask may be a BOZ constant (A BOZ constant means it is either a', &
'  Binary, Octal, or Hexadecimal literal constant). The BOZ values are', &
'  converted to the integer type of the non-BOZ value(s) as if called by the', &
'  intrinsic function INT() with the kind of the non-BOZ value(s), so the BOZ', &
'  values must be in the range of the type of the result.', &
'', &
'OPTIONS', &
'  o  I : value to select bits from when the associated bit in the mask is', &
'', &
'     1.', &
'', &
'  o  J : value to select bits from when the associated bit in the mask is', &
'', &
'     0.', &
'', &
'  o  MASK : a value whose bits are used as a mask to select bits from I and J', &
'', &
'RESULT', &
'  The bits blended from I and J using the mask MASK.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_merge_bits', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int16) :: if_one,if_zero,msk', &
'      character(len=*),parameter :: fmt=''(*(g0, 1X))''', &
'', &
'        ! basic usage', &
'        print *,''MERGE_BITS( 5,10,41) should be 3.=>'',merge_bits(5,10,41)', &
'        print *,''MERGE_BITS(13,18,22) should be 4.=>'',merge_bits(13,18,22)', &
'', &
'        ! use some values in base2 illustratively:', &
'        if_one =int(b''1010101010101010'',kind=int16)', &
'        if_zero=int(b''0101010101010101'',kind=int16)', &
'', &
'        msk=int(b''0101010101010101'',kind=int16)', &
'        print ''("should get all zero bits =>",b16.16)'', &', &
'        & merge_bits(if_one,if_zero,msk)', &
'', &
'        msk=int(b''1010101010101010'',kind=int16)', &
'        print ''("should get all ones bits =>",b16.16)'', &', &
'        & merge_bits(if_one,if_zero,msk)', &
'', &
'        ! using BOZ values', &
'        print fmt, &', &
'        & merge_bits(32767_int16,    o''12345'',       32767_int16), &', &
'        & merge_bits(o''12345'', 32767_int16, b''0000000000010101''), &', &
'        & merge_bits(32767_int16,    o''12345'',           z''1234'')', &
'', &
'        ! a do-it-yourself equivalent for comparison and validation', &
'        print fmt, &', &
'        & ior(iand(32767_int16, 32767_int16),                   &', &
'        &   iand(o''12345'', not(32767_int16))),                &', &
'', &
'        & ior(iand(o''12345'', int(o''12345'', kind=int16)),    &', &
'        &   iand(32767_int16, not(int(o''12345'', kind=int16)))), &', &
'', &
'        & ior(iand(32767_int16, z''1234''),                     &', &
'        &   iand(o''12345'', not(int( z''1234'', kind=int16))))', &
'', &
'      end program demo_merge_bits', &
'', &
'  Results:', &
'', &
'       >   MERGE_BITS( 5,10,41) should be 3.=>          3', &
'       >   MERGE_BITS(13,18,22) should be 4.=>          4', &
'       >  should get all zero bits =>0000000000000000', &
'       >  should get all ones bits =>1111111111111111', &
'       >  32767 32751 5877', &
'       >  32767 32767 5877', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  o  dshiftl(3) - Combined left shift of the bits of two integers', &
'', &
'  o  dshiftr(3) - Combined right shift of the bits of two integers', &
'', &
'  o  ibits(3) - Extraction of a subset of bits', &
'', &
'  o  merge_bits(3) - Merge bits using a mask', &
'', &
'  o  mvbits(3) - Reproduce bit patterns found in one integer in another', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025            merge_bits(3fortran)', &
'']

shortname="merge_bits"
call process()

case('161','min')

textblock=[character(len=256) :: &
'', &
'min(3fortran)                                                   min(3fortran)', &
'', &
'NAME', &
'  MIN(3) - [NUMERIC] Minimum value of an argument list', &
'', &
'SYNOPSIS', &
'  result = min(a1, a2, a3, ... )', &
'', &
'          elemental TYPE(kind=KIND) function min(a1, a2, a3, ... )', &
'', &
'           TYPE(kind=KIND,intent(in)   :: a1', &
'           TYPE(kind=KIND,intent(in)   :: a2', &
'           TYPE(kind=KIND,intent(in)   :: a3', &
'                     :', &
'                     :', &
'                     :', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be integer, real or character.', &
'', &
'DESCRIPTION', &
'  MIN(3) returns the argument with the smallest (most negative) value.', &
'', &
'  The arguments must the same type which shall be integer, real, or character', &
'  and they also all have the same kind type parameter.', &
'', &
'  The type and kind type parameter of the result are the same as those of the', &
'  arguments.', &
'', &
'  NOTE:', &
'', &
'  A common extension is that the argument kinds can vary. In that case the', &
'  returned value may be the kind of the first argument, or might be the kind', &
'  of the expression a1+a2+a3+a4... per the rules of promotion.', &
'', &
'OPTIONS', &
'  o  A1 : the first element of the set of values to examine.', &
'', &
'  o  A2, A3, ... : An expression of the same type and kind as A1 completing', &
'     the set of values to evaluate.', &
'', &
'RESULT', &
'  The return value corresponds to the minimum value among the arguments, and', &
'  has the same type and kind as the first argument.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_min', &
'      implicit none', &
'      integer :: i', &
'      integer :: rectangle(3,4)=reshape([(-6+i,i=0,11)],[3,4])', &
'         print *, ''basics''', &
'         print *, min(10.0,11.0,30.0,-100.0)', &
'         print *, min(-200.0,-1.0)', &
'         print *, ''elemental''', &
'         print *, min(1,[2,3,4])', &
'         print *, min(5,[2,3,4])', &
'', &
'         print *, ''box:''', &
'         do i=1,size(rectangle,dim=1)', &
'            write(*,''(*(i3,1x))'')rectangle(i,:)', &
'         enddo', &
'         print *, ''make all values 0 or less:''', &
'         do i=1,size(rectangle,dim=1)', &
'            write(*,''(*(i3,1x))'')min(rectangle(i,:),0)', &
'         enddo', &
'      end program demo_min', &
'', &
'  Results:', &
'', &
'       >  basics', &
'       >   -100.000000', &
'       >   -200.000000', &
'       >  elemental', &
'       >           1           1           1', &
'       >           2           3           4', &
'       >  box:', &
'       >  -6  -3   0   3', &
'       >  -5  -2   1   4', &
'       >  -4  -1   2   5', &
'       >  make all values 0 or less:', &
'       >  -6  -3   0   0', &
'       >  -5  -2   0   0', &
'       >  -4  -1   0   0', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  MAX(3), MAXLOC(3), MINLOC(3), MINVAL(3), MAXVAL(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost ''', &
'', &
'                               March 16, 2025                   min(3fortran)', &
'']

shortname="min"
call process()

case('162','minexponent')

textblock=[character(len=256) :: &
'', &
'minexponent(3fortran)                                   minexponent(3fortran)', &
'', &
'NAME', &
'  MINEXPONENT(3) - [MODEL:NUMERIC] Minimum exponent of a real kind', &
'', &
'SYNOPSIS', &
'  result = minexponent(x)', &
'', &
'          elemental integer function minexponent(x)', &
'', &
'           real(kind=**),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is a real scalar or array of any real kind', &
'', &
'  o  the result is a default integer scalar', &
'', &
'DESCRIPTION', &
'  MINEXPONENT(3) returns the minimum exponent in the model of the type of X.', &
'', &
'OPTIONS', &
'  o  X : A value used to select the kind of real to return a value for.', &
'', &
'RESULT', &
'  The value returned is the maximum exponent for the kind of the value queried', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_minexponent', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real32) :: x', &
'      real(kind=real64) :: y', &
'         print *, minexponent(x), maxexponent(x)', &
'         print *, minexponent(y), maxexponent(y)', &
'      end program demo_minexponent', &
'', &
'  Expected Results:', &
'', &
'       >     -125         128', &
'       >    -1021        1024', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025           minexponent(3fortran)', &
'']

shortname="minexponent"
call process()

case('163','minloc')

textblock=[character(len=256) :: &
'', &
'minloc(3fortran)                                             minloc(3fortran)', &
'', &
'NAME', &
'  MINLOC(3) - [ARRAY:LOCATION] Location of the minimum value within an array', &
'', &
'SYNOPSIS', &
'  result = minloc(array [,mask]) | minloc(array [,dim] [,mask])', &
'', &
'          NUMERIC function minloc(array, dim, mask)', &
'', &
'           NUMERIC,intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  NUMERIC is any numeric type and kind.', &
'', &
'DESCRIPTION', &
'  MINLOC(3) determines the location of the element in the array with the', &
'  minimum value, or, if the DIM argument is supplied, determines the locations', &
'  of the minimum element along each row of the array in the DIM direction.', &
'', &
'  If MASK is present, only the elements for which MASK is true. are', &
'  considered.', &
'', &
'  If more than one element in the array has the minimum value, the location', &
'  returned is that of the first such element in array element order.', &
'', &
'  If the array has zero size, or all of the elements of MASK are .false., then', &
'  the result is an array of zeroes. Similarly, if DIM is supplied and all of', &
'  the elements of MASK along a given row are zero, the result value for that', &
'  row is zero.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array of type integer, real, or character.', &
'', &
'  o  DIM : (Optional) Shall be a scalar of type integer, with a value between', &
'     one and the rank of ARRAY, inclusive. It may not be an optional dummy', &
'     argument.', &
'', &
'  o  MASK : Shall be an array of type logical, and conformable with ARRAY.', &
'', &
'RESULT', &
'  If DIM is absent, the result is a rank-one array with a length equal to the', &
'  rank of ARRAY. If DIM is present, the result is an array with a rank one', &
'  less than the rank of ARRAY, and a size corresponding to the size of ARRAY', &
'  with the DIM dimension removed. If DIM is present and ARRAY has a rank of', &
'  one, the result is a scalar. In all cases, the result is of default integer', &
'  type.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_minloc', &
'      implicit none', &
'      integer,save :: ints(3,5)= reshape([&', &
'        4, 10,  1,  7, 13, &', &
'        9, 15,  6, 12,  3, &', &
'       14,  5, 11,  2,  8  &', &
'      ],shape(ints),order=[2,1])', &
'        write(*,*) minloc(ints)', &
'        write(*,*) minloc(ints,dim=1)', &
'        write(*,*) minloc(ints,dim=2)', &
'        ! where in each column is the smallest number .gt. 10 ?', &
'        write(*,*) minloc(ints,dim=2,mask=ints.gt.10)', &
'        ! a one-dimensional array with dim=1 explicitly listed returns a scalar', &
'        write(*,*) minloc(pack(ints,.true.),dim=1) ! scalar', &
'      end program demo_minloc', &
'', &
'  Results:', &
'', &
'       >       1       3', &
'       >       1       3       1       3       2', &
'       >       3       5       4', &
'       >       5       4       3', &
'       >       7', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  FINDLOC(3) - Location of first element of ARRAY identified by MASK along', &
'     dimension DIM matching a target', &
'', &
'  o  MAXLOC(3) - Location of the maximum value within an array', &
'', &
'  o  MINLOC(3) - Location of the minimum value within an array', &
'', &
'  o  MIN(3)', &
'', &
'  o  MINVAL(3)', &
'', &
'  o  MAXVAL(3)', &
'', &
'  o  MAX(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                minloc(3fortran)', &
'']

shortname="minloc"
call process()

case('164','minval')

textblock=[character(len=256) :: &
'', &
'minval(3fortran)                                             minval(3fortran)', &
'', &
'NAME', &
'  MINVAL(3) - [ARRAY:REDUCTION] Minimum value of all the elements of ARRAY', &
'  along dimension DIM corresponding to true elements of MASK.', &
'', &
'SYNOPSIS', &
'  forms:', &
'', &
'         result = minval(array [,mask])', &
'', &
'  or', &
'', &
'         result = minval(array ,dim [,mask])', &
'', &
'          type(TYPE(kind=**)) function minval(array, dim, mask)', &
'', &
'           type(TYPE(kind=**)),intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real, integer, or character.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  DIM is an integer scalar indicating a dimension of the array. It may not', &
'     be an optional dummy argument.', &
'', &
'  o  MASK is an array of type logical, and conformable with ARRAY.', &
'', &
'  o  the result is of the same type and kind as ARRAY.', &
'', &
'DESCRIPTION', &
'  MINVAL(3) determines the minimum value of the elements in an array or, if', &
'  the DIM argument is supplied, determines the minimum value in the subarrays', &
'  indicated by stepping along the DIMth dimension.', &
'', &
'  Note that the result of', &
'', &
'       MINVAL(ARRAY, MASK = MASK)', &
'', &
'  has a value equal to that of', &
'', &
'       MINVAL (PACK (ARRAY, MASK)).', &
'', &
'  and The result of', &
'', &
'       MINVAL (ARRAY, DIM = DIM [, MASK = MASK])', &
'', &
'  has a value equal to that of', &
'', &
'       MINVAL (ARRAY [, MASK = MASK])', &
'', &
'  if ARRAY has rank one. Otherwise, the value of element (s1 , s2 , . . .  ,', &
'  sDIM-1 , sDIM+1 , . . . , sn ) of the result is equal to', &
'', &
'       MINVAL (ARRAY (s1 , s2 , . . . , sDIM-1 , :, sDIM+1 , . . . , sn )', &
'       [, MASK= MASK (s1 , s2 , . . . , sDIM-1 , :, sDIM+1 , . . . , sn ) ] ).', &
'', &
'OPTIONS', &
'  o  ARRAY : array to search for minimum values. If the array has zero size,', &
'     or all of the elements of MASK are .false., then the result is', &
'     HUGE(ARRAY) if ARRAY is numeric, or an array of strings of', &
'     CHAR(LEN=LEN(ARRAY)) characters, with each character equal to CHAR (n -', &
'     1, KIND (ARRAY)), where n is the number of characters in the collating', &
'     sequence for characters with the kind type parameter of ARRAY.', &
'', &
'     If ARRAY is of type character, the result is the value that would be', &
'     selected by application of intrinsic relational operators; that is, the', &
'     collating sequence for characters with the kind type parameter of the', &
'     arguments is applied.', &
'', &
'  o  DIM : Indicates which dimension to split the array into subarrays along.', &
'     It has a value between one and the rank of ARRAY, inclusive.', &
'', &
'  o  MASK ; If MASK is present, only the elements for which MASK is .true. are', &
'     considered when searching for the minimal value.', &
'', &
'RESULT', &
'  If DIM is absent, or if ARRAY has a rank of one, the result is a scalar.', &
'', &
'  If DIM is present, the result is an array with a rank one less than the rank', &
'  of ARRAY, and a size corresponding to the size of ARRAY with the DIM', &
'  dimension removed. In all cases, the result is of the same type and kind as', &
'  ARRAY.', &
'', &
'EXAMPLES', &
'  sample program:', &
'', &
'      program demo_minval', &
'      implicit none', &
'      integer :: i', &
'      character(len=:),allocatable :: strs(:)', &
'      character(len=*),parameter :: g=''(3x,*(g0,1x))''', &
'', &
'      integer,save :: ints(3,5)= reshape([&', &
'            1,  -2,   3,   4,   5,  &', &
'           10,  20, -30,  40,  50,  &', &
'           11,  22,  33, -44,  55  &', &
'      ],shape(ints),order=[2,1])', &
'', &
'      integer,save :: box(3,5,2)', &
'', &
'        box(:,:,1)=ints', &
'        box(:,:,2)=-ints', &
'', &
'        write(*,*)''Given the array''', &
'        write(*,''(1x,*(g4.4,1x))'') &', &
'        & (ints(i,:),new_line(''a''),i=1,size(ints,dim=1))', &
'', &
'        write(*,*)''What is the smallest element in the array?''', &
'        write(*,g) minval(ints),''at <'',minloc(ints),''>''', &
'', &
'        write(*,*)''What is the smallest element in each column?''', &
'        write(*,g) minval(ints,dim=1)', &
'', &
'        write(*,*)''What is the smallest element in each row?''', &
'        write(*,g) minval(ints,dim=2)', &
'', &
'        ! notice the shape of the output has less columns', &
'        ! than the input in this case', &
'        write(*,*)''What is the smallest element in each column,''', &
'        write(*,*)''considering only those elements that are''', &
'        write(*,*)''greater than zero?''', &
'        write(*,g) minval(ints, dim=1, mask = ints > 0)', &
'', &
'        write(*,*)&', &
'        & ''if everything is false a zero-sized array is NOT returned''', &
'        write(*,*) minval(ints, dim=1, mask = .false.)', &
'        write(*,*)''even for a zero-sized input''', &
'        write(*,g) minval([integer ::], dim=1, mask = .false.)', &
'', &
'        write(*,*)''a scalar answer for everything false is huge()''', &
'        write(*,g) minval(ints, mask = .false.)', &
'        write(*,g) minval([integer ::], mask = .false.)', &
'', &
'        print *, ''if zero-size character array all dels if ASCII''', &
'        strs=[character(len=5)::]', &
'        strs=minval(strs)', &
'        print g, ichar([(strs(i),i=1,len(strs))])', &
'', &
'        write(*,*)''some calls with three dimensions''', &
'        write(*,g) minval(box, mask = .true. )', &
'        write(*,g) minval(box, dim=1, mask = .true. )', &
'', &
'        write(*,g) minval(box, dim=2, mask = .true. )', &
'        write(*,g) ''shape of answer is '', &', &
'        & shape(minval(box, dim=2, mask = .true. ))', &
'', &
'      end program demo_minval', &
'', &
'  Result:', &
'', &
'       >  Given the array', &
'       >     1  -2    3    4    5', &
'       >    10  20  -30   40   50', &
'       >    11  22   33  -44   55', &
'       >', &
'       >  What is the smallest element in the array?', &
'       >    -44 at < 3 4 >', &
'       >  What is the smallest element in each column?', &
'       >    1 -2 -30 -44 5', &
'       >  What is the smallest element in each row?', &
'       >    -2 -30 -44', &
'       >  What is the smallest element in each column,', &
'       >  considering only those elements that are', &
'       >  greater than zero?', &
'       >    1 20 3 4 5', &
'       >  if everything is false a zero-sized array is NOT returned', &
'       >   2147483647  2147483647  2147483647  2147483647  2147483647', &
'       >  even for a zero-sized input', &
'       >    2147483647', &
'       >  a scalar answer for everything false is huge()', &
'       >    2147483647', &
'       >    2147483647', &
'       >  if zero-size character array all dels if ASCII', &
'       >', &
'       >  some calls with three dimensions', &
'       >    -55', &
'       >    1 -2 -30 -44 5 -11 -22 -33 -40 -55', &
'       >    -2 -30 -44 -5 -50 -55', &
'       >    shape of answer is 3 2', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MAXVAL(3), MIN(3), MAX(3) MINLOC(3) MAXLOC(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                minval(3fortran)', &
'']

shortname="minval"
call process()

case('165','mod')

textblock=[character(len=256) :: &
'', &
'mod(3fortran)                                                   mod(3fortran)', &
'', &
'NAME', &
'  MOD(3) - [NUMERIC] Remainder function', &
'', &
'SYNOPSIS', &
'  result = mod(a, p)', &
'', &
'          elemental type(TYPE(kind=KIND)) function mod(a,p)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: a', &
'           type(TYPE(kind=KIND)),intent(in) :: p', &
'', &
'CHARACTERISTICS', &
'  o  The result and arguments are all of the same type and kind.', &
'', &
'  o  The type may be any kind of real or integer.', &
'', &
'DESCRIPTION', &
'  MOD(3) computes the remainder of the division of A by P.', &
'', &
'  In mathematics, the remainder is the amount "left over" after performing', &
'  some computation. In arithmetic, the remainder is the integer "left over"', &
'  after dividing one integer by another to produce an integer quotient', &
'  (integer division). In algebra of polynomials, the remainder is the', &
'  polynomial "left over" after dividing one polynomial by another. The modulo', &
'  operation is the operation that produces such a remainder when given a', &
'  dividend and divisor.', &
'', &
'  o  (remainder). (2022, October 10). In Wikipedia.', &
'     https://en.wikipedia.org/wiki/Remainder', &
'', &
'OPTIONS', &
'  o  A : The dividend', &
'', &
'  o  P : the divisor (not equal to zero).', &
'', &
'RESULT', &
'  The return value is the result of A - (INT(A/P) * P).', &
'', &
'  As can be seen by the formula the sign of P is canceled out. Therefore the', &
'  returned value always has the sign of A.', &
'', &
'  Of course, the magnitude of the result will be less than the magnitude of P,', &
'  as the result has been reduced by all multiples of P.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_mod', &
'      implicit none', &
'', &
'        ! basics', &
'         print *, mod( -17,  3 ), modulo( -17,  3 )', &
'         print *, mod(  17, -3 ), modulo(  17, -3 )', &
'         print *, mod(  17,  3 ), modulo(  17,  3 )', &
'         print *, mod( -17, -3 ), modulo( -17, -3 )', &
'', &
'         print *, mod(-17.5, 5.2), modulo(-17.5, 5.2)', &
'         print *, mod( 17.5,-5.2), modulo( 17.5,-5.2)', &
'         print *, mod( 17.5, 5.2), modulo( 17.5, 5.2)', &
'         print *, mod(-17.5,-5.2), modulo(-17.5,-5.2)', &
'', &
'       ! with a divisor of 1 the fractional part is returned', &
'         print *, mod(-17.5, 1.0), modulo(-17.5, 1.0)', &
'         print *, mod( 17.5,-1.0), modulo( 17.5,-1.0)', &
'         print *, mod( 17.5, 1.0), modulo( 17.5, 1.0)', &
'         print *, mod(-17.5,-1.0), modulo(-17.5,-1.0)', &
'', &
'      end program demo_mod', &
'', &
'  Results:', &
'', &
'       >          -2           1', &
'       >           2          -1', &
'       >           2           2', &
'       >          -2          -2', &
'       >  -1.900001       3.299999', &
'       >   1.900001      -3.299999', &
'       >   1.900001       1.900001', &
'       >  -1.900001      -1.900001', &
'       > -0.5000000      0.5000000', &
'       >  0.5000000     -0.5000000', &
'       >  0.5000000      0.5000000', &
'       > -0.5000000     -0.5000000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  MODULO(3) - Modulo function', &
'', &
'  o  AINT(3) - truncate toward zero to a whole real number', &
'', &
'  o  INT(3) - truncate toward zero to a whole integer number', &
'', &
'  o  ANINT(3) - real nearest whole number', &
'', &
'  o  NINT(3) - integer nearest whole number', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   mod(3fortran)', &
'']

shortname="mod"
call process()

case('166','modulo')

textblock=[character(len=256) :: &
'', &
'modulo(3fortran)                                             modulo(3fortran)', &
'', &
'NAME', &
'  MODULO(3) - [NUMERIC] Modulo function', &
'', &
'SYNOPSIS', &
'  result = modulo(a, p)', &
'', &
'          elemental TYPE(kind=KIND) function modulo(a,p)', &
'', &
'           TYPE(kind=KIND),intent(in) :: a', &
'           TYPE(kind=KIND),intent(in) :: p', &
'', &
'CHARACTERISTICS', &
'  o  A may be any kind of real or integer.', &
'', &
'  o  P is the same type and kind as A', &
'', &
'  o  The result and arguments are all of the same type and kind.', &
'', &
'DESCRIPTION', &
'  MODULO(3) computes the A modulo P.', &
'', &
'OPTIONS', &
'  o  A : the value to take the MODULO of', &
'', &
'  o  P : The value to reduce A by till the remainder is <= P. It shall not be', &
'     zero.', &
'', &
'RESULT', &
'  The type and kind of the result are those of the arguments.', &
'', &
'  o  If A and P are of type integer: MODULO(A,P) has the value of A - FLOOR', &
'     (REAL(A) / REAL(P)) * P.', &
'', &
'  o  If A and P are of type real: MODULO(A,P) has the value of A - FLOOR (A /', &
'     P) * P.', &
'', &
'  The returned value has the same sign as P and a magnitude less than the', &
'  magnitude of P.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_modulo', &
'      implicit none', &
'          print *, modulo(17,3)        ! yields 2', &
'          print *, modulo(17.5,5.5)    ! yields 1.0', &
'', &
'          print *, modulo(-17,3)       ! yields 1', &
'          print *, modulo(-17.5,5.5)   ! yields 4.5', &
'', &
'          print *, modulo(17,-3)       ! yields -1', &
'          print *, modulo(17.5,-5.5)   ! yields -4.5', &
'      end program demo_modulo', &
'', &
'  Results:', &
'', &
'       >           2', &
'       >    1.000000', &
'       >           1', &
'       >    4.500000', &
'       >          -1', &
'       >   -4.500000', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MOD(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                modulo(3fortran)', &
'']

shortname="modulo"
call process()

case('167','move_alloc')

textblock=[character(len=256) :: &
'', &
'move_alloc(3fortran)                                     move_alloc(3fortran)', &
'', &
'NAME', &
'  MOVE_ALLOC(3) - [MEMORY] Move allocation from one object to another', &
'', &
'SYNOPSIS', &
'  call move_alloc(from, to [,stat] [,errmsg] )', &
'', &
'          subroutine move_alloc(from, to)', &
'', &
'           type(TYPE(kind=**)),intent(inout),allocatable :: from(..)', &
'           type(TYPE(kind=**)),intent(out),allocatable   :: to(..)', &
'           integer(kind=**),intent(out)   :: stat', &
'           character(len=*),intent(inout) :: errmsg', &
'', &
'CHARACTERISTICS', &
'  o  FROM may be of any type and kind.', &
'', &
'  o  TO shall be of the same type, kind and rank as FROM.', &
'', &
'DESCRIPTION', &
'  MOVE_ALLOC(3) moves the allocation from FROM to TO. FROM will become', &
'  deallocated in the process.', &
'', &
'  This is potentially more efficient than other methods of assigning the', &
'  values in FROM to TO and explicitly deallocating FROM, which are far more', &
'  likely to require a temporary object or a copy of the elements of the array.', &
'', &
'OPTIONS', &
'  o  FROM : The data object to be moved to TO and deallocated.', &
'', &
'  o  TO : The destination data object to move the allocated data object FROM', &
'     to. Typically, it is a different shape than FROM.', &
'', &
'  o  STAT : If STAT is present and execution is successful, it is assigned the', &
'     value zero.', &
'', &
'     Otherwise, if an error condition occurs:', &
'', &
'     o if STAT is absent, error termination is initiated; o otherwise, if', &
'       FROM is a coarray and the current team contains a stopped image, STAT', &
'       is assigned the value STAT_STOPPED_IMAGE from the intrinsic module', &
'       ISO_FORTRAN_ENV; o otherwise, if FROM is a coarray and the current', &
'       team contains a failed image, and no other error condition occurs,', &
'       STAT is assigned the value STAT_FAILED_IMAGE from the intrinsic module', &
'       ISO_FORTRAN_ENV; o otherwise, STAT is assigned a processor-dependent', &
'       positive value that differs from that of STAT_STOPPED_IMAGE or', &
'       STAT_FAILED_IMAGE.', &
'', &
'  o  ERRMSG : If the ERRMSG argument is present and an error condition occurs,', &
'     it is assigned an explanatory message. If no error condition occurs, the', &
'     definition status and value of ERRMSG are unchanged.', &
'', &
'EXAMPLES', &
'  Basic sample program to allocate a bigger grid', &
'', &
'      program demo_move_alloc', &
'      implicit none', &
'      ! Example to allocate a bigger GRID', &
'      real, allocatable :: grid(:), tempgrid(:)', &
'      integer :: n, i', &
'', &
'        ! initialize small GRID', &
'        n = 3', &
'        allocate (grid(1:n))', &
'        grid = [ (real (i), i=1,n) ]', &
'', &
'        ! initialize TEMPGRID which will be used to replace GRID', &
'        allocate (tempgrid(1:2*n))    ! Allocate bigger grid', &
'        tempgrid(::2)  = grid         ! Distribute values to new locations', &
'        tempgrid(2::2) = grid + 0.5   ! initialize other values', &
'', &
'        ! move TEMPGRID to GRID', &
'        call MOVE_ALLOC (from=tempgrid, to=grid)', &
'', &
'        ! TEMPGRID should no longer be allocated', &
'        ! and GRID should be the size TEMPGRID was', &
'        if (size (grid) /= 2*n .or. allocated (tempgrid)) then', &
'           print *, "Failure in move_alloc!"', &
'        endif', &
'        print *, allocated(grid), allocated(tempgrid)', &
'        print ''(99f8.3)'', grid', &
'      end program demo_move_alloc', &
'', &
'  Results:', &
'', &
'       > T F', &
'       >   1.000   1.500   2.000   2.500   3.000   3.500', &
'', &
'STANDARD', &
'  Fortran 2003, STAT and ERRMSG options added 2018', &
'', &
'SEE ALSO', &
'  ALLOCATED(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            move_alloc(3fortran)', &
'']

shortname="move_alloc"
call process()

case('168','mvbits')

textblock=[character(len=256) :: &
'', &
'mvbits(3fortran)                                             mvbits(3fortran)', &
'', &
'NAME', &
'  MVBITS(3) - [BIT:COPY] Reproduce bit patterns found in one integer in', &
'  another', &
'', &
'SYNOPSIS', &
'  call mvbits(from, frompos, len, to, topos)', &
'', &
'         elemental subroutine mvbits( from, frompos, len, to, topos )', &
'', &
'          integer(kind=KIND),intent(in)    :: from', &
'          integer(kind=**),intent(in)      :: frompos', &
'          integer(kind=**),intent(in)      :: len', &
'          integer(kind=KIND),intent(inout) :: to', &
'          integer(kind=**),intent(in)      :: topos', &
'', &
'CHARACTERISTICS', &
'  o  FROM is an integer', &
'', &
'  o  FROMPOS is an integer', &
'', &
'  o  LEN is an integer', &
'', &
'  o  TO is an integer of the same kind as FROM.', &
'', &
'  o  TOPOS is an integer', &
'', &
'DESCRIPTION', &
'  MVBITS(3) copies a bit pattern found in a range of adjacent bits in the', &
'  integer FROM to a specified position in another integer TO (which is of the', &
'  same kind as FROM). It otherwise leaves the bits in TO as-is.', &
'', &
'  The bit positions copied must exist within the value of FROM. That is, the', &
'  values of FROMPOS+LEN-1 and TOPOS+LEN-1 must be nonnegative and less than', &
'  BIT_SIZE(from).', &
'', &
'  The bits are numbered 0 to BIT_SIZE(I)-1, from right to left.', &
'', &
'OPTIONS', &
'  o  FROM : An integer to read bits from.', &
'', &
'  o  FROMPOS : FROMPOS is the position of the first bit to copy. It is a', &
'     nonnegative integer value < BIT_SIZE(FROM).', &
'', &
'  o  LEN : A nonnegative integer value that indicates how many bits to copy', &
'     from FROM. It must not specify copying bits past the end of FROM. That', &
'     is, FROMPOS + LEN must be less than or equal to BIT_SIZE(FROM).', &
'', &
'  o  TO : The integer variable to place the copied bits into. It must be of', &
'     the same kind as FROM and may even be the same variable as FROM, or', &
'     associated to it.', &
'', &
'     TO is set by copying the sequence of bits of length LEN, starting at', &
'     position FROMPOS of FROM to position TOPOS of TO. No other bits of TO are', &
'     altered. On return, the LEN bits of TO starting at TOPOS are equal to the', &
'     value that the LEN bits of FROM starting at FROMPOS had on entry.', &
'', &
'  o  TOPOS : A nonnegative integer value indicating the starting location in', &
'     TO to place the specified copy of bits from FROM. TOPOS + LEN must be', &
'     less than or equal to BIT_SIZE(TO).', &
'', &
'EXAMPLES', &
'  Sample program that populates a new 32-bit integer with its bytes in reverse', &
'  order from the input value (ie. changes the Endian of the integer).', &
'', &
'      program demo_mvbits', &
'      use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: intfrom, intto, abcd_int', &
'      character(len=*),parameter :: bits= ''(g0,t30,b32.32)''', &
'      character(len=*),parameter :: fmt= ''(g0,t30,a,t40,b32.32)''', &
'', &
'         intfrom=huge(0)  ! all bits are 1 accept the sign bit', &
'         intto=0          ! all bits are 0', &
'', &
'         !! CHANGE BIT 0', &
'         ! show the value and bit pattern', &
'         write(*,bits)intfrom,intfrom', &
'         write(*,bits)intto,intto', &
'', &
'         ! copy bit 0 from intfrom to intto to show the rightmost bit changes', &
'         !          (from,    frompos, len,    to, topos)', &
'         call mvbits(intfrom,       0,   1, intto,     0) ! change bit 0', &
'         write(*,bits)intto,intto', &
'', &
'         !! COPY PART OF A VALUE TO ITSELF', &
'         ! can copy bit from a value to itself', &
'         call mvbits(intfrom,0,1,intfrom,31)', &
'         write(*,bits)intfrom,intfrom', &
'', &
'         !! MOVING BYTES AT A TIME', &
'         ! make native integer value with bit patterns', &
'         ! that happen to be the same as the beginning of the alphabet', &
'         ! to make it easy to see the bytes are reversed', &
'         abcd_int=transfer(''abcd'',0)', &
'         ! show the value and bit pattern', &
'         write(*,*)''native''', &
'         write(*,fmt)abcd_int,abcd_int,abcd_int', &
'', &
'         ! change endian of the value', &
'         abcd_int=int_swap32(abcd_int)', &
'         ! show the values and their bit pattern', &
'         write(*,*)''non-native''', &
'         write(*,fmt)abcd_int,abcd_int,abcd_int', &
'', &
'       contains', &
'', &
'       pure elemental function int_swap32(intin) result(intout)', &
'       ! Convert a 32 bit integer from big Endian to little Endian,', &
'       ! or conversely from little Endian to big Endian.', &
'       !', &
'       integer(kind=int32), intent(in) :: intin', &
'       integer(kind=int32) :: intout', &
'         ! copy bytes from input value to new position in output value', &
'         !          (from,  frompos, len,     to, topos)', &
'         call mvbits(intin,       0,   8, intout,    24) ! byte1 to byte4', &
'         call mvbits(intin,       8,   8, intout,    16) ! byte2 to byte3', &
'         call mvbits(intin,      16,   8, intout,     8) ! byte3 to byte2', &
'         call mvbits(intin,      24,   8, intout,     0) ! byte4 to byte1', &
'       end function int_swap32', &
'', &
'       end program demo_mvbits', &
'', &
'  Results:', &
'', &
'       > 2147483647                  01111111111111111111111111111111', &
'       > 0                           00000000000000000000000000000000', &
'       > 1                           00000000000000000000000000000001', &
'       > -1                          11111111111111111111111111111111', &
'       >  native', &
'       > 1684234849                  abcd      01100100011000110110001001100001', &
'       >  non-native', &
'       > 1633837924                  dcba      01100001011000100110001101100100', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  BTEST(3), IAND(3), IBCLR(3), IBITS(3), IBSET(3), IEOR(3), IOR(3), NOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                mvbits(3fortran)', &
'']

shortname="mvbits"
call process()

case('169','namelist')

textblock=[character(len=256) :: &
'', &
'namelist(7fortran)                                         namelist(7fortran)', &
'', &
'NAME', &
'  namelist(7f) - [STATEMENT] specify a group of data to be referred to by a', &
'  single name in data input/output', &
'', &
'SYNOPSIS', &
'  NAMELIST /namelist-group-name/ namelist-group-object-list [[,] /namelist-', &
'  group-name/ namelist-group-object-list ] ...', &
'', &
'    namelist-group-object is variable-name', &
'', &
'DESCRIPTION', &
'  A NAMELIST statement specifies a group of named data objects, which may be', &
'  referred to by a single name for the purpose of data transfer.', &
'', &
'  The order in which the variables are specified in the NAMELIST statement', &
'  determines the order in which the values appear on output.', &
'', &
'    o  The namelist-group-name shall not be a name accessed by use', &
'       association.', &
'', &
'    o  A namelist-group-object shall not be an assumed-size array.', &
'', &
'    o  A namelist-group-object shall not have the PRIVATE attribute if the', &
'       namelist-group-name has the PUBLIC attribute.', &
'', &
'  Any namelist-group-name may occur more than once in the NAMELIST statements', &
'  in a scoping unit. The namelist-group-object-list following each successive', &
'  appearance of the same namelist-group-name in a scoping unit is treated as a', &
'  continuation of the list for that namelist-group-name.', &
'', &
'  A namelist group object may be a member of more than one namelist group.', &
'', &
'  A namelist group object shall either be accessed by use or host association', &
'  or shall have its type, type parameters, and shape specified by previous', &
'  specification statements or the procedure heading in the same scoping unit', &
'  or by the implicit typing rules in effect for the scoping unit. If a', &
'  namelist group object is typed by the implicit typing rules, its appearance', &
'  in any subsequent type declaration statement shall confirm the implied type', &
'  and type parameters.', &
'', &
'  The specification-part of a BLOCK construct shall not contain a NAMELIST', &
'  statement.', &
'', &
'  Why is NAMELIST not allowed in a BLOCK unit? Would be handy for quick', &
'  writes, like list-directed output', &
'', &
'         block', &
'            namelist /nlist/ a,b,c,d', &
'            write(*,nlist)', &
'         endblock', &
'', &
'  Input for a namelist input statement consists of', &
'', &
'    1. optional blanks and namelist comments,', &
'', &
'    2. the character & followed immediately by the namelist-group-name as', &
'       specified in the NAMELIST statement,', &
'', &
'    3. one or more blanks,', &
'', &
'    4. a sequence of zero or more name-value subsequences separated by value', &
'       separators, and', &
'', &
'    5. a slash to terminate the namelist input.', &
'', &
'           A slash encountered in a namelist input record causes the input', &
'           statement to terminate. A slash cannot be used to separate two', &
'           values in a namelist input statement.', &
'', &
'    A group name or object name is without regard to case.', &
'', &
'EXAMPLE', &
'  An example of a NAMELIST statement is:', &
'', &
'          NAMELIST /NLIST/ A, B, C', &
'', &
'  or a group may be defined by multiple statements using the same group name', &
'  in a scoping unit:', &
'', &
'          NAMELIST /NLIST/ A, B', &
'          NAMELIST /NLIST/ C', &
'', &
'          ! READ/WRITE EXAMPLES: [ NML = ] namelist-group-name', &
'          READ(*,NML=NLIST)', &
'          WRITE(*,NLIST)', &
'          WRITE(*,NML=NLIST)', &
'', &
'           program sample_namelist', &
'           implicit none', &
'           logical           :: l=.true.', &
'           character(len=10) :: c=''XXXXXXXXXX''', &
'           real              :: r=12.3456', &
'           integer           :: i=789', &
'           complex           :: x=(12345.6789,9876.54321)', &
'           doubleprecision   :: d= 123456789.123456789d0', &
'           namelist /nlist/ l,c,r,i,x,d', &
'              write(*,nlist)', &
'           end program sample_namelist', &
'', &
'  Results:', &
'', &
'        > &NLIST', &
'        >  L=T,', &
'        >  C="XXXXXXXXXX",', &
'        >  R=  12.3456001    ,', &
'        >  I=        789,', &
'        >  X=(  12345.6787    ,  9876.54297    ),', &
'        >  D=  123456789.12345679     ,', &
'        >  /', &
'', &
'  Longer example:', &
'', &
'           program demo_namelist', &
'           implicit none', &
'           integer           :: lun', &
'', &
'           ! create a namelist and initialize the values', &
'           logical           :: l=.true.', &
'           character(len=10) :: c=''XXXXXXXXXX''', &
'           real              :: r=12.3456', &
'           integer           :: i=789', &
'           complex           :: x=(12345.6789,9876.54321)', &
'           doubleprecision   :: d= 123456789.123456789d0', &
'           integer           :: a(5)=[1,2,3,4,5]', &
'           type point', &
'            integer           :: x=0', &
'            integer           :: y=0', &
'            character(len=10) :: color=''red''', &
'           endtype point', &
'           type(point) :: dot', &
'           namelist /nlist/ l,c,r,i,x,d,a,dot', &
'', &
'           open(file=''_tmp_'',newunit=lun,action=''readwrite'')', &
'', &
'              write(*,*)''initial nlist''', &
'              write(*,nlist)', &
'              write(lun,nlist)', &
'', &
'              write(*,*)''change values and print nlist again''', &
'              a=[10,20,30,40,50]', &
'              dot%color=''orange''', &
'              write(lun,nlist)', &
'', &
'              write(*,*)''read back values. Can have multiple sets in a file''', &
'              rewind(lun)', &
'              read(lun,nlist)', &
'              read(lun,nlist)', &
'              write(*,nlist)', &
'', &
'           end program demo_namelist', &
'', &
'  Results:', &
'', &
'        >  initial nlist', &
'        > &NLIST', &
'        >  L=T,', &
'        >  C="XXXXXXXXXX",', &
'        >  R=  12.3456001    ,', &
'        >  I=        789,', &
'        >  X=(12345.6787,9876.54297),', &
'        >  D=  123456789.12345679     ,', &
'        >  A=          1,          2,          3,          4,          5,', &
'        >', &
'        >  DOT%X=          0,', &
'        >  DOT%Y=          0,', &
'        >  DOT%COLOR="red       ",', &
'        >  /', &
'        >  change values and print nlist again', &
'        > read back values. Can have multiple sets in a file', &
'        > &NLIST', &
'        >  L=T,', &
'        >  C="XXXXXXXXXX",', &
'        >  R=  12.3456001    ,', &
'        >  I=        789,', &
'        >  X=(12345.6787,9876.54297),', &
'        >  D=  123456789.12345679     ,', &
'        >  A=         10,         20,         30,         40,         50,', &
'        >', &
'        >  DOT%X=          0,', &
'        >  DOT%Y=          0,', &
'        >  DOT%COLOR="orange    ",', &
'        >  /', &
'', &
'        o Scanning on input till group name is found', &
'        o reading partial lists', &
'        o string quoting', &
'        o NAMELIST in internal read and write. See', &
'', &
'         ./arguments/namelist', &
'', &
'OTHER', &
'  C915 (R913) A namelist-group-name shall be the name of a namelist group.', &
'', &
'  C916 (R913) A namelist-group-name shall not appear if a REC= specifier,', &
'  format, input-item-list, or an output-item-list appears in the data transfer', &
'  statement. C917 (R913) An io-control-spec-list shall not contain both a', &
'  format and a namelist-group-name. C919 (R913) If namelist-group-name appears', &
'  without a preceding NML=, it shall be the second item in the io-control-', &
'  spec-list and the first item shall be io-unit. C928 (R913) If a DECIMAL=,', &
'  BLANK=, PAD=, SIGN=, or ROUND= specifier appears, a format or namelist-', &
'  group-name shall also appear.  C929 (R913) If a DELIM= specifier appears,', &
'  either format shall be an asterisk or namelist-group-name shall appear. 3.', &
'  If the data transfer statement contains a format or namelist-group-name, the', &
'  statement is a formatted input/output statement; otherwise, it is an', &
'  unformatted input/output statement.', &
'', &
'  1.  The NML= specifier supplies the namelist-group-name (5.6). This name', &
'      identifies a particular collection of data objects on which transfer is', &
'      to be performed.', &
'', &
'  2.  If a namelist-group-name appears, the statement is a namelist', &
'      input/output statement.', &
'', &
'  3.  All values following the name= part of the namelist entity (10.11)', &
'      within the input records are transmitted to the matching entity', &
'      specified in the namelist-group-object-list prior to processing any', &
'      succeeding entity within the input record for namelist input statements.', &
'      If an entity is specified more than once within the input record during', &
'      a namelist formatted data transfer input statement, the last occurrence', &
'      of the entity specifies the value or values to be used for that entity.', &
'', &
'  9.6.4.6 Namelist formatting', &
'', &
'  1.  If namelist formatting has been established, editing is performed as', &
'      described in 10.11.', &
'', &
'  2.  Every allocatable namelist-group-object in the namelist group shall be', &
'      allocated and every namelist-group-object that is a pointer shall be', &
'      associated with a target. If a namelist-group-object is polymorphic or', &
'      has an ultimate component that is allocatable or a pointer, that object', &
'      shall be processed by a defined input/output procedure (9.6.4.7).', &
'', &
'  9.6.5 Termination of data transfer statements', &
'', &
'  1.  Termination of an input/output data transfer statement occurs when', &
'', &
'      format processing encounters a colon or data edit descriptor and', &
'      there are no remaining elements in the input-item-list or', &
'      output-item-list,', &
'', &
'      unformatted or list-directed data transfer exhausts the', &
'      input-item-list or output-item-list, namelist output exhausts the', &
'      namelist-group-object-list,', &
'', &
'      an error condition occurs,', &
'', &
'      an end-of-file condition occurs,', &
'', &
'      a slash (/) is encountered as a value separator (10.10, 10.11) in', &
'      the record being read during list-directed or namelist input, or an', &
'      end-of-record condition occurs during execution of a nonadvancing', &
'      input statement (9.11).', &
'', &
'  2.  If an error condition occurs during execution of an input/output', &
'      statement that contains neither an ERR= nor IOSTAT= specifier, error', &
'      termination of the program is initiated. If an error condition occurs', &
'      during execution of an input/output statement that contains either an', &
'      ERR= specifier or an IOSTAT= specifier then: 1. processing of the', &
'      input/output list, if any, terminates;', &
'', &
'      2.  if the statement is a data transfer statement or the error occurs', &
'         during a wait operation, all do-variables in the statement that', &
'         initiated the transfer become undefined;', &
'', &
'      3.  if an IOSTAT= specifier appears, the scalar-int-variable in the', &
'         IOSTAT= specifier becomes defined as specified in 9.11.5;', &
'', &
'      4.  if an IOMSG= specifier appears, the iomsg-variable becomes defined', &
'         as specified in 9.11.6;', &
'', &
'      5.  if the statement is a READ statement and it contains a SIZE=', &
'         specifier, the scalar-int-variable in the SIZE= specifier becomes', &
'         defined as specified in 9.6.2.15;', &
'', &
'      6.  if the statement is a READ statement or the error condition occurs', &
'         in a wait operation for a transfer initiated by a READ statement,', &
'         all input items or namelist group objects in the statement that', &
'         initiated the transfer become undefined;', &
'', &
'      7.  if an ERR= specifier appears, a branch to the statement labeled by', &
'         the label in the ERR= specifier occurs.', &
'', &
'  3.  In a data transfer statement, the variable specified in an IOSTAT=,', &
'      IOMSG=, or SIZE= specifier, if any, shall not be associated with any', &
'      entity in the data transfer input/output list (9.6.3) or namelist-group-', &
'      object-list, nor with a do-variable of an io-implied-do in the data', &
'      transfer input/output list. 10.11 Namelist formatting 10.11.1 General', &
'', &
'  4.  Namelist input/output allows data editing with NAME=value subsequences.', &
'      This facilitates documentation of input and output files and more', &
'      flexibility on input.', &
'', &
'  10.11.2 Name-value subsequences', &
'', &
'  1.  The characters in one or more namelist records constitute a sequence of', &
'      name-value subsequences, each of which consists of an object designator', &
'      followed by an equals and followed by one or more values and value', &
'      separators. The equals may optionally be preceded or followed by one or', &
'      more contiguous blanks. The end of a record has the same effect as a', &
'      blank character, unless it is within a character constant. Any sequence', &
'      of two or more consecutive blanks is treated as a single blank, unless', &
'      it is within a character constant.', &
'', &
'  2.  The name may be any name in the namelist-group-object-list (5.6).', &
'', &
'  3.  A value separator for namelist formatting is the same as for list-', &
'      directed formatting (10.10).', &
'', &
'  10.11.3 Namelist input 10.11.3.1 Overall syntax', &
'', &
'  2.  In each name-value subsequence, the name shall be the name of a namelist', &
'      group object list item with an optional qualification and the name with', &
'      the optional qualification shall not be a zero-sized array, a zero-sized', &
'      array section, or a zero-length character string. The optional', &
'      qualification, if any, shall not contain a vector subscript.', &
'', &
'  10.11.3.2 Namelist group object names', &
'', &
'  1.  Within the input data, each name shall correspond to a particular', &
'      namelist group object name. Subscripts, strides, and substring range', &
'      expressions used to qualify group object names shall be optionally', &
'      signed integer literal constants with no kind type parameters specified.', &
'      If a namelist group object is an array, the input record corresponding', &
'      to it may contain either the array name or the designator of a subobject', &
'      of that array, using the syntax of object designators (R601). If the', &
'      namelist group object name is the name of a variable of derived type,', &
'      the name in the input record may be either the name of the variable or', &
'      the designator of one of its components, indicated by qualifying the', &
'      variable name with the appropriate component name. Successive', &
'      qualifications may be applied as appropriate to the shape and type of', &
'      the variable represented.', &
'', &
'  2.  The order of names in the input records need not match the order of the', &
'      namelist group object items. The input records need not contain all the', &
'      names of the namelist group object items. The definition status of any', &
'      names from the namelist-group-object-list that do not occur in the input', &
'      record remains unchanged. In the input record, each object name or', &
'      subobject designator may be preceded and followed by one or more', &
'      optional blanks but shall not contain embedded blanks.', &
'', &
'  10.11.3.3 Namelist group object list items', &
'', &
'  1.  The name-value subsequences are evaluated serially, in left-to-right', &
'      order. A namelist group object designator may appear in more than one', &
'      name-value sequence.', &
'', &
'  2.  When the name in the input record represents an array variable or a', &
'      variable of derived type, the effect is as if the variable represented', &
'      were expanded into a sequence of scalar list items, in the same way that', &
'      formatted input/output list items are expanded (9.6.3). Each input value', &
'      following the equals shall then be acceptable to format specifications', &
'      for the type of the list item in the corresponding position in the', &
'      expanded sequence, except as noted in this subclause. The number of', &
'      values following the equals shall not exceed the number of list items in', &
'      the expanded sequence, but may be less; in the latter case, the effect', &
'      is as if sufficient null values had been appended to match any remaining', &
'      list items in the expanded sequence.', &
'', &
'      NOTE 10.35 For example, if the name in the input record is the name of', &
'      an integer array of size 100, at most 100 values, each of which is', &
'      either a digit string or a null value, may follow the equals; these', &
'      values would then be assigned to the elements of the array in array', &
'      element order.', &
'', &
'  3.  A slash encountered as a value separator during the execution of a', &
'      namelist input statement causes termination of execution of that input', &
'      statement after transference of the previous value. If there are', &
'      additional items in the namelist group object being transferred, the', &
'      effect is as if null values had been supplied for them.', &
'', &
'  4.  A namelist comment may appear after any value separator except a slash.', &
'      A namelist comment is also permitted to start in the first nonblank', &
'      position of an input record except within a character literal constant.', &
'', &
'  5.  Successive namelist records are read by namelist input until a slash is', &
'      encountered; the remainder of the record is ignored and need not follow', &
'      the rules for namelist input values.', &
'', &
'      10.11.3.4 Namelist input values', &
'', &
'  6.  Each value is either a null value (10.11.3.5), c, r*c, or r*, where c is', &
'      a literal constant, optionally signed if integer or real, and r is an', &
'      unsigned, nonzero, integer literal constant. A kind type parameter shall', &
'      not be specified for c or r. The constant c is interpreted as though it', &
'      had the same kind type parameter as the corresponding effective item.', &
'      The r*c form is equivalent to r successive appearances of the constant', &
'      c, and the r * form is equivalent to r successive null values. Neither', &
'      of these forms may contain embedded blanks, except where permitted', &
'      within the constant c.', &
'', &
'  7.  The datum c (10.11) is any input value acceptable to format', &
'      specifications for a given type, except for a restriction on the form of', &
'      input values corresponding to list items of types logical, integer, and', &
'      character as specified in this subclause. The form of a real or complex', &
'      value is dependent on the decimal edit mode in effect (10.6). The form', &
'', &
'      of an input value shall be acceptable for the type of the namelist group', &
'      object list item. The number and forms of the input values that may', &
'      follow the equals in a name-value subsequence depend on the shape and', &
'      type of the object represented by the name in the input record. When the', &
'      name in the input record is that of a scalar variable of an intrinsic', &
'      type, the equals shall not be followed by more than one value. Blanks', &
'      are never used as zeros, and embedded blanks are not permitted in', &
'      constants except within character constants and complex constants as', &
'      specified in this subclause.', &
'', &
'  8.  When the next effective item is of type real, the input form of the', &
'      input value is that of a numeric input field. A numeric input field is a', &
'      field suitable for F editing (10.7.2.3.2) that is assumed to have no', &
'      fractional digits unless a decimal symbol appears within the field.', &
'', &
'  9.  When the next effective item is of type complex, the input form of the', &
'      input value consists of a left parenthesis followed by an ordered pair', &
'      of numeric input fields separated by a comma (if the decimal edit mode', &
'      is POINT) or a semicolon (if the decimal edit mode is COMMA), and', &
'      followed by a right parenthesis. The first numeric input field is the', &
'      real part of the complex constant and the second part is the imaginary', &
'      part. Each of the numeric input fields may be preceded or followed by', &
'      any number of blanks and ends of records.  The end of a record may occur', &
'      between the real part and the comma or semicolon, or between the comma', &
'      or semicolon and the imaginary part.', &
'', &
'  10. When the next effective item is of type logical, the input form of the', &
'      input value shall not include equals or value separators among the', &
'      optional characters permitted for L editing (10.7.3).', &
'', &
'  11. When the next effective item is of type integer, the value in the input', &
'      record is interpreted as if an Iw edit descriptor with a suitable value', &
'      of w were used.', &
'', &
'  12. When the next effective item is of type character, the input form', &
'      consists of a delimited sequence of zero or more rep-char s whose kind', &
'      type parameter is implied by the kind of the corresponding list item.', &
'      Such a sequence may be continued from the end of one record to the', &
'      beginning of the next record, but the end of record shall not occur', &
'      between a doubled apostrophe in an apostrophe-delimited sequence, nor', &
'      between a doubled quote in a quote-delimited sequence.  The end of the', &
'      record does not cause a blank or any other character to become part of', &
'      the sequence. The sequence may be continued on as many records as', &
'      needed. The characters blank, comma, semicolon, and slash may appear in', &
'      such character sequences.', &
'', &
'      NOTE 10.36 A character sequence corresponding to a namelist input item', &
'      of character type shall be delimited either with apostrophes or with', &
'      quotes. The delimiter is required to avoid ambiguity between undelimited', &
'      character sequences and object names. The value of the DELIM= specifier,', &
'      if any, in the OPEN statement for an external file is ignored during', &
'      namelist input (9.5.6.8).', &
'', &
'  13. Let len be the length of the next effective item, and let w be the', &
'      length of the character sequence. If len is less than or equal to w, the', &
'      leftmost len characters of the sequence are transmitted to the next', &
'      effective item. If len is greater than w, the constant is transmitted to', &
'      the leftmost w characters of the next effective item and the remaining', &
'      len-w characters of the next effective item are filled with blanks. The', &
'      effect is as though the sequence were assigned to the next effective', &
'      item in an intrinsic assignment statement (7.2.1.3).', &
'', &
'  10.11.3.5 Null values', &
'', &
'  1.  A null value is specified by', &
'', &
'      the r * form,', &
'', &
'      blanks between two consecutive nonblank value separators following', &
'      an equals,', &
'', &
'      zero or more blanks preceding the first value separator and', &
'      following an equals, or two consecutive nonblank value separators.', &
'', &
'  2.  A null value has no effect on the definition status of the corresponding', &
'      input list item. If the namelist group object list item is defined, it', &
'      retains its previous value; if it is undefined, it remains undefined. A', &
'      null value shall', &
'', &
'      not be used as either the real or imaginary part of a complex constant,', &
'      but a single null value may represent an entire complex constant.', &
'', &
'      NOTE 10.37 The end of a record following a value separator, with or', &
'      without intervening blanks, does not specify a null value in namelist', &
'      input.', &
'', &
'  10.11.3.6 Blanks', &
'', &
'  1.  All blanks in a namelist input record are considered to be part of some', &
'      value separator except for', &
'', &
'      o  blanks embedded in a character constant, o embedded blanks', &
'        surrounding the real or imaginary part of a complex constant, o', &
'        leading blanks following the equals unless followed immediately by a', &
'        slash or comma, or a semicolon if the o decimal edit mode is comma,', &
'        and o blanks between a name and the following equals.', &
'', &
'  10.11.3.7 Namelist Comments', &
'', &
'  1.  Except within a character literal constant, a "!" character after a', &
'      value separator or in the first nonblank position of a namelist input', &
'      record initiates a comment. The comment extends to the end of the', &
'      current input record and may contain any graphic character in the', &
'      processor-dependent character set. The comment is ignored. A slash', &
'      within the namelist comment does not terminate execution of the namelist', &
'      input statement. Namelist comments are not allowed in stream input', &
'      because comments depend on record structure.', &
'', &
'      NOTE 10.38 Namelist input example:', &
'', &
'            INTEGER I; REAL X (8); CHARACTER (11) P; COMPLEX Z;', &
'            LOGICAL :: G', &
'            NAMELIST / TODAY / G, I, P, Z, X', &
'            READ (*, NML = TODAY)', &
'', &
'      The input data records are:', &
'', &
'            &TODAY I = 12345, X(1) = 12345, X(3:4) = 2*1.5,', &
'             I=6, ! This is a comment.', &
'             P = ''''ISN''T_BOB''S'''', Z = (123,0)/', &
'', &
'             The results stored are:', &
'', &
'                      Variable                         Value', &
'                        I                                6', &
'                        X (1)                            12345.0', &
'                        X (2)                            unchanged', &
'                        X (3)                            1.5', &
'                        X (4)                            1.5', &
'                        X (5)   X (8)                    unchanged', &
'                        P                                ISN''T BOB''S', &
'                        Z                                (123.0,0.0)', &
'                        G                                unchanged', &
'', &
'      10.11.4 Namelist output 10.11.4.1 Form of namelist output', &
'', &
'  1.  The form of the output produced is the same as that required for input,', &
'      except for the forms of real, character, and logical values.  The name', &
'      in the output is in upper case. With the exception of adjacent', &
'      undelimited character values, the values are separated by one or more', &
'      blanks or by a comma, or a semicolon if the decimal edit mode is COMMA,', &
'      optionally preceded by one or more blanks and optionally followed by one', &
'      or more blanks.', &
'', &
'  2.  Namelist output shall not include namelist comments.', &
'', &
'  3.  The processor may begin new records as necessary. However, except for', &
'      complex constants and character values, the end of a record shall not', &
'      occur within a constant, character value, or name, and blanks shall not', &
'      appear within a constant, character value, or name.', &
'', &
'      NOTE 10.39 The length of the output records is not specified exactly and', &
'      may be processor dependent.', &
'', &
'  10.11.4.2 Namelist output editing', &
'', &
'  1.  Values in namelist output records are edited as for list-directed output', &
'      (10.10.4).', &
'', &
'      NOTE 10.40 Namelist output records produced with a DELIM= specifier with', &
'      a value of NONE and which contain a character sequence might not be', &
'      acceptable as namelist input records.', &
'', &
'  10.11.4.3 Namelist output records', &
'', &
'  1.  If two or more successive values for the same namelist group item in an', &
'      output record produced have identical values, the processor has the', &
'      option of producing a repeated constant of the form r *c instead of the', &
'      sequence of identical values.', &
'', &
'  2.  The name of each namelist group object list item is placed in the output', &
'      record followed by an equals and a list of values of the namelist group', &
'      object list item.', &
'', &
'  3.  An ampersand character followed immediately by a namelist-group-name', &
'      will be produced by namelist formatting at the start of the first output', &
'      record to indicate which particular group of data objects is being', &
'      output. A slash is produced by namelist formatting to indicate the end', &
'      of the namelist formatting.', &
'', &
'  4.  A null value is not produced by namelist formatting.', &
'', &
'  5.  Except for new records created by explicit formatting within a defined', &
'      output procedure or by continuation of delimited character sequences,', &
'      each output record begins with a blank character.', &
'', &
'                               March 16, 2025              namelist(7fortran)', &
'']

shortname="namelist"
call process()

case('170','nearest')

textblock=[character(len=256) :: &
'', &
'nearest(3fortran)                                           nearest(3fortran)', &
'', &
'NAME', &
'  NEAREST(3) - [MODEL:COMPONENTS] Nearest representable number', &
'', &
'SYNOPSIS', &
'  result = nearest(x, s)', &
'', &
'          elemental real(kind=KIND) function nearest(x,s)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'           real(kind=**),intent(in) :: s', &
'', &
'CHARACTERISTICS', &
'  o  X may be a real value of any kind.', &
'', &
'  o  S may be a real value of any kind.', &
'', &
'  o  The return value is of the same type and kind as X.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  NEAREST(3) returns the processor-representable number nearest to X in the', &
'  direction indicated by the sign of S.', &
'', &
'OPTIONS', &
'  o  X : the value to find the nearest representable value of', &
'', &
'  o  S : a non-zero value whose sign is used to determine the direction in', &
'     which to search from X to the representable value.', &
'', &
'     If S is positive, NEAREST returns the processor-representable number', &
'     greater than X and nearest to it.', &
'', &
'     If S is negative, NEAREST returns the processor-representable number', &
'     smaller than X and nearest to it.', &
'', &
'RESULT', &
'  The return value is of the same type as X. If S is positive, NEAREST returns', &
'  the processor-representable number greater than X and nearest to it. If S is', &
'  negative, NEAREST returns the processor-representable number smaller than X', &
'  and nearest to it.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_nearest', &
'      implicit none', &
'', &
'        real :: x, y', &
'        x = nearest(42.0, 1.0)', &
'        y = nearest(42.0, -1.0)', &
'        write (*,"(3(g20.15))") x, y, x - y', &
'', &
'      !  write (*,"(3(g20.15))") &', &
'      !   nearest(tiny(0.0),1.0), &', &
'      !   nearest(tiny(0.0),-1.0), &', &
'      !   nearest(tiny(0.0),1.0) -nearest(tiny(0.0),-1.0)', &
'', &
'      !  write (*,"(3(g20.15))") &', &
'      !   nearest(huge(0.0),1.0), &', &
'      !   nearest(huge(0.0),-1.0), &', &
'      !   nearest(huge(0.0),1.0)- nearest(huge(0.0),-1.0)', &
'', &
'      end program demo_nearest', &
'', &
'  Results:', &
'', &
'       > 42.0000038146973    41.9999961853027    .762939453125000E-05', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025               nearest(3fortran)', &
'']

shortname="nearest"
call process()

case('171','new_line')

textblock=[character(len=256) :: &
'', &
'new_line(3fortran)                                         new_line(3fortran)', &
'', &
'NAME', &
'  NEW_LINE(3) - [CHARACTER:INQUIRY] Newline character', &
'', &
'SYNOPSIS', &
'  result = new_line(c)', &
'', &
'          character(len=1,kind=KIND) function new_line(c)', &
'', &
'           character(len=1,kind=KIND),intent(in) :: c(..)', &
'', &
'CHARACTERISTICS', &
'  o  C shall be of type character. It may be a scalar or an array.', &
'', &
'  o  the result is a character scalar of length one with the same kind type', &
'     parameter as C.', &
'', &
'DESCRIPTION', &
'  NEW_LINE(3) returns the newline character.', &
'', &
'  Normally, newlines are generated with regular formatted I/O statements like', &
'  WRITE() and PRINT() when each statement completes:', &
'', &
'        print *, ''x=11''', &
'        print *', &
'        print *, ''y=22''', &
'        end', &
'', &
'  produces:', &
'', &
'         x=11', &
'', &
'         y=22', &
'', &
'  Alternatively, a "/" descriptor in a format is used to generate a newline on', &
'  the output. For example:', &
'', &
'        write(*,''(a,1x,i0,/,a)'') ''x ='',11,''is the answer''', &
'        end', &
'', &
'  produces:', &
'', &
'        x = 11', &
'        is the answer', &
'', &
'  Also, for formatted sequential output if more data is listed on the output', &
'  statement than can be represented by the format statement a newline is', &
'  generated and then the format is reused until the output list is exhausted.', &
'', &
'        write(*,''(a,"=",i0)'') ''x'', 10, ''y'', 20', &
'        end', &
'', &
'  produces', &
'', &
'        x=10', &
'        y=20', &
'', &
'  But there are occasions, particularly when non-advancing I/O or stream I/O', &
'  is being generated (which does not generate a newline at the end of each', &
'  WRITE statement, as normally occurs) where it is preferable to place a', &
'  newline explicitly in the output at specified points.', &
'', &
'  To do so you must make sure you are generating the correct newline', &
'  character, which the techniques above do automatically.', &
'', &
'  The newline character varies between some platforms, and can even depend on', &
'  the encoding (ie. which character set is being used) of the output file. In', &
'  these cases selecting the correct character to output can be determined by', &
'  the NEW_LINE(3) procedure.', &
'', &
'OPTIONS', &
'  o  C : an arbitrary character whose kind is used to decide on the output', &
'     character that represents a newline.', &
'', &
'RESULT', &
'  Case (i) : If A is default character and the character in position 10 of the', &
'  ASCII collating sequence is representable in the default character set, then', &
'  the result is ACHAR(10).', &
'', &
'  This is the typical case, and just requires using "new_line(''a'')".', &
'', &
'  Case (ii) : If A is an ASCII character or an ISO 10646 character, then the', &
'  result is CHAR(10, KIND (A)).', &
'', &
'  Case (iii) : Otherwise, the result is a processor-dependent character that', &
'  represents a newline in output to files connected for formatted stream', &
'  output if there is such a character.', &
'', &
'  Case (iv) : If not of the previous cases apply, the result is the blank', &
'  character.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_new_line', &
'      implicit none', &
'      character,parameter :: nl=new_line(''a'')', &
'      character(len=:),allocatable :: string', &
'      real :: r', &
'      integer :: i, count', &
'', &
'       ! basics', &
'        ! print a string with a newline embedded in it', &
'        string=''This is record 1.''//nl//''This is record 2.''', &
'        write(*,''(a)'') string', &
'', &
'        ! print a newline character string', &
'        write(*,''(*(a))'',advance=''no'') &', &
'           nl,''This is record 1.'',nl,''This is record 2.'',nl', &
'', &
'        ! output a number of words of random length as a paragraph', &
'        ! by inserting a new_line before line exceeds 70 characters', &
'', &
'       ! simplistic paragraph print using non-advancing I/O', &
'        count=0', &
'        do i=1,100', &
'', &
'           ! make some fake word of random length', &
'           call random_number(r)', &
'           string=repeat(''x'',int(r*10)+1)', &
'', &
'           count=count+len(string)+1', &
'           if(count.gt.70)then', &
'              write(*,''(a)'',advance=''no'')nl', &
'              count=len(string)+1', &
'           endif', &
'           write(*,''(1x,a)'',advance=''no'')string', &
'        enddo', &
'        write(*,''(a)'',advance=''no'')nl', &
'', &
'      end program demo_new_line', &
'', &
'  Results:', &
'', &
'       > This is record 1.', &
'       > This is record 2.', &
'       >', &
'       > This is record 1.', &
'       > This is record 2.', &
'       >  x x xxxx xxxxxxx xxxxxxxxxx xxxxxxxxx xxxx xxxxxxxxxx xxxxxxxx', &
'       >  xxxxxxxxx xxxx xxxxxxxxx x xxxxxxxxx xxxxxxxx xxxxxxxx xxxx x', &
'       >  xxxxxxxxxx x x x xxxxxx xxxxxxxxxx x xxxxxxxxxx x xxxxxxx xxxxxxxxx', &
'       >  xx xxxxxxxxxx xxxxxxxx x xx xxxxxxxxxx xxxxxxxx xxx xxxxxxx xxxxxx', &
'       >  xxxxx xxxxxxxxx x xxxxxxxxxx xxxxxx xxxxxxxx xxxxx xxxxxxxx xxxxxxxx', &
'       >  xxxxx xxx xxxxxxxx xxxxxxx xxxxxxxx xxx xxxx xxx xxxxxxxx xxxxxx', &
'       >  xxxxxxx xxxxxxx xxxxx xxxxx xx xxxxxx xx xxxxxxxxxx xxxxxx x xxxx', &
'       >  xxxxxx xxxxxxx x xxx xxxxx xxxxxxxxx xxx xxxxxxx x xxxxxx xxxxxxxxx', &
'       >  xxxx xxxxxxxxx xxxxxxxx xxxxxxxx xxx xxxxxxx xxxxxxx xxxxxxxxxx', &
'       >  xxxxxxxxxx xxxxxx xxxxx xxxx xxxxxxx xx xxxxxxxxxx xxxxxx xxxxxx', &
'       >  xxxxxx xxxx xxxxx', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  ACHAR(3), CHAR(3), IACHAR(3), ICHAR(3), SELECTED_CHAR_KIND(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              new_line(3fortran)', &
'']

shortname="new_line"
call process()

case('172','nint')

textblock=[character(len=256) :: &
'', &
'nint(3fortran)                                                 nint(3fortran)', &
'', &
'NAME', &
'  NINT(3) - [TYPE:CONVERSION] Nearest whole number', &
'', &
'SYNOPSIS', &
'  result = nint( a [,kind] )', &
'', &
'          elemental integer(kind=KIND) function nint(a, kind )', &
'', &
'           real(kind=**),intent(in) :: a', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  A is type real of any kind', &
'', &
'  o  KIND is a scalar integer constant expression', &
'', &
'  o  The result is default integer kind or the value of KIND if KIND is', &
'     present.', &
'', &
'DESCRIPTION', &
'  NINT(3) rounds its argument to the nearest whole number with its sign', &
'  preserved.', &
'', &
'  The user must ensure the value is a valid value for the range of the KIND', &
'  returned. If the processor cannot represent the result in the kind', &
'  specified, the result is undefined.', &
'', &
'  If A is greater than zero, NINT(A) has the value INT(A+0.5).', &
'', &
'  If A is less than or equal to zero, NINT(A) has the value INT(A-0.5).', &
'', &
'OPTIONS', &
'  o  A : The value to round to the nearest whole number', &
'', &
'  o  KIND : can specify the kind of the output value. If not present, the', &
'     output is the default type of integer.', &
'', &
'RESULT', &
'  The result is the integer nearest A, or if there are two integers equally', &
'  near A, the result is whichever such integer has the greater magnitude.', &
'', &
'  The result is undefined if it cannot be represented in the specified integer', &
'  type.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_nint', &
'      implicit none', &
'      integer,parameter   :: dp=kind(0.0d0)', &
'      real,allocatable   :: in(:)', &
'      integer,allocatable :: out(:)', &
'      integer            :: i', &
'      real               :: x4', &
'      real(kind=dp)      :: x8', &
'', &
'       ! basic use', &
'        x4 = 1.234E0', &
'        x8 = 4.721_dp', &
'        print *, nint(x4), nint(-x4)', &
'        print *, nint(x8), nint(-x8)', &
'', &
'       ! elemental', &
'        in = [ -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, -0.4, &', &
'             &  0.0,   &', &
'             & +0.04, +0.5, +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ]', &
'        out = nint(in)', &
'        do i=1,size(in)', &
'           write(*,*)in(i),out(i)', &
'        enddo', &
'', &
'       ! dusty corners', &
'        ISSUES: block', &
'        use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'        integer :: icheck', &
'           ! make sure input is in range for the type returned', &
'           write(*,*)''Range limits for typical KINDS:''', &
'           write(*,''(1x,g0,1x,g0)'')  &', &
'           & int8,huge(0_int8),   &', &
'           & int16,huge(0_int16), &', &
'           & int32,huge(0_int32), &', &
'           & int64,huge(0_int64)', &
'', &
'           ! the standard does not require this to be an error ...', &
'           x8=12345.67e15 ! too big of a number', &
'           icheck=selected_int_kind(ceiling(log10(x8)))', &
'           write(*,*)''Any KIND big enough? ICHECK='',icheck', &
'           print *, ''These are all wrong answers for '',x8', &
'           print *, nint(x8,kind=int8)', &
'           print *, nint(x8,kind=int16)', &
'           print *, nint(x8,kind=int32)', &
'           print *, nint(x8,kind=int64)', &
'        endblock ISSUES', &
'', &
'      end program demo_nint', &
'', &
'  Results:', &
'', &
'       >              1          -1', &
'       >              5          -5', &
'       >      -2.700000             -3', &
'       >      -2.500000             -3', &
'       >      -2.200000             -2', &
'       >      -2.000000             -2', &
'       >      -1.500000             -2', &
'       >      -1.000000             -1', &
'       >     -0.5000000             -1', &
'       >     -0.4000000              0', &
'       >      0.0000000E+00          0', &
'       >      3.9999999E-02          0', &
'       >      0.5000000              1', &
'       >       1.000000              1', &
'       >       1.500000              2', &
'       >       2.000000              2', &
'       >       2.200000              2', &
'       >       2.500000              3', &
'       >       2.700000              3', &
'       >     Range limits for typical KINDS:', &
'       >     1 127', &
'       >     2 32767', &
'       >     4 2147483647', &
'       >     8 9223372036854775807', &
'       >     Any KIND big enough? ICHECK=         -1', &
'       >     These are all wrong answers for   1.234566949990144E+019', &
'       >       0', &
'       >         0', &
'       >     -2147483648', &
'       >      -9223372036854775808', &
'', &
'STANDARD', &
'  FORTRAN 77 , with KIND argument - Fortran 90', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), INT(3), SELECTED_INT_KIND(3), CEILING(3), FLOOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  nint(3fortran)', &
'']

shortname="nint"
call process()

case('173','norm2')

textblock=[character(len=256) :: &
'', &
'norm2(3fortran)                                               norm2(3fortran)', &
'', &
'NAME', &
'  NORM2(3) - [MATHEMATICS] Euclidean vector norm', &
'', &
'SYNOPSIS', &
'  result = norm2(array, [dim])', &
'', &
'          real(kind=KIND) function norm2(array, dim)', &
'', &
'           real(kind=KIND),intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY shall be an array of type real.', &
'', &
'  o  DIM shall be a scalar of type integer', &
'', &
'  o  The result is of the same type as ARRAY.', &
'', &
'DESCRIPTION', &
'  NORM2(3) calculates the Euclidean vector norm (L_2 norm or generalized L', &
'  norm) of ARRAY along dimension DIM.', &
'', &
'OPTIONS', &
'  o  ARRAY : the array of input values for the L_2 norm computations', &
'', &
'  o  DIM : a value in the range from 1 to RANK(ARRAY).', &
'', &
'RESULT', &
'  If DIM is absent, a scalar with the square root of the sum of squares of the', &
'  elements of ARRAY is returned.', &
'', &
'  Otherwise, an array of rank N-1, where N equals the rank of ARRAY, and a', &
'  shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'', &
'  Case (i) : The result of NORM2 (X) has a value equal to a processor-', &
'  dependent approximation to the generalized L norm of X, which is the square', &
'  root of the sum of the squares of the elements of X. If X has size zero, the', &
'  result has the value zero.', &
'', &
'  Case (ii) : The result of NORM2 (X, DIM=DIM) has a value equal to that of', &
'  NORM2 (X) if X has rank one. Otherwise, the resulting array is reduced in', &
'  rank with dimension DIM removed, and each remaining elment is the result of', &
'  NORM2(X) for the values along dimension DIM.', &
'', &
'  It is recommended that the processor compute the result without undue', &
'  overflow or underflow.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_norm2', &
'      implicit none', &
'      integer :: i', &
'      real :: x(2,3) = reshape([ &', &
'        1, 2, 3, &', &
'        4, 5, 6  &', &
'        ],shape(x),order=[2,1])', &
'', &
'       write(*,*) ''input in row-column order''', &
'       write(*,*) ''x=''', &
'       write(*,''(4x,3f4.0)'')transpose(x)', &
'       write(*,*)', &
'       write(*,*) ''norm2(x)='',norm2(x)', &
'       write(*,*) ''which is equivalent to''', &
'       write(*,*) ''sqrt(sum(x**2))='',sqrt(sum(x**2))', &
'       write(*,*)', &
'       write(*,*) ''for reference the array squared is''', &
'       write(*,*) ''x**2=''', &
'       write(*,''(4x,3f4.0)'')transpose(x**2)', &
'       write(*,*)', &
'       write(*,*) ''norm2(x,dim=1)='',norm2(x,dim=1)', &
'       write(*,*) ''norm2(x,dim=2)='',norm2(x,dim=2)', &
'       write(*,*) ''(sqrt(sum(x(:,i)**2)),i=1,3)='',(sqrt(sum(x(:,i)**2)),i=1,3)', &
'       write(*,*) ''(sqrt(sum(x(i,:)**2)),i=1,2)='',(sqrt(sum(x(i,:)**2)),i=1,2)', &
'', &
'      end program demo_norm2', &
'', &
'  Results:', &
'', &
'       >  input in row-column order', &
'       >  x=', &
'       >       1.  2.  3.', &
'       >       4.  5.  6.', &
'       >', &
'       >  norm2(x)=   9.539392', &
'       >  which is equivalent to', &
'       >  sqrt(sum(x**2))=   9.539392', &
'       >', &
'       >  for reference the array squared is', &
'       >  x**2=', &
'       >       1.  4.  9.', &
'       >      16. 25. 36.', &
'       >', &
'       >  norm2(x,dim=1)=   4.123106      5.385165       6.708204', &
'       >  norm2(x,dim=2)=   3.741657      8.774964', &
'       >  (sqrt(sum(x(:,i)**2)),i=1,3)=   4.123106      5.385165       6.708204', &
'       >  (sqrt(sum(x(i,:)**2)),i=1,2)=   3.741657      8.774964', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  PRODUCT(3), SUM(3), HYPOT(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 norm2(3fortran)', &
'']

shortname="norm2"
call process()

case('174','not')

textblock=[character(len=256) :: &
'', &
'not(3fortran)                                                   not(3fortran)', &
'', &
'NAME', &
'  NOT(3) - [BIT:LOGICAL] Logical negation; flips all bits in an integer', &
'', &
'SYNOPSIS', &
'  result = not(i)', &
'', &
'  elemental integer(kind=KIND) function not(i)', &
'', &
'          integer(kind=KIND), intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I may be an integer of any valid kind', &
'', &
'  o  The returned integer is of the same kind as the argument I.', &
'', &
'DESCRIPTION', &
'  NOT(3) returns the bitwise Boolean inverse of I. This is also known as the', &
'  "Bitwise complement" or "Logical negation" of the value.', &
'', &
'  If an input bit is a one, that position is a zero on output. Conversely any', &
'  input bit that is zero is a one on output.', &
'', &
'OPTIONS', &
'  o  I : The value to flip the bits of.', &
'', &
'RESULT', &
'  The result has the value obtained by complementing I bit-by-bit according to', &
'  the following truth table:', &
'', &
'        >    I   |  NOT(I)', &
'        >    ----#----------', &
'        >    1   |   0', &
'        >    0   |   1', &
'', &
'  That is, every input bit is flipped.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_not', &
'      implicit none', &
'      integer :: i', &
'       ! basics', &
'        i=-13741', &
'        print *,''the input value'',i,''represented in bits is''', &
'        write(*,''(1x,b32.32,1x,i0)'') i, i', &
'        i=not(i)', &
'        print *,''on output it is'',i', &
'        write(*,''(1x,b32.32,1x,i0)'') i, i', &
'        print *, " on a two''s complement machine flip the bits and add 1"', &
'        print *, " to get the value with the sign changed, for example."', &
'        print *, 1234, not(1234)+1', &
'        print *, -1234, not(-1234)+1', &
'        print *, " of course ''x=-x'' works just fine and more generally."', &
'      end program demo_not', &
'', &
'  Results:', &
'', &
'       > the input value      -13741 represented in bits is', &
'       > 11111111111111111100101001010011 -13741', &
'       > on output it is       13740', &
'       > 00000000000000000011010110101100 13740', &
'       >  on a two''s complement machine flip the bits and add 1', &
'       >  to get the value with the sign changed, for example.', &
'       >        1234       -1234', &
'       >       -1234        1234', &
'       >  of course ''x=-x'' works just fine and more generally.', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  IAND(3), IOR(3), IEOR(3), IBITS(3), IBSET(3),', &
'', &
'  IBCLR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   not(3fortran)', &
'']

shortname="not"
call process()

case('175','null')

textblock=[character(len=256) :: &
'', &
'null(3fortran)                                                 null(3fortran)', &
'', &
'NAME', &
'  NULL(3) - [TRANSFORMATIONAL] Function that returns a disassociated pointer', &
'', &
'SYNOPSIS', &
'  ptr => null( [mold] )', &
'', &
'          function null(mold)', &
'', &
'           type(TYPE(kind=**)),pointer,optional :: mold', &
'', &
'CHARACTERISTICS', &
'  o  MOLD is a pointer of any association status and of any type.', &
'', &
'  o  The result is a disassociated pointer or an unallocated allocatable', &
'     entity.', &
'', &
'DESCRIPTION', &
'  NULL(3) returns a disassociated pointer.', &
'', &
'  If MOLD is present, a disassociated pointer of the same type is returned,', &
'  otherwise the type is determined by context.', &
'', &
'  In Fortran 95, MOLD is optional. Please note that Fortran 2003 includes', &
'  cases where it is required.', &
'', &
'OPTIONS', &
'  o  MOLD : a pointer of any association status and of any type.', &
'', &
'RESULT', &
'  A disassociated pointer or an unallocated allocatable entity.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      !program demo_null', &
'      module showit', &
'      implicit none', &
'      private', &
'      character(len=*),parameter :: g=''(*(g0,1x))''', &
'      public gen', &
'      ! a generic interface that only differs in the', &
'      ! type of the pointer the second argument is', &
'      interface gen', &
'       module procedure s1', &
'       module procedure s2', &
'      end interface', &
'', &
'      contains', &
'', &
'      subroutine s1 (j, pi)', &
'       integer j', &
'       integer, pointer :: pi', &
'        if(associated(pi))then', &
'           write(*,g)''Two integers in S1:,'',j,''and'',pi', &
'        else', &
'           write(*,g)''One integer in S1:,'',j', &
'        endif', &
'      end subroutine s1', &
'', &
'      subroutine s2 (k, pr)', &
'       integer k', &
'       real, pointer :: pr', &
'        if(associated(pr))then', &
'           write(*,g)''integer and real in S2:,'',k,''and'',pr', &
'        else', &
'           write(*,g)''One integer in S2:,'',k', &
'        endif', &
'      end subroutine s2', &
'', &
'      end module showit', &
'', &
'      program demo_null', &
'      use showit, only : gen', &
'', &
'      real,target :: x = 200.0', &
'      integer,target :: i = 100', &
'', &
'      real, pointer :: real_ptr', &
'      integer, pointer :: integer_ptr', &
'', &
'      ! so how do we call S1() or S2() with a disassociated pointer?', &
'', &
'      ! the answer is the null() function with a mold value', &
'', &
'      ! since s1() and s2() both have a first integer', &
'      ! argument the NULL() pointer must be associated', &
'      ! to a real or integer type via the mold option', &
'      ! so the following can distinguish whether s1(1)', &
'      ! or s2() is called, even though the pointers are', &
'      ! not associated or defined', &
'', &
'      call gen (1, null (real_ptr) )   ! invokes s2', &
'      call gen (2, null (integer_ptr) ) ! invokes s1', &
'      real_ptr => x', &
'      integer_ptr => i', &
'      call gen (3, real_ptr ) ! invokes s2', &
'      call gen (4, integer_ptr ) ! invokes s1', &
'', &
'      end program demo_null', &
'', &
'  Results:', &
'', &
'       > One integer in S2:, 1', &
'       > One integer in S1:, 2', &
'       > integer and real in S2:, 3 and 200.000000', &
'       > Two integers in S1:, 4 and 100', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  ASSOCIATED(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  null(3fortran)', &
'']

shortname="null"
call process()

case('176','num_images')

textblock=[character(len=256) :: &
'', &
'num_images(3fortran)                                     num_images(3fortran)', &
'', &
'NAME', &
'  NUM_IMAGES(3) - [COLLECTIVE] Number of images', &
'', &
'SYNOPSIS', &
'  result = num_images([team|team_number])', &
'', &
'          integer function num_images (team)', &
'', &
'           type(TEAM_TYPE),intent(in),optional    :: team', &
'           integer(kind=KIND),intent(in),optional :: team_number', &
'', &
'CHARACTERISTICS', &
'  o  use of TEAM and TEAM_NUMBER is mutually exclusive', &
'', &
'  o  TEAM is a scalar of type TEAM_TYPE from the intrinsic module', &
'     ISO_FORTRAN_ENV.', &
'', &
'  o  TEAM_NUMBER is an integer scalar.', &
'', &
'  o  the result is a default integer scalar.', &
'', &
'DESCRIPTION', &
'  NUM_IMAGES(3) Returns the number of images.', &
'', &
'OPTIONS', &
'  o  TEAM : shall be a scalar of type TEAM_TYPE from the intrinsic module', &
'     ISO_FORTRAN_ENV, with a value that identifies the current or an ancestor', &
'     team.', &
'', &
'  o  TEAM_NUMBER : identifies the initial team or a team whose parent is the', &
'     same as that of the current team.', &
'', &
'RESULT', &
'  The number of images in the specified team, or in the current team if no', &
'  team is specified.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_num_images', &
'      implicit none', &
'      integer :: value[*]', &
'      real    :: p[*]', &
'      integer :: i', &
'', &
'        value = this_image()', &
'        sync all', &
'        if (this_image() == 1) then', &
'          do i = 1, num_images()', &
'            write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]', &
'          end do', &
'        endif', &
'', &
'       ! The following code uses image 1 to read data and', &
'       ! broadcast it to other images.', &
'        if (this_image()==1) then', &
'           p=1234.5678', &
'           do i = 2, num_images()', &
'              p[i] = p', &
'           end do', &
'        end if', &
'        sync all', &
'', &
'      end program demo_num_images', &
'', &
'STANDARD', &
'  Fortran 2008 . With DISTANCE or FAILED argument, TS 18508', &
'', &
'SEE ALSO', &
'  THIS_IMAGE(3), IMAGE_INDEX(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025            num_images(3fortran)', &
'']

shortname="num_images"
call process()

case('177','open')

textblock=[character(len=256) :: &
'', &
'open(7fortran)                                                 open(7fortran)', &
'', &
'NAME', &
'  open(7f) - [IO] Initiates or modifies a connection between an external file', &
'  and a specified unit.', &
'', &
'SYNOPSIS', &
'  OPEN (', &
'', &
'          [ UNIT = ] file-unit-number', &
'          ACCESS = scalar-default-char-expr', &
'          ACTION = scalar-default-char-expr', &
'          ASYNCHRONOUS = scalar-default-char-expr', &
'          BLANK = scalar-default-char-expr', &
'          DECIMAL = scalar-default-char-expr', &
'          DELIM = scalar-default-char-expr', &
'          ENCODING = scalar-default-char-expr', &
'          ERR = label', &
'          FILE = file-name-scalar-default-char-expr', &
'          FORM = scalar-default-char-expr', &
'          IOMSG = scalar-default-char-variable', &
'          IOSTAT = scalar-int-variable', &
'          NEWUNIT = scalar-int-variable', &
'          PAD = scalar-default-char-expr', &
'          POSITION = scalar-default-char-expr', &
'          RECL = scalar-int-expr', &
'          ROUND = scalar-default-char-expr', &
'          SIGN = scalar-default-char-expr', &
'          STATUS = scalar-default-char-expr', &
'', &
'  )', &
'', &
'DESCRIPTION', &
'  An OPEN statement initiates or modifies the connection between an external', &
'  file and a specified unit. The OPEN statement may be used to connect an', &
'  existing file to a unit, create a file that is preconnected, create a file', &
'  and connect it to a unit, or change certain modes of a connection between a', &
'  file and a unit.', &
'', &
'  An external unit may be connected by an OPEN statement in the main program', &
'  or any subprogram and, once connected, a reference to it may appear in any', &
'  program unit of the program.', &
'', &
'  If the file to be connected to the unit does not exist but is the same as', &
'  the file to which the unit is preconnected, the modes specified by an OPEN', &
'  statement become a part of the connection.', &
'', &
'  If the file to be connected to the unit is not the same as the file to which', &
'  the unit is connected, the effect is as if a CLOSE statement without a', &
'  STATUS= specifier had been executed for the unit immediately prior to the', &
'  execution of an OPEN statement.', &
'', &
'  If a unit is connected to a file that exists, execution of an OPEN statement', &
'  for that unit is permitted. If the FILE= specifier is not included in such', &
'  an OPEN statement, the file to be connected to the unit is the same as the', &
'  file to which the unit is already connected.', &
'', &
'  If the file to be connected to the unit is the same as the file to which the', &
'  unit is connected, only the specifiers for changeable modes (9.5.2) may have', &
'  values different from those currently in effect. If the POSITION= specifier', &
'  appears in such an OPEN statement, the value specified shall not disagree', &
'  with the current position of the file. If the STATUS= specifier is included', &
'  in such an OPEN statement, it shall be specified with the value OLD.', &
'  Execution of such an OPEN statement causes any new values of the specifiers', &
'  for changeable modes to be in effect, but does not cause any change in any', &
'  of the unspecified specifiers and the position of the file is unaffected.', &
'  The ERR=, IOSTAT=, and IOMSG= specifiers from any previously executed OPEN', &
'  statement have no effect on any currently executed OPEN statement.', &
'', &
'  A STATUS= specifier with a value of OLD is always allowed when the file to', &
'  be connected to the unit is the same as the file to which the unit is', &
'  connected. In this case, if the status of the file was SCRATCH before', &
'  execution of the OPEN statement, the file will still be deleted when the', &
'  unit is closed, and the file is still considered to have a status of', &
'  SCRATCH.', &
'', &
'  If a file is already connected to a unit, an OPEN statement on that file', &
'  with a different unit shall not be executed.', &
'', &
'OPTIONS', &
'  A specifier that requires a scalar-default-char-expr may have a limited list', &
'  of character values. These values are listed for each such specifier. Any', &
'  trailing blanks are ignored. The value specified is without regard to case.', &
'  Some specifiers have a default value if the specifier is omitted. No', &
'  specifier shall appear more than once in a given connect-spec-list.', &
'', &
'  If the NEWUNIT= specifier does not appear, a file-unit-number shall be', &
'  specified; if the optional characters UNIT= are omitted, the file-unit-', &
'  number shall be the first item in the connect-spec-list.', &
'', &
'  The label used in the ERR= specifier shall be the statement label of a', &
'  branch target statement that appears in the same scoping unit as the OPEN', &
'  statement.', &
'', &
'  If a NEWUNIT= specifier appears, a file-unit-number shall not appear.', &
'', &
'  IOSTAT=, ERR=, and IOMSG= specifiers are described in 9.11.', &
'', &
'KEYWORDS', &
'  ACCESS : The scalar-default-char-expr shall evaluate to SEQUENTIAL, DIRECT,', &
'  or STREAM. The ACCESS= specifier specifies the access method for the', &
'  connection of the file as being sequential, direct, or stream. If this', &
'  specifier is omitted, the default value is SEQUENTIAL. For an existing file,', &
'  the specified access method shall be included in the set of allowed access', &
'  methods for the file. For a new file, the processor creates the file with a', &
'  set of allowed access methods that includes the specified method.', &
'', &
'  ACTION : The scalar-default-char-expr shall evaluate to READ, WRITE, or', &
'  READWRITE. READ specifies that the WRITE, PRINT, and ENDFILE statements', &
'  shall not refer to this connection. WRITE specifies that READ statements', &
'  shall not refer to this connection. READWRITE permits any input/output', &
'  statements to refer to this connection. If this specifier is omitted, the', &
'  default value is processor dependent. If READWRITE is included in the set of', &
'  allowable actions for a file, both READ and WRITE also shall be included in', &
'  the set of allowed actions for that file. For an existing file, the', &
'  specified action shall be included in the set of allowed actions for the', &
'  file. For a new file, the processor creates the file with a set of allowed', &
'  actions that includes the specified action.', &
'', &
'  ASYNCHRONOUS : The scalar-default-char-expr shall evaluate to YES or NO.  If', &
'  YES is specified, asynchronous input/output on the unit is allowed.  If NO', &
'  is specified, asynchronous input/output on the unit is not allowed. If this', &
'  specifier is omitted, the default value is NO.', &
'', &
'  BLANK : The scalar-default-char-expr shall evaluate to NULL or ZERO. The', &
'  BLANK= specifier is permitted only for a connection for formatted', &
'  input/output. It specifies the current value of the blank interpretation', &
'  mode (10.8.6, 9.6.2.6) for input for this connection. This mode has no', &
'  effect on output. It is a changeable mode (9.5.2). If this specifier is', &
'  omitted in an OPEN statement that initiates a connection, the default value', &
'  is NULL.', &
'', &
'  DECIMAL : The scalar-default-char-expr shall evaluate to COMMA or POINT.', &
'  The DECIMAL= specifier is permitted only for a connection for formatted', &
'  input/output. It specifies the current value of the decimal edit mode (10.6,', &
'  10.8.8, 9.6.2.7) for this connection. This is a changeable mode (9.5.2). If', &
'  this specifier is omitted in an OPEN statement that initiates a connection,', &
'  the default value is POINT.', &
'', &
'  DELIM : The scalar-default-char-expr shall evaluate to APOSTROPHE, QUOTE, or', &
'  NONE. The DELIM= specifier is permitted only for a connection for formatted', &
'  input/output. It specifies the current value of the delimiter mode (9.6.2.8)', &
'  for list-directed (10.10.4) and namelist (10.11.4.2) output for the', &
'  connection. This mode has no effect on input.  It is a changeable mode', &
'  (9.5.2). If this specifier is omitted in an OPEN statement that initiates a', &
'  connection, the default value is NONE.', &
'', &
'  ENCODING : The scalar-default-char-expr shall evaluate to UTF-8 or DEFAULT.', &
'  The ENCODING= specifier is permitted only for a connection for formatted', &
'  input/output. The value UTF-8 specifies that the encoding form of the file', &
'  is UTF-8 as specified by ISO/IEC 10646-1:2000. Such a file is called a', &
'  Unicode file, and all characters therein are of ISO 10646 character type.', &
'  The value UTF-8 shall not be specified if the processor does not support the', &
'  ISO 10646 character type. The value DEFAULT specifies that the encoding form', &
'  of the file is processor-dependent. If this specifier is omitted in an OPEN', &
'  statement that initiates a connection, the default value is DEFAULT.', &
'', &
'  FILE : The value of the FILE= specifier is the name of the file to be', &
'  connected to the specified unit. Any trailing blanks are ignored. The file-', &
'  name-expr shall be a name that is allowed by the processor. If this', &
'  specifier is omitted and the unit is not connected to a file, the STATUS=', &
'  specifier shall be specified with a value of SCRATCH; in this case, the', &
'  connection is made to a processor-dependent file. The interpretation of case', &
'  is processor dependent.', &
'', &
'  FORM : The scalar-default-char-expr shall evaluate to FORMATTED or', &
'  UNFORMATTED. The FORM= specifier determines whether the file is being', &
'  connected for formatted or unformatted input/output. If this specifier is', &
'  omitted, the default value is UNFORMATTED if the file is being connected for', &
'  direct access or stream access, and the default value is FORMATTED if the', &
'  file is being connected for sequential access. For an existing file, the', &
'  specified form shall be included in the set of allowed forms for the file.', &
'  For a new file, the processor creates the file with a set of allowed forms', &
'  that includes the specified form.', &
'', &
'  NEWUNIT : If the NEWUNIT= specifier appears in an OPEN statement, either the', &
'  FILE= specifier shall appear, or the STATUS= specifier shall appear with a', &
'  value of SCRATCH. The unit identified by a NEWUNIT value shall not be', &
'  preconnected.', &
'', &
'  The variable is defined with a processor determined NEWUNIT value if no', &
'  error occurs during the execution of the OPEN statement. If an error occurs,', &
'  the processor shall not change the value of the variable.', &
'', &
'  A NEWUNIT value is a negative number, and shall not be equal to -1, any of', &
'  the named constants ERROR_UNIT, INPUT_UNIT, or OUTPUT_UNIT from the', &
'  intrinsic module ISO_FORTRAN_ENV (13.8.2), any value used by the processor', &
'  for the unit argument to a defined input/output procedure, nor any previous', &
'  NEWUNIT value that identifies a file that is currently connected.', &
'', &
'  PAD : The scalar-default-char-expr shall evaluate to YES or NO. The PAD=', &
'  specifier is permitted only for a connection for formatted input/output.  It', &
'  specifies the current value of the pad mode (9.6.4.4.3, 9.6.2.10) for input', &
'  for this connection. This mode has no effect on output. It is a changeable', &
'  mode (9.5.2). If this specifier is omitted in an OPEN statement that', &
'  initiates a connection, the default value is YES.', &
'', &
'  POSITION : The scalar-default-char-expr shall evaluate to ASIS, REWIND, or', &
'  APPEND. The connection shall be for sequential or stream access. A new file', &
'  is positioned at its initial point. REWIND positions an existing file at its', &
'  initial point. APPEND positions an existing file such that the endfile', &
'  record is the next record, if it has one. If an existing file does not have', &
'  an endfile record, APPEND positions the file at its terminal point. ASIS', &
'  leaves the position unchanged if the file exists and already is connected.', &
'  ASIS leaves the position unspecified if the file exists but is not', &
'  connected. If this specifier is omitted, the default value is ASIS.', &
'', &
'  RECL : The value of the RECL= specifier shall be positive. It specifies the', &
'  length of each record in a file being connected for direct access, or', &
'  specifies the maximum length of a record in a file being connected for', &
'  sequential access. This specifier shall not appear when a file is being', &
'  connected for stream access. This specifier shall appear when a file is', &
'  being connected for direct access. If this specifier is omitted when a file', &
'  is being connected for sequential access, the default value is processor', &
'  dependent. If the file is being connected for formatted input/output, the', &
'  length is the number of characters for all records that contain only', &
'  characters of default kind. When a record contains any nondefault', &
'  characters, the effect of the RECL= specifier is processor dependent. If the', &
'  file is being connected for unformatted input/output, the length is measured', &
'  in file storage units. For an existing file, the value of the RECL=', &
'  specifier shall be included in the set of allowed record lengths for the', &
'  file. For a new file, the processor creates the file with a set of allowed', &
'  record lengths that includes the specified value.', &
'', &
'  ROUND : The scalar-default-char-expr shall evaluate to one of UP, DOWN,', &
'  ZERO, NEAREST, COMPATIBLE, or PROCESSOR DEFINED. The ROUND= specifier is', &
'  permitted only for a connection for formatted input/output. It specifies the', &
'  current value of the I/O rounding mode for this connection. This is a', &
'  changeable mode. If this specifier is omitted in an OPEN statement that', &
'  initiates a connection, the I/O rounding mode is processor dependent; it', &
'  shall be one of the above modes.', &
'', &
'  A processor is free to select any I/O rounding mode for the default mode.', &
'  The mode might correspond to UP, DOWN, ZERO, NEAREST, or COMPATIBLE; or it', &
'  might be a completely different I/O rounding mode.', &
'', &
'  SIGN : The scalar-default-char-expr shall evaluate to one of PLUS, SUPPRESS,', &
'  or PROCESSOR DEFINED. The SIGN= specifier is permitted only for a connection', &
'  for formatted input/output. It specifies the current value of the sign mode', &
'  this connection. This is a changeable mode. If this specifier is omitted in', &
'  an OPEN statement that initiates a connection, the default value is', &
'  PROCESSOR DEFINED.', &
'', &
'  STATUS : If the STATUS= specifier has the value NEW or REPLACE, the FILE=', &
'  specifier shall appear. If the STATUS= specifier has the value SCRATCH, the', &
'  FILE= specifier shall not appear. If the STATUS= specifier has the value', &
'  OLD, the FILE= specifier shall appear unless the unit is connected and the', &
'  file connected to the unit exists.', &
'', &
'  The scalar-default-char-expr shall evaluate to OLD, NEW, SCRATCH, REPLACE,', &
'  or UNKNOWN. If OLD is specified, the file shall exist. If NEW is specified,', &
'  the file shall not exist.', &
'', &
'  Successful execution of an OPEN statement with NEW specified creates the', &
'  file and changes the status to OLD. If REPLACE is specified and the file', &
'  does not already exist, the file is created and the status is changed to', &
'  OLD. If REPLACE is specified and the file does exist, the file is deleted, a', &
'  new file is created with the same name, and the status is changed to OLD. If', &
'  SCRATCH is specified, the file is created and connected to the specified', &
'  unit for use by the program but is deleted at the execution of a CLOSE', &
'  statement referring to the same unit or at the normal termination of the', &
'  program.', &
'', &
'  SCRATCH shall not be specified with a named file.', &
'', &
'  If UNKNOWN is specified, the status is processor dependent. If this', &
'  specifier is omitted, the default value is UNKNOWN.', &
'', &
'EXAMPLES', &
'  An example of an OPEN statement is:', &
'', &
'      program demo_open', &
'      integer :: ios', &
'      character(len=256) :: message', &
'      integer :: lun', &
'        open  (                  &', &
'        & newunit=lun,           &', &
'        & file=''employee.names'', &', &
'        & action=''read'',       &', &
'        & iostat=ios,            &', &
'        & iomsg=message)', &
'        if (ios < 0) then', &
'           ! Perform end-of-file processing on the file connected to unit', &
'           call end_processing()', &
'        elseif (ios > 0) then', &
'           ! Perform error processing', &
'           write(*,''(a)'')trim(message)', &
'           call error_processing()', &
'           stop', &
'        else', &
'           write(*,*)''OPENED FILE''', &
'        endif', &
'      contains', &
'      !', &
'      subroutine end_processing()', &
'        write(*,*)''END OF FILE:'',ios,''MESSAGE='',trim(message)', &
'        close(unit=lun,iostat=ios)', &
'        stop', &
'      end subroutine end_processing', &
'      !', &
'      subroutine error_processing()', &
'        write(*,*)''ERROR:'',ios,''MESSAGE='',trim(message)', &
'        close(unit=lun,iostat=ios)', &
'        stop', &
'      end subroutine error_processing', &
'      !', &
'      end program demo_open', &
'', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025                  open(7fortran)', &
'']

shortname="open"
call process()

case('178','out_of_range')

textblock=[character(len=256) :: &
'', &
'out_of_range(3fortran)                                 out_of_range(3fortran)', &
'', &
'NAME', &
'  OUT_OF_RANGE(3) - [TYPE:CONVERSION] Whether a numeric value can be converted', &
'  safely to another type', &
'', &
'SYNOPSIS', &
'  result = out_of_range (x, mold [, round])', &
'', &
'          elemental logical function(x, mold, round)', &
'', &
'           type(TYPE(kind=**)),intent(in) :: x', &
'           type(TYPE(kind=**)),intent(in) :: mold', &
'           logical,intent(in),optional    :: round', &
'', &
'CHARACTERISTICS', &
'  o  X is of type integer or real.', &
'', &
'  o  MOLD is an integer or real scalar.', &
'', &
'  o  ROUND is a logical scalar.', &
'', &
'  o  the result is a default logical.', &
'', &
'DESCRIPTION', &
'  OUT_OF_RANGE(3) determines whether a value X can be converted safely to a', &
'  real or integer variable the same type and kind as MOLD.', &
'', &
'  For example, if INT8 is the KIND name for an 8-bit binary integer type, then', &
'  for', &
'', &
'         logical :: L1, L2', &
'         L1=out_of_range(-128.5, 0_int8)', &
'         L2=out_of_range(-128.5, 0_int8,.true.)', &
'         end', &
'', &
'  L1 likely will have the value .FALSE. because the value will be truncated to', &
'  -128.0, which is a representable integer number on a two''s complement', &
'  machine.', &
'', &
'  L2 will be .TRUE. because it will be rounded to -129.0, which is not likely', &
'  to be a representable eight-bit integer.', &
'', &
'OPTIONS', &
'  o  X : a scalar to be tested for whether it can be stored in a variable of', &
'     the type and kind of MOLD', &
'', &
'  o  MOLD : the type and kind of the variable (but not the value) is used to', &
'     identify the characteristics of the variable type to fit X into.', &
'', &
'  o  ROUND : flag whether to round the value of X before validating it as a', &
'     value like MOLD.', &
'', &
'     ROUND can only be present if X is of type real and MOLD is of type', &
'     integer.', &
'', &
'RESULT', &
'  From the standard:', &
'', &
'  Case (i): If MOLD is of type integer, and ROUND is absent or present with', &
'  the value false, the result is true if and only if the value of X is an IEEE', &
'  infinity or NaN, or if the integer with largest magnitude that lies between', &
'  zero and X inclusive is not representable by objects with the type and kind', &
'  of MOLD.', &
'', &
'  Case (ii): If MOLD is of type integer, and ROUND is present with the value', &
'  true, the result is true if and only if the value of X is an IEEE infinity', &
'  or NaN, or if the integer nearest X, or the integer of greater magnitude if', &
'  two integers are equally near to X, is not representable by objects with the', &
'  type and kind of MOLD.', &
'', &
'  Case (iii): Otherwise, the result is true if and only if the value of X is', &
'  an IEEE infinity or NaN that is not supported by objects of the type and', &
'  kind of MOLD, or if X is a finite number and the result of rounding the', &
'  value of X (according to the IEEE rounding mode if appropriate) to the', &
'  extended model for the kind of MOLD has magnitude larger than that of the', &
'  largest finite number with the same sign as X that is representable by', &
'  objects with the type and kind of MOLD.', &
'', &
'NOTE', &
'  MOLD is required to be a scalar because the only information taken from it', &
'  is its type and kind. Allowing an array MOLD would require that it be', &
'  conformable with X. ROUND is scalar because allowing an array rounding mode', &
'  would have severe performance difficulties on many processors.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_out_of_range', &
'      use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      integer           :: i', &
'      integer(kind=int8) :: i8, j8', &
'', &
'         ! compilers are not required to produce an error on out of range.', &
'         ! here storing the default integers into 1-byte integers', &
'         ! incorrectly can have unexpected results', &
'         do i=127,130', &
'            i8=i', &
'            j8=-i', &
'            ! OUT_OF_RANGE(3) can let you check if the value will fit', &
'            write(*,*)i8,j8,'' might have expected'',i,-i, &', &
'             & out_of_range( i,i8), &', &
'             & out_of_range(-i,i8)', &
'         enddo', &
'         write(*,*) ''RANGE IS '',-1-huge(0_int8),''TO'',huge(0_int8)', &
'         ! the real -128.5 is truncated to -128 and is in range', &
'         write(*,*) out_of_range (  -128.5, 0_int8)         ! false', &
'', &
'         ! the real -128.5 is rounded to -129 and is not in range', &
'         write(*,*) out_of_range (  -128.5, 0_int8, .true.) ! true', &
'', &
'      end program demo_out_of_range', &
'', &
'  Results:', &
'', &
'       >  127 -127  might have expected         127        -127 F F', &
'       > -128 -128  might have expected         128        -128 T F', &
'       > -127  127  might have expected         129        -129 T T', &
'       > -126  126  might have expected         130        -130 T T', &
'       > RANGE IS         -128 TO  127', &
'       > F', &
'       > T', &
'', &
'STANDARD', &
'  FORTRAN 2018', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Convert values to a complex type', &
'', &
'  o  DBLE(3) - Double conversion function', &
'', &
'  o  INT(3) - Truncate towards zero and convert to integer', &
'', &
'  o  NINT(3) - Nearest whole number', &
'', &
'  o  REAL(3) - Convert to real type', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025          out_of_range(3fortran)', &
'']

shortname="out_of_range"
call process()

case('179','pack')

textblock=[character(len=256) :: &
'', &
'pack(3fortran)                                                 pack(3fortran)', &
'', &
'NAME', &
'  PACK(3) - [ARRAY:CONSTRUCTION] Pack an array into an array of rank one', &
'', &
'SYNOPSIS', &
'  result = pack( array, mask [,vector] )', &
'', &
'          TYPE(kind=KIND) function pack(array,mask,vector)', &
'', &
'           TYPE(kind=KIND),option(in) :: array(..)', &
'           logical  :: mask(..)', &
'           TYPE(kind=KIND),option(in),optional :: vector(*)', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY is an array of any type', &
'', &
'  o  MASK a logical scalar as well as an array conformable with ARRAY.', &
'', &
'  o  VECTOR is of the same kind and type as ARRAY and of rank one', &
'', &
'  o  the returned value is of the same kind and type as ARRAY', &
'', &
'DESCRIPTION', &
'  PACK(3) stores the elements of ARRAY in an array of rank one.', &
'', &
'  The beginning of the resulting array is made up of elements whose MASK', &
'  equals .true.. Afterwards, remaining positions are filled with elements', &
'  taken from VECTOR', &
'', &
'OPTIONS', &
'  o  ARRAY : The data from this array is used to fill the resulting vector', &
'', &
'  o  MASK : the logical mask must be the same size as ARRAY or, alternatively,', &
'     it may be a logical scalar.', &
'', &
'  o  VECTOR : an array of the same type as ARRAY and of rank one. If present,', &
'     the number of elements in VECTOR shall be equal to or greater than the', &
'     number of true elements in MASK. If MASK is scalar, the number of', &
'     elements in VECTOR shall be equal to or greater than the number of', &
'     elements in ARRAY.', &
'', &
'  VECTOR shall have at least as many elements as there are in ARRAY.', &
'', &
'RESULT', &
'  The result is an array of rank one and the same type as that of ARRAY.  If', &
'  VECTOR is present, the result size is that of VECTOR, the number of .true.', &
'  values in MASK otherwise.', &
'', &
'  If MASK is scalar with the value .true., in which case the result size is', &
'  the size of ARRAY.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'         program demo_pack', &
'         implicit none', &
'         integer, allocatable :: m(:)', &
'         character(len=10) :: c(4)', &
'', &
'          ! gathering nonzero elements from an array:', &
'            m = [ 1, 0, 0, 0, 5, 0 ]', &
'            write(*, fmt="(*(i0, '' ''))") pack(m, m /= 0)', &
'', &
'          ! Gathering nonzero elements from an array and appending elements', &
'          ! from VECTOR till the size of the mask array (or array size if the', &
'          ! mask is scalar):', &
'            m = [ 1, 0, 0, 2 ]', &
'            write(*, fmt="(*(i0, '' ''))") pack(m, m /= 0, [ 0, 0, 3, 4 ])', &
'            write(*, fmt="(*(i0, '' ''))") pack(m, m /= 0 )', &
'', &
'          ! select strings whose second character is "a"', &
'            c = [ character(len=10) :: ''ape'', ''bat'', ''cat'', ''dog'']', &
'            write(*, fmt="(*(g0, '' ''))") pack(c, c(:)(2:2) == ''a'' )', &
'', &
'          ! creating a quicksort using PACK(3f)', &
'            block', &
'            intrinsic random_seed, random_number', &
'            real :: x(10)', &
'               call random_seed()', &
'               call random_number(x)', &
'               write (*,"(a10,*(1x,f0.3))") "initial",x', &
'               write (*,"(a10,*(1x,f0.3))") "sorted",qsort(x)', &
'            endblock', &
'         contains', &
'         !', &
'         ! concise quicksort from @arjen and @beliavsky shows recursion,', &
'         ! array sections, and vectorized comparisons.', &
'         !', &
'         pure recursive function qsort(values) result(sorted)', &
'         intrinsic pack, size', &
'         real, intent(in) :: values(:)', &
'         real             :: sorted(size(values))', &
'            if (size(values) > 1) then', &
'               sorted = &', &
'               & [qsort(pack(values(2:),values(2:)<values(1))), values(1), &', &
'               & qsort(pack(values(2:),values(2:)>=values(1)))]', &
'            else', &
'               sorted = values', &
'            endif', &
'         end function qsort', &
'         end program demo_pack', &
'', &
'  Result:', &
'', &
'         > 1 5', &
'         > 1 2 3 4', &
'         > 1 2', &
'         > bat        cat', &
'         >    initial .833 .367 .958 .454 .122 .602 .418 .942 .566 .400', &
'         >     sorted .122 .367 .400 .418 .454 .566 .602 .833 .942 .958', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MERGE(3), SPREAD(3), UNPACK(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  pack(3fortran)', &
'']

shortname="pack"
call process()

case('180','parity')

textblock=[character(len=256) :: &
'', &
'parity(3fortran)                                             parity(3fortran)', &
'', &
'NAME', &
'  PARITY(3) - [ARRAY:REDUCTION] Array reduction by .NEQV. operation', &
'', &
'SYNOPSIS', &
'  result = parity( mask [,dim] )', &
'', &
'          logical(kind=KIND) function parity(mask, dim)', &
'', &
'           type(logical(kind=KIND)),intent(in)        :: mask(..)', &
'           type(integer(kind=**)),intent(in),optional :: dim', &
'', &
'CHARACTERISTICS', &
'  o  MASK is a logical array', &
'', &
'  o  DIM is an integer scalar', &
'', &
'  o  the result is of type logical with the same kind type parameter as MASK.', &
'     It is a scalar if DIM does not appear; otherwise it is the rank and shape', &
'     of MASK with the dimension specified by DIM removed.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  PARITY(3) calculates the parity array (i.e. the reduction using .neqv.)  of', &
'  MASK along dimension DIM if DIM is present and not 1. Otherwise, it returns', &
'  the parity of the entire MASK array as a scalar.', &
'', &
'OPTIONS', &
'  o  MASK : Shall be an array of type logical.', &
'', &
'  o  DIM : (Optional) shall be a scalar of type integer with a value in the', &
'     range from 1 to n, where n equals the rank of MASK.', &
'', &
'RESULT', &
'  The result is of the same type as MASK.', &
'', &
'  If DIM is absent, a scalar with the parity of all elements in MASK is', &
'  returned: .true. if an odd number of elements are .true. and .false.', &
'  otherwise.', &
'', &
'  If MASK has rank one, PARITY (MASK, DIM) is equal to PARITY (MASK).', &
'  Otherwise, the result is an array of parity values with dimension DIM', &
'  dropped.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_parity', &
'      implicit none', &
'      logical, parameter :: T=.true., F=.false.', &
'      logical :: x(3,4)', &
'       ! basics', &
'        print *, parity([T,F])', &
'        print *, parity([T,F,F])', &
'        print *, parity([T,F,F,T])', &
'        print *, parity([T,F,F,T,T])', &
'        x(1,:)=[T,T,T,T]', &
'        x(2,:)=[T,T,T,T]', &
'        x(3,:)=[T,T,T,T]', &
'        print *, parity(x)', &
'        print *, parity(x,dim=1)', &
'        print *, parity(x,dim=2)', &
'      end program demo_parity', &
'', &
'  Results:', &
'', &
'       >  T', &
'       >  T', &
'       >  F', &
'       >  T', &
'       >  F', &
'       >  T T T T', &
'       >  F F F', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  o  ALL(3) - Determines if all the values are true', &
'', &
'  o  ANY(3) - Determines if any of the values in the logical array are .true.', &
'', &
'  o  COUNT(3) - Count true values in an array', &
'', &
'  o  SUM(3) - Sum the elements of an array', &
'', &
'  o  MAXVAL(3) - Determines the maximum value in an array or row', &
'', &
'  o  MINVAL(3) - Minimum value of an array', &
'', &
'  o  PRODUCT(3) - Product of array elements', &
'', &
'  o  REDUCE(3) - General array reduction', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                parity(3fortran)', &
'']

shortname="parity"
call process()

case('181','popcnt')

textblock=[character(len=256) :: &
'', &
'popcnt(3fortran)                                             popcnt(3fortran)', &
'', &
'NAME', &
'  POPCNT(3) - [BIT:COUNT] Number of bits set', &
'', &
'SYNOPSIS', &
'  result = popcnt(i)', &
'', &
'          elemental integer function popcnt(i)', &
'', &
'           integer(kind=KIND), intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I may be an integer of any kind.', &
'', &
'  o  The return value is an integer of the default integer kind.', &
'', &
'DESCRIPTION', &
'  POPCNT(3) returns the number of bits set to one in the binary representation', &
'  of an integer.', &
'', &
'OPTIONS', &
'  o  I : value to count set bits in', &
'', &
'RESULT', &
'  The number of bits set to one in I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_popcnt', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'        & int8, int16, int32, int64', &
'      implicit none', &
'      character(len=*),parameter :: pretty=''(b64,1x,i0)''', &
'       ! basic usage', &
'        print pretty, 127,     popcnt(127)', &
'        print pretty, int(b"01010"), popcnt(int(b"01010"))', &
'', &
'       ! any kind of an integer can be used', &
'        print pretty, huge(0_int8),  popcnt(huge(0_int8))', &
'        print pretty, huge(0_int16), popcnt(huge(0_int16))', &
'        print pretty, huge(0_int32), popcnt(huge(0_int32))', &
'        print pretty, huge(0_int64), popcnt(huge(0_int64))', &
'      end program demo_popcnt', &
'', &
'  Results:', &
'', &
'  Note that on most machines the first bit is the sign bit, and a zero is used', &
'  for positive values; but that this is system-dependent. These are typical', &
'  values, where the huge(3) function has set all but the first bit to 1.', &
'', &
'       >                                                        1111111 7', &
'       >                                                           1010 2', &
'       >                                                        1111111 7', &
'       >                                                111111111111111 15', &
'       >                                1111111111111111111111111111111 31', &
'       > 111111111111111111111111111111111111111111111111111111111111111 63', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  There are many procedures that operator or query values at the bit level:', &
'', &
'  POPPAR(3), LEADZ(3), TRAILZ(3) ATOMIC_AND(3), ATOMIC_FETCH_AND(3),', &
'  ATOMIC_FETCH_OR(3), ATOMIC_FETCH_XOR(3), ATOMIC_OR(3), ATOMIC_XOR(3),', &
'  BGE(3), BGT(3), BIT_SIZE(3), BLE(3), BLT(3), BTEST(3), DSHIFTL(3),', &
'  DSHIFTR(3), IALL(3), IAND(3), IANY(3), IBCLR(3), IBITS(3), IBSET(3),', &
'  IEOR(3), IOR(3), IPARITY(3), ISHFTC(3), ISHFT(3), MASKL(3), MASKR(3),', &
'  MERGE_BITS(3), MVBITS(3), NOT(3), SHIFTA(3), SHIFTL(3), SHIFTR(3),', &
'  STORAGE_SIZE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                popcnt(3fortran)', &
'']

shortname="popcnt"
call process()

case('182','poppar')

textblock=[character(len=256) :: &
'', &
'poppar(3fortran)                                             poppar(3fortran)', &
'', &
'NAME', &
'  POPPAR(3) - [BIT:COUNT] Parity of the number of bits set', &
'', &
'SYNOPSIS', &
'  result = poppar(i)', &
'', &
'          elemental integer function poppar(i)', &
'', &
'           integer(kind=KIND), intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I is an integer of any kind', &
'', &
'  o  the return value is a default kind integer', &
'', &
'DESCRIPTION', &
'  POPPAR(3) returns the parity of an integer''s binary representation (i.e.,', &
'  the parity of the number of bits set).', &
'', &
'  The parity is expressed as', &
'', &
'  o  0 (zero) if I has an even number of bits set to 1.', &
'', &
'  o  1 (one) if the number of bits set to one 1 is odd,', &
'', &
'OPTIONS', &
'  o  I : The value to query for its bit parity', &
'', &
'RESULT', &
'  The return value is equal to 0 if I has an even number of bits set and 1 if', &
'  an odd number of bits are set.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_poppar', &
'      use, intrinsic :: iso_fortran_env, only : integer_kinds, &', &
'        & int8, int16, int32, int64', &
'      implicit none', &
'      character(len=*),parameter :: pretty=''(b64,1x,i0)''', &
'        ! basic usage', &
'        print pretty, 127,     poppar(127)', &
'        print pretty, 128,     poppar(128)', &
'        print pretty, int(b"01010"), poppar(int(b"01010"))', &
'', &
'        ! any kind of an integer can be used', &
'        print pretty, huge(0_int8),  poppar(huge(0_int8))', &
'        print pretty, huge(0_int16), poppar(huge(0_int16))', &
'        print pretty, huge(0_int32), poppar(huge(0_int32))', &
'        print pretty, huge(0_int64), poppar(huge(0_int64))', &
'      end program demo_poppar', &
'', &
'  Results:', &
'', &
'       >                                                         1111111 1', &
'       >                                                        10000000 1', &
'       >                                                            1010 0', &
'       >                                 1111111111111111111111111111111 1', &
'       >                                                         1111111 1', &
'       >                                                 111111111111111 1', &
'       >                                 1111111111111111111111111111111 1', &
'       >  111111111111111111111111111111111111111111111111111111111111111 1', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  There are many procedures that operator or query values at the bit level:', &
'', &
'  POPCNT(3), LEADZ(3), TRAILZ(3) ATOMIC_AND(3), ATOMIC_FETCH_AND(3),', &
'  ATOMIC_FETCH_OR(3), ATOMIC_FETCH_XOR(3), ATOMIC_OR(3), ATOMIC_XOR(3),', &
'  BGE(3), BGT(3), BIT_SIZE(3), BLE(3), BLT(3), BTEST(3), DSHIFTL(3),', &
'  DSHIFTR(3), IALL(3), IAND(3), IANY(3), IBCLR(3), IBITS(3), IBSET(3),', &
'  IEOR(3), IOR(3), IPARITY(3), ISHFTC(3), ISHFT(3), MASKL(3), MASKR(3),', &
'  MERGE_BITS(3), MVBITS(3), NOT(3), SHIFTA(3), SHIFTL(3), SHIFTR(3),', &
'  STORAGE_SIZE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                poppar(3fortran)', &
'']

shortname="poppar"
call process()

case('183','precision')

textblock=[character(len=256) :: &
'', &
'precision(3fortran)                                       precision(3fortran)', &
'', &
'NAME', &
'  PRECISION(3) - [MODEL:NUMERIC] Decimal precision of a real kind', &
'', &
'SYNOPSIS', &
'  result = precision(x)', &
'', &
'          integer function precision(x)', &
'', &
'           TYPE(kind=**),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X shall be of type real or complex. It may be a scalar or an array.', &
'', &
'  o  the result is a default integer scalar.', &
'', &
'DESCRIPTION', &
'  PRECISION(3) returns the decimal precision in the model of the type of X.', &
'', &
'OPTIONS', &
'  o  X : the type and kind of the argument are used to determine which number', &
'     model to query. The value of the argument is not unused; it may even be', &
'     undefined.', &
'', &
'RESULT', &
'  The precision of values of the type and kind of X', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_precision', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp)    :: x(2)', &
'      complex(kind=dp) :: y', &
'', &
'        print *, precision(x), range(x)', &
'        print *, precision(y), range(y)', &
'', &
'      end program demo_precision', &
'', &
'  Results:', &
'', &
'       >           6          37', &
'       >          15         307', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), RADIX(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025             precision(3fortran)', &
'']

shortname="precision"
call process()

case('184','present')

textblock=[character(len=256) :: &
'', &
'present(3fortran)                                           present(3fortran)', &
'', &
'NAME', &
'  PRESENT(3) - [STATE:INQUIRY] Determine whether an optional dummy argument is', &
'  specified', &
'', &
'SYNOPSIS', &
'  result = present(a)', &
'', &
'          logical function present (a)', &
'', &
'           type(TYPE(kind=KIND)) :: a(..)', &
'', &
'CHARACTERISTICS', &
'  o  A May be of any type and may be a pointer, scalar or array value, or a', &
'     dummy procedure.', &
'', &
'DESCRIPTION', &
'  PRESENT(3) can be used in a procedure to determine if an optional dummy', &
'  argument was present on the current call to the procedure.', &
'', &
'  A shall be the name of an optional dummy argument that is accessible in the', &
'  subprogram in which the PRESENT(3) function reference appears. There are no', &
'  other requirements on A.', &
'', &
'  Note when an argument is not present when the current procedure is invoked,', &
'  you may only pass it as an optional argument to another procedure or pass it', &
'  as an argument to PRESENT.', &
'', &
'OPTIONS', &
'  o  A : the name of an optional dummy argument accessible within the current', &
'     subroutine or function.', &
'', &
'RESULT', &
'  Returns .true. if the optional argument A is present (was passed on the call', &
'  to the procedure) , or .false. otherwise.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_present', &
'      implicit none', &
'      integer :: answer', &
'        ! argument to func() is not present', &
'        answer=func()', &
'        write(*,*) answer', &
'        ! argument to func() is present', &
'        answer=func(1492)', &
'        write(*,*) answer', &
'      contains', &
'      !', &
'      integer function func(x)', &
'      ! the optional characteristic on this definition allows this variable', &
'      ! to not be specified on a call; and also allows it to subsequently', &
'      ! be passed to PRESENT(3):', &
'      integer, intent(in), optional :: x', &
'      integer :: x_local', &
'        !', &
'        ! basic', &
'        if(present(x))then', &
'          ! if present, you can use x like any other variable.', &
'          x_local=x', &
'        else', &
'          ! if not, you cannot define or reference x except to', &
'          ! pass it as an optional parameter to another procedure', &
'          ! or in a call to present(3)', &
'          x_local=0', &
'        endif', &
'        !', &
'        func=x_local**2', &
'        !', &
'        ! passing the argument on to other procedures', &
'        ! so something like this is a bad idea because x is used', &
'        ! as the first argument to merge(3) when it might not be', &
'        ! present', &
'        ! xlocal=merge(x,0,present(x)) ! NO!!', &
'        !', &
'        ! We can pass it to another procedure if another', &
'        ! procedure declares the argument as optional as well,', &
'        ! or we have tested that X is present', &
'        call tattle(''optional argument x'',x)', &
'        if(present(x))call not_optional(x)', &
'      end function', &
'      !', &
'      subroutine tattle(label,arg)', &
'      character(len=*),intent(in) :: label', &
'      integer,intent(in),optional :: arg', &
'        if(present(arg))then', &
'           write(*,*)label,'' is present''', &
'        else', &
'           write(*,*)label,'' is not present''', &
'        endif', &
'      end subroutine tattle', &
'      !', &
'      subroutine not_optional(arg)', &
'      integer,intent(in) :: arg', &
'        write(*,*)''already tested X is defined'',arg', &
'      end subroutine not_optional', &
'      !', &
'      end program demo_present', &
'', &
'  Results:', &
'', &
'       > optional argument x is not present', &
'       >           0', &
'       > optional argument x is present', &
'       > already tested X is defined 1492', &
'       >     2226064', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               present(3fortran)', &
'']

shortname="present"
call process()

case('185','print')

textblock=[character(len=256) :: &
'', &
'print(7fortran)                                               print(7fortran)', &
'', &
'NAME', &
'  print(7f) - [IO] write formatted sequential I/O to stdout', &
'', &
'SYNOPSIS', &
'  PRINT format [ , output-item-list ]', &
'', &
'DESCRIPTION', &
'  print(7f) is equivalent to', &
'', &
'             write(*,fmt=FORMAT_SPECIFIER) LIST', &
'', &
'  That is, it always writes formatted sequential I/O to stdout. It may use', &
'  list-directed I/O or a FORMAT specifier.', &
'', &
'  print(7f) allows for no other options and therefore cannot be used for', &
'  binary or non-advancing or stream or asynchronous I/O or any of the other', &
'  options provided by the more general but also more complicated write(7f)', &
'  statement.', &
'', &
'  Note that pure subprograms cannot contain I/O statements such as print(7f).', &
'', &
'OPTIONS', &
'  format', &
'    a format may be used to specify how output items are displayed using the', &
'    many Fortran format descriptors, or an asterisk (*) may be used to', &
'    indicate to use list-directed default formatting.', &
'', &
'  output-item-list', &
'    the variables whose values are to be displayed', &
'', &
'EXAMPLE', &
'  A simple example program:', &
'', &
'      program demo_print', &
'      implicit none', &
'      real :: a=11.11, s=sqrt(12.0)', &
'      integer :: j=753210', &
'      character(len=*),parameter :: commas=''(*(g0:,","))''', &
'', &
'       ! List-directed output is frequently specified', &
'       PRINT *, A, S', &
'', &
'       ! a format may be placed on the print(7f) statement', &
'       PRINT ''(*(g0,1x))'', A, S, J', &
'', &
'       ! the format may be in a character variable', &
'       print commas, a, s, j', &
'', &
'       ! or may be in a labeled format statement', &
'       PRINT 10, A, S, J', &
'       10 FORMAT (2E16.3,1x,I0)', &
'', &
'      end program demo_print', &
'', &
'  Results:', &
'', &
'       >    11.1099997      3.46410155', &
'       > 11.1099997 3.46410155 753210', &
'       > 11.1099997,3.46410155,753210', &
'       >       0.111E+02       0.346E+01 753210', &
'', &
'SEE ALSO', &
'  o  BACKSPACE(7)', &
'', &
'  o  CLOSE(7)', &
'', &
'  o  ENDFILE(7)', &
'', &
'  o  FLUSH(7)', &
'', &
'  o  INQUIRE(7)', &
'', &
'  o  OPEN(7)', &
'', &
'  o  PRINT(7)', &
'', &
'  o  READ(7)', &
'', &
'  o  REWIND(7)', &
'', &
'  o  WAIT(7)', &
'', &
'  o  WRITE(7)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 print(7fortran)', &
'']

shortname="print"
call process()

case('186','product')

textblock=[character(len=256) :: &
'', &
'product(3fortran)                                           product(3fortran)', &
'', &
'NAME', &
'  PRODUCT(3) - [ARRAY:REDUCTION] Product of array elements', &
'', &
'SYNOPSIS', &
'  result = product(array [,dim] [,mask])', &
'', &
'          NUMERIC function product(array, dim, mask)', &
'', &
'           NUMERIC,intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  NUMERIC is any numeric type and kind.', &
'', &
'DESCRIPTION', &
'  PRODUCT(3) multiplies together all the selected elements of ARRAY, or along', &
'  dimension DIM if the corresponding element in MASK is .true..', &
'', &
'  If DIM is absent, a scalar with the product of all elements in ARRAY is', &
'  returned. (Note a zero-sized ARRAY returns 1).', &
'', &
'  When DIM is present, If the masked array has a dimension of one (ie. is a', &
'  vector) the result is a scalar. Otherwise, an array of rank N-1, where N', &
'  equals the rank of ARRAY, and a shape similar to that of ARRAY with', &
'  dimension DIM dropped is returned.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an array of type integer, real or complex.', &
'', &
'  o  DIM : shall be a scalar of type integer with a value in the range from 1', &
'     TO N, where N equals the rank of ARRAY.', &
'', &
'  o  MASK : shall be of type logical and either be a scalar or an array of the', &
'     same shape as ARRAY.', &
'', &
'RESULT', &
'  The result is of the same type as ARRAY.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_product', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))'' ! a handy format', &
'      character(len=1),parameter :: nl=new_line(''a'')', &
'', &
'      NO_DIM: block', &
'      !    If DIM is not specified, the result is the product of all the', &
'      !    selected array elements.', &
'      integer :: i,n, p1, p2', &
'      integer,allocatable :: array(:)', &
'        ! all elements are selected by default', &
'        do n=1,10', &
'           print all, ''factorial of '',n,'' is '', product([(real(i),i=1,n)])', &
'        enddo', &
'', &
'        ! using a mask', &
'        array=[10,12,13,15,20,25,30]', &
'        p1=product(array, mask=mod(array, 2)==1) ! only odd elements', &
'        p2=product(array, mask=mod(array, 2)/=1) ! only even elements', &
'        print all, nl,''product of all elements'',product(array) ! all elements', &
'        print all, '' odd * even ='',nl,p1,''*'',p2,''='',p1*p2', &
'', &
'        ! NOTE: If ARRAY is a zero-sized array, the result is equal to one', &
'        print all', &
'        print all, ''zero-sized array=>'',product([integer :: ])', &
'        ! NOTE: If nothing in the mask is true, this also results in a null', &
'        !       array', &
'        print all, ''all elements have a false mask=>'', &', &
'                 & product(array,mask=.false.)', &
'', &
'      endblock NO_DIM', &
'', &
'      WITH_DIM: block', &
'      integer :: rect(2,3)', &
'      integer :: box(2,3,4)', &
'', &
'      !  lets fill a few arrays', &
'        rect = reshape([ &', &
'          1, 2, 3,       &', &
'          4, 5, 6        &', &
'        ],shape(rect),order=[2,1])', &
'        call print_matrix_int(''rect'',rect)', &
'', &
'      !  Find the product of each column in RECT.', &
'        print all, ''product of columns='',product(rect, dim = 1)', &
'', &
'      ! Find the product of each row in RECT.', &
'        print all, ''product of rows='',product(rect, dim = 2)', &
'', &
'      ! now lets try a box', &
'        box(:,:,1)=rect', &
'        box(:,:,2)=rect*(+10)', &
'        box(:,:,3)=rect*(-10)', &
'        box(:,:,4)=rect*2', &
'        ! lets look at the values', &
'        call print_matrix_int(''box 1'',box(:,:,1))', &
'        call print_matrix_int(''box 2'',box(:,:,2))', &
'        call print_matrix_int(''box 3'',box(:,:,3))', &
'        call print_matrix_int(''box 4'',box(:,:,4))', &
'', &
'        ! remember without dim= even a box produces a scalar', &
'        print all, ''no dim gives a scalar'',product(real(box))', &
'', &
'        ! only one plane has negative values, so note all the "1" values', &
'        ! for vectors with no elements', &
'        call print_matrix_int(''negative values'', &', &
'        & product(box,mask=box < 0,dim=1))', &
'', &
'      !   If DIM is specified and ARRAY has rank greater than one, the', &
'      !   result is a new array in which dimension DIM has been eliminated.', &
'', &
'        ! pick a dimension to multiply though', &
'        call print_matrix_int(''dim=1'',product(box,dim=1))', &
'', &
'        call print_matrix_int(''dim=2'',product(box,dim=2))', &
'', &
'        call print_matrix_int(''dim=3'',product(box,dim=3))', &
'', &
'      endblock WITH_DIM', &
'', &
'      contains', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      implicit none', &
'', &
'      !@(#) print small 2d integer arrays in row-column format', &
'', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'', &
'        print all', &
'        print all, trim(title),'':('',shape(arr),'')''  ! print title', &
'        biggest=''          '' ! make buffer to write integer into', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_product', &
'', &
'  Results:', &
'', &
'       > factorial of  1  is  1.00000000', &
'       > factorial of  2  is  2.00000000', &
'       > factorial of  3  is  6.00000000', &
'       > factorial of  4  is  24.0000000', &
'       > factorial of  5  is  120.000000', &
'       > factorial of  6  is  720.000000', &
'       > factorial of  7  is  5040.00000', &
'       > factorial of  8  is  40320.0000', &
'       > factorial of  9  is  362880.000', &
'       > factorial of  10  is  3628800.00', &
'       >', &
'       >  product of all elements 351000000', &
'       >  odd * even =', &
'       >  4875 * 72000 = 351000000', &
'       >', &
'       > zero-sized array=> 1', &
'       > all elements have a false mask=> 1', &
'       >', &
'       > rect :( 2 3 )', &
'       >  > [  1,  2,  3 ]', &
'       >  > [  4,  5,  6 ]', &
'       > product of columns= 4 10 18', &
'       > product of rows= 6 120', &
'       >', &
'       > box 1 :( 2 3 )', &
'       >  > [  1,  2,  3 ]', &
'       >  > [  4,  5,  6 ]', &
'       >', &
'       > box 2 :( 2 3 )', &
'       >  > [  10,  20,  30 ]', &
'       >  > [  40,  50,  60 ]', &
'       >', &
'       > box 3 :( 2 3 )', &
'       >  > [ -10, -20, -30 ]', &
'       >  > [ -40, -50, -60 ]', &
'       >', &
'       > box 4 :( 2 3 )', &
'       >  > [  2,   4,   6 ]', &
'       >  > [  8,  10,  12 ]', &
'       > no dim gives a scalar 0.171992703E+26', &
'       >', &
'       > negative values :( 3 4 )', &
'       >  > [    1,     1,   400,     1 ]', &
'       >  > [    1,     1,  1000,     1 ]', &
'       >  > [    1,     1,  1800,     1 ]', &
'       >', &
'       > dim=1 :( 3 4 )', &
'       >  > [    4,   400,   400,    16 ]', &
'       >  > [   10,  1000,  1000,    40 ]', &
'       >  > [   18,  1800,  1800,    72 ]', &
'       >', &
'       > dim=2 :( 2 4 )', &
'       >  > [      6,    6000,   -6000,      48 ]', &
'       >  > [    120,  120000, -120000,     960 ]', &
'       >', &
'       > dim=3 :( 2 3 )', &
'       >  > [   -200,   -3200,  -16200 ]', &
'       >  > [  -51200, -125000, -259200 ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  SUM(3), note that an element by element multiplication is done directly', &
'  using the star character.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               product(3fortran)', &
'']

shortname="product"
call process()

case('187','program')

textblock=[character(len=256) :: &
'', &
'program(7fortran)                                           program(7fortran)', &
'', &
'NAME', &
'  PROGRAM(3) - [PROGRAM UNITS] Absolute value', &
'', &
'SYNOPSIS', &
'  Basic Fortran program sections:', &
'', &
'         [ PROGRAM [program-name]]', &
'', &
'             [ specification-part ]', &
'             [ execution-part ]', &
'             [ internal-subprogram-part ]', &
'', &
'         end [PROGRAM [program-name]]', &
'', &
'  A PROGRAM directive optionally marks the beginning of a main program.', &
'', &
'  A main program is the starting point for execution of a program.', &
'', &
'  The main program may be defined by means other than Fortran; in that case,', &
'  the program shall not contain a Fortran main-program program unit at all.', &
'', &
'  The optional name of the main program has no explicit use within the Fortran', &
'  language. It is available for documentation and for possible use by a', &
'  processor.', &
'', &
'  A processor might implement an unnamed program unit by assigning it a global', &
'  identifier that is not used elsewhere in the program. This could be done by', &
'  using a default name that does not satisfy the rules for Fortran names, but', &
'  if the name is specified it must conform to the rules for a Fortran', &
'  identifier (composed from the ASCII alphanumeric characters and underscore,', &
'  up to 63 characters, must begin with a letter).', &
'', &
'  The PROGRAM statement is optional but is almost always present in modern', &
'  programs. Since it is optional a Fortran main program block is defined as a', &
'  program unit that does not contain a SUBROUTINE, FUNCTION, MODULE,', &
'  SUBMODULE,or BLOCKDATA statement as its first statement.', &
'', &
'  Note that the PROGRAM block is not required to be the first program unit in', &
'  a file. Modules or procedure definitions or other program units may proceed', &
'  it and most may follow it (A module must be defined before a reference to it', &
'  is made).', &
'', &
'  The program-name shall not be included in the end-program-stmt unless the', &
'  optional program-stmt is used. If included, it shall be identical to the', &
'  program-name specified in the program-stmt.', &
'', &
'  NOTE1 The program name is global to the program.', &
'', &
'  An example of a main program is:', &
'', &
'   PROGRAM ANALYZE', &
'  REAL A, B, C (10,10)', &
'    !  Specification part', &
'', &
'  CALL FIND', &
'    !  Execution part', &
'', &
'   CONTAINS', &
'  SUBROUTINE FIND', &
'    !  Internal subprogram . . .', &
'', &
'   END SUBROUTINE FIND', &
'   END PROGRAM ANALYZE', &
'  A reference to a Fortran main-program shall not appear in any program unit', &
'  in the program, including itself. That is, you cannot call or jump to a main', &
'  program from another program unit such as a module or procedure.', &
'', &
'GLOSSARY', &
'  program', &
'', &
'  set of Fortran program units and entities defined by means other than', &
'  Fortran that includes exactly one main program.', &
'', &
'  program unit', &
'', &
'  A main program, external subprogram, module, submodule, or block data', &
'  program unit.', &
'', &
'                               March 16, 2025               program(7fortran)', &
'']

shortname="program"
call process()

case('188','radix')

textblock=[character(len=256) :: &
'', &
'radix(3fortran)                                               radix(3fortran)', &
'', &
'NAME', &
'  RADIX(3) - [MODEL:NUMERIC] Base of a numeric model', &
'', &
'SYNOPSIS', &
'  result = radix(x)', &
'', &
'         integer function radix(x)', &
'', &
'          TYPE(kind=**),intent(in) :: x(..)', &
'', &
'CHARACTERISTICS', &
'  o  X may be scalar or an array of any real or integer type.', &
'', &
'  o  the result is a default integer scalar.', &
'', &
'DESCRIPTION', &
'  RADIX(3) returns the base of the internal model representing the numeric', &
'  entity X.', &
'', &
'  In a positional numeral system, the radix or base is the number of unique', &
'  digits, including the digit zero, used to represent numbers.', &
'', &
'  This function helps to represent the internal computing model generically,', &
'  but will be 2 (representing a binary machine) for any common platform for', &
'  all the numeric types.', &
'', &
'OPTIONS', &
'  o  X : used to identify the type of number to query.', &
'', &
'RESULT', &
'  The returned value indicates what base is internally used to represent the', &
'  type of numeric value X represents.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_radix', &
'      implicit none', &
'        print *, "The radix for the default integer kind is", radix(0)', &
'        print *, "The radix for the default real kind is", radix(0.0)', &
'        print *, "The radix for the doubleprecision real kind is", radix(0.0d0)', &
'      end program demo_radix', &
'', &
'  Results:', &
'', &
'       >  The radix for the default integer kind is          2', &
'       >  The radix for the default real kind is          2', &
'       >  The radix for the doubleprecision real kind is          2', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RANGE(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 radix(3fortran)', &
'']

shortname="radix"
call process()

case('189','random_init')

textblock=[character(len=256) :: &
'', &
'random_init(3fortran)                                   random_init(3fortran)', &
'', &
'NAME', &
'  RANDOM_INIT(3) - [MATHEMATICS:RANDOM] Initializes the state of the', &
'  pseudorandom number generator', &
'', &
'SYNOPSIS', &
'  call random_init(repeatable, image_distinct)', &
'', &
'          logical,intent(in) :: repeatable', &
'          logical,intent(in) :: image_distinct', &
'', &
'CHARACTERISTICS', &
'  o  HARVEST and IMAGE_DISTINCT are logical scalars', &
'', &
'  Description', &
'', &
'  Initializes the state of the pseudorandom number generator used by', &
'  RANDOM_NUMBER.', &
'', &
'OPTIONS', &
'  REPEATABLE : If it is .TRUE., the seed is set to a processor-dependent value', &
'  that is the same each time RANDOM_INIT is called from the same image. The', &
'  term "same image" means a single instance of program execution. The sequence', &
'  of random numbers is different for repeated execution of the program.', &
'', &
'  If it is .FALSE., the seed is set to a processor-dependent value.', &
'', &
'  IMAGE_DISTINCT : If it is .true., the seed is set to a processor-dependent', &
'  value that is distinct from the seed set by a call to RANDOM_INITin another', &
'  image. If it is .FALSE., the seed is set to a value that does depend on', &
'  which image called RANDOM_INIT.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'         program demo_random_init', &
'         implicit none', &
'         real x(3), y(3)', &
'            call random_init(.true., .true.)', &
'            call random_number(x)', &
'            call random_init(.true., .true.)', &
'            call random_number(y)', &
'            ! x and y should be the same sequence', &
'            if ( any(x /= y) ) stop "x(:) and y(:) are not all equal"', &
'            write(*,*)x', &
'            write(*,*)y', &
'         end program demo_random_init', &
'', &
'  Results:', &
'', &
'  RUN 1:', &
'', &
'       >   0.825262189     0.191325366      0.155503273', &
'       >   0.825262189     0.191325366      0.155503273', &
'', &
'  RUN 2:', &
'', &
'       >   0.825262189     0.191325366      0.155503273', &
'       >   0.825262189     0.191325366      0.155503273', &
'', &
'STANDARD', &
'  Fortran 2018', &
'', &
'SEE ALSO', &
'  random_number, random_seed', &
'', &
'  _Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025           random_init(3fortran)', &
'']

shortname="random_init"
call process()

case('190','random_number')

textblock=[character(len=256) :: &
'', &
'random_number(3fortran)                               random_number(3fortran)', &
'', &
'NAME', &
'  RANDOM_NUMBER(3) - [MATHEMATICS:RANDOM] Pseudo-random number', &
'', &
'SYNOPSIS', &
'  call random_number(harvest)', &
'', &
'          subroutine random_number(harvest)', &
'', &
'           real,intent(out) :: harvest(..)', &
'', &
'CHARACTERISTICS', &
'  o  HARVEST and the result are default real variables', &
'', &
'DESCRIPTION', &
'  RANDOM_NUMBER(3) returns a single pseudorandom number or an array of', &
'  pseudorandom numbers from the uniform distribution over the range 0 <= x <', &
'  1.', &
'', &
'OPTIONS', &
'  o  HARVEST : Shall be a scalar or an array of type real.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_random_number', &
'      use, intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      integer, allocatable :: seed(:)', &
'      integer             :: n', &
'      integer             :: first,last', &
'      integer             :: i', &
'      integer             :: rand_int', &
'      integer,allocatable  :: count(:)', &
'      real(kind=dp)       :: rand_val', &
'        call random_seed(size = n)', &
'        allocate(seed(n))', &
'        call random_seed(get=seed)', &
'        first=1', &
'        last=10', &
'        allocate(count(last-first+1))', &
'        ! To have a discrete uniform distribution on the integers', &
'        ! [first, first+1, ..., last-1, last] carve the continuous', &
'        ! distribution up into last+1-first equal sized chunks,', &
'        ! mapping each chunk to an integer.', &
'        !', &
'        ! One way is:', &
'        !   call random_number(rand_val)', &
'        ! choose one from last-first+1 integers', &
'        !   rand_int = first + FLOOR((last+1-first)*rand_val)', &
'           count=0', &
'           ! generate a lot of random integers from 1 to 10 and count them.', &
'           ! with a large number of values you should get about the same', &
'           ! number of each value', &
'           do i=1,100000000', &
'              call random_number(rand_val)', &
'              rand_int=first+floor((last+1-first)*rand_val)', &
'              if(rand_int.ge.first.and.rand_int.le.last)then', &
'                 count(rand_int)=count(rand_int)+1', &
'              else', &
'                 write(*,*)rand_int,'' is out of range''', &
'              endif', &
'           enddo', &
'           write(*,''(i0,1x,i0)'')(i,count(i),i=1,size(count))', &
'      end program demo_random_number', &
'', &
'  Results:', &
'', &
'       >  1 10003588', &
'       >  2 10000104', &
'       >  3 10000169', &
'       >  4 9997996', &
'       >  5 9995349', &
'       >  6 10001304', &
'       >  7 10001909', &
'       >  8 9999133', &
'       >  9 10000252', &
'       >  10 10000196', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  RANDOM_SEED(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025         random_number(3fortran)', &
'']

shortname="random_number"
call process()

case('191','random_seed')

textblock=[character(len=256) :: &
'', &
'random_seed(3fortran)                                   random_seed(3fortran)', &
'', &
'NAME', &
'  RANDOM_SEED(3) - [MATHEMATICS:RANDOM] Initialize a pseudo-random number', &
'  sequence', &
'', &
'SYNOPSIS', &
'  call random_seed( [size] [,put] [,get] )', &
'', &
'          subroutine random_seed( size, put, get )', &
'', &
'           integer,intent(out),optional :: size', &
'           integer,intent(in),optional :: put(*)', &
'           integer,intent(out),optional :: get(*)', &
'', &
'CHARACTERISTICS', &
'  o  SIZE a scalar default integer', &
'', &
'  o  PUT a rank-one default integer array', &
'', &
'  o  GET a rank-one default integer array', &
'', &
'  o  the result', &
'', &
'DESCRIPTION', &
'  RANDOM_SEED(3) restarts or queries the state of the pseudorandom number', &
'  generator used by random_number.', &
'', &
'  If random_seed is called without arguments, it is seeded with random data', &
'  retrieved from the operating system.', &
'', &
'OPTIONS', &
'  o  SIZE : specifies the minimum size of the arrays used with the PUT and GET', &
'     arguments.', &
'', &
'  o  PUT : the size of the array must be larger than or equal to the number', &
'     returned by the SIZE argument.', &
'', &
'  o  GET : It is INTENT(OUT) and the size of the array must be larger than or', &
'     equal to the number returned by the SIZE argument.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'         program demo_random_seed', &
'         implicit none', &
'         integer, allocatable :: seed(:)', &
'         integer :: n', &
'', &
'            call random_seed(size = n)', &
'            allocate(seed(n))', &
'            call random_seed(get=seed)', &
'            write (*, *) seed', &
'', &
'         end program demo_random_seed', &
'', &
'  Results:', &
'', &
'       >    -674862499 -1750483360  -183136071 -317862567   682500039', &
'       >    349459   344020729 -1725483289', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  RANDOM_NUMBER(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025           random_seed(3fortran)', &
'']

shortname="random_seed"
call process()

case('192','range')

textblock=[character(len=256) :: &
'', &
'range(3fortran)                                               range(3fortran)', &
'', &
'NAME', &
'  RANGE(3) - [MODEL:NUMERIC] Decimal exponent range of a numeric kind', &
'', &
'SYNOPSIS', &
'  result = range(x)', &
'', &
'           integer function range (x)', &
'', &
'            TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be of type integer, real, or complex. It may be a scalar or an', &
'     array.', &
'', &
'  o  KIND is any kind supported by the type of X', &
'', &
'  o  the result is a default integer scalar', &
'', &
'DESCRIPTION', &
'  RANGE(3) returns the decimal exponent range in the model of the type of X.', &
'', &
'  Since X is only used to determine the type and kind being interrogated, the', &
'  value need not be defined.', &
'', &
'OPTIONS', &
'  o  X : the value whose type and kind are used for the query', &
'', &
'RESULT', &
'  Case (i) : For an integer argument, the result has the value', &
'', &
'         int (log10 (huge(x)))', &
'', &
'  Case (ii) : For a real argument, the result has the value', &
'', &
'          int(min (log10 (huge(x)), -log10(tiny(x) )))', &
'', &
'  Case (iii) : For a complex argument, the result has the value', &
'', &
'         range(real(x))', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_range', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32', &
'      implicit none', &
'      real(kind=sp)    :: x(2)', &
'      complex(kind=dp) :: y', &
'        print *, precision(x), range(x)', &
'        print *, precision(y), range(y)', &
'      end program demo_range', &
'', &
'  Results:', &
'', &
'       >           6          37', &
'       >          15         307', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RRSPACING(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 range(3fortran)', &
'']

shortname="range"
call process()

case('193','rank')

textblock=[character(len=256) :: &
'', &
'rank(3fortran)                                                 rank(3fortran)', &
'', &
'NAME', &
'  RANK(3) - [ARRAY:INQUIRY] Rank of a data object', &
'', &
'SYNOPSIS', &
'  result = rank(a)', &
'', &
'          integer function rank(a)', &
'', &
'           type(TYPE(kind=**)),intent(in) :: a(..)', &
'', &
'CHARACTERISTICS', &
'  o  A can be of any type TYPE and rank.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  RANK(3) returns the rank of a scalar or array data object.', &
'', &
'  The rank of an array is the number of dimensions it has (zero for a scalar).', &
'', &
'OPTIONS', &
'  o  A : is the data object to query the dimensionality of. The rank returned', &
'     may be from 0 to 16.', &
'', &
'     The argument A may be any data object type, including an assumed-rank', &
'     array.', &
'', &
'RESULT', &
'  For arrays, their rank is returned; for scalars zero is returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_rank', &
'      implicit none', &
'', &
'      ! a bunch of data objects to query', &
'      integer          :: a', &
'      real, allocatable :: b(:,:)', &
'      real, pointer    :: c(:)', &
'      complex          :: d', &
'', &
'      ! make up a type', &
'      type mytype', &
'        integer :: int', &
'        real :: float', &
'        character :: char', &
'      end type mytype', &
'      type(mytype) :: any_thing(1,2,3,4,5)', &
'', &
'       ! basics', &
'        print *, ''rank of scalar a='',rank(a)', &
'        ! you can query this array even though it is not allocated', &
'        print *, ''rank of matrix b='',rank(b)', &
'        print *, ''rank of vector pointer c='',rank(c)', &
'        print *, ''rank of complex scalar d='',rank(d)', &
'', &
'       ! you can query any type, not just intrinsics', &
'        print *, ''rank of any arbitrary type='',rank(any_thing)', &
'', &
'       ! an assumed-rank object may be queried', &
'        call query_int(10)', &
'        call query_int([20,30])', &
'        call query_int( reshape([40,50,60,70],[2,2]) )', &
'', &
'       ! you can even query an unlimited polymorphic entity', &
'        call query_anything(10.0)', &
'        call query_anything([.true.,.false.])', &
'        call query_anything( reshape([40.0,50.0,60.0,70.0],[2,2]) )', &
'', &
'      contains', &
'', &
'      subroutine query_int(data_object)', &
'      ! It is hard to do much with something dimensioned', &
'      ! name(..) if not calling C except inside of a', &
'      ! SELECT_RANK construct but one thing you can', &
'      ! do is call the inquiry functions ...', &
'      integer,intent(in) :: data_object(..)', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'', &
'        if(rank(data_object).eq.0)then', &
'           print all,&', &
'           & ''passed a scalar to an assumed rank,  &', &
'           & rank='',rank(data_object)', &
'        else', &
'           print all,&', &
'           & ''passed an array to an assumed rank,  &', &
'           & rank='',rank(data_object)', &
'        endif', &
'', &
'      end subroutine query_int', &
'', &
'      subroutine query_anything(data_object)', &
'      class(*),intent(in) ::data_object(..)', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'       if(rank(data_object).eq.0)then', &
'         print all,&', &
'         &''passed a scalar to an unlimited polymorphic rank='', &', &
'         & rank(data_object)', &
'       else', &
'         print all,&', &
'         & ''passed an array to an unlimited polymorphic, rank='', &', &
'         & rank(data_object)', &
'       endif', &
'      end subroutine query_anything', &
'', &
'      end program demo_rank', &
'', &
'  Results:', &
'', &
'       >  rank of scalar a=           0', &
'       >  rank of matrix b=           2', &
'       >  rank of vector pointer c=           1', &
'       >  rank of complex scalar d=           0', &
'       >  rank of any arbitrary type=           5', &
'       > passed a scalar to an assumed rank,   rank= 0', &
'       > passed an array to an assumed rank,   rank= 1', &
'       > passed an array to an assumed rank,   rank= 2', &
'       > passed a scalar to an unlimited polymorphic rank= 0', &
'       > passed an array to an unlimited polymorphic, rank= 1', &
'       > passed an array to an unlimited polymorphic, rank= 2', &
'', &
'STANDARD', &
'SEE ALSO', &
'  Array inquiry:', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  SHAPE(3) - Determine the shape of an array', &
'', &
'  o  UBOUND(3) - Upper dimension bounds of an array', &
'', &
'  o  LBOUND(3) - Lower dimension bounds of an array', &
'', &
'  State Inquiry:', &
'', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - Test if object is contiguous', &
'', &
'  Kind Inquiry:', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Bit Inquiry:', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  rank(3fortran)', &
'']

shortname="rank"
call process()

case('194','read')

textblock=[character(len=256) :: &
'', &
'read(7fortran)                                                 read(7fortran)', &
'', &
'NAME', &
'  read(7f) - [IO] read data', &
'', &
'SYNOPSIS', &
'DESCRIPTION', &
'OPTIONS', &
'EXAMPLES', &
'  Sample:', &
'', &
'        program testit', &
'        use,intrinsic :: iso_fortran_env, only : stdin=>input_unit', &
'        implicit none', &
'        character(len=:),allocatable :: line', &
'        character(len=*),parameter   :: gen=''(*(g0))''', &
'        integer                      :: ichars=0, ilines=0, ilength=0, ios', &
'           open(unit=stdin,pad=''no'')', &
'           READFILE: do', &
'              call getl(line,ios)', &
'              if(ios.ne.0)exit READFILE', &
'              ilines=ilines+1', &
'              ilength=len(line)', &
'              ichars=ichars+ilength', &
'              write(*,''(i9,i9,i9,"[",a,"]")'')ichars,ilines,ilength,line', &
'           enddo READFILE', &
'           write(*,gen)''CHARS+LINES='',ichars+ilines', &
'        contains', &
'        subroutine getl(line,ios)', &
'        use,intrinsic :: iso_fortran_env, only : iostat_eor, iostat_end, &', &
'         & stderr=>error_unit', &
'        character(len=:),intent(out),allocatable :: line', &
'        integer,intent(out) :: ios', &
'        character :: a*1,msg*256', &
'           line=''''', &
'           READLINE: do', &
'              read(stdin,advance=''no'',iostat=ios,fmt=''(a)'',iomsg=msg) a', &
'              select case(ios)', &
'              case(IOSTAT_END);              exit READLINE', &
'              case(IOSTAT_EOR); ios=0;       exit READLINE', &
'              case(0);          line=line//a', &
'              case default', &
'                 write(stderr,gen)''LINE '',ilines,'' ERROR:'',trim(msg)', &
'                 exit READLINE', &
'              end select', &
'           enddo READLINE', &
'        end subroutine getl', &
'        end program testit', &
'', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025                  read(7fortran)', &
'']

shortname="read"
call process()

case('195','real')

textblock=[character(len=256) :: &
'', &
'real(3fortran)                                                 real(3fortran)', &
'', &
'NAME', &
'  REAL(3) - [TYPE:CONVERSION] Convert to real type', &
'', &
'SYNOPSIS', &
'  result = real(x [,kind])', &
'', &
'        elemental real(kind=KIND) function real(x,KIND)', &
'', &
'         TYPE(kind=**),intent(in) :: x', &
'         integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  the type of X may be integer, real, or complex; or a BOZ-literal-', &
'     constant.', &
'', &
'  o  KIND is a integer initialization expression (a constant expression)', &
'', &
'     o If KIND is present it defines the kind of the real result', &
'', &
'     o if KIND is not present', &
'', &
'       o  when X is complex the result is a real of the same kind as X.', &
'', &
'       o  when X is real or integer the result is a real of default kind', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  REAL(3) converts its argument X to a real type.', &
'', &
'  The real part of a complex value is returned. For complex values this is', &
'  similar to the modern complex-part-designator %RE which also designates the', &
'  real part of a complex value.', &
'', &
'           z=(3.0,4.0)     ! if z is a complex value', &
'           print *, z%re == real(z) ! these expressions are equivalent', &
'', &
'OPTIONS', &
'  o  X : An integer, real, or complex value to convert to real.', &
'', &
'  o  KIND : When present the value of KIND defines the kind of the result.', &
'', &
'RESULT', &
'  1.  REAL(X) converts X to a default real type if X is an integer or real', &
'      variable.', &
'', &
'  2.  REAL(X) converts a complex value to a real type with the magnitude of', &
'      the real component of the input with kind type parameter the same as X.', &
'', &
'  3.  REAL(X, KIND) is converted to a real type with kind type parameter KIND', &
'      if X is a complex, integer, or real variable.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_real', &
'      use,intrinsic :: iso_fortran_env, only : dp=>real64', &
'      implicit none', &
'      complex             :: zr = (1.0, 2.0)', &
'      doubleprecision     :: xd=huge(3.0d0)', &
'      complex(kind=dp) :: zd=cmplx(4.0e0_dp,5.0e0_dp,kind=dp)', &
'', &
'        print *, real(zr), aimag(zr)', &
'        print *, dble(zd), aimag(zd)', &
'', &
'        write(*,*)xd,real(xd,kind=kind(0.0d0)),dble(xd)', &
'      end program demo_real', &
'', &
'  Results:', &
'', &
'       > 1.00000000      2.00000000', &
'       > 4.0000000000000000     5.0000000000000000', &
'       > 1.7976931348623157E+308 1.7976931348623157E+308 1.7976931348623157E+30', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  o  AIMAG(3) - Imaginary part of complex number', &
'', &
'  o  CMPLX(3) - Complex conversion function', &
'', &
'  o  CONJG(3) - Complex conjugate function', &
'', &
'  Fortran has strong support for complex values, including many intrinsics', &
'  that take or produce complex values in addition to algebraic and logical', &
'  expressions:', &
'', &
'  ABS(3), ACOSH(3), ACOS(3), ASINH(3), ASIN(3), ATAN2(3), ATANH(3), ATAN(3),', &
'  COSH(3), COS(3), CO_SUM(3), DBLE(3), DOT_PRODUCT(3), EXP(3), INT(3),', &
'  IS_CONTIGUOUS(3), KIND(3), LOG(3), MATMUL(3), PRECISION(3), PRODUCT(3),', &
'  RANGE(3), RANK(3), SINH(3), SIN(3), SQRT(3), STORAGE_SIZE(3), SUM(3),', &
'  TANH(3), TAN(3), UNPACK(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  real(3fortran)', &
'']

shortname="real"
call process()

case('196','reduce')

textblock=[character(len=256) :: &
'', &
'reduce(3fortran)                                             reduce(3fortran)', &
'', &
'NAME', &
'  REDUCE(3) - [ARRAY:TRANSFORMATIONAL] General reduction of an array', &
'', &
'SYNOPSIS', &
'  There are two forms to this function:', &
'', &
'        result = reduce(array, operation [,mask]  [,identity]  [,ordered] )', &
'', &
'  or', &
'', &
'        result = reduce (array, operation, dim  &', &
'        & [,mask] [,identity] [,ordered] )', &
'', &
'         type(TYPE(kind=KIND)) function reduce &', &
'         & (array, operation, dim, mask, identity, ordered )', &
'', &
'          type(TYPE(kind=KIND)),intent(in) :: array', &
'          pure function                  :: operation', &
'          integer,intent(in),optional    :: dim', &
'          logical,optional               :: mask', &
'          type(TYPE),intent(in),optional :: identity', &
'          logical,intent(in),optional    :: ordered', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY is an array of any type', &
'', &
'  o  OPERATION is a pure function with exactly two arguments', &
'', &
'     o each argument is scalar, non-allocatable, a nonpointer, nonpolymorphic', &
'       and nonoptional with the same type and kind as array.', &
'', &
'     o if one argument has the asynchronous, target, or value attribute so', &
'       shall the other.', &
'', &
'  o  DIM is an integer scalar', &
'', &
'  o  MASK is a logical conformable with ARRAY', &
'', &
'  o  IDENTITY is a scalar with the same type and type parameters as ARRAY', &
'', &
'  o  ORDERED is a logical scalar', &
'', &
'  o  the result is of the same type and type parameters as ARRAY.', &
'', &
'DESCRIPTION', &
'  REDUCE(3) reduces a list of conditionally selected values from an array to a', &
'  single value by iteratively applying a binary function.', &
'', &
'  Common in functional programming, a REDUCE function applies a binary', &
'  operator (a pure function with two arguments) to all elements cumulatively.', &
'', &
'  REDUCE is a "higher-order" function; ie. it is a function that receives', &
'  other functions as arguments.', &
'', &
'  The REDUCE function receives a binary operator (a function with two', &
'  arguments, just like the basic arithmetic operators). It is first applied to', &
'  two unused values in the list to generate an accumulator value which is', &
'  subsequently used as the first argument to the function as the function is', &
'  recursively applied to all the remaining selected values in the input array.', &
'', &
'OPTIONS', &
'  o  ARRAY : An array of any type and allowed rank to select values from.', &
'', &
'  o  OPERATION : shall be a pure function with exactly two arguments; each', &
'     argument shall be a scalar, nonallocatable, nonpointer, nonpolymorphic,', &
'     nonoptional dummy data object with the same type and type parameters as', &
'     ARRAY. If one argument has the ASYNCHRONOUS, TARGET, or VALUE attribute,', &
'     the other shall have that attribute. Its result shall be a nonpolymorphic', &
'     scalar and have the same type and type parameters as ARRAY. OPERATION', &
'     should implement a mathematically associative operation. It need not be', &
'     commutative.', &
'', &
'   NOTE', &
'  If OPERATION is not computationally associative, REDUCE without', &
'  ORDERED=.TRUE. with the same argument values might not always produce the', &
'  same result, as the processor can apply the associative law to the', &
'  evaluation.', &
'', &
'  Many operations that mathematically are associative are not when applied to', &
'  floating-point numbers. The order you sum values in may affect the result,', &
'  for example.', &
'', &
'  o  DIM : An integer scalar with a value in the range 1<= DIM <= n, where n', &
'     is the rank of ARRAY.', &
'', &
'     o MASK : (optional) shall be of type logical and shall be conformable', &
'       with ARRAY.', &
'', &
'       When present only those elements of ARRAY are passed to OPERATION for', &
'       which the corresponding elements of MASK are true, as if ARRAY was', &
'       filtered with PACK(3).', &
'', &
'     o IDENTITY : shall be scalar with the same type and type parameters as', &
'       ARRAY. If the initial sequence is empty, the result has the value', &
'       IDENTIFY if IDENTIFY is present, and otherwise, error termination is', &
'       initiated.', &
'', &
'     o ORDERED : shall be a logical scalar. If ORDERED is present with the', &
'       value .true., the calls to the OPERATOR function begins with the first', &
'       two elements of ARRAY and the process continues in row-column order', &
'       until the sequence has only one element which is the value of the', &
'       reduction. Otherwise, the compiler is free to assume that the', &
'       operation is commutative and may evaluate the reduction in the most', &
'       optimal way.', &
'', &
'RESULT', &
'  The result is of the same type and type parameters as ARRAY. It is scalar if', &
'  DIM does not appear.', &
'', &
'  If DIM is present, it indicates the one dimension along which to perform the', &
'  reduction, and the resultant array has a rank reduced by one relative to the', &
'  input array.', &
'', &
'EXAMPLES', &
'  The following examples all use the function MY_MULT, which returns the', &
'  product of its two real arguments.', &
'', &
'        program demo_reduce', &
'        implicit none', &
'        character(len=*),parameter :: f=''("[",*(g0,",",1x),"]")''', &
'        integer,allocatable :: arr(:), b(:,:)', &
'', &
'        ! Basic usage:', &
'           ! the product of the elements of an array', &
'           arr=[1, 2, 3, 4 ]', &
'           write(*,*) arr', &
'           write(*,*) ''product='', reduce(arr, my_mult)', &
'           write(*,*) ''sum='', reduce(arr, my_sum)', &
'', &
'        ! Examples of masking:', &
'           ! the product of only the positive elements of an array', &
'           arr=[1, -1, 2, -2, 3, -3 ]', &
'           write(*,*)''positive value product='',reduce(arr, my_mult, mask=arr>0)', &
'        ! sum values ignoring negative values', &
'           write(*,*)''sum positive values='',reduce(arr, my_sum, mask=arr>0)', &
'', &
'        ! a single-valued array returns the single value as the', &
'        ! calls to the operator stop when only one element remains', &
'           arr=[ 1234 ]', &
'           write(*,*)''single value sum'',reduce(arr, my_sum )', &
'           write(*,*)''single value product'',reduce(arr, my_mult )', &
'', &
'        ! Example of operations along a dimension:', &
'        !  If B is the array   1 3 5', &
'        !                      2 4 6', &
'           b=reshape([1,2,3,4,5,6],[2,3])', &
'           write(*,f) REDUCE(B, MY_MULT),''should be [720]''', &
'           write(*,f) REDUCE(B, MY_MULT, DIM=1),''should be [2,12,30]''', &
'           write(*,f) REDUCE(B, MY_MULT, DIM=2),''should be [15, 48]''', &
'', &
'        contains', &
'', &
'        pure function my_mult(a,b) result(c)', &
'        integer,intent(in) :: a, b', &
'        integer            :: c', &
'           c=a*b', &
'        end function my_mult', &
'', &
'        pure function my_sum(a,b) result(c)', &
'        integer,intent(in) :: a, b', &
'        integer            :: c', &
'           c=a+b', &
'        end function my_sum', &
'', &
'        end program demo_reduce', &
'', &
'  Results:', &
'', &
'          >  1 2 3 4', &
'          >  product= 24', &
'          >  sum=     10', &
'          >  positive value sum= 6', &
'          >  sum positive values= 6', &
'          >  single value sum     1234', &
'          >  single value product 1234', &
'          > [720, should be [720],', &
'          > [2, 12, 30, should be [2,12,30],', &
'          > [15, 48, should be [15, 48],', &
'', &
'STANDARD', &
'  Fortran 2018', &
'', &
'SEE ALSO', &
'  o  co_reduce(3)', &
'', &
'RESOURCES', &
'  o  associative:wikipedia', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                reduce(3fortran)', &
'']

shortname="reduce"
call process()

case('197','repeat')

textblock=[character(len=256) :: &
'', &
'repeat(3fortran)                                             repeat(3fortran)', &
'', &
'NAME', &
'  REPEAT(3) - [CHARACTER:PAD] Repeated string concatenation', &
'', &
'SYNOPSIS', &
'  result = repeat(string, ncopies)', &
'', &
'          character(len=len(string)*ncopies) function repeat(string, ncopies)', &
'', &
'           character(len=*),intent(in)   :: string', &
'           integer(kind=**),intent(in)   :: ncopies', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  STRING is a scalar character type.', &
'', &
'  o  NCOPIES is a scalar integer.', &
'', &
'  o  the result is a new scalar of type character of the same kind as the', &
'     variable STRING.', &
'', &
'DESCRIPTION', &
'  REPEAT(3) concatenates copies of a string.', &
'', &
'OPTIONS', &
'  o  STRING : The input string to repeat', &
'', &
'  o  NCOPIES : Number of copies to make of STRING, greater than or equal to', &
'     zero (0).', &
'', &
'RESULT', &
'  A new string built up from NCOPIES copies of STRING.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_repeat', &
'      implicit none', &
'         write(*,''(a)'') repeat("^v", 35)       ! line break', &
'         write(*,''(a)'') repeat("_", 70)        ! line break', &
'         write(*,''(a)'') repeat("1234567890", 7)  ! number line', &
'         write(*,''(a)'') repeat("       |", 7)  !', &
'      end program demo_repeat', &
'', &
'  Results:', &
'', &
'       > ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v', &
'       > ______________________________________________________________________', &
'       > 1234567890123456789012345678901234567890123456789012345678901234567890', &
'       >         |         |         |         |         |         |         |', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NON-ELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                repeat(3fortran)', &
'']

shortname="repeat"
call process()

case('198','reshape')

textblock=[character(len=256) :: &
'', &
'reshape(3fortran)                                           reshape(3fortran)', &
'', &
'NAME', &
'  RESHAPE(3) - [ARRAY:RESHAPE] Function to reshape an array', &
'', &
'SYNOPSIS', &
'  result = reshape( source, shape [,pad] [,order] )', &
'', &
'          type(TYPE(kind=KIND)) function reshape', &
'', &
'           type(TYPE(kind=KIND)),intent(in)          :: source(..)', &
'           integer(kind=**),intent(in)               :: shape(:)', &
'           type(TYPE(kind=KIND)),intent(in),optional :: pad(..)', &
'           integer(kind=**),intent(in),optional      :: order(:)', &
'', &
'CHARACTERISTICS', &
'  o  SOURCE is an array of any type', &
'', &
'  o  SHAPE defines a Fortran shape and therefore an integer vector (of rank', &
'     one) of constant size of up to 16 non-negative values.', &
'', &
'  o  PAD is the same type as SOURCE', &
'', &
'  o  ORDER is the same shape as SHAPE', &
'', &
'  o  The result is an array of shape SHAPE with the same type as SOURCE.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  RESHAPE constructs an array of arbitrary shape SHAPE using the elements from', &
'  SOURCE and possibly PAD to fill it.', &
'', &
'  If necessary, the new array may be padded with elements from PAD or permuted', &
'  as defined by ORDER.', &
'', &
'  Among many other uses, RESHAPE can be used to reorder a Fortran array to', &
'  match C array ordering before the array is passed from Fortran to a C', &
'  procedure.', &
'', &
'OPTIONS', &
'  o  SOURCE : an array containing the elements to be copied to the result.', &
'     there must be enough elements in the source to fill the new shape if PAD', &
'     is omitted or has size zero. Expressed in Fortran ...', &
'', &
'        if(.not.present(pad))then', &
'           if(size(source) < product(shape))then', &
'             stop ''not enough elements in the old array to fill the new one''', &
'           endif', &
'        endif', &
'', &
'  o  SHAPE : This is the shape of the new array being generated. Being by', &
'     definition a shape; all elements are either positive integers or zero,', &
'     the size but be 1 or greater, it may have up to 16 elements but must be', &
'     of constant fixed size and rank one.', &
'', &
'  o  PAD : used to fill in extra values if the result array is larger than', &
'     SOURCE. It will be used repeatedly after all the elements of SOURCE have', &
'     been placed in the result until the result has all elements assigned. :', &
'     If it is absent or is a zero-sized array, you can only make SOURCE into', &
'     another array of the same size as SOURCE or smaller.', &
'', &
'  o  ORDER : used to insert elements in the result in an order other than the', &
'     normal Fortran array element order, in which the first dimension varies', &
'     fastest. : By definition of ranks the values have to be a permutation of', &
'     the numbers from 1 to n, where n is the rank of SHAPE. : the elements of', &
'     SOURCE and pad are placed into the result in order; changing the left-', &
'     most rank most rapidly by default. To change the order by which the', &
'     elements are placed in the result use ORDER.', &
'', &
'RESULT', &
'  The result is an array of shape SHAPE with the same type and type parameters', &
'  as SOURCE. It is first filled with the values of elements of SOURCE, with', &
'  the remainder filled with repeated copies of PAD until all elements are', &
'  filled. The new array may be smaller than SOURCE.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_reshape', &
'      implicit none', &
'      ! notice the use of "shape(box)" on the RHS', &
'      integer :: box(3,4)=reshape([1,2,3,4,5,6,7,8,9,10,11,12],shape(box))', &
'      integer,allocatable :: v(:,:)', &
'      integer :: rc(2)', &
'        ! basics0', &
'         ! what is the current shape of the array?', &
'         call printi(''shape of box is '',box)', &
'         ! change the shape', &
'         call printi(''reshaped '',reshape(box,[2,6]))', &
'         call printi(''reshaped '',reshape(box,[4,3]))', &
'', &
'        ! fill in row column order using order', &
'         v=reshape([1,2,3,4,10,20,30,40,100,200,300,400],[1,12])', &
'         call printi(''here is some data to shape'',v)', &
'         call printi(''normally fills columns first '',reshape([v],[3,4]))', &
'         call printi(''fill rows first'', reshape([v],[3,4],order=[2,1]))', &
'', &
'         ! if we take the data and put in back in filling', &
'         ! rows first instead of columns, and flipping the', &
'         ! height and width of the box we not only fill in', &
'         ! a vector using row-column order we actually', &
'         ! transpose it.', &
'         rc(2:1:-1)=shape(box)', &
'         ! copy the data in changing column number fastest', &
'         v=reshape(box,rc,order=[2,1])', &
'         call printi(''reshaped and reordered'',v)', &
'         ! of course we could have just done a transpose', &
'         call printi(''transposed'',transpose(box))', &
'', &
'        ! making the result bigger than source using pad', &
'         v=reshape(box,rc*2,pad=[-1,-2,-3],order=[2,1])', &
'         call printi(''bigger and padded and reordered'',v)', &
'      contains', &
'', &
'      subroutine printi(title,arr)', &
'      implicit none', &
'', &
'      !@(#) print small 2d integer arrays in row-column format', &
'', &
'      character(len=*),parameter :: all=''(*(g0,1x))'' ! a handy format', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'', &
'        print all', &
'        print all, trim(title),'':('',shape(arr),'')''  ! print title', &
'        biggest=''          '' ! make buffer to write integer into', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''(" > [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'', &
'      end subroutine printi', &
'', &
'      end program demo_reshape', &
'', &
'  Results:', &
'', &
'        shape of box is :( 3 4 )', &
'         > [   1,   4,   7,  10 ]', &
'         > [   2,   5,   8,  11 ]', &
'         > [   3,   6,   9,  12 ]', &
'', &
'        reshaped :( 2 6 )', &
'         > [   1,   3,   5,   7,   9,  11 ]', &
'         > [   2,   4,   6,   8,  10,  12 ]', &
'', &
'        reshaped :( 4 3 )', &
'         > [   1,   5,   9 ]', &
'         > [   2,   6,  10 ]', &
'         > [   3,   7,  11 ]', &
'         > [   4,   8,  12 ]', &
'', &
'        here is some data to shape :( 1 12 )', &
'         > [   1,   2,   3,   4,  10,  20,  30,  40, 100, 200, 300, 400 ]', &
'', &
'        normally fills columns first :( 3 4 )', &
'         > [    1,    4,   30,  200 ]', &
'         > [    2,   10,   40,  300 ]', &
'         > [    3,   20,  100,  400 ]', &
'', &
'        fill rows first :( 3 4 )', &
'         > [    1,    2,    3,    4 ]', &
'         > [   10,   20,   30,   40 ]', &
'         > [  100,  200,  300,  400 ]', &
'', &
'        reshaped and reordered :( 4 3 )', &
'         > [   1,   2,   3 ]', &
'         > [   4,   5,   6 ]', &
'         > [   7,   8,   9 ]', &
'         > [  10,  11,  12 ]', &
'', &
'        transposed :( 4 3 )', &
'         > [   1,   2,   3 ]', &
'         > [   4,   5,   6 ]', &
'         > [   7,   8,   9 ]', &
'         > [  10,  11,  12 ]', &
'', &
'        bigger and padded and reordered :( 8 6 )', &
'         > [   1,   2,   3,   4,   5,   6 ]', &
'         > [   7,   8,   9,  10,  11,  12 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'         > [  -1,  -2,  -3,  -1,  -2,  -3 ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  SHAPE(3), PACK(3), TRANSPOSE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               reshape(3fortran)', &
'']

shortname="reshape"
call process()

case('199','return')

textblock=[character(len=256) :: &
'', &
'return(7fortran)                                             return(7fortran)', &
'', &
'NAME', &
'  return(7f) - [STATEMENT] completes execution of the instance of the', &
'  subprogram in which it appears', &
'', &
'SYNOPSIS', &
'  RETURN [scalar-int-expr]', &
'', &
'DESCRIPTION', &
'  Execution of the RETURN statement completes execution of the instance of the', &
'  subprogram in which it appears.', &
'', &
'  It is generally considered good practice to avoid having multiple RETURN', &
'  statements in a single subprogram. A RETURN is not required in a subprogram', &
'  as reaching the end of the subprogram is equivalent to execution of a RETURN', &
'  statement with no expression.', &
'', &
'  The RETURN statement must appear in the scoping unit of a function or', &
'  subroutine subprogram.', &
'', &
'OPTIONS', &
'  scalar-int-expr Alternate returns are deprecated!', &
'', &
'                     If the expression appears and has a value n between', &
'                     1 and the number of asterisks in the dummy argument', &
'                     list, the CALL statement that invoked the subroutine', &
'                     transfers control to the statement identified by', &
'                     the nth alternate return specifier in the actual', &
'                     argument list of the referenced procedure. If the', &
'                     expression is omitted or has a value outside the', &
'                     required range, there is no transfer of control to', &
'                     an alternate return.', &
'', &
'                     The scalar-int-expr is allowed only in the scoping', &
'                     unit of a subroutine subprogram.', &
'', &
'EXAMPLE', &
'  Sample program', &
'', &
'         program demo_return', &
'            call tryreturn(1)', &
'            write(*,*)''back at main program:1''', &
'            call tryreturn(10)', &
'            write(*,*)''back at main program:10''', &
'         contains', &
'         subroutine tryreturn(i)', &
'         integer,intent(in) :: i', &
'            select case(i)', &
'            case(1)', &
'               write(*,*)''*one*''', &
'               return', &
'            case(2)', &
'               write(*,*)''*two*''', &
'               return', &
'            case default', &
'               write(*,*)''*unexpected value*''', &
'            end select', &
'            write(*,*)''*<ERROR> should not get here*''', &
'         end subroutine tryreturn', &
'         end program demo_return', &
'', &
'  Results:', &
'', &
'       >  *one*', &
'       >  back at main program:1', &
'       >  *unexpected value*', &
'       >  *<ERROR> should not get here*', &
'       >  back at main program:10', &
'', &
'  Sample program using alternate returns. Alternate returns are an obsolescent', &
'  feature.', &
'', &
'        program alt_return', &
'        implicit none', &
'           call one(2,*10,*20,*30)', &
'           write(*,*)''did not select alternate return''', &
'           goto 999', &
'        10 continue', &
'           write(*,*)''picked first alternate return''', &
'           goto 999', &
'        20 continue', &
'           write(*,*)''picked second alternate return''', &
'           goto 999', &
'        30 continue', &
'           write(*,*)''picked third alternate return''', &
'           goto 999', &
'        999 continue', &
'        contains', &
'        subroutine one(ipick,*,*,*)', &
'        implicit none', &
'        integer :: ipick', &
'           select case(ipick)', &
'            case(1)', &
'              write(*,*)''first alternate return selected''', &
'              return 1', &
'            case(2)', &
'              write(*,*)''second alternate return selected''', &
'              return 2', &
'            case(3)', &
'              write(*,*)''third alternate return selected''', &
'              return 3', &
'           end select', &
'           write(*,*)''no alternate return selected''', &
'        end subroutine one', &
'        end program alt_return', &
'', &
'  Results:', &
'', &
'       >  second alternate return selected', &
'       >  picked second alternate return', &
'', &
'  Fortran statement descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                return(7fortran)', &
'']

shortname="return"
call process()

case('200','rewind')

textblock=[character(len=256) :: &
'', &
'rewind(7fortran)                                             rewind(7fortran)', &
'', &
'NAME', &
'  rewind(7f) - [FILE_POSITIONING] rewind specified sequential access I/O unit', &
'', &
'SYNOPSIS', &
'  rewind file-unit-number', &
'', &
'  rewind ( [UNIT=]file-unit-number][,IOMSG=iomsg-variable] & &', &
'  [,IOSTAT=scalar-int-variable][,ERR=label] )', &
'', &
'DESCRIPTION', &
'  Execution of a REWIND(7F) statement causes the file connected to the', &
'  specified unit to be positioned at the beginning of the file.', &
'', &
'  If the file is already positioned at its initial point, execution of this', &
'  statement has no effect on the position of the file.', &
'', &
'  Execution of a REWIND(7F) statement for a file that is connected but does', &
'  not exist is permitted and has no effect on any file.', &
'', &
'OPTIONS', &
'  UNIT : unit number of file to rewind. A unit open for direct access or', &
'  stream access cannot be referenced by a REWIND(7F) (e.g. you cannot', &
'  typically rewind stdin and stdout).', &
'', &
'  IOSTAT : (Optional) a compiler-specific number that indicates an error', &
'  occurred if non-zero. If not present and an error occurs the program', &
'  terminates.', &
'', &
'  IOMSG : (Optional) a message describing the error if IOSTAT is not zero.', &
'', &
'  ERR : (Optional) a label number to jump to if an error occurs', &
'', &
'EXAMPLES', &
'  An example of a REWIND(7F) statement is:', &
'', &
'         program demo_rewind', &
'         implicit none', &
'         character(len=256) :: line', &
'         character(len=256) :: mssge', &
'         integer            :: i', &
'         integer            :: ios', &
'            open (10, file=''demo_rewind.txt'') ! open a file', &
'            do i = 1, 100                     ! write lines to it', &
'               write (10, ''(a,i0)'') ''line '', i', &
'            enddo', &
'            rewind (10, iostat=ios, iomsg=mssge)', &
'            if (ios .ne. 0) then', &
'               write (*, *) ''*error* '', trim(mssge)', &
'               stop', &
'            endif', &
'            write (*, *) ''wrote 100 lines, but now at line ...''', &
'            read (10, ''(a)'') line', &
'            write (*, ''(a)'') line', &
'            read (10)', &
'            read (10)', &
'            read (10)', &
'            write (*, *) ''skipped a few lines, now at ...''', &
'            read (10, ''(a)'') line', &
'            write (*, ''(a)'') line', &
'            close (10, status=''delete'')', &
'         end program demo_rewind', &
'', &
'SEE ALSO', &
'  The input/output statements are the OPEN(3), CLOSE(3), READ(3), WRITE(3),', &
'  PRINT(3), BACKSPACE(3), ENDFILE(3), REWIND(3), FLUSH(3), WAIT(3) and', &
'  INQUIRE(3) statements.', &
'', &
'  o  The READ(3) statement is a data transfer input statement.', &
'', &
'  o  The WRITE(3) statement and the PRINT(3) statement are data transfer', &
'     output statements.', &
'', &
'  o  The WAIT(3) and FLUSH(3) statements are data transfer statements.', &
'', &
'  o  The OPEN(3) statement and the CLOSE(3) statement are file connection', &
'     statements.', &
'', &
'  o  The INQUIRE(3) statement is a file inquiry statement.', &
'', &
'  o  The BACKSPACE(3), ENDFILE(3), and REWIND(3) statements are file', &
'     positioning statements.', &
'', &
'  Fortran statement descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                rewind(7fortran)', &
'']

shortname="rewind"
call process()

case('201','rrspacing')

textblock=[character(len=256) :: &
'', &
'rrspacing(3fortran)                                       rrspacing(3fortran)', &
'', &
'NAME', &
'  RRSPACING(3) - [MODEL_COMPONENTS] Reciprocal of the relative spacing of a', &
'  numeric type', &
'', &
'SYNOPSIS', &
'  result = rrspacing(x)', &
'', &
'          elemental real(kind=KIND) function rrspacing(x)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is type real of any kind', &
'', &
'  o  The return value is of the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  RRSPACING(3) returns the reciprocal of the relative spacing of model numbers', &
'  near X.', &
'', &
'OPTIONS', &
'  o  X : Shall be of type real.', &
'', &
'RESULT', &
'  The return value is of the same type and kind as X. The value returned is', &
'  equal to ABS(FRACTION(X)) * FLOAT(RADIX(X))**DIGITS(X).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_rrspacing', &
'      implicit none', &
'      integer, parameter :: sgl = selected_real_kind(p=6, r=37)', &
'      integer, parameter :: dbl = selected_real_kind(p=13, r=200)', &
'      character(len=*),parameter :: gen=''(*(g0))'', nl=new_line(''A'')', &
'      real(kind=sgl) :: x', &
'        x=-3.0_sgl', &
'        print gen, &', &
'        ''rrspacing('',x,''_sgl)='', rrspacing(x),                   nl, &', &
'        ''rrspacing(x)=abs(fraction(x))*float(radix(x))**digits(x)'',  nl, &', &
'        ''so this should be the same as rrspacing():'',                      nl, &', &
'        abs( fraction(x) ) * float( radix(x) )**digits(x),           nl, &', &
'        ''RRSPACING (-3.0) has the value 0.75x2**24 for reals'',       nl, &', &
'        ''on current typical platforms. For reference:'',            nl, &', &
'        ''   0.75*2**24='', 0.75*2**24,                                      nl, &', &
'        ''sign should not matter, so'',rrspacing(x)==rrspacing(-x),    nl, &', &
'        ''note the kind of the value is significant'',               nl, &', &
'        rrspacing(-3.0_dbl),                                         nl, &', &
'        ''for common platforms rrspacing(487923.3d0)=>'',            nl, &', &
'        ''   8.382458680573952E+015'',                               nl, &', &
'        rrspacing(487923.3d0),                                       nl, &', &
'        '' ''', &
'      end program demo_rrspacing', &
'', &
'       > rrspacing(-3.00000000_sgl)=12582912.0', &
'       > rrspacing(x)=abs(fraction(x))*float(radix(x))**digits(x)', &
'       > so this should be the same as rrspacing():', &
'       > 12582912.0', &
'       > RRSPACING (-3.0) has the value 0.75x2**24 for reals', &
'       > on current typical platforms. For reference:', &
'       > 0.75*2**24=12582912.0', &
'       > sign should not matter, soT', &
'       > note the kind of the value is significant', &
'       > 6755399441055744.0', &
'       > for common platforms rrspacing(487923.3d0)=>8.382458680573952E+015', &
'       > 8382458465825587.0', &
'', &
'STANDARD', &
'  Fortran 90', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), SCALE(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025             rrspacing(3fortran)', &
'']

shortname="rrspacing"
call process()

case('202','same_type_as')

textblock=[character(len=256) :: &
'', &
'same_type_as(3fortran)                                 same_type_as(3fortran)', &
'', &
'NAME', &
'  SAME_TYPE_AS(3) - [STATE:INQUIRY] Query dynamic types for equality', &
'', &
'SYNOPSIS', &
'  result = same_type_as(a, b)', &
'', &
'          logical same_type_as(a, b)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: a', &
'           type(TYPE(kind=KIND)),intent(in) :: b', &
'', &
'CHARACTERISTICS', &
'  o  A shall be an object of extensible declared type or unlimited', &
'     polymorphic. If it is a polymorphic pointer, it shall not have an', &
'     undefined association status.', &
'', &
'  o  B shall be an object of extensible declared type or unlimited', &
'     polymorphic. If it is a polymorphic pointer, it shall not have an', &
'     undefined association status.', &
'', &
'DESCRIPTION', &
'  SAME_TYPE_AS(3) queries the dynamic types of objects for equality.', &
'', &
'OPTIONS', &
'  o  A : object to compare to B for equality of type', &
'', &
'  o  B : object to be compared to for equality of type', &
'', &
'RESULT', &
'  If the dynamic type of A or B is extensible, the result is true if and only', &
'  if the dynamic type of A is the same as the dynamic type of B. If neither A', &
'  nor B has extensible dynamic type, the result is processor dependent.', &
'', &
'      NOTE1', &
'', &
'  The dynamic type of a disassociated pointer or unallocated allocatable', &
'  variable is its declared type. An unlimited polymorphic entity has no', &
'  declared type.', &
'', &
'      NOTE2', &
'', &
'  The test performed by SAME_TYPE_AS is not the same as the test performed by', &
'  the type guard TYPE IS. The test performed by SAME_TYPE_AS does not consider', &
'  kind type parameters.', &
'', &
'  Sample program:', &
'', &
'       ! program demo_same_type_as', &
'       module M_ether', &
'       implicit none', &
'       private', &
'', &
'       type   :: dot', &
'         real :: x=0', &
'         real :: y=0', &
'       end type dot', &
'', &
'       type, extends(dot) :: point', &
'         real :: z=0', &
'       end type point', &
'', &
'       type something_else', &
'       end type something_else', &
'', &
'       public :: dot', &
'       public :: point', &
'       public :: something_else', &
'', &
'       end module M_ether', &
'', &
'       program demo_same_type_as', &
'       use M_ether, only : dot, point, something_else', &
'       implicit none', &
'       type(dot) :: dad, mom', &
'       type(point) :: me', &
'       type(something_else) :: alien', &
'', &
'        write(*,*)same_type_as(me,dad),''I am descended from Dad, but equal?''', &
'        write(*,*)same_type_as(me,me) ,''I am what I am''', &
'        write(*,*)same_type_as(dad,mom) ,''what a pair!''', &
'', &
'        write(*,*)same_type_as(dad,me),''no paradox here''', &
'        write(*,*)same_type_as(dad,alien),''no relation''', &
'', &
'        call pointers()', &
'        contains', &
'        subroutine pointers()', &
'        ! Given the declarations and assignments', &
'        type t1', &
'           real c', &
'        end type', &
'        type, extends(t1) :: t2', &
'        end type', &
'        class(t1), pointer :: p, q, r', &
'           allocate (p, q)', &
'           allocate (t2 :: r)', &
'           ! the result of SAME_TYPE_AS (P, Q) will be true, and the result', &
'           ! of SAME_TYPE_AS (P, R) will be false.', &
'           write(*,*)''(P,Q)'',same_type_as(p,q),"mind your P''s and Q''s"', &
'           write(*,*)''(P,R)'',same_type_as(p,r)', &
'        end subroutine pointers', &
'', &
'       end program demo_same_type_as', &
'', &
'  Results:', &
'', &
'       >  F I am descended from Dad, but equal?', &
'       >  T I am what I am', &
'       >  T what a pair!', &
'       >  F no paradox here', &
'       >  F no relation', &
'       >  (P,Q) T mind your P''s and Q''s', &
'       >  (P,R) F', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  EXTENDS_TYPE_OF(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          same_type_as(3fortran)', &
'']

shortname="same_type_as"
call process()

case('203','scale')

textblock=[character(len=256) :: &
'', &
'scale(3fortran)                                               scale(3fortran)', &
'', &
'NAME', &
'  SCALE(3) - [MODEL:COMPONENTS] Scale a real value by a whole power of the', &
'  radix', &
'', &
'SYNOPSIS', &
'  result = scale(x, i)', &
'', &
'          elemental real(kind=KIND) function scale(x, i)', &
'', &
'           real(kind=KIND),intent(in)   :: x', &
'           integer(kind=**),intent(in)  :: i', &
'', &
'CHARACTERISTICS', &
'  o  X is type real of any kind', &
'', &
'  o  I is type an integer of any kind', &
'', &
'  o  the result is real of the same kind as X', &
'', &
'DESCRIPTION', &
'  SCALE(3) returns x * RADIX(X)**I.', &
'', &
'  It is almost certain the radix(base) of the platform is two, therefore', &
'  SCALE(3) is generally the same as X*2**I', &
'', &
'OPTIONS', &
'  o  X : the value to multiply by RADIX(X)**I. Its type and kind is used to', &
'     determine the radix for values with its characteristics and determines', &
'     the characteristics of the result, so care must be taken the returned', &
'     value is within the range of the characteristics of X.', &
'', &
'  o  I : The power to raise the radix of the machine to', &
'', &
'RESULT', &
'  The return value is X * RADIX(X)**I, assuming that value can be represented', &
'  by a value of the type and kind of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_scale', &
'      implicit none', &
'      real :: x', &
'      complex :: c', &
'      integer :: i', &
'        x = 1.0', &
'        print *, (scale(x,i),i=1,5)', &
'        x = 3.0', &
'        print *, (scale(x,i),i=1,5)', &
'        print *, (scale(log(1.0),i),i=1,5)', &
'        ! on modern machines radix(x) is almost certainly 2', &
'        x = 178.1387e-4', &
'        i = 5', &
'        print *, x, i, scale(x, i), x*radix(x)**i', &
'        ! x*radix(x)**i is the same except roundoff errors are not restricted', &
'        i = 2', &
'        print *, x, i, scale(x, i), x*radix(x)**i', &
'        ! relatively easy to do complex values as well', &
'        c=(3.0,4.0)', &
'        print *, c, i, scale_complex(c, i)!, c*radix(c)**i', &
'      contains', &
'      function scale_complex(x, n)', &
'      ! example supporting complex value for default kinds', &
'      complex, intent(in) :: x', &
'      integer, intent(in) :: n', &
'      complex :: scale_complex', &
'        scale_complex=cmplx(scale(x%re, n), scale(x%im, n), kind=kind(x%im))', &
'      end function scale_complex', &
'      end program demo_scale', &
'', &
'  Results:', &
'', &
'       > 2.00000000 4.00000000 8.00000000     16.0000000 32.0000000', &
'       > 6.00000000 12.0000000 24.0000000      48.0000000 96.0000000', &
'       > 0.00000000 0.00000000 0.00000000     0.00000000 0.00000000', &
'       > 1.78138707E-02    5   0.570043862     0.570043862', &
'       > 1.78138707E-02    2   7.12554827E-02  7.12554827E-02', &
'       > (3.00000000,4.00000000) 2 (12.0000000,16.0000000)', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SET_EXPONENT(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 scale(3fortran)', &
'']

shortname="scale"
call process()

case('204','scan')

textblock=[character(len=256) :: &
'', &
'scan(3fortran)                                                 scan(3fortran)', &
'', &
'NAME', &
'  SCAN(3) - [CHARACTER:SEARCH] Scan a string for the presence of a set of', &
'  characters', &
'', &
'SYNOPSIS', &
'  result = scan( string, set, [,back] [,kind] )', &
'', &
'          elemental integer(kind=KIND) function scan(string,set,back,kind)', &
'', &
'           character(len=*,kind=**),intent(in) :: string', &
'           character(len=*,kind=**),intent(in) :: set', &
'           logical,intent(in),optional :: back', &
'           integer,intent(in),optional :: kind', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a character string of any kind', &
'', &
'  o  SET must be a character string with the same kind as STRING', &
'', &
'  o  BACK is a logical', &
'', &
'  o  KIND is a scalar integer constant expression', &
'', &
'  o  the result is an integer with the kind specified by KIND. If KIND is not', &
'     present the result is a default integer.', &
'', &
'DESCRIPTION', &
'  SCAN(3) scans a STRING for any of the characters in a SET of characters.', &
'', &
'  If BACK is either absent or equals .false., this function returns the', &
'  position of the leftmost character of STRING that is in SET. If BACK equals', &
'  .true., the rightmost position is returned. If no character of SET is found', &
'  in STRING, the result is zero.', &
'', &
'OPTIONS', &
'  o  STRING : the string to be scanned', &
'', &
'  o  SET : the set of characters which will be matched', &
'', &
'  o  BACK : if .true. the position of the rightmost character matched is', &
'     returned, instead of the leftmost.', &
'', &
'  o  KIND : the kind of the returned value is the same as KIND if present.', &
'     Otherwise a default integer kind is returned.', &
'', &
'RESULT', &
'  If BACK is absent or is present with the value false and if STRING contains', &
'  at least one character that is in SET, the value of the result is the', &
'  position of the leftmost character of STRING that is in SET.', &
'', &
'  If BACK is present with the value true and if STRING contains at least one', &
'  character that is in SET, the value of the result is the position of the', &
'  rightmost character of STRING that is in SET.', &
'', &
'  The value of the result is zero if no character of STRING is in SET or if', &
'  the length of STRING or SET is zero.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_scan', &
'      implicit none', &
'        write(*,*) scan("fortran", "ao")          ! 2, found ''o''', &
'        write(*,*) scan("fortran", "ao", .true.)  ! 6, found ''a''', &
'        write(*,*) scan("fortran", "c++")         ! 0, found none', &
'      end program demo_scan', &
'', &
'  Results:', &
'', &
'       >           2', &
'       >           6', &
'       >           0', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  scan(3fortran)', &
'']

shortname="scan"
call process()

case('205','select_case')

textblock=[character(len=256) :: &
'', &
'select_case(7fortran)                                   select_case(7fortran)', &
'', &
'NAME', &
'  select_case(7f) - [EXECUTION CONTROL] select a block based on the value of', &
'  an expression (a case)', &
'', &
'SYNOPSIS', &
'  The CASE construct selects for execution at most one of its constituent', &
'  blocks. The selection is based on the value of an expression.', &
'', &
'       [ case-construct-name : ] SELECT CASE (case-expr)', &
'       CASE (value) [case-construct-name]', &
'          [selected code]', &
'       CASE ([lower_value]:[upper_value]) [case-construct-name]', &
'          [selected code]', &
'       CASE (range_or_value,range_or_value,...) [case-construct-name]', &
'          [selected code]', &
'', &
'   CASE DEFAULT', &
'  END SELECT [ case-construct-name ]', &
'', &
'  The expression may be integer,character,or logical. In particular it cannot', &
'  be real.', &
'', &
'    For a given case-construct, there shall be no possible value of the case-', &
'    expr that matches more than one case-value-range.', &
'', &
'    If the select-case-stmt of a case-construct specifies a case-construct-', &
'    name, the corresponding end-select-stmt shall specify the same case-', &
'    construct-name.', &
'', &
'    If the select-case-stmt of a case-construct does not specify a case-', &
'    construct-name, the corresponding end-select-stmt shall not specify a', &
'    case-construct-name.', &
'', &
'    If a case-stmt specifies a case-construct-name, the corresponding select-', &
'    case-stmt shall specify the same case-construct-name.', &
'', &
'    No more than one of the selectors of one of the CASE statements shall be', &
'    DEFAULT.', &
'', &
'    o  For a given case-construct, each case-value shall be of the same type', &
'       as case-expr', &
'', &
'    o  For character type, the kind type parameters shall be the same', &
'', &
'    o  character length differences are allowed.', &
'', &
'    o  A case-value-range using a colon shall not be used if case-expr is of', &
'       type logical.', &
'', &
'DESCRIPTION', &
'  The execution of the SELECT CASE statement causes the case expression to be', &
'  evaluated. The resulting value is called the case index. For a case value', &
'  range list, a match occurs if the case index matches any of the case value', &
'  ranges in the list. For a case index with a value of c, a match is', &
'  determined as follows.', &
'', &
'    1. If the case value range contains a single value v without a colon, a', &
'       match occurs for type logical if the expression c .EQV. v is true, and', &
'       a match occurs for type integer or character if the expression c == v', &
'       is true.', &
'', &
'    2. If the case value range is of the form low : high, a match occurs if', &
'       the expression low <= c .AND. c <= high is true.', &
'', &
'    3. If the case value range is of the form low :, a match occurs if the', &
'       expression low <= c is true.', &
'', &
'    4. If the case value range is of the form : high, a match occurs if the', &
'       expression c <= high is true.', &
'', &
'    5. If no other selector matches and a DEFAULT selector appears, it', &
'       matches the case index.', &
'', &
'    6. If no other selector matches and the DEFAULT selector does not appear,', &
'       there is no match.', &
'', &
'  The block following the CASE statement containing the matching selector, if', &
'  any, is executed. This completes execution of the construct.', &
'', &
'  It is permissible to branch to an end-select-stmt only from within its CASE', &
'  construct.', &
'', &
'EXAMPLES', &
'  An integer signum function:', &
'', &
'      integer function signum (n)', &
'        select case (n)', &
'        case (:-1)', &
'           signum = -1  ! if <= -1 set to negative 1', &
'        case (0)', &
'           signum = 0', &
'        case (1:)', &
'           signum = 1   ! anything >= 1 set to positive 1', &
'        end select', &
'      end function signum', &
'', &
'  A code fragment to check for balanced parentheses:', &
'', &
'            character (80) :: line', &
'               ...', &
'            level = 0', &
'            scan_line: do i = 1, 80', &
'               check_parens: select case (line (i:i))', &
'               case (''('')', &
'                  level = level + 1', &
'               case ('')'')', &
'                  level = level - 1', &
'                  if (level < 0) then', &
'                     print *, ''unexpected right parenthesis''', &
'                     exit scan_line', &
'                  end if', &
'               case default', &
'                  ! ignore all other characters', &
'                end select check_parens', &
'             end do scan_line', &
'             if (level > 0) then', &
'                print *, ''missing right parenthesis''', &
'             end if', &
'', &
'  the following three fragments are equivalent:', &
'', &
'             if (silly == 1) then', &
'                call this', &
'             else', &
'                call that', &
'             end if', &
'', &
'             select case (silly == 1)', &
'             case (.true.)', &
'                call this', &
'             case (.false.)', &
'                call that', &
'             end select', &
'', &
'             select case (silly)', &
'             case default', &
'                call that', &
'             case (1)', &
'                call this', &
'             end select', &
'', &
'  A code fragment showing several selections of one block:', &
'', &
'        select case (n)', &
'           case (1, 3:5, 8)        ! selects 1, 3, 4, 5, 8', &
'              call sub()', &
'           case default', &
'              call other()', &
'        end select', &
'', &
'                               March 16, 2025           select_case(7fortran)', &
'']

shortname="select_case"
call process()

case('206','selected_char_kind')

textblock=[character(len=256) :: &
'', &
'selected_char_kind(3fortran)                     selected_char_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_CHAR_KIND(3) - [KIND] Select character kind such as "Unicode"', &
'', &
'SYNOPSIS', &
'  result = selected_char_kind(name)', &
'', &
'          integer function selected_char_kind(name)', &
'', &
'           character(len=*),intent(in) :: name', &
'', &
'CHARACTERISTICS', &
'  o  NAME is a default character scalar', &
'', &
'  o  the result is a default integer scalar', &
'', &
'DESCRIPTION', &
'  SELECTED_CHAR_KIND(3) returns a kind parameter value for the character set', &
'  named NAME.', &
'', &
'  If a name is not supported, -1 is returned. Otherwise the result is a value', &
'  equal to that kind type parameter value.', &
'', &
'  The list of supported names is processor-dependent except for "DEFAULT".', &
'', &
'  o  If NAME has the value "DEFAULT", then the result has a value equal to', &
'     that of the kind type parameter of default character. This name is always', &
'     supported.', &
'', &
'  o  If NAME has the value "ASCII", then the result has a value equal to that', &
'     of the kind type parameter of ASCII character.', &
'', &
'  o  If NAME has the value "ISO_10646", then the result has a value equal to', &
'     that of the kind type parameter of the ISO 10646 character kind', &
'     (corresponding to UCS-4 as specified in ISO/IEC 10646).', &
'', &
'  o  If NAME is a processor-defined name of some other character kind', &
'     supported by the processor, then the result has a value equal to that', &
'     kind type parameter value. Pre-defined names include "ASCII" and', &
'     "ISO_10646".', &
'', &
'  The NAME is interpreted without respect to case or trailing blanks.', &
'', &
'OPTIONS', &
'  o  NAME : A name to query the processor-dependent kind value of, and/or to', &
'     determine if supported. NAME, interpreted without respect to case or', &
'     trailing blanks.', &
'', &
'     Currently, supported character sets include "ASCII" and "DEFAULT" and', &
'     "ISO_10646" (Universal Character Set, UCS-4) which is commonly known as', &
'     "Unicode". Supported names other than "DEFAULT" are processor dependent.', &
'', &
'RESULT', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      Linux', &
'      program demo_selected_char_kind', &
'      use iso_fortran_env', &
'      implicit none', &
'', &
'      intrinsic date_and_time,selected_char_kind', &
'', &
'      ! set some aliases for common character kinds', &
'      ! as the numbers can vary from platform to platform', &
'', &
'      integer, parameter :: default = selected_char_kind ("default")', &
'      integer, parameter :: ascii =   selected_char_kind ("ascii")', &
'      integer, parameter :: ucs4  =   selected_char_kind (''ISO_10646'')', &
'      integer, parameter :: utf8  =   selected_char_kind (''utf-8'')', &
'', &
'      ! assuming ASCII and UCS4 are supported (ie. not equal to -1)', &
'      ! define some string variables', &
'      character(len=26, kind=ascii ) :: alphabet', &
'      character(len=30, kind=ucs4  ) :: hello_world', &
'      character(len=30, kind=ucs4  ) :: string', &
'', &
'        write(*,*)''ASCII     '',&', &
'         & merge(''Supported   '',''Not Supported'',ascii /= -1)', &
'        write(*,*)''ISO_10646 '',&', &
'         & merge(''Supported   '',''Not Supported'',ucs4 /= -1)', &
'        write(*,*)''UTF-8     '',&', &
'         & merge(''Supported   '',''Not Supported'',utf8 /= -1)', &
'', &
'        if(default.eq.ascii)then', &
'            write(*,*)''ASCII is the default on this processor''', &
'        endif', &
'', &
'       ! for constants the kind precedes the value, somewhat like a', &
'       ! BOZ constant', &
'        alphabet = ascii_"abcdefghijklmnopqrstuvwxyz"', &
'        write (*,*) alphabet', &
'', &
'        hello_world = ucs4_''Hello World and Ni Hao -- '' &', &
'                      // char (int (z''4F60''), ucs4)   &', &
'                      // char (int (z''597D''), ucs4)', &
'', &
'       ! an encoding option is required on OPEN for non-default I/O', &
'        if(ucs4 /= -1 )then', &
'           open (output_unit, encoding=''UTF-8'')', &
'           write (*,*) trim (hello_world)', &
'        else', &
'           write (*,*) ''cannot use utf-8''', &
'        endif', &
'', &
'        call create_date_string(string)', &
'        write (*,*) trim (string)', &
'', &
'      contains', &
'', &
'      ! The following produces a Japanese date stamp.', &
'      subroutine create_date_string(string)', &
'      intrinsic date_and_time,selected_char_kind', &
'      integer,parameter :: ucs4 = selected_char_kind("ISO_10646")', &
'      character(len=1,kind=ucs4),parameter :: &', &
'            nen =   char(int( z''5e74'' ),ucs4), & ! year', &
'            gatsu = char(int( z''6708'' ),ucs4), & ! month', &
'            nichi = char(int( z''65e5'' ),ucs4)          ! day', &
'      character(len= *, kind= ucs4) string', &
'      integer values(8)', &
'        call date_and_time(values=values)', &
'        write(string,101) values(1),nen,values(2),gatsu,values(3),nichi', &
'       101 format(*(i0,a))', &
'      end subroutine create_date_string', &
'', &
'      end program demo_selected_char_kind', &
'', &
'  Results:', &
'', &
'  The results are very processor-dependent', &
'', &
'       >  ASCII     Supported', &
'       >  ISO_10646 Supported', &
'       >  UTF-8     Not Supported', &
'       >  ASCII is the default on this processor', &
'       >  abcdefghijklmnopqrstuvwxyz', &
'       >  Hello World and Ni Hao --', &
'       >  20221015', &
'', &
'STANDARD', &
'  Fortran 2003', &
'', &
'SEE ALSO', &
'  SELECTED_INT_KIND(3), SELECTED_REAL_KIND(3)', &
'', &
'  ACHAR(3), CHAR(3), ICHAR(3), IACHAR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025    selected_char_kind(3fortran)', &
'']

shortname="selected_char_kind"
call process()

case('207','selected_int_kind')

textblock=[character(len=256) :: &
'', &
'selected_int_kind(3fortran)                       selected_int_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_INT_KIND(3) - [KIND] Choose integer kind', &
'', &
'SYNOPSIS', &
'  result = selected_int_kind(r)', &
'', &
'  integer function selected_int_kind(r)', &
'', &
'          integer(kind=KIND),intent(in) :: r', &
'', &
'CHARACTERISTICS', &
'  o  R is an integer scalar.', &
'', &
'  o  the result is an default integer scalar.', &
'', &
'DESCRIPTION', &
'  SELECTED_INT_KIND(3) return the kind value of the smallest integer type that', &
'  can represent all values ranging from -10**R (exclusive) to 10**R', &
'  (exclusive). If there is no integer kind that accommodates this range,', &
'  selected_int_kind returns -1.', &
'', &
'OPTIONS', &
'  o  R : The value specifies the required range of powers of ten that need', &
'     supported by the kind type being returned.', &
'', &
'RESULT', &
'  The result has a value equal to the value of the kind type parameter of an', &
'  integer type that represents all values in the requested range.', &
'', &
'  if no such kind type parameter is available on the processor, the result is', &
'  -1.', &
'', &
'  If more than one kind type parameter meets the criterion, the value returned', &
'  is the one with the smallest decimal exponent range, unless there are', &
'  several such values, in which case the smallest of these kind values is', &
'  returned.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_selected_int_kind', &
'      implicit none', &
'      integer,parameter :: k5 = selected_int_kind(5)', &
'      integer,parameter :: k15 = selected_int_kind(15)', &
'      integer(kind=k5) :: i5', &
'      integer(kind=k15) :: i15', &
'', &
'         print *, huge(i5), huge(i15)', &
'', &
'         ! the following inequalities are always true', &
'         print *, huge(i5) >= 10_k5**5-1', &
'         print *, huge(i15) >= 10_k15**15-1', &
'      end program demo_selected_int_kind', &
'', &
'  Results:', &
'', &
'       >   2147483647  9223372036854775807', &
'       >  T', &
'       >  T', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  AINT(3), ANINT(3), INT(3), NINT(3), CEILING(3), FLOOR(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025     selected_int_kind(3fortran)', &
'']

shortname="selected_int_kind"
call process()

case('208','selected_real_kind')

textblock=[character(len=256) :: &
'', &
'selected_real_kind(3fortran)                     selected_real_kind(3fortran)', &
'', &
'NAME', &
'  SELECTED_REAL_KIND(3) - [KIND] Choose real kind', &
'', &
'SYNOPSIS', &
'  result = selected_real_kind([p] [,r] [,radix] )', &
'', &
'  integer function selected_int_kind(r)', &
'', &
'          real(kind=KIND),intent(in),optional :: p', &
'          real(kind=KIND),intent(in),optional :: r', &
'          real(kind=KIND),intent(in),optional :: radix', &
'', &
'CHARACTERISTICS', &
'  o  P is an integer scalar', &
'', &
'  o  R is an integer scalar', &
'', &
'  o  RADIX is an integer scalar', &
'', &
'  o  the result is an default integer scalar', &
'', &
'DESCRIPTION', &
'  SELECTED_REAL_KIND(3) return the kind value of a real data type with decimal', &
'  precision of at least P digits, exponent range of at least R, and with a', &
'  radix of RADIX. That is, if such a kind exists', &
'', &
'  o  it has the decimal precision as returned by PRECISION(3) of at least P', &
'     digits.', &
'', &
'  o  a decimal exponent range, as returned by the function RANGE(3) of at', &
'     least R', &
'', &
'  o  a radix, as returned by the function RADIX(3) , of RADIX,', &
'', &
'  If the requested kind does not exist, -1 is returned.', &
'', &
'  At least one argument shall be present.', &
'', &
'OPTIONS', &
'  o  P : the requested precision', &
'', &
'  o  R : the requested range', &
'', &
'  o  RADIX : the desired radix', &
'', &
'      Before FORTRAN 2008, at least one of the arguments R or P shall be', &
'      present; since FORTRAN 2008, they are assumed to be zero if absent.', &
'', &
'RESULT', &
'  selected_real_kind returns the value of the kind type parameter of a real', &
'  data type with decimal precision of at least P digits, a decimal exponent', &
'  range of at least R, and with the requested RADIX.', &
'', &
'  If P or R is absent, the result value is the same as if it were present with', &
'  the value zero.', &
'', &
'  If the RADIX parameter is absent, there is no requirement on the radix of', &
'  the selected kind and real kinds with any radix can be returned.', &
'', &
'  If more than one real data type meet the criteria, the kind of the data type', &
'  with the smallest decimal precision is returned. If no real data type', &
'  matches the criteria, the result is', &
'', &
'  o  -1 : if the processor does not support a real data type with a precision', &
'     greater than or equal to P, but the R and RADIX requirements can be', &
'     fulfilled', &
'', &
'  o  -2 : if the processor does not support a real type with an exponent range', &
'     greater than or equal to R, but P and RADIX are fulfillable', &
'', &
'  o  -3 : if RADIX but not P and R requirements are fulfillable', &
'', &
'  o  -4 : if RADIX and either P or R requirements are fulfillable', &
'', &
'  o  -5 : if there is no real type with the given RADIX', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_selected_real_kind', &
'      implicit none', &
'      integer,parameter :: p6 = selected_real_kind(6)', &
'      integer,parameter :: p10r100 = selected_real_kind(10,100)', &
'      integer,parameter :: r400 = selected_real_kind(r=400)', &
'      real(kind=p6) :: x', &
'      real(kind=p10r100) :: y', &
'      real(kind=r400) :: z', &
'', &
'        print *, precision(x), range(x)', &
'        print *, precision(y), range(y)', &
'        print *, precision(z), range(z)', &
'      end program demo_selected_real_kind', &
'', &
'  Results:', &
'', &
'       >            6          37', &
'       >           15         307', &
'       >           18        4931', &
'', &
'STANDARD', &
'  Fortran 95 ; with RADIX - Fortran 2008', &
'', &
'SEE ALSO', &
'  PRECISION(3), RANGE(3), RADIX(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025    selected_real_kind(3fortran)', &
'']

shortname="selected_real_kind"
call process()

case('209','set_exponent')

textblock=[character(len=256) :: &
'', &
'set_exponent(3fortran)                                 set_exponent(3fortran)', &
'', &
'NAME', &
'  SET_EXPONENT(3) - [MODEL:COMPONENTS] real value with specified exponent', &
'', &
'SYNOPSIS', &
'  result = set_exponent(x, i)', &
'', &
'          elemental real(kind=KIND) function set_exponent(x,i)', &
'', &
'           real(kind=KIND),intent(in) :: x', &
'           integer(kind=**),intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  X is type real', &
'', &
'  o  I is type integer', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  The return value is of the same type and kind as X.', &
'', &
'DESCRIPTION', &
'  SET_EXPONENT(3) returns the real number whose fractional part is that of X', &
'  and whose exponent part is I.', &
'', &
'OPTIONS', &
'  o  X : Shall be of type real.', &
'', &
'  o  I : Shall be of type integer.', &
'', &
'RESULT', &
'  The return value is of the same type and kind as X. The real number whose', &
'  fractional part is that of X and whose exponent part if I is returned; it is', &
'  FRACTION(X) * REAL(RADIX(X))**I.', &
'', &
'  If X has the value zero, the result has the same value as X.', &
'', &
'  If X is an IEEE infinity, the result is an IEEE NaN.', &
'', &
'  If X is an IEEE NaN, the result is the same NaN.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_setexp', &
'      implicit none', &
'      real :: x = 178.1387e-4', &
'      integer :: i = 17', &
'        print *, set_exponent(x, i), fraction(x) * real(radix(x))**i', &
'      end program demo_setexp', &
'', &
'  Results:', &
'', &
'       >   74716.7891       74716.7891', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SPACING(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          set_exponent(3fortran)', &
'']

shortname="set_exponent"
call process()

case('210','shape')

textblock=[character(len=256) :: &
'', &
'shape(3fortran)                                               shape(3fortran)', &
'', &
'NAME', &
'  SHAPE(3) - [ARRAY:INQUIRY] Determine the shape of an array or scalar', &
'', &
'SYNOPSIS', &
'  result = shape( source [,kind] )', &
'', &
'        integer(kind=KIND) function shape( source, KIND )', &
'', &
'         type(TYPE(kind=**)),intent(in)       :: source(..)', &
'         integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  SOURCE is an array or scalar of any type. If SOURCE is a pointer it must', &
'     be associated and allocatable arrays must be allocated. It shall not be', &
'     an assumed-size array.', &
'', &
'  o  KIND is a constant integer initialization expression.', &
'', &
'  o  the result is an integer array of rank one with size equal to the rank of', &
'     SOURCE of the kind specified by KIND if KIND is present, otherwise it has', &
'     the default integer kind.', &
'', &
'DESCRIPTION', &
'  SHAPE(3) queries the shape of an array.', &
'', &
'OPTIONS', &
'  o  SOURCE : an array or scalar of any type. If SOURCE is a pointer it must', &
'     be associated and allocatable arrays must be allocated.', &
'', &
'  o  KIND : indicates the kind parameter of the result.', &
'', &
'RESULT', &
'  An integer array of rank one with as many elements as SOURCE has dimensions.', &
'', &
'  The elements of the resulting array correspond to the extent of SOURCE along', &
'  the respective dimensions.', &
'', &
'  If SOURCE is a scalar, the result is an empty array (a rank-one array of', &
'  size zero).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shape', &
'      implicit none', &
'      character(len=*),parameter :: all=''(*(g0,1x))''', &
'      integer, dimension(-1:1, -1:2) :: a', &
'        print all, ''shape of array='',shape(a)', &
'        print all, ''shape of constant='',shape(42)', &
'        print all, ''size of shape of constant='',size(shape(42))', &
'        print all, ''ubound of array='',ubound(a)', &
'        print all, ''lbound of array='',lbound(a)', &
'      end program demo_shape', &
'', &
'  Results:', &
'', &
'       > shape of array= 3 4', &
'       > shape of constant=', &
'       > size of shape of constant= 0', &
'       > ubound of array= 1 2', &
'       > lbound of array= -1 -1', &
'', &
'STANDARD', &
'  Fortran 95 ; with KIND argument Fortran 2003', &
'', &
'SEE ALSO', &
'  Array inquiry:', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  UBOUND(3) - Upper dimension bounds of an array', &
'', &
'  o  LBOUND(3) - Lower dimension bounds of an array', &
'', &
'  State Inquiry:', &
'', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - Test if object is contiguous', &
'', &
'  Kind Inquiry:', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Bit Inquiry:', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 shape(3fortran)', &
'']

shortname="shape"
call process()

case('211','shifta')

textblock=[character(len=256) :: &
'', &
'shifta(3fortran)                                             shifta(3fortran)', &
'', &
'NAME', &
'  SHIFTA(3) - [BIT:SHIFT] Right shift with fill', &
'', &
'SYNOPSIS', &
'  result = shifta(i, shift )', &
'', &
'          elemental integer(kind=KIND) function shifta(i, shift)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer of any kind', &
'', &
'  o  SHIFT is an integer of any kind', &
'', &
'  o  the result will automatically be of the same type, kind and rank as I.', &
'', &
'DESCRIPTION', &
'  SHIFTA(3) returns a value corresponding to I with all of the bits shifted', &
'  right by SHIFT places and the vacated bits on the left filled with the value', &
'  of the original left-most bit.', &
'', &
'OPTIONS', &
'  o  I : The initial value to shift and fill', &
'', &
'  o  SHIFT : how many bits to shift right. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I). or the value is undefined. If SHIFT is zero', &
'     the result is I.', &
'', &
'RESULT', &
'  The result has the value obtained by shifting the bits of I to the right', &
'  SHIFT bits and replicating the leftmost bit of I in the left SHIFT bits', &
'  (Note the leftmost bit in "two''s complement" representation is the sign', &
'  bit).', &
'', &
'  Bits shifted out from the right end are lost.', &
'', &
'  If SHIFT is zero the result is I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shifta', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer(kind=int32) :: ival', &
'      integer            :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer            :: i', &
'      integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'', &
'       ! basic usage', &
'       write(*,*)shifta(100,3)', &
'', &
'       ! loop through some interesting values', &
'        shift=5', &
'', &
'        ivals=[ -1, -0, +0, +1, &', &
'        & int(b"01010101010101010101010101010101"), &', &
'        & int(b"10101010101010101010101010101010"), &', &
'        & int(b"00000000000000000000000000011111") ]', &
'', &
'        ! does your platform distinguish between +0 and -0?', &
'        ! note the original leftmost bit is used to fill in the vacated bits', &
'', &
'        write(*,''(/,"SHIFT =  ",i0)'') shift', &
'        do i=1,size(ivals)', &
'           ival=ivals(i)', &
'           write(*,''( "I =      ",b32.32," == ",i0)'') ival,ival', &
'           oval=shifta(ival,shift)', &
'           write(*,''( "RESULT = ",b32.32," == ",i0)'') oval,oval', &
'        enddo', &
'        ! elemental', &
'        write(*,*)"characteristics of the result are the same as input"', &
'        write(*,''(*(g0,1x))'') &', &
'          & "kind=",kind(shifta(arr,3)), "shape=",shape(shifta(arr,3)), &', &
'          & "size=",size(shifta(arr,3)) !, "rank=",rank(shifta(arr,3))', &
'', &
'      end program demo_shifta', &
'', &
'  Results:', &
'', &
'       >          12', &
'       >', &
'       > SHIFT =  5', &
'       > I =     11111111111111111111111111111111 == -1', &
'       > RESULT = 11111111111111111111111111111111 == -1', &
'       > I =     00000000000000000000000000000000 == 0', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =     00000000000000000000000000000000 == 0', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =     00000000000000000000000000000001 == 1', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       > I =     01010101010101010101010101010101 == 1431655765', &
'       > RESULT = 00000010101010101010101010101010 == 44739242', &
'       > I =     10101010101010101010101010101010 == -1431655766', &
'       > RESULT = 11111101010101010101010101010101 == -44739243', &
'       > I =     00000000000000000000000000011111 == 31', &
'       > RESULT = 00000000000000000000000000000000 == 0', &
'       >  characteristics of the result are the same as input', &
'       > kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  SHIFTL(3), SHIFTR(3), ISHFT(3), ISHFTC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                shifta(3fortran)', &
'']

shortname="shifta"
call process()

case('212','shiftl')

textblock=[character(len=256) :: &
'', &
'shiftl(3fortran)                                             shiftl(3fortran)', &
'', &
'NAME', &
'  SHIFTL(3) - [BIT:SHIFT] Shift bits left', &
'', &
'SYNOPSIS', &
'  result = shiftl( i, shift )', &
'', &
'          elemental integer(kind=KIND) function shiftl(i, shift)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer of any kind', &
'', &
'  o  SHIFT is an integer of any kind', &
'', &
'  o  the result will automatically be of the same type, kind and rank as I.', &
'', &
'DESCRIPTION', &
'  SHIFTL(3) returns a value corresponding to I with all of the bits shifted', &
'  left by SHIFT places.', &
'', &
'  Bits shifted out from the left end are lost, and bits shifted in from the', &
'  right end are set to 0.', &
'', &
'  If the absolute value of SHIFT is greater than BIT_SIZE(I), the value is', &
'  undefined.', &
'', &
'  For example, for a 16-bit integer left-shifted five ...', &
'', &
'         >  |a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p| <- original 16-bit example', &
'         >  |f|g|h|i|j|k|l|m|n|o|p|           <- left-shifted five', &
'         >  |f|g|h|i|j|k|l|m|n|o|p|0|0|0|0|0| <- right-padded with zeros', &
'', &
'  Note the value of the result is the same as ISHFT (I, SHIFT).', &
'', &
'OPTIONS', &
'  o  I : The initial value to shift and fill in with zeros', &
'', &
'  o  SHIFT : how many bits to shift left. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I).', &
'', &
'RESULT', &
'  The return value is of type integer and of the same kind as I.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shiftl', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32) :: ival', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer            :: i', &
'', &
'       print *, '' basic usage''', &
'       ival=100', &
'       write(*,*)ival, shiftl(ival,3)', &
'', &
'       ! elemental (input values may be conformant arrays)', &
'       print *, '' elemental''', &
'', &
'       ! loop through some ivalues', &
'        shift=9', &
'        ivals=[ &', &
'        & int(b"01010101010101010101010101010101"), &', &
'        & int(b"10101010101010101010101010101010"), &', &
'        & int(b"11111111111111111111111111111111") ]', &
'', &
'        write(*,''(/,"SHIFT =  ",i0)'') shift', &
'        do i=1,size(ivals)', &
'           ! print initial value as binary and decimal', &
'           write(*,''( "I =      ",b32.32," == ",i0)'') ivals(i),ivals(i)', &
'           ! print shifted value as binary and decimal', &
'           oval=shiftl(ivals(i),shift)', &
'           write(*,''( "RESULT = ",b32.32," == ",i0)'') oval,oval', &
'        enddo', &
'', &
'       ! more about elemental', &
'        ELEM : block', &
'        integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'        write(*,*)"characteristics of the result are the same as input"', &
'        write(*,''(*(g0,1x))'') &', &
'          & "kind=",kind(shiftl(arr,3)), "shape=",shape(shiftl(arr,3)), &', &
'          & "size=",size(shiftl(arr,3)) !, "rank=",rank(shiftl(arr,3))', &
'        endblock ELEM', &
'', &
'      end program demo_shiftl', &
'', &
'  Results:', &
'', &
'       >    basic usage', &
'       >          100         800', &
'       >    elemental', &
'       >', &
'       >  SHIFT =  9', &
'       >  I =     01010101010101010101010101010101 == 1431655765', &
'       >  RESULT = 10101010101010101010101000000000 == -1431655936', &
'       >  I =     10101010101010101010101010101010 == -1431655766', &
'       >  RESULT = 01010101010101010101010000000000 == 1431655424', &
'       >  I =     11111111111111111111111111111111 == -1', &
'       >  RESULT = 11111111111111111111111000000000 == -512', &
'       >   characteristics of the result are the same as input', &
'       >  kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  SHIFTA(3), SHIFTR(3), ISHFT(3), ISHFTC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                shiftl(3fortran)', &
'']

shortname="shiftl"
call process()

case('213','shiftr')

textblock=[character(len=256) :: &
'', &
'shiftr(3fortran)                                             shiftr(3fortran)', &
'', &
'NAME', &
'  SHIFTR(3) - [BIT:SHIFT] Shift bits right', &
'', &
'SYNOPSIS', &
'  result = shiftr( i, shift )', &
'', &
'          elemental integer(kind=KIND) function shiftr(i, shift)', &
'', &
'           integer(kind=KIND),intent(in) :: i', &
'           integer(kind=**),intent(in) :: shift', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  I is an integer of any kind', &
'', &
'  o  SHIFT is an integer of any kind', &
'', &
'  o  the result will automatically be of the same type, kind and rank as I.', &
'', &
'DESCRIPTION', &
'  SHIFTR(3) returns a value corresponding to I with all of the bits shifted', &
'  right by SHIFT places.', &
'', &
'  If the absolute value of SHIFT is greater than BIT_SIZE(I), the value is', &
'  undefined.', &
'', &
'  Bits shifted out from the right end are lost, and bits shifted in from the', &
'  left end are set to 0.', &
'', &
'  For example, for a 16-bit integer right-shifted five ...', &
'', &
'         >  |a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p| <- original 16-bit example', &
'         >            |a|b|c|d|e|f|g|h|i|j|k| <- right-shifted five', &
'         >  |0|0|0|0|0|f|g|h|i|j|k|l|m|n|o|p| <- left-padded with zeros', &
'', &
'  Note the value of the result is the same as ISHFT (I, -SHIFT).', &
'', &
'OPTIONS', &
'  o  I : The value to shift', &
'', &
'  o  SHIFT : How many bits to shift right. It shall be nonnegative and less', &
'     than or equal to BIT_SIZE(I).', &
'', &
'RESULT', &
'  The remaining bits shifted right SHIFT positions. Vacated positions on the', &
'  left are filled with zeros.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_shiftr', &
'      use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64', &
'      implicit none', &
'      integer            :: shift', &
'      integer(kind=int32) :: oval', &
'      integer(kind=int32) :: ival', &
'      integer(kind=int32),allocatable :: ivals(:)', &
'      integer            :: i', &
'', &
'       print *,'' basic usage''', &
'       ival=100', &
'       write(*,*)ival, shiftr(100,3)', &
'', &
'       ! elemental (input values may be conformant arrays)', &
'       print *,'' elemental''', &
'        shift=9', &
'        ivals=[ &', &
'        & int(b"01010101010101010101010101010101"), &', &
'        & int(b"10101010101010101010101010101010"), &', &
'        & int(b"11111111111111111111111111111111") ]', &
'', &
'        write(*,''(/,"SHIFT =  ",i0)'') shift', &
'        do i=1,size(ivals)', &
'           ! print initial value as binary and decimal', &
'           write(*,''( "I =      ",b32.32," == ",i0)'') ivals(i),ivals(i)', &
'           ! print shifted value as binary and decimal', &
'           oval=shiftr(ivals(i),shift)', &
'           write(*,''( "RESULT = ",b32.32," == ",i0,/)'') oval,oval', &
'        enddo', &
'', &
'        ! more on elemental', &
'        ELEM : block', &
'        integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])', &
'        write(*,*)"characteristics of the result are the same as input"', &
'        write(*,''(*(g0,1x))'') &', &
'          & "kind=",kind(shiftr(arr,3)), "shape=",shape(shiftr(arr,3)), &', &
'          & "size=",size(shiftr(arr,3)) !, "rank=",rank(shiftr(arr,3))', &
'        endblock ELEM', &
'', &
'      end program demo_shiftr', &
'', &
'  Results:', &
'', &
'       >    basic usage', &
'       >           100          12', &
'       >    elemental', &
'       >', &
'       >  SHIFT =  9', &
'       >  I =      01010101010101010101010101010101 == 1431655765', &
'       >  RESULT = 00000000001010101010101010101010 == 2796202', &
'       >', &
'       >  I =      10101010101010101010101010101010 == -1431655766', &
'       >  RESULT = 00000000010101010101010101010101 == 5592405', &
'       >', &
'       >  I =      11111111111111111111111111111111 == -1', &
'       >  RESULT = 00000000011111111111111111111111 == 8388607', &
'       >', &
'       >   characteristics of the result are the same as input', &
'       >  kind= 1 shape= 2 2 size= 4', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  SHIFTA(3), SHIFTL(3), ISHFT(3), ISHFTC(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                shiftr(3fortran)', &
'']

shortname="shiftr"
call process()

case('214','sign')

textblock=[character(len=256) :: &
'', &
'sign(3fortran)                                                 sign(3fortran)', &
'', &
'NAME', &
'  SIGN(3) - [NUMERIC] Sign copying function', &
'', &
'SYNOPSIS', &
'  result = sign(a, b)', &
'', &
'          elemental type(TYPE(kind=KIND))function sign(a, b)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: a, b', &
'', &
'CHARACTERISTICS', &
'  o  A shall be of type integer or real.', &
'', &
'  o  B shall be of the same type as A.', &
'', &
'  o  the characteristics of the result are the same as A.', &
'', &
'DESCRIPTION', &
'  SIGN(3) returns a value with the magnitude of a but with the sign of b.', &
'', &
'  For processors that distinguish between positive and negative zeros sign()', &
'  may be used to distinguish between real values 0.0 and -0.0. SIGN (1.0,', &
'  -0.0) will return -1.0 when a negative zero is distinguishable.', &
'', &
'OPTIONS', &
'  o  A : The value whose magnitude will be returned.', &
'', &
'  o  B : The value whose sign will be returned.', &
'', &
'RESULT', &
'  a value with the magnitude of A with the sign of B. That is,', &
'', &
'  o  If b >= 0 then the result is abs(a)', &
'', &
'  o  else if b < 0 it is -abs(a).', &
'', &
'  o  if b is real and the processor distinguishes between -0.0 and 0.0 then', &
'     the result is -abs(a)', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sign', &
'      implicit none', &
'       ! basics', &
'        print *,  sign( -12,  1 )', &
'        print *,  sign( -12,  0 )', &
'        print *,  sign( -12, -1 )', &
'        print *,  sign(  12,  1 )', &
'        print *,  sign(  12,  0 )', &
'        print *,  sign(  12, -1 )', &
'', &
'        if(sign(1.0,-0.0)== -1.0)then', &
'           print *, ''this processor distinguishes +0 from -0''', &
'        else', &
'           print *, ''this processor does not distinguish +0 from -0''', &
'        endif', &
'', &
'        print *,  ''elemental'', sign( -12.0, [1.0, 0.0, -1.0] )', &
'', &
'      end program demo_sign', &
'', &
'  Results:', &
'', &
'         >        12', &
'         >        12', &
'         >       -12', &
'         >        12', &
'         >        12', &
'         >       -12', &
'         > this processor does not distinguish +0 from -0', &
'         > elemental   12.00000       12.00000      -12.00000', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  ABS(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  sign(3fortran)', &
'']

shortname="sign"
call process()

case('215','sin')

textblock=[character(len=256) :: &
'', &
'sin(3fortran)                                                   sin(3fortran)', &
'', &
'NAME', &
'  SIN(3) - [MATHEMATICS:TRIGONOMETRIC] Sine function', &
'', &
'SYNOPSIS', &
'  result = sin(x)', &
'', &
'          elemental TYPE(kind=KIND) function sin(x)', &
'', &
'           TYPE(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real or complex type', &
'', &
'  o  KIND may be any kind supported by the associated type of X.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  SIN(3) computes the sine of an angle given the size of the angle in radians.', &
'', &
'  The sine of an angle in a right-angled triangle is the ratio of the length', &
'  of the side opposite the given angle divided by the length of the', &
'  hypotenuse.', &
'', &
'OPTIONS', &
'  o  X : The angle in radians to compute the sine of.', &
'', &
'RESULT', &
'  The return value contains the processor-dependent approximation of the sine', &
'  of X', &
'', &
'  If X is of type real, it is regarded as a value in radians.', &
'', &
'  If X is of type complex, its real part is regarded as a value in radians.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program sample_sin', &
'      implicit none', &
'      real :: x = 0.0', &
'        x = sin(x)', &
'        write(*,*)''X='',x', &
'      end program sample_sin', &
'', &
'  Results:', &
'', &
'       >  X=  0.0000000E+00', &
'', &
'  Extended Example', &
'', &
'  Haversine Formula', &
'', &
'  From the article on "Haversine formula" in Wikipedia:', &
'', &
'        The haversine formula is an equation important in navigation,', &
'        giving great-circle distances between two points on a sphere from', &
'        their longitudes and latitudes.', &
'', &
'  So to show the great-circle distance between the Nashville International', &
'  Airport (BNA) in TN, USA, and the Los Angeles International Airport (LAX) in', &
'  CA, USA you would start with their latitude and longitude, commonly given as', &
'', &
'       BNA: N 36 degrees 7.2'',   W 86 degrees 40.2''', &
'       LAX: N 33 degrees 56.4'',  W 118 degrees 24.0''', &
'', &
'  which converted to floating-point values in degrees is:', &
'', &
'    o  BNA latitude=36.12, longitude=-86.67', &
'', &
'    o  LAX latitude=33.94, longitude=-118.40', &
'', &
'  And then use the haversine formula to roughly calculate the distance along', &
'  the surface of the Earth between the locations:', &
'', &
'  Sample program:', &
'', &
'      program demo_sin', &
'      implicit none', &
'      real :: d', &
'         d = haversine(36.12,-86.67, 33.94,-118.40) ! BNA to LAX', &
'         print ''(*(A,1x,F9.4,1x))'',''distance:'',d,''km, or'',d*0.62137119,''miles''', &
'      contains', &
'      function haversine(latA,lonA,latB,lonB) result (dist)', &
'      !', &
'      ! calculate great circle distance in kilometers', &
'      ! given latitude and longitude in degrees', &
'      !', &
'      real,intent(in) :: latA,lonA,latB,lonB', &
'      real           :: a,c,dist,delta_lat,delta_lon,lat1,lat2', &
'      real,parameter  :: radius = 6371 ! mean earth radius in kilometers,', &
'      ! recommended by the International Union of Geodesy and Geophysics', &
'', &
'      ! generate constant pi/180', &
'      real, parameter :: deg_to_rad = atan(1.0)/45.0', &
'        delta_lat = deg_to_rad*(latB-latA)', &
'        delta_lon = deg_to_rad*(lonB-lonA)', &
'        lat1 = deg_to_rad*(latA)', &
'        lat2 = deg_to_rad*(latB)', &
'        a = (sin(delta_lat/2))**2 + &', &
'               & cos(lat1)*cos(lat2)*(sin(delta_lon/2))**2', &
'        c = 2*asin(sqrt(a))', &
'        dist = radius*c', &
'      end function haversine', &
'      end program demo_sin', &
'', &
'  Results:', &
'', &
'       > distance: 2886.4446 km, or 1793.5536 miles', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  ASIN(3), COS(3), TAN(3), ACOSH(3), ACOS(3), ASINH(3), ATAN2(3), ATANH(3),', &
'  ACOSH(3), ASINH(3), ATANH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   sin(3fortran)', &
'']

shortname="sin"
call process()

case('216','sind')

textblock=[character(len=256) :: &
'', &
'sind(3fortran)                                                 sind(3fortran)', &
'', &
'NAME', &
'  SIND(3) - [MATHEMATICS:TRIGONOMETRIC] Degree sine function', &
'', &
'SYNOPSIS', &
'  result = sind(x)', &
'', &
'          elemental real(kind=KIND) function sind(x)', &
'', &
'           real(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real type', &
'', &
'  o  KIND may be any kind supported by the associated real type of X.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  SIND(3) computes the sine of an angle given the size of the angle in', &
'  degrees.', &
'', &
'  The sine of an angle in a right-angled triangle is the ratio of the length', &
'  of the side opposite the given angle divided by the length of the', &
'  hypotenuse.', &
'', &
'OPTIONS', &
'  o  X : The angle in degrees to compute the sine of.', &
'', &
'RESULT', &
'  The return value contains the processor-dependent approximation of the sine', &
'  of X, which is regarded as a value in degrees.', &
'', &
'EXAMPLES', &
'  sind(180.0) has the value 0.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program sample_sind', &
'      implicit none', &
'        write(*,*)''sind(0.0)='',sind(0.0)', &
'        write(*,*)''sind(45.0)='',sind(45.0)', &
'        write(*,*)''sind(90.0)='',sind(90.0)', &
'        write(*,*)''sind(180.0)='',sind(180.0)', &
'        write(*,*)''sind(270.0)='',sind(270.0)', &
'        write(*,*)''sind(720.0)='',sind(720.0)', &
'        write(*,*)''sind(-720.0d0)='',sind(-720.0d0)', &
'      end program sample_sind', &
'', &
'  Extended Example', &
'', &
'  Haversine Formula', &
'', &
'  From the article on "Haversine formula" in Wikipedia:', &
'', &
'        The haversine formula is an equation important in navigation,', &
'        giving great-circle distances between two points on a sphere from', &
'        their longitudes and latitudes.', &
'', &
'  So to show the great-circle distance between the Nashville International', &
'  Airport (BNA) in TN, USA, and the Los Angeles International Airport (LAX) in', &
'  CA, USA you would start with their latitude and longitude, commonly given as', &
'', &
'       BNA: N 36 degrees 7.2'',   W 86 degrees 40.2''', &
'       LAX: N 33 degrees 56.4'',  W 118 degrees 24.0''', &
'', &
'  which converted to floating-point values in degrees is:', &
'', &
'    o  BNA latitude=36.12, longitude=-86.67', &
'', &
'    o  LAX latitude=33.94, longitude=-118.40', &
'', &
'  And then use the haversine formula to roughly calculate the distance along', &
'  the surface of the Earth between the locations:', &
'', &
'  Sample program:', &
'', &
'      program demo_sin', &
'      implicit none', &
'      real :: d', &
'         d = haversine(36.12,-86.67, 33.94,-118.40) ! BNA to LAX', &
'         print ''(A,F9.4,A)'', ''distance: '',d,'' km''', &
'      contains', &
'      function haversine(latA,lonA,latB,lonB) result (dist)', &
'      !', &
'      ! calculate great circle distance in kilometers', &
'      ! given latitude and longitude in degrees', &
'      !', &
'      real,intent(in) :: latA,lonA,latB,lonB', &
'      real :: a,c,dist,delta_lat,delta_lon,lat1,lat2', &
'      real,parameter :: radius = 6371 ! mean earth radius in kilometers,', &
'      ! recommended by the International Union of Geodesy and Geophysics', &
'', &
'        delta_lat = latB-latA', &
'        delta_lon = lonB-lonA', &
'        lat1 = latA', &
'        lat2 = latB', &
'        a = (sind(delta_lat/2))**2 + &', &
'               & cosd(lat1)*cosd(lat2)*(sind(delta_lon/2))**2', &
'        c = 2*asin(sqrt(a))', &
'        dist = radius*c', &
'      end function haversine', &
'      end program demo_sin', &
'', &
'  Results:', &
'', &
'       > distance: 2886.4446 km', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ASIN(3), COS(3), TAN(3), ACOSH(3), ACOS(3), ASINH(3), ATAN2(3), ATANH(3),', &
'  ACOSH(3), ASINH(3), ATANH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  sind(3fortran)', &
'']

shortname="sind"
call process()

case('217','sinh')

textblock=[character(len=256) :: &
'', &
'sinh(3fortran)                                                 sinh(3fortran)', &
'', &
'NAME', &
'  SINH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic sine function', &
'', &
'SYNOPSIS', &
'  result = sinh(x)', &
'', &
'          elemental TYPE(kind=KIND) function sinh(x)', &
'', &
'           TYPE(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex', &
'', &
'  o  KIND may be any kind supported by the associated type.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  SINH(3) computes the hyperbolic sine of X.', &
'', &
'  The hyperbolic sine of x is defined mathematically as:', &
'', &
'          sinh(x) = (exp(x) - exp(-x)) / 2.0', &
'', &
'OPTIONS', &
'  o  X : The value to calculate the hyperbolic sine of', &
'', &
'RESULT', &
'  The result has a value equal to a processor-dependent approximation to', &
'  sinh(X). If X is of type complex its imaginary part is regarded as a value', &
'  in radians.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sinh', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = - 1.0_real64', &
'      real(kind=real64) :: nan, inf', &
'      character(len=20) :: line', &
'', &
'       ! basics', &
'        print *, sinh(x)', &
'        print *, (exp(x)-exp(-x))/2.0', &
'', &
'       ! sinh(3) is elemental and can handle an array', &
'        print *, sinh([x,2.0*x,x/3.0])', &
'', &
'        ! a NaN input returns NaN', &
'        line=''NAN''', &
'        read(line,*) nan', &
'        print *, sinh(nan)', &
'', &
'        ! a Inf input returns Inf', &
'        line=''Infinity''', &
'        read(line,*) inf', &
'        print *, sinh(inf)', &
'', &
'        ! an overflow returns Inf', &
'        x=huge(0.0d0)', &
'        print *, sinh(x)', &
'', &
'      end program demo_sinh', &
'', &
'  Results:', &
'', &
'       > -1.1752011936438014', &
'       > -1.1752011936438014', &
'       > -1.1752011936438014      -3.6268604078470190      -0.33954055725615012', &
'       >                     NaN', &
'       >                Infinity', &
'       >                Infinity', &
'', &
'STANDARD', &
'  Fortran 95 , for a complex argument Fortran 2008', &
'', &
'SEE ALSO', &
'  ASINH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  sinh(3fortran)', &
'']

shortname="sinh"
call process()

case('218','sinpi')

textblock=[character(len=256) :: &
'', &
'sinpi(3fortran)                                               sinpi(3fortran)', &
'', &
'NAME', &
'  SINPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular sine function', &
'', &
'SYNOPSIS', &
'  result = sinpi(x)', &
'', &
'          elemental real(kind=KIND) function sinpi(x)', &
'', &
'           real(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real', &
'', &
'  o  KIND may be any kind supported by the associated real type of X.', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  SINPI(3) computes the circular sine of an angle given the size of the angle', &
'  in half-revolutions.', &
'', &
'  SINPI(X) is approximately equal to SIN(X*PI).', &
'', &
'  The sine of an angle in a right-angled triangle is the ratio of the length', &
'  of the side opposite the given angle divided by the length of the', &
'  hypotenuse.', &
'', &
'OPTIONS', &
'  o  X : The angle in half-revolutions to compute the sine of.', &
'', &
'RESULT', &
'  The return value contains the processor-dependent approximation of the sine', &
'  of X.', &
'', &
'EXAMPLES', &
'  Example. SINPI(1.0) has the value 0.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_sinpi', &
'      implicit none', &
'      real    :: x', &
'      integer :: i', &
'      real,parameter :: PI=acos(-1.0)', &
'        do i=0,8', &
'           x=i*0.25', &
'           write(*,*)''x='',x,'' sinpi(x)='',sinpi(x)', &
'        enddo', &
'      end program demo_sinpi', &
'', &
'  Results:', &
'', &
'       > x=   0.00000000  sinpi(x)=   0.00000000', &
'       > x=  0.250000000  sinpi(x)=   0.707106769', &
'       > x=  0.500000000  sinpi(x)=   1.00000000', &
'       > x=  0.750000000  sinpi(x)=   0.707106769', &
'       > x=   1.00000000  sinpi(x)=  -8.74227766E-08', &
'       > x=   1.25000000  sinpi(x)=  -0.707106888', &
'       > x=   1.50000000  sinpi(x)=  -1.00000000', &
'       > x=   1.75000000  sinpi(x)=  -0.707106531', &
'       > x=   2.00000000  sinpi(x)=   1.74845553E-07', &
'', &
'STANDARD', &
'  fortran 2023', &
'', &
'SEE ALSO', &
'  o  ACOS(3), ACOSD(3), ACOSPI(3),', &
'', &
'  o  ASIN(3), ASIND(3),', &
'', &
'  o  ATAN2(3), ATAN2D(3), ATAN2PI(3),', &
'', &
'  o  COS(3), COSD(3), COSPI(3),', &
'', &
'  o  TAN(3), TAND(3), TANPI(3),', &
'', &
'  o  ACOSH(3),', &
'', &
'  o  ACOSH(3),', &
'', &
'  o  ASINH(3),', &
'', &
'  o  ASINH(3),', &
'', &
'  o  ATANH(3)', &
'', &
'  o  ATANH(3),', &
'', &
'RESOURCES', &
'  o  Wikipedia:sine and cosine', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 sinpi(3fortran)', &
'']

shortname="sinpi"
call process()

case('219','size')

textblock=[character(len=256) :: &
'', &
'size(3fortran)                                                 size(3fortran)', &
'', &
'NAME', &
'  SIZE(3) - [ARRAY:INQUIRY] Determine the size of an array or extent of one', &
'  dimension', &
'', &
'SYNOPSIS', &
'  result = size(array [,dim] [,kind])', &
'', &
'          integer(kind=KIND) function size(array,dim,kind)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           integer(kind=**),intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY is an assumed-rank array or array of any type and associated kind.', &
'', &
'     If ARRAY is a pointer it must be associated and allocatable arrays must', &
'     be allocated.', &
'', &
'  o  DIM is an integer scalar', &
'', &
'  o  KIND is a scalar integer constant expression.', &
'', &
'  o  the result is an integer scalar of kind KIND. If KIND is absent a integer', &
'     of default kind is returned.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  SIZE(3) returns the total number of elements in an array, or if DIM is', &
'  specified returns the number of elements along that dimension.', &
'', &
'  SIZE(3) determines the extent of ARRAY along a specified dimension DIM, or', &
'  the total number of elements in ARRAY if DIM is absent.', &
'', &
'OPTIONS', &
'  o  ARRAY : the array to measure the number of elements of. If ARRAY is an', &
'     assumed-size array, DIM shall be present with a value less than the rank', &
'     of ARRAY.', &
'', &
'  o  DIM : a value shall be in the range from 1 to n, where n equals the rank', &
'     of ARRAY.', &
'', &
'     If not present the total number of elements of the entire array are', &
'     returned.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'     If absent the kind type parameter of the returned value is that of', &
'     default integer type.', &
'', &
'     The KIND must allow for the magnitude returned by SIZE or results are', &
'     undefined.', &
'', &
'     If KIND is absent, the return value is of default integer kind.', &
'', &
'RESULT', &
'  If DIM is not present ARRAY is assumed-rank, the result has a value equal to', &
'  PRODUCT(SHAPE(ARRAY,KIND)). Otherwise, the result has a value equal to the', &
'  total number of elements of ARRAY.', &
'', &
'  If DIM is present the number of elements along that dimension are returned,', &
'  except that if ARRAY is assumed-rank and associated with an assumed-size', &
'  array and DIM is present with a value equal to the rank of ARRAY, the value', &
'  is -1.', &
'', &
'  NOTE1', &
'', &
'  If ARRAY is assumed-rank and has rank zero, DIM cannot be present since it', &
'  cannot satisfy the requirement', &
'', &
'  1 <= DIM <= 0.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_size', &
'      implicit none', &
'      integer :: arr(0:2,-5:5)', &
'        write(*,*)''SIZE of simple two-dimensional array''', &
'        write(*,*)''SIZE(arr)      :total count of elements:'',size(arr)', &
'        write(*,*)''SIZE(arr,DIM=1) :number of rows        :'',size(arr,dim=1)', &
'        write(*,*)''SIZE(arr,DIM=2) :number of columns     :'',size(arr,dim=2)', &
'', &
'        ! pass the same array to a procedure that passes the value two', &
'        ! different ways', &
'        call interfaced(arr,arr)', &
'      contains', &
'', &
'      subroutine interfaced(arr1,arr2)', &
'      ! notice the difference in the array specification', &
'      ! for arr1 and arr2.', &
'      integer,intent(in) :: arr1(:,:)', &
'      integer,intent(in) :: arr2(2,*)', &
'        !', &
'        write(*,*)''interfaced assumed-shape array''', &
'        write(*,*)''SIZE(arr1)       :'',size(arr1)', &
'        write(*,*)''SIZE(arr1,DIM=1)  :'',size(arr1,dim=1)', &
'        write(*,*)''SIZE(arr1,DIM=2)  :'',size(arr1,dim=2)', &
'', &
'      !  write(*,*)''SIZE(arr2)              :'',size(arr2)', &
'        write(*,*)''SIZE(arr2,DIM=1)  :'',size(arr2,dim=1)', &
'      !', &
'      ! CANNOT DETERMINE SIZE OF ASSUMED SIZE ARRAY LAST DIMENSION', &
'      !  write(*,*)''SIZE(arr2,DIM=2)  :'',size(arr2,dim=2)', &
'', &
'      end subroutine interfaced', &
'', &
'      end program demo_size', &
'', &
'  Results:', &
'', &
'       > SIZE of simple two-dimensional array', &
'       > SIZE(arr)       :total count of elements:          33', &
'       > SIZE(arr,DIM=1) :number of rows         :           3', &
'       > SIZE(arr,DIM=2) :number of columns      :          11', &
'       > interfaced assumed-shape array', &
'       > SIZE(arr1)        :          33', &
'       > SIZE(arr1,DIM=1)  :           3', &
'       > SIZE(arr1,DIM=2)  :          11', &
'       > SIZE(arr2,DIM=1)  :           2', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  Array inquiry:', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  SHAPE(3) - Determine the shape of an array', &
'', &
'  o  UBOUND(3) - Upper dimension bounds of an array', &
'', &
'  o  LBOUND(3) - Lower dimension bounds of an array', &
'', &
'  State Inquiry:', &
'', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - Test if object is contiguous', &
'', &
'  Kind Inquiry:', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Bit Inquiry:', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  size(3fortran)', &
'']

shortname="size"
call process()

case('220','spacing')

textblock=[character(len=256) :: &
'', &
'spacing(3fortran)                                           spacing(3fortran)', &
'', &
'NAME', &
'  SPACING(3) - [MODEL_COMPONENTS] Smallest distance between two numbers of a', &
'  given type', &
'', &
'SYNOPSIS', &
'  result = spacing(x)', &
'', &
'          elemental real(kind=KIND) function spacing(x)', &
'', &
'           real(kind=KIND), intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X is type real of any valid kind', &
'', &
'  o  The result is of the same type as the input argument X.', &
'', &
'DESCRIPTION', &
'  SPACING(3) determines the distance between the argument X and the nearest', &
'  adjacent number of the same type.', &
'', &
'OPTIONS', &
'  o  X : Shall be of type real.', &
'', &
'RESULT', &
'  If X does not have the value zero and is not an IEEE infinity or NaN, the', &
'  result has the value nearest to X for values of the same type and kind', &
'  assuming the value is representable.', &
'', &
'  Otherwise, the value is the same as TINY(X). + zero produces TINY(X) + IEEE', &
'  Infinity produces an IEEE Nan + if an IEEE NaN, that NaN is returned', &
'', &
'  If there are two extended model values equally near to X, the value of', &
'  greater absolute value is taken.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_spacing', &
'      implicit none', &
'      integer, parameter :: sgl = selected_real_kind(p=6, r=37)', &
'      integer, parameter :: dbl = selected_real_kind(p=13, r=200)', &
'', &
'        write(*,*) spacing(1.0_sgl)', &
'        write(*,*) nearest(1.0_sgl,+1.0),nearest(1.0_sgl,+1.0)-1.0', &
'', &
'        write(*,*) spacing(1.0_dbl)', &
'      end program demo_spacing', &
'', &
'  Results:', &
'', &
'  Typical values ...', &
'', &
'       >  1.1920929E-07', &
'       >   1.000000      1.1920929E-07', &
'       >  0.9999999     -5.9604645E-08', &
'       >  2.220446049250313E-016', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), TINY(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025               spacing(3fortran)', &
'']

shortname="spacing"
call process()

case('221','split')

textblock=[character(len=256) :: &
'', &
'split(3fortran)                                               split(3fortran)', &
'', &
'NAME', &
'  SPLIT(3) - [CHARACTER:PARSE] Parse a string into tokens, one at a time', &
'', &
'SYNOPSIS', &
'  call split (string, set, pos [, back])', &
'', &
'           character(kind=KIND),intent(in)       :: string', &
'           character(len=*,kind=KIND),intent(in) :: set', &
'           integer,intent(inout)                 :: pos', &
'           logical,intent(in),optional           :: back', &
'', &
'CHARACTERISTICS', &
'  o  STRING is a scalar character variable', &
'', &
'  o  SET is a scalar character variable of the same kind as STRING.', &
'', &
'DESCRIPTION', &
'  Find the extent of consecutive tokens in a string. Given a string and a', &
'  position to start looking for a token return the position of the end of the', &
'  token. A set of separator characters may be specified as well as the', &
'  direction of parsing.', &
'', &
'  Typically consecutive calls are used to parse a string into a set of tokens', &
'  by stepping through the start and end positions of each token.', &
'', &
'OPTIONS', &
'  o  STRING : The string to search for tokens in.', &
'', &
'  o  SET : Each character in SET is a token delimiter. A sequence of zero or', &
'     more characters in STRING delimited by any token delimiter, or the', &
'     beginning or end of STRING, comprise a token. Thus, two consecutive token', &
'     delimiters in STRING, or a token delimiter in the first or last character', &
'     of STRING, indicate a token with zero length.', &
'', &
'  o  POS : On input, the position from which to start looking for the next', &
'     separator from. This is typically the first character or the last', &
'     returned value of POS if searching from left to right (ie. BACK is absent', &
'     or .true.) or the last character or the last returned value of POS when', &
'     searching from right to left (ie. when BACK is .false.).', &
'', &
'     If BACK is present with the value .true., the value of POS shall be in', &
'     the range 0 < POS <= LEN(STRING)+1; otherwise it shall be in the range 0', &
'     <= POS <= LEN(STRING).', &
'', &
'     So POS on input is typically an end of the string or the position of a', &
'     separator, probably from a previous call to SPLIT but POS on input can be', &
'     any position in the range 1 <= POS <= LEN(STRING). If POS points to a', &
'     non-separator character in the string the call is still valid but it will', &
'     start searching from the specified position and that will result', &
'     (somewhat obviously) in the string from POS on input to the returned POS', &
'     being a partial token.', &
'', &
'  o  BACK : If BACK is absent or is present with the value .false., POS is', &
'     assigned the position of the leftmost token delimiter in STRING whose', &
'     position is greater than POS, or if there is no such character, it is', &
'     assigned a value one greater than the length of STRING. This identifies a', &
'     token with starting position one greater than the value of POS on', &
'     invocation, and ending position one less than the value of POS on return.', &
'', &
'     If BACK is present with the value .true., POS is assigned the position of', &
'     the rightmost token delimiter in STRING whose position is less than POS,', &
'     or if there is no such character, it is assigned the value zero. This', &
'     identifies a token with ending position one less than the value of POS on', &
'     invocation, and starting position one greater than the value of POS on', &
'     return.', &
'', &
'EXAMPLE', &
'  Sample program:', &
'', &
'      program demo_split', &
'        !use m_strings, only: split=>split2020', &
'        implicit none', &
'        character (len=:), allocatable :: input', &
'        integer :: position, istart, iend', &
'        input = "one,last example,,x,, ,,"', &
'        position = 0', &
'        ! write a number line', &
'        write(*,''(t3,a)'') repeat(''1234567890'',6)', &
'        ! display the input line', &
'        write(*,''(t3,a)'') input', &
'        ! step through the input string locating the bounds of the', &
'        ! next token and printing it', &
'        do while (position < len(input))', &
'           istart = position + 1', &
'           call split (input, set='', '', pos=position)', &
'           iend = position - 1', &
'           if(iend >= istart)then', &
'              print ''(t3,a,1x,i0,1x,i0)'', input (istart:iend),istart,iend', &
'           else', &
'              ! maybe ignore null fields, maybe not ...', &
'              write(*,''(t3,*(g0))'')''null between '',iend,'' and '',istart', &
'           endif', &
'        end do', &
'      end program demo_split', &
'', &
'  Results:', &
'', &
'       >   123456789012345678901234567890123456789012345678901234567890', &
'       >   one,last example,,x,, ,,', &
'       >   one 1 3', &
'       >   last 5 8', &
'       >   example 10 16', &
'       >   null between 17 and 18', &
'       >   x 19 19', &
'       >   null between 20 and 21', &
'       >   null between 21 and 22', &
'       >   null between 22 and 23', &
'       >   null between 23 and 24', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  TOKENIZE(3) - Parse a string into tokens', &
'', &
'  o  INDEX(3) - Position of a substring within a string', &
'', &
'  o  SCAN(3) - Scan a string for the presence of a set of characters', &
'', &
'  o  VERIFY(3) - Position of a character in a string of characters that does', &
'     not appear in a given set of characters.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 split(3fortran)', &
'']

shortname="split"
call process()

case('222','spread')

textblock=[character(len=256) :: &
'', &
'spread(3fortran)                                             spread(3fortran)', &
'', &
'NAME', &
'  SPREAD(3) - [ARRAY:CONSTRUCTION] Add a dimension and replicate data', &
'', &
'SYNOPSIS', &
'  result = spread(source, dim, ncopies)', &
'', &
'          TYPE(kind=KIND) function spread(source, dim, ncopies)', &
'', &
'           TYPE(kind=KIND)             :: source(..)', &
'           integer(kind=**),intent(in) :: dim', &
'           integer(kind=**),intent(in) :: ncopies', &
'', &
'CHARACTERISTICS', &
'  o  SOURCE is a scalar or array of any type and a rank less than fifteen.', &
'', &
'  o  DIM is an integer scalar', &
'', &
'  o  NCOPIES is an integer scalar', &
'', &
'DESCRIPTION', &
'  SPREAD(3) replicates a SOURCE array along a specified dimension DIM. The', &
'  copy is repeated NCOPIES times.', &
'', &
'  So to add additional rows to a matrix DIM=1 would be used, but to add', &
'  additional rows DIM=2 would be used, for example.', &
'', &
'  If SOURCE is scalar, the size of the resulting vector is NCOPIES and each', &
'  element of the result has a value equal to SOURCE.', &
'', &
'OPTIONS', &
'  o  SOURCE : the input data to duplicate', &
'', &
'  o  DIM : The additional dimension value in the range from 1 to N+1, where N', &
'     equals the rank of SOURCE.', &
'', &
'  o  NCOPIES : the number of copies of the original data to generate', &
'', &
'RESULT', &
'  The result is an array of the same type as SOURCE and has rank N+1 where N', &
'  equals the rank of SOURCE.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_spread', &
'      implicit none', &
'', &
'      integer a1(4,3), a2(3,4), v(4), s', &
'', &
'        write(*,''(a)'' ) &', &
'        ''TEST SPREAD(3)                                     '', &', &
'        ''  SPREAD(3) is a FORTRAN90 function which replicates'', &', &
'        ''  an array by adding a dimension.                  '', &', &
'        '' ''', &
'', &
'        s = 99', &
'        call printi(''suppose we have a scalar S'',s)', &
'', &
'        write(*,*) ''to add a new dimension (1) of extent 4 call''', &
'        call printi(''spread( s, dim=1, ncopies=4 )'',spread ( s, 1, 4 ))', &
'', &
'        v = [ 1, 2, 3, 4 ]', &
'        call printi('' first we will set V to'',v)', &
'', &
'        write(*,''(a)'')'' and then do "spread ( v, dim=2, ncopies=3 )"''', &
'        a1 = spread ( v, dim=2, ncopies=3 )', &
'        call printi(''uses v as a column and makes 3 columns'',a1)', &
'', &
'        a2 = spread ( v, 1, 3 )', &
'        call printi('' spread(v,1,3) uses v as a row and makes 3 rows'',a2)', &
'', &
'      contains', &
'      ! CONVENIENCE ROUTINE; NOT DIRECTLY CONNECTED TO SPREAD(3)', &
'      subroutine printi(title,a)', &
'      use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,&', &
'       & stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT', &
'      implicit none', &
'', &
'      !@(#) print small 2d integer scalar, vector, matrix in row-column format', &
'', &
'      character(len=*),parameter   :: all=''(" ",*(g0,1x))''', &
'      character(len=*),intent(in)  :: title', &
'      character(len=20)           :: row', &
'      integer,intent(in)          :: a(..)', &
'      integer                     :: i', &
'', &
'        write(*,all,advance=''no'')trim(title)', &
'        ! select rank of input', &
'        select rank(a)', &
'        rank (0); write(*,''(a)'')'' (a scalar)''', &
'           write(*,''(" > [ ",i0," ]")'')a', &
'        rank (1); write(*,''(a)'')'' (a vector)''', &
'           ! find how many characters to use for integers', &
'           write(row,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(a))))))+2', &
'           ! use this format to write a row', &
'           row=''(" > [",*(i''//trim(row)//'':,","))''', &
'           do i=1,size(a)', &
'              write(*,fmt=row,advance=''no'')a(i)', &
'              write(*,''(" ]")'')', &
'           enddo', &
'        rank (2); write(*,''(a)'')'' (a matrix) ''', &
'           ! find how many characters to use for integers', &
'           write(row,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(a))))))+2', &
'           ! use this format to write a row', &
'           row=''(" > [",*(i''//trim(row)//'':,","))''', &
'           do i=1,size(a,dim=1)', &
'              write(*,fmt=row,advance=''no'')a(i,:)', &
'              write(*,''(" ]")'')', &
'           enddo', &
'        rank default', &
'           write(stderr,*)''*printi* did not expect rank='', rank(a), &', &
'            & ''shape='', shape(a),''size='',size(a)', &
'           stop ''*printi* unexpected rank''', &
'        end select', &
'        write(*,all) ''>shape='',shape(a),'',rank='',rank(a),'',size='',size(a)', &
'        write(*,*)', &
'', &
'      end subroutine printi', &
'', &
'      end program demo_spread', &
'', &
'  Results:', &
'', &
'       > TEST SPREAD(3)', &
'       >   SPREAD(3) is a FORTRAN90 function which replicates', &
'       >   an array by adding a dimension.', &
'       >', &
'       >  suppose we have a scalar S  (a scalar)', &
'       >  > [ 99 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  to add a new dimension (1) of extent 4 call', &
'       >  spread( s, dim=1, ncopies=4 )  (a vector)', &
'       >  > [  99 ]', &
'       >  > [  99 ]', &
'       >  > [  99 ]', &
'       >  > [  0 ]', &
'       >  >shape= 4 ,rank= 1 ,size= 4', &
'       >', &
'       >   first we will set V to  (a vector)', &
'       >  > [  1 ]', &
'       >  > [  2 ]', &
'       >  > [  3 ]', &
'       >  > [  4 ]', &
'       >  >shape= 4 ,rank= 1 ,size= 4', &
'       >', &
'       >  and then do "spread ( v, dim=2, ncopies=3 )"', &
'       >  uses v as a column and makes 3 columns  (a matrix)', &
'       >  > [  1,  1,  1 ]', &
'       >  > [  2,  2,  2 ]', &
'       >  > [  3,  3,  3 ]', &
'       >  > [  4,  4,  4 ]', &
'       >  >shape= 4 3 ,rank= 2 ,size= 12', &
'       >', &
'       >   spread(v,1,3) uses v as a row and makes 3 rows  (a matrix)', &
'       >  > [  1,  2,  3,  4 ]', &
'       >  > [  1,  2,  3,  4 ]', &
'       >  > [  1,  2,  3,  4 ]', &
'       >  >shape= 3 4 ,rank= 2 ,size= 12', &
'       >', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MERGE(3), PACK(3), UNPACK(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                spread(3fortran)', &
'']

shortname="spread"
call process()

case('223','sqrt')

textblock=[character(len=256) :: &
'', &
'sqrt(3fortran)                                                 sqrt(3fortran)', &
'', &
'NAME', &
'  SQRT(3) - [MATHEMATICS] Square-root function', &
'', &
'SYNOPSIS', &
'  result = sqrt(x)', &
'', &
'          elemental TYPE(kind=KIND) function sqrt(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  TYPE may be real or complex.', &
'', &
'  o  KIND may be any kind valid for the declared type.', &
'', &
'  o  the result has the same characteristics as X.', &
'', &
'DESCRIPTION', &
'  SQRT(3) computes the principal square root of X.', &
'', &
'  The number whose square root is being considered is known as the radicand.', &
'', &
'  In mathematics, a square root of a radicand X is a number Y such that Y*Y =', &
'  X.', &
'', &
'  Every nonnegative radicand X has two square roots of the same unique', &
'  magnitude, one positive and one negative. The nonnegative square root is', &
'  called the principal square root.', &
'', &
'  The principal square root of 9 is 3, for example, even though (-3)*(-3) is', &
'  also 9.', &
'', &
'  Square roots of negative numbers are a special case of complex numbers,', &
'  where with COMPLEX input the components of the radicand need not be positive', &
'  in order to have a valid square root.', &
'', &
'OPTIONS', &
'  o  X : The radicand to find the principal square root of. If X is real its', &
'     value must be greater than or equal to zero.', &
'', &
'RESULT', &
'  The principal square root of X is returned.', &
'', &
'  For a complex result the real part is greater than or equal to zero.', &
'', &
'  When the real part of the result is zero, the imaginary part has the same', &
'  sign as the imaginary part of X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sqrt', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x, x2', &
'      complex :: z, z2', &
'', &
'       ! basics', &
'        x = 2.0_real64', &
'        ! complex', &
'        z = (1.0, 2.0)', &
'        write(*,*)''input values '',x,z', &
'', &
'        x2 = sqrt(x)', &
'        z2 = sqrt(z)', &
'        write(*,*)''output values '',x2,z2', &
'', &
'       ! elemental', &
'       write(*,*)''elemental'',sqrt([64.0,121.0,30.0])', &
'', &
'       ! alternatives', &
'        x2 = x**0.5', &
'        z2 = z**0.5', &
'        write(*,*)''alternatively'',x2,z2', &
'', &
'      end program demo_sqrt', &
'', &
'  Results:', &
'', &
'       > input values    2.00000000000000      (1.000000,2.000000)', &
'       > output values    1.41421356237310      (1.272020,0.7861513)', &
'       > elemental   8.000000       11.00000       5.477226', &
'       > alternatively   1.41421356237310      (1.272020,0.7861513)', &
'', &
'STANDARD', &
'  FORTRAN 77', &
'', &
'SEE ALSO', &
'  EXP(3), LOG(3), LOG10(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  sqrt(3fortran)', &
'']

shortname="sqrt"
call process()

case('224','stop')

textblock=[character(len=256) :: &
'', &
'stop(7fortran)                                                 stop(7fortran)', &
'', &
'NAME', &
'  STOP(7) - [STATEMENT] initiates termination of execution', &
'', &
'SYNOPSIS', &
'  stop [ stop-code ]', &
'', &
'  error stop [ stop-code ]', &
'', &
'CHARACTERISTICS', &
'  o  STOP-CODE is a constant scalar _character_or integer expression, of', &
'     default kind.', &
'', &
'DESCRIPTION', &
'  A STOP statement will cause the program to terminate normally.', &
'', &
'  It may provide additional information in the form of output or a system', &
'  status code, depending on the system.', &
'', &
'  Any messages generated appear on the ERROR_UNIT file, as identified in the', &
'  intrinsic module ISO_FORTRAN_ENV. This unit is often referred to as', &
'  "stderr".', &
'', &
'  It is recommended that systems write the value of the stop code whether', &
'  numeric or a string.', &
'', &
'  Note that although STOP causes a "normal" termination, system status codes', &
'  or "exit codes" are often used for error processing in many scripting', &
'  languages. This code may be detectable by EXECUTE_SYSTEM_COMMAND(3f).', &
'', &
'  Execution of an ERROR STOP statement initiates error termination of an', &
'  execution, which on several systems includes the output from a traceback.', &
'', &
'  So when an image is terminated by a STOP or ERROR STOP statement, its stop', &
'  code, if any, is made available in a processor-dependent manner.', &
'', &
'  If any exception is signaling on a stopped image, the processor issues a', &
'  warning indicating which exceptions are signaling;', &
'', &
'  When normal termination occurs on more than one image, it is expected that a', &
'  processor-dependent summary of any stop codes and signaling exceptions will', &
'  be made available.', &
'', &
'  If an integer STOP-CODE is used as the process exit status, the processor', &
'  might be able to interpret only values within a limited range, OR only a', &
'  limited portion of the integer value (for example, only the least-', &
'  significant 8 bits).', &
'', &
'  If the STOP-CODE is of type character or does not appear, OR if an END', &
'  PROGRAM statement is executed, it is recommended that the value zero be', &
'  supplied as the process exit status, if the processor supports that concept.', &
'', &
'EXAMPLES', &
'  Sample:', &
'', &
'        program demo_stop', &
'        ! select which STOP call to make from command line', &
'        use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT', &
'        implicit none', &
'        integer :: istat, argument_length, stopcode', &
'        character(len=:),allocatable :: which, message', &
'           ! allocate string array big enough to hold command line', &
'           call get_command_argument(number=1,length=argument_length)', &
'           ! argument strings and related information', &
'           if(allocated(which))deallocate(which)', &
'           allocate(character(len=argument_length) :: which)', &
'           call get_command_argument(1, which,status=istat)', &
'           if(istat.ne.0)which=''''', &
'           select case(which)', &
'           ! normal terminations:', &
'           ! A STOP with no non-zero numeric parameter is a normal', &
'           ! termination and generally returns a zero status value if the', &
'           ! system supports return statuses', &
'           case(''basic''); stop    ! usually displays nothing', &
'           case(''zero'');  stop 0  ! sometimes displays "STOP 0" or "0"', &
'           case(''text'');  stop ''That is all, folks!''', &
'           !', &
'           ! All other stops are generally used to indicate an error or', &
'           ! special exit type', &
'           case(''nonzero'');               stop 10', &
'           case(''variable''); stopcode=11;   stop stopcode', &
'           case(''expression''); stopcode=11; stop 110/stopcode', &
'           case(''string''); message=''oops'';  stop ''ERROR:[''//message//'']''', &
'           ! Error terminations:', &
'           ! ERROR STOP is always an error stop, even without a stop-code', &
'           ! ERROR STOP often displays a traceback but that is not required', &
'           case(''error'')', &
'              error stop', &
'           case(''errornum'')', &
'              stopcode=10', &
'              error stop stopcode+3', &
'           case(''errorstring'')', &
'              message=''That is all, folks!''', &
'              error stop ''ERROR:''//message', &
'           case default', &
'              write(*,''(a)'')''enter a stop type:'', &', &
'                   & ''{basic, text, zero, nonzero, variable, expression}'', &', &
'                   & ''{error, errornum, errorstring}''', &
'              write(*,*)''try again ...''', &
'           end select', &
'        end program demo_stop', &
'', &
'STANDARD', &
'  FORTRAN 77, ERROR STOP introduced in Fortran f2018', &
'', &
'  Fortran statement descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  stop(7fortran)', &
'']

shortname="stop"
call process()

case('225','storage_size')

textblock=[character(len=256) :: &
'', &
'storage_size(3fortran)                                 storage_size(3fortran)', &
'', &
'NAME', &
'  STORAGE_SIZE(3) - [BIT:INQUIRY] Storage size in bits', &
'', &
'SYNOPSIS', &
'  result = storage_size(a [,KIND] )', &
'', &
'          integer(kind=KIND) storage_size(a,KIND)', &
'', &
'           type(TYPE(kind=**)) :: a', &
'           integer,intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  A may be of any type and kind. If it is polymorphic it shall not be an', &
'     undefined pointer. If it is unlimited polymorphic or has any deferred', &
'     type parameters, it shall not be an unallocated allocatable variable or a', &
'     disassociated or undefined pointer.', &
'', &
'  o  The kind type parameter of the returned value is that specified by the', &
'     value of KIND; otherwise, the kind type parameter is that of default', &
'     integer type.', &
'', &
'  o  The result is an integer scalar of default kind unless KIND is specified,', &
'     in which case it has the kind specified by KIND.', &
'', &
'DESCRIPTION', &
'  STORAGE_SIZE(3) returns the storage size of argument A in bits.', &
'', &
'OPTIONS', &
'  o  A : The entity to determine the storage size of', &
'', &
'  o  KIND : a scalar integer constant expression that defines the kind of the', &
'     output value.', &
'', &
'RESULT', &
'  The result value is the size expressed in bits for an element of an array', &
'  that has the dynamic type and type parameters of A.', &
'', &
'  If the type and type parameters are such that storage association applies,', &
'  the result is consistent with the named constants defined in the intrinsic', &
'  module ISO_FORTRAN_ENV.', &
'', &
'  NOTE1', &
'', &
'  An array element might take "type" more bits to store than an isolated', &
'  scalar, since any hardware-imposed alignment requirements for array elements', &
'  might not apply to a simple scalar variable.', &
'', &
'  NOTE2', &
'', &
'  This is intended to be the size in memory that an object takes when it is', &
'  stored; this might differ from the size it takes during expression handling', &
'  (which might be the native register size) or when stored in a file. If an', &
'  object is never stored in memory but only in a register, this function', &
'  nonetheless returns the size it would take if it were stored in memory.', &
'', &
'EXAMPLES', &
'  Sample program', &
'', &
'      program demo_storage_size', &
'      implicit none', &
'', &
'        ! a default real, integer, and logical are the same storage size', &
'        write(*,*)''size of integer      '',storage_size(0)', &
'        write(*,*)''size of real         '',storage_size(0.0)', &
'        write(*,*)''size of logical      '',storage_size(.true.)', &
'        write(*,*)''size of complex      '',storage_size((0.0,0.0))', &
'', &
'        ! note the size of an element of the array, not the storage size of', &
'        ! the entire array is returned for array arguments', &
'        write(*,*)''size of integer array '',storage_size([0,1,2,3,4,5,6,7,8,9])', &
'', &
'      end program demo_storage_size', &
'', &
'  Results:', &
'', &
'       > size of integer                 32', &
'       > size of real                    32', &
'       > size of logical                 32', &
'       > size of complex                 64', &
'       > size of integer array           32', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  C_SIZEOF(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          storage_size(3fortran)', &
'']

shortname="storage_size"
call process()

case('226','sum')

textblock=[character(len=256) :: &
'', &
'sum(3fortran)                                                   sum(3fortran)', &
'', &
'NAME', &
'  SUM(3) - [ARRAY:REDUCTION] Sum the elements of an array', &
'', &
'SYNOPSIS', &
'  result = sum(array [,dim[,mask]] | [mask] )', &
'', &
'          TYPE(kind=KIND) function sum(array, dim, mask)', &
'', &
'           TYPE(kind=KIND),intent(in) :: array(..)', &
'           integer(kind=**),intent(in),optional :: dim', &
'           logical(kind=**),intent(in),optional :: mask(..)', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  ARRAY may be of any numeric type - integer, real or complex.', &
'', &
'  o  DIM is an integer', &
'', &
'  o  MASK is logical and conformable with ARRAY.', &
'', &
'  o  The result is of the same type and kind as ARRAY. It is scalar if DIM is', &
'     not present or ARRAY is a vector, else it is an array.', &
'', &
'DESCRIPTION', &
'  SUM(3) adds the elements of ARRAY.', &
'', &
'  When only ARRAY is specified all elements are summed, but groups of sums may', &
'  be returned along the dimension specified by DIM and/or elements to add may', &
'  be selected by a logical mask.', &
'', &
'  No method is designated for how the sum is conducted, so whether or not', &
'  accumulated error is compensated for is processor-dependent.', &
'', &
'OPTIONS', &
'  o  ARRAY : an array containing the elements to add', &
'', &
'  o  DIM : a value in the range from 1 to n, where n equals the rank (the', &
'     number of dimensions) of ARRAY. DIM designates the dimension along which', &
'     to create sums. When absent a scalar sum of the elements optionally', &
'     selected by MASK is returned.', &
'', &
'  o  MASK : an array of the same shape as ARRAY that designates which elements', &
'     to add. If absent all elements are used in the sum(s).', &
'', &
'RESULT', &
'  If DIM is absent, a scalar with the sum of all selected elements in ARRAY is', &
'  returned. Otherwise, an array of rank n-1, where n equals the rank of ARRAY,', &
'  and a shape similar to that of ARRAY with dimension DIM dropped is returned.', &
'  Since a vector has a rank of one, the result is a scalar (if n==1, n-1 is', &
'  zero; and a rank of zero means a scalar).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_sum', &
'      implicit none', &
'      integer :: vector(5) , matrix(3,4), box(5,6,7)', &
'', &
'        vector = [ 1, 2, -3, 4, 5 ]', &
'', &
'        matrix(1,:)=[  -1,   2,    -3,   4    ]', &
'        matrix(2,:)=[  10,   -20,  30,   -40  ]', &
'        matrix(3,:)=[  100,  200, -300,  400  ]', &
'', &
'        box=11', &
'', &
'       ! basics', &
'        print *, ''sum all elements:'',sum(vector)', &
'        print *, ''real :'',sum([11.0,-5.0,20.0])', &
'        print *, ''complex :'',sum([(1.1,-3.3),(4.0,5.0),(8.0,-6.0)])', &
'       ! with MASK option', &
'        print *, ''sum odd elements:'',sum(vector, mask=mod(vector, 2)==1)', &
'        print *, ''sum positive values:'', sum(vector, mask=vector>0)', &
'', &
'        call printi(''the input array'', matrix )', &
'        call printi(''sum of all elements in matrix'', sum(matrix) )', &
'        call printi(''sum of positive elements'', sum(matrix,matrix>=0) )', &
'       ! along dimensions', &
'        call printi(''sum along rows'', sum(matrix,dim=1) )', &
'        call printi(''sum along columns'', sum(matrix,dim=2) )', &
'        call printi(''sum of a vector is always a scalar'', sum(vector,dim=1) )', &
'        call printi(''sum of a volume by row'', sum(box,dim=1) )', &
'        call printi(''sum of a volume by column'', sum(box,dim=2) )', &
'        call printi(''sum of a volume by depth'', sum(box,dim=3) )', &
'', &
'      contains', &
'      ! CONVENIENCE ROUTINE; NOT DIRECTLY CONNECTED TO SPREAD(3)', &
'      subroutine printi(title,a)', &
'      use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,&', &
'       & stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT', &
'      implicit none', &
'', &
'      !@(#) print small 2d integer scalar, vector, matrix in row-column format', &
'', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: a(..)', &
'', &
'      character(len=*),parameter   :: all=''(" ",*(g0,1x))''', &
'      character(len=20)           :: row', &
'      integer,allocatable         :: b(:,:)', &
'      integer                     :: i', &
'        write(*,all,advance=''no'')trim(title)', &
'        ! copy everything to a matrix to keep code simple', &
'        select rank(a)', &
'        rank (0); write(*,''(a)'')'' (a scalar)''; b=reshape([a],[1,1])', &
'        rank (1); write(*,''(a)'')'' (a vector)''; b=reshape(a,[size(a),1])', &
'        rank (2); write(*,''(a)'')'' (a matrix)''; b=a', &
'        rank default; stop ''*printi* unexpected rank''', &
'        end select', &
'        ! find how many characters to use for integers', &
'        write(row,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(b))))))+2', &
'        ! use this format to write a row', &
'        row=''(" > [",*(i''//trim(row)//'':,","))''', &
'        do i=1,size(b,dim=1)', &
'           write(*,fmt=row,advance=''no'')b(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'        write(*,all) ''>shape='',shape(a),'',rank='',rank(a),'',size='',size(a)', &
'        write(*,*)', &
'      end subroutine printi', &
'      end program demo_sum', &
'', &
'  Results:', &
'', &
'       >  sum all elements:          9', &
'       >  real :   26.0000000', &
'       >  complex :           (13.1000004,-4.30000019)', &
'       >  sum odd elements:          6', &
'       >  sum positive values:         12', &
'       >  the input array  (a matrix)', &
'       >  > [  -1,    2,   -3,    4 ]', &
'       >  > [  10,  -20,   30,  -40 ]', &
'       >  > [  100,  200, -300,  400 ]', &
'       >  >shape= 3 4 ,rank= 2 ,size= 12', &
'       >', &
'       >  sum of all elements in matrix  (a scalar)', &
'       >  > [  382 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  sum of positive elements  (a scalar)', &
'       >  > [  746 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  sum along rows  (a vector)', &
'       >  > [  109 ]', &
'       >  > [  182 ]', &
'       >  > [ -273 ]', &
'       >  > [  364 ]', &
'       >  >shape= 4 ,rank= 1 ,size= 4', &
'       >', &
'       >  sum along columns  (a vector)', &
'       >  > [   2 ]', &
'       >  > [  -20 ]', &
'       >  > [  400 ]', &
'       >  >shape= 3 ,rank= 1 ,size= 3', &
'       >', &
'       >  sum of a vector is always a scalar  (a scalar)', &
'       >  > [  9 ]', &
'       >  >shape= ,rank= 0 ,size= 1', &
'       >', &
'       >  sum of a volume by row  (a matrix)', &
'       >  > [  55,  55,  55,  55,  55, 55,  55 ]', &
'       >  > [  55,  55,  55,  55,  55, 55,  55 ]', &
'       >  > [  55,  55,  55,  55,  55, 55,  55 ]', &
'       >  > [  55,  55,  55,  55,  55, 55,  55 ]', &
'       >  > [  55,  55,  55,  55,  55, 55,  55 ]', &
'       >  > [  55,  55,  55,  55,  55, 55, 113 ]', &
'       >  >shape= 6 7 ,rank= 2 ,size= 42', &
'       >', &
'       >  sum of a volume by column  (a matrix)', &
'       >  > [  66,  66,  66,  66,  66, 66,  66 ]', &
'       >  > [  66,  66,  66,  66,  66, 66,  66 ]', &
'       >  > [  66,  66,  66,  66,  66, 66,  66 ]', &
'       >  > [  66,  66,  66,  66,  66, 66,  66 ]', &
'       >  > [  66,  66,  66,  66,  66, 66,**** ]', &
'       >  >shape= 5 7 ,rank= 2 ,size= 35', &
'       >', &
'       >  sum of a volume by depth  (a matrix)', &
'       >  > [  77,  77,  77,  77,  77, 77 ]', &
'       >  > [  77,  77,  77,  77,  77, 77 ]', &
'       >  > [  77,  77,  77,  77,  77, 77 ]', &
'       >  > [  77,  77,  77,  77,  77, 77 ]', &
'       >  > [  77,  77,  77,  77,  77,4193 ]', &
'       >  >shape= 5 6 ,rank= 2 ,size= 30', &
'       >', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  ALL(3) - Determines if all the values are true', &
'', &
'  o  ANY(3) - Determines if any of the values in the logical array are true.', &
'', &
'  o  COUNT(3) - Count true values in an array', &
'', &
'  o  MAXVAL(3) - Determines the maximum value in an array', &
'', &
'  o  MINVAL(3) - Minimum value of an array', &
'', &
'  o  PRODUCT(3) - Product of array elements', &
'', &
'  o  MERGE(3) - Merge variables', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   sum(3fortran)', &
'']

shortname="sum"
call process()

case('227','system_clock')

textblock=[character(len=256) :: &
'', &
'system_clock(3fortran)                                 system_clock(3fortran)', &
'', &
'NAME', &
'  SYSTEM_CLOCK(3) - [SYSTEM:TIME] Query system clock', &
'', &
'SYNOPSIS', &
'  call system_clock([count] [,count_rate] [,count_max] )', &
'', &
'          subroutine system_clock(count, count_rate, count_max)', &
'', &
'           integer(kind=**),intent(out),optional    :: count', &
'           type(TYPE(kind=**)),intent(out),optional :: count_rate', &
'           integer(kind=**),intent(out),optional    :: count_max', &
'', &
'CHARACTERISTICS', &
'  o  COUNT is an integer scalar', &
'', &
'  o  COUNT_RATE is an integer or real scalar', &
'', &
'  o  COUNT_MAX is an integer scalar', &
'', &
'DESCRIPTION', &
'  SYSTEM_CLOCK(3) lets you measure durations of time with the precision of the', &
'  smallest time increment generally available on a system by returning', &
'  processor-dependent values based on the current value of the processor', &
'  clock.', &
'', &
'  SYSTEM_CLOCK is typically used to measure short time intervals (system', &
'  clocks may be 24-hour clocks or measure processor clock ticks since boot,', &
'  for example). It is most often used for measuring or tracking the time spent', &
'  in code blocks in lieu of using profiling tools.', &
'', &
'  COUNT_RATE and COUNT_MAX are assumed constant (even though CPU rates can', &
'  vary on a single platform).', &
'', &
'  Whether an image has no clock, has a single clock of its own, or shares a', &
'  clock with another image, is processor dependent.', &
'', &
'  If there is no clock, or querying the clock fails, COUNT is set to', &
'  -HUGE(COUNT), and COUNT_RATE and COUNT_MAX are set to zero.', &
'', &
'  The accuracy of the measurements may depend on the kind of the arguments!', &
'', &
'  Timing-related procedures are obviously processor and system-dependent.', &
'  More specific information may generally be found in compiler-specific', &
'  documentation.', &
'', &
'OPTIONS', &
'  o  COUNT : If there is no clock, the returned value for COUNT is the', &
'     negative value -HUGE(COUNT).', &
'', &
'     Otherwise, the CLOCK value is incremented by one for each clock count', &
'     until the value COUNT_MAX is reached and is then reset to zero at the', &
'     next count. CLOCK therefore is a modulo value that lies in the range 0 TO', &
'     COUNT_MAX.', &
'', &
'  o  COUNT_RATE : is assigned a processor-dependent approximation to the', &
'     number of processor clock counts per second, or zero if there is no', &
'     clock. COUNT_RATE is system dependent and can vary depending on the kind', &
'     of the arguments. Generally, a large real may generate a more precise', &
'     interval.', &
'', &
'  o  COUNT_MAX : is assigned the maximum value that COUNT can have, or zero if', &
'     there is no clock.', &
'', &
'EXAMPLES', &
'  If the processor clock is a 24-hour clock that registers time at', &
'  approximately 18.20648193 ticks per second, at 11:30 A.M. the reference', &
'', &
'           call system_clock (count = c, count_rate = r, count_max = m)', &
'', &
'  defines', &
'', &
'           C = (11*3600+30*60)*18.20648193 = 753748,', &
'           R = 18.20648193, and', &
'           M = 24*3600*18.20648193-1 = 1573039.', &
'', &
'  Sample program:', &
'', &
'      program demo_system_clock', &
'      use, intrinsic :: iso_fortran_env, only: wp => real64, int32, int64', &
'      implicit none', &
'      character(len=*), parameter :: g = ''(1x,*(g0,1x))''', &
'', &
'      integer(kind=int64) :: count64, count_rate64, count_max64', &
'      integer(kind=int64) :: start64, finish64', &
'', &
'      integer(kind=int32) :: count32, count_rate32, count_max32', &
'', &
'      real(kind=wp)      :: time_read', &
'      real(kind=wp)      :: sum', &
'      integer            :: i', &
'', &
'        print g, ''accuracy may vary with argument type!''', &
'', &
'        print g, ''query all arguments''', &
'', &
'        call system_clock(count64, count_rate64, count_max64)', &
'        print g, ''COUNT_MAX(64bit)='', count_max64', &
'        print g, ''COUNT_RATE(64bit)='', count_rate64', &
'        print g, ''CURRENT COUNT(64bit)='', count64', &
'', &
'        call system_clock(count32, count_rate32, count_max32)', &
'        print g, ''COUNT_MAX(32bit)='', count_max32', &
'        print g, ''COUNT_RATE(32bit)='', count_rate32', &
'        print g, ''CURRENT COUNT(32bit)='', count32', &
'', &
'        print g, ''time some computation''', &
'        call system_clock(start64)', &
'', &
'        ! some code to time', &
'        sum = 0.0_wp', &
'        do i = -0, huge(0) - 1', &
'           sum = sum + sqrt(real(i))', &
'        end do', &
'        print g, ''SUM='', sum', &
'', &
'        call system_clock(finish64)', &
'', &
'        time_read = (finish64 - start64)/real(count_rate64, wp)', &
'        write (*, ''(1x,a,1x,g0,1x,a)'') ''time : '', time_read, '' seconds''', &
'', &
'      end program demo_system_clock', &
'', &
'  Results:', &
'', &
'       >  accuracy may vary with argument type!', &
'       >  query all arguments', &
'       >  COUNT_MAX(64bit)= 9223372036854775807', &
'       >  COUNT_RATE(64bit)= 1000000000', &
'       >  CURRENT COUNT(64bit)= 1105422387865806', &
'       >  COUNT_MAX(32bit)= 2147483647', &
'       >  COUNT_RATE(32bit)= 1000', &
'       >  CURRENT COUNT(32bit)= 1105422387', &
'       >  time some computation', &
'       >  SUM= 66344288183024.266', &
'       >  time :  6.1341038460000004  seconds', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DATE_AND_TIME(3), CPU_TIME(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025          system_clock(3fortran)', &
'']

shortname="system_clock"
call process()

case('228','tan')

textblock=[character(len=256) :: &
'', &
'tan(3fortran)                                                   tan(3fortran)', &
'', &
'NAME', &
'  TAN(3) - [MATHEMATICS:TRIGONOMETRIC] Tangent function', &
'', &
'SYNOPSIS', &
'  result = tan(x)', &
'', &
'       elemental TYPE(kind=KIND) function tan(x)', &
'', &
'       TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  the TYPE of X may be real or complex of any supported kind', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  TAN(3) computes the tangent of X.', &
'', &
'OPTIONS', &
'  o  X : The angle in radians to compute the tangent of when the input is', &
'     real. If X is of type complex, its real part is regarded as a value in', &
'     radians.', &
'', &
'RESULT', &
'  The return value is the tangent of the value X.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tan', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.165_real64', &
'          write(*,*)x, tan(x)', &
'      end program demo_tan', &
'', &
'  Results:', &
'', &
'       >  0.16500000000000001       0.16651386310913616', &
'', &
'STANDARD', &
'  FORTRAN 77 . For a complex argument, Fortran 2008 .', &
'', &
'SEE ALSO', &
'  ATAN(3), ATAN2(3), COS(3), SIN(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   tan(3fortran)', &
'']

shortname="tan"
call process()

case('229','tand')

textblock=[character(len=256) :: &
'', &
'tand(3fortran)                                                 tand(3fortran)', &
'', &
'NAME', &
'  TAND(3) - [MATHEMATICS:TRIGONOMETRIC] Degree Tangent function', &
'', &
'SYNOPSIS', &
'  result = tand(x)', &
'', &
'       elemental real(kind=KIND) function tand(x)', &
'', &
'       real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  the TYPE of X is real of any supported kind', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  TAND(3) computes the degree tangent of X.', &
'', &
'OPTIONS', &
'  o  X : The angle in degrees to compute the tangent of.', &
'', &
'RESULT', &
'  The return value is a processor-dependent approximation to the tangent of', &
'  the value X where X is regarded as a value in degrees.', &
'', &
'EXAMPLES', &
'  tand(180.0) has the value 0.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_tand', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 0.5_real64', &
'          write(*,*)x, tand(x)', &
'      end program demo_tand', &
'', &
'  Result:', &
'', &
'       > 0.50000000000000000        8.7268677907587893E-003', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ATAND(3), ATAN(3), ATAN2D(3), ATAN2(3), COSD(3), SIND(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  tand(3fortran)', &
'']

shortname="tand"
call process()

case('230','tanh')

textblock=[character(len=256) :: &
'', &
'tanh(3fortran)                                                 tanh(3fortran)', &
'', &
'NAME', &
'  TANH(3) - [MATHEMATICS:TRIGONOMETRIC] Hyperbolic tangent function', &
'', &
'SYNOPSIS', &
'  result = tanh(x)', &
'', &
'          elemental TYPE(kind=KIND) function tanh(x)', &
'', &
'           TYPE(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be real or complex and any associated kind supported by the', &
'     processor.', &
'', &
'  o  The returned value will be of the same type and kind as the argument.', &
'', &
'DESCRIPTION', &
'  TANH(3) computes the hyperbolic tangent of X.', &
'', &
'OPTIONS', &
'  o  X : The value to compute the Hyperbolic tangent of.', &
'', &
'RESULT', &
'  Returns the hyperbolic tangent of X.', &
'', &
'  If X is complex, the imaginary part of the result is regarded as a radian', &
'  value.', &
'', &
'  If X is real, the return value lies in the range', &
'', &
'           -1 <= tanh(x) <= 1.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tanh', &
'      use, intrinsic :: iso_fortran_env, only : real32, real64, real128', &
'      implicit none', &
'      real(kind=real64) :: x = 2.1_real64', &
'        write(*,*)x, tanh(x)', &
'      end program demo_tanh', &
'', &
'  Results:', &
'', &
'       >   2.1000000000000001       0.97045193661345386', &
'', &
'STANDARD', &
'  FORTRAN 77 , for a complex argument Fortran 2008', &
'', &
'SEE ALSO', &
'  ATANH(3)', &
'', &
'RESOURCES', &
'  o  Wikipedia:hyperbolic functions', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025                  tanh(3fortran)', &
'']

shortname="tanh"
call process()

case('231','tanpi')

textblock=[character(len=256) :: &
'', &
'tanpi(3fortran)                                               tanpi(3fortran)', &
'', &
'NAME', &
'  TANPI(3) - [MATHEMATICS:TRIGONOMETRIC] Circular tangent function', &
'', &
'SYNOPSIS', &
'  result = tanpi(x)', &
'', &
'       elemental real(kind=KIND) function tanpi(x)', &
'', &
'       real(kind=KIND),intent(in) :: x', &
'', &
'CHARACTERISTICS', &
'  o  the TYPE of X is real any supported kind', &
'', &
'  o  The returned value will be of the same type and kind as the argument X.', &
'', &
'DESCRIPTION', &
'  TANPI(3) computes the Circular Tangent of X in half-revolutions.', &
'', &
'  The result has a value equal to a processor-dependent approximation to the', &
'  tangent of X, which is regarded as a value in half-revolutions; thus, TANPI', &
'  (X) is approximately equal to tan(X*PI).', &
'', &
'OPTIONS', &
'  o  X : The angle in half-revolutions to compute the tangent of.', &
'', &
'RESULT', &
'  The return value is the tangent of the value X.', &
'', &
'EXAMPLES', &
'  Example: TAND(1.0) has the value 0.0 (approximately).', &
'', &
'  Sample program:', &
'', &
'      program demo_tanpi', &
'      use, intrinsic :: iso_fortran_env, only : real64', &
'      implicit none', &
'      integer :: i', &
'      real(kind=real64) :: x', &
'        do i=0,8', &
'           x=0.250000000d0*i', &
'           write(*,101)x, tanpi(x), tanpi(x)*180.0d0', &
'        enddo', &
'      101 format(g0,t23,g0,t50,g0)', &
'      end program demo_tanpi', &
'', &
'  Results:', &
'', &
'       > .000000000000000    0.000000000000000         0.000000000000000', &
'       > .2500000000000000   0.9999999999999999       180.0000000000000', &
'       > .5000000000000000   0.1633123935319537E+17    0.2939623083575166E+19', &
'       > .7500000000000000  -1.000000000000000      -180.0000000000000', &
'       > 1.000000000000000  -0.1224646799147353E-15    -0.2204364238465236E-13', &
'       > 1.250000000000000   0.9999999999999997       179.9999999999999', &
'       > 1.500000000000000  5443746451065123.          0.9798743611917221E+18', &
'       > 1.750000000000000  -1.000000000000000      -180.0000000000001', &
'       > 2.000000000000000  -0.2449293598294706E-15    -0.4408728476930472E-13', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  ATAND(3), ATAND(3), ATAN2PI(3), ATAN2D(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                 tanpi(3fortran)', &
'']

shortname="tanpi"
call process()

case('232','this_image')

textblock=[character(len=256) :: &
'', &
'this_image(3fortran)                                     this_image(3fortran)', &
'', &
'NAME', &
'  THIS_IMAGE(3) - [COLLECTIVE] Cosubscript index of this image', &
'', &
'SYNOPSIS', &
'  result = this_image() | = this_image(distance) | = this_image(coarray,dim)', &
'', &
'        integer function this_image( distance ,coarray, dim )', &
'', &
'         type(TYPE(kind=**)),optional :: coarray[*]', &
'         integer,intent(in),optional  :: distance', &
'         integer,intent(in),optional  :: dim', &
'', &
'CHARACTERISTICS', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'  o  COARRAY can be of any type. If DIM is present it is required.', &
'', &
'  o  DISTANCE is not permitted together with COARRAY', &
'', &
'  o  if DIM if present, coarray is required.', &
'', &
'DESCRIPTION', &
'  THIS_IMAGE(3) returns the cosubscript for this image.', &
'', &
'OPTIONS', &
'  o  DISTANCE : Nonnegative scalar integer (not permitted together with', &
'     COARRAY).', &
'', &
'  o  COARRAY : if DIM present, required).', &
'', &
'  o  DIM : If present, DIM shall be between one and the corank of COARRAY.', &
'', &
'RESULT', &
'  Default integer. If COARRAY is not present, it is scalar; if DISTANCE is not', &
'  present or has value 0, its value is the image index on the invoking image', &
'  for the current team, for values smaller or equal distance to the initial', &
'  team, it returns the image index on the ancestor team which has a distance', &
'  of DISTANCE from the invoking team. If DISTANCE is larger than the distance', &
'  to the initial team, the image index of the initial team is returned.', &
'  Otherwise when the COARRAY is present, if DIM is not present, a rank-1 array', &
'  with corank elements is returned, containing the cosubscripts for COARRAY', &
'  specifying the invoking image. If DIM is present, a scalar is returned, with', &
'  the value of the DIM element of THIS_IMAGE(COARRAY).', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_this_image', &
'      implicit none', &
'      integer :: value[*]', &
'      integer :: i', &
'        value = this_image()', &
'        sync all', &
'        if (this_image() == 1) then', &
'           do i = 1, num_images()', &
'              write(*,''(2(a,i0))'') ''value['', i, ''] is '', value[i]', &
'           end do', &
'        endif', &
'      end program demo_this_image', &
'', &
'  Results:', &
'', &
'       >  value[1] is 1', &
'', &
'STANDARD', &
'  Fortran 2008. With DISTANCE argument, TS 18508', &
'', &
'SEE ALSO', &
'  NUM_IMAGES(3), IMAGE_INDEX(3)', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025            this_image(3fortran)', &
'']

shortname="this_image"
call process()

case('233','tiny')

textblock=[character(len=256) :: &
'', &
'tiny(3fortran)                                                 tiny(3fortran)', &
'', &
'NAME', &
'  TINY(3) - [MODEL:NUMERIC] Smallest positive number of a real kind', &
'', &
'SYNOPSIS', &
'  result = tiny(x)', &
'', &
'          real(kind=KIND) function tiny(x)', &
'', &
'           real(kind=KIND) :: x', &
'', &
'CHARACTERISTICS', &
'  o  X may be any real scalar or array', &
'', &
'  o  the result has the same type and kind as X', &
'', &
'DESCRIPTION', &
'  TINY(3) returns the smallest positive (non zero) number of the type and kind', &
'  of X.', &
'', &
'  For real X', &
'', &
'        result = 2.0**(minexponent(x)-1)', &
'', &
'OPTIONS', &
'  o  X : The value whose kind is used to determine the model type to query', &
'', &
'RESULT', &
'  The smallest positive value for the real type of the specified kind.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_tiny', &
'      implicit none', &
'        print *, ''default real is from'', tiny(0.0), ''to'',huge(0.0)', &
'        print *, ''doubleprecision is from '', tiny(0.0d0), ''to'',huge(0.0d0)', &
'      end program demo_tiny', &
'', &
'  Results:', &
'', &
'       > default real is from 1.17549435E-38 to 3.40282347E+38', &
'       > doubleprecision is from 2.2250738585072014E-308 to', &
'       > 1.7976931348623157E+308', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  DIGITS(3), EPSILON(3), EXPONENT(3), FRACTION(3), HUGE(3), MAXEXPONENT(3),', &
'  MINEXPONENT(3), NEAREST(3), PRECISION(3), RADIX(3), RANGE(3), RRSPACING(3),', &
'  SCALE(3), SET_EXPONENT(3), SPACING(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  tiny(3fortran)', &
'']

shortname="tiny"
call process()

case('234','tokenize')

textblock=[character(len=256) :: &
'', &
'tokenize(3fortran)                                         tokenize(3fortran)', &
'', &
'NAME', &
'  TOKENIZE(3) - [CHARACTER:PARSE] Parse a string into tokens', &
'', &
'SYNOPSIS', &
'  TOKEN form (returns array of strings)', &
'', &
'         subroutine tokenize(string, set, tokens [, separator])', &
'', &
'          character(len=*),intent(in) :: string', &
'          character(len=*),intent(in) :: set', &
'          character(len=:),allocatable,intent(out) :: tokens(:)', &
'          character(len=1),allocatable,intent(out),optional :: separator(:)', &
'', &
'  ARRAY BOUNDS form (returns arrays defining token positions)', &
'', &
'         subroutine tokenize (string, set, first, last)', &
'', &
'          character(len=*),intent(in) :: string', &
'          character(len=*),intent(in) :: set', &
'          integer,allocatable,intent(out) :: first(:)', &
'          integer,allocatable,intent(out) :: last(:)', &
'', &
'CHARACTERISTICS', &
'  o  STRING - a scalar of type character. It is an INTENT(IN) argument.', &
'', &
'  o  SET - a scalar of type character with the same kind type parameter as', &
'     STRING. It is an INTENT(IN) argument.', &
'', &
'  o  SEPARATOR - (optional) shall be of type character with the same kind type', &
'     parameter as STRING. It is an INTENT(OUT)argument. It shall not be a', &
'     coarray or a coindexed object.', &
'', &
'  o  TOKENS - of type character with the same kind type parameter as STRING.', &
'     It is an INTENT(OUT) argument. It shall not be a coarray or a coindexed', &
'     object.', &
'', &
'  o  FIRST,LAST - an allocatable array of type integer and rank one. It is an', &
'     INTENT(OUT) argument. It shall not be a coarray or a coindexed object.', &
'', &
'  To reiterate, STRING, SET, TOKENS and SEPARATOR must all be of the same', &
'  CHARACTER kind type parameter.', &
'', &
'DESCRIPTION', &
'  TOKENIZE(3) parses a string into tokens. There are two forms of the', &
'  subroutine TOKENIZE(3).', &
'', &
'  o  The token form returns an array with one token per element, all of the', &
'     same length as the longest token.', &
'', &
'  o  The array bounds form returns two integer arrays. One contains the', &
'     beginning position of the tokens and the other the end positions.', &
'', &
'  Since the token form pads all the tokens to the same length the original', &
'  number of trailing spaces of each token accept for the longest is lost.', &
'', &
'  The array bounds form retains information regarding the exact token length', &
'  even when padded by spaces.', &
'', &
'OPTIONS', &
'  o  STRING : The string to parse into tokens.', &
'', &
'  o  SET : Each character in SET is a token delimiter. A sequence of zero or', &
'     more characters in STRING delimited by any token delimiter, or the', &
'     beginning or end of STRING, comprise a token. Thus, two consecutive token', &
'     delimiters in STRING, or a token delimiter in the first or last character', &
'     of STRING, indicate a token with zero length.', &
'', &
'  o  TOKENS : It shall be an allocatable array of rank one with deferred', &
'     length. It is allocated with the lower bound equal to one and the upper', &
'     bound equal to the number of tokens in STRING, and with character length', &
'     equal to the length of the longest token.', &
'', &
'     The tokens in STRING are assigned in the order found, as if by intrinsic', &
'     assignment, to the elements of TOKENS, in array element order.', &
'', &
'  o  FIRST : shall be an allocatable array of type integer and rank one.  It', &
'     is an INTENT(OUT) argument. It shall not be a coarray or a coindexed', &
'     object.', &
'', &
'     It is allocated with the lower bound equal to one and the upper bound', &
'     equal to the number of tokens in STRING. Each element is assigned, in', &
'     array element order, the starting position of each token in STRING, in', &
'     the order found.', &
'', &
'     If a token has zero length, the starting position is equal to one if the', &
'     token is at the beginning of STRING, and one greater than the position of', &
'     the preceding delimiter otherwise.', &
'', &
'  o  LAST : It is allocated with the lower bound equal to one and the upper', &
'     bound equal to the number of tokens in STRING. Each element is assigned,', &
'     in array element order, the ending position of each token in STRING, in', &
'     the order found.', &
'', &
'     If a token has zero length, the ending position is one less than the', &
'     starting position.', &
'', &
'EXAMPLES', &
'  Sample of uses', &
'', &
'         program demo_tokenize', &
'         !use M_strings, only : tokenize=>split2020', &
'         implicit none', &
'         ! some useful formats', &
'         character(len=*),parameter :: brackets=''(*("[",g0,"]":,","))''', &
'         character(len=*),parameter :: a_commas=''(a,*(g0:,","))''', &
'         character(len=*),parameter :: space=''(*(g0:,1x))''', &
'         character(len=*),parameter :: gen=''(*(g0))''', &
'', &
'         ! Execution of TOKEN form (return array of tokens)', &
'', &
'         block', &
'            character (len=:), allocatable :: string', &
'            character (len=:), allocatable :: tokens(:)', &
'            character (len=:), allocatable :: kludge(:)', &
'            integer                        :: i', &
'            string = ''  first,second ,third      ''', &
'            call tokenize(string, set='';,'', tokens=tokens )', &
'            write(*,brackets)tokens', &
'', &
'            string = ''  first , second ,third      ''', &
'            call tokenize(string, set='' ,'', tokens=tokens )', &
'            write(*,brackets)(trim(tokens(i)),i=1,size(tokens))', &
'            ! remove blank tokens', &
'            ! <<<', &
'            !tokens=pack(tokens, tokens /= '''' )', &
'            ! gfortran 13.1.0 bug -- concatenate //'''' and use scratch', &
'            ! variable KLUDGE. JSU: 2024-08-18', &
'            kludge=pack(tokens//'''', tokens /= '''' )', &
'            ! >>>', &
'            write(*,brackets)kludge', &
'', &
'         endblock', &
'', &
'         ! Execution of BOUNDS form (return position of tokens)', &
'', &
'         block', &
'            character (len=:), allocatable :: string', &
'            character (len=*),parameter :: set = " ,"', &
'            integer, allocatable        :: first(:), last(:)', &
'            write(*,gen)repeat(''1234567890'',6)', &
'            string = ''first,second,,fourth''', &
'            write(*,gen)string', &
'            call tokenize (string, set, first, last)', &
'            write(*,a_commas)''FIRST='',first', &
'            write(*,a_commas)''LAST='',last', &
'            write(*,a_commas)''HAS LENGTH='',last-first.gt.0', &
'         endblock', &
'', &
'         end program demo_tokenize', &
'', &
'  Results:', &
'', &
'       > [  first     ],[second      ],[third      ]', &
'       > [],[first],[],[],[second],[],[third],[],[],[],[],[]', &
'       > [first ],[second],[third ]', &
'       > 123456789012345678901234567890123456789012345678901234567890', &
'       > first,second,,fourth', &
'       > FIRST=1,7,14,15', &
'       > LAST=5,12,13,20', &
'       > HAS LENGTH=T,T,F,T', &
'', &
'STANDARD', &
'  Fortran 2023', &
'', &
'SEE ALSO', &
'  o  SPLIT(3) - return tokens from a string, one at a time', &
'', &
'  o  INDEX(3) - Position of a substring within a string', &
'', &
'  o  SCAN(3) - Scan a string for the presence of a set of characters', &
'', &
'  o  VERIFY(3) - Position of a character in a string of characters that does', &
'     not appear in a given set of characters.', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025              tokenize(3fortran)', &
'']

shortname="tokenize"
call process()

case('235','trailz')

textblock=[character(len=256) :: &
'', &
'trailz(3fortran)                                             trailz(3fortran)', &
'', &
'NAME', &
'  TRAILZ(3) - [BIT:COUNT] Number of trailing zero bits of an integer', &
'', &
'SYNOPSIS', &
'  result = trailz(i)', &
'', &
'       elemental integer function trailz(i)', &
'', &
'        integer(kind=**),intent(in) :: i', &
'', &
'CHARACTERISTICS', &
'  o  I is an integer of any kind.', &
'', &
'  o  the result is an integer of default kind', &
'', &
'DESCRIPTION', &
'  TRAILZ(3) returns the number of trailing zero bits of an integer value.', &
'', &
'OPTIONS', &
'  o  I : the value to count trailing zero bits in', &
'', &
'RESULT', &
'  The number of trailing rightmost zero bits in an integer value after the', &
'  last non-zero bit.', &
'', &
'            >      right-most non-zero bit', &
'            >                 V', &
'            >  |0|0|0|1|1|1|0|1|0|0|0|0|0|0|', &
'            >  ^               |___________| trailing zero bits', &
'            >   bit_size(i)', &
'', &
'  If all the bits of I are zero, the result is the size of the input value in', &
'  bits, ie. BIT_SIZE(I).', &
'', &
'  The result may also be seen as the position of the rightmost 1 bit in I,', &
'  starting with the rightmost bit being zero and counting to the left.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_trailz', &
'', &
'      ! some common integer kinds', &
'      use, intrinsic :: iso_fortran_env, only : &', &
'       & integer_kinds, int8, int16, int32, int64', &
'', &
'      implicit none', &
'', &
'      ! a handy format', &
'      character(len=*),parameter :: &', &
'       & show = ''(1x,"value=",i4,", value(bits)=",b32.32,1x,", trailz=",i3)''', &
'', &
'      integer(kind=int64) :: bigi', &
'       ! basics', &
'        write(*,*)''Note default integer is'',bit_size(0),''bits''', &
'        print  show,  -1, -1,  trailz(-1)', &
'        print  show,   0,  0,  trailz(0)', &
'        print  show,   1,  1,  trailz(1)', &
'        print  show,  96, 96,  trailz(96)', &
'       ! elemental', &
'        print *, ''elemental and any integer kind:''', &
'        bigi=2**5', &
'        write(*,*) trailz( [ bigi, bigi*256, bigi/2 ] )', &
'        write(*,''(1x,b64.64)'')[ bigi, bigi*256, bigi/2 ]', &
'', &
'      end program demo_trailz', &
'', &
'  Results:', &
'', &
'       >  Note default integer is         32 bits', &
'       >  value=  -1, value(bits)=11111111111111111111111111111111 , trailz=  0', &
'       >  value=   0, value(bits)=00000000000000000000000000000000 , trailz= 32', &
'       >  value=   1, value(bits)=00000000000000000000000000000001 , trailz=  0', &
'       >  value=  96, value(bits)=00000000000000000000000001100000 , trailz=  5', &
'       >  elemental and any integer kind:', &
'       >           5          13           4', &
'       >  0000000000000000000000000000000000000000000000000000000000100000', &
'       >  0000000000000000000000000000000000000000000000000010000000000000', &
'       >  0000000000000000000000000000000000000000000000000000000000010000', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  BIT_SIZE(3), POPCNT(3), POPPAR(3), LEADZ(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                trailz(3fortran)', &
'']

shortname="trailz"
call process()

case('236','transfer')

textblock=[character(len=256) :: &
'', &
'transfer(3fortran)                                         transfer(3fortran)', &
'', &
'NAME', &
'  TRANSFER(3) - [TYPE:CONVERSION] Transfer data as bit patterns using mold', &
'', &
'SYNOPSIS', &
'  result = transfer(source, mold [,size] )', &
'', &
'          type(TYPE(kind=KIND)) function transfer(source,mold,size)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: source(..)', &
'           type(TYPE(kind=KIND)),intent(in) :: mold(..)', &
'           integer(kind=**),intent(in),optional :: size', &
'', &
'CHARACTERISTICS', &
'  o  SOURCE shall be a scalar or an array of any type.', &
'', &
'  o  MOLD shall be a scalar or an array of any type.', &
'', &
'  o  SIZE shall be a scalar of type integer.', &
'', &
'  o  RESULT has the same type as MOLD', &
'', &
'DESCRIPTION', &
'  TRANSFER(3) copies the bitwise representation of SOURCE in memory into a', &
'  variable or array of the same type and type parameters as MOLD.', &
'', &
'  This is approximately equivalent to the C concept of "casting" one type to', &
'  another.', &
'', &
'OPTIONS', &
'  o  SOURCE : Holds the bit pattern to be copied', &
'', &
'  o  MOLD : the type of MOLD is used to define the type of the returned value.', &
'     In addition, if it is an array the returned value is a one-dimensional', &
'     array. If it is a scalar the returned value is a scalar.', &
'', &
'  o  SIZE : If SIZE is present, the result is a one-dimensional array of', &
'     length SIZE.', &
'', &
'  If SIZE is absent but MOLD is an array (of any size or shape), the result is', &
'  a one-dimensional array of the minimum length needed to contain the entirety', &
'  of the bitwise representation of SOURCE.', &
'', &
'  If SIZE is absent and MOLD is a scalar, the result is a scalar.', &
'', &
'RESULT', &
'  The result has the bit level representation of SOURCE.', &
'', &
'  If the bitwise representation of the result is longer than that of SOURCE,', &
'  then the leading bits of the result correspond to those of SOURCE but any', &
'  trailing bits are filled arbitrarily.', &
'', &
'  When the resulting bit representation does not correspond to a valid', &
'  representation of a variable of the same type as MOLD, the results are', &
'  undefined, and subsequent operations on the result cannot be guaranteed to', &
'  produce sensible behavior. For example, it is possible to create logical', &
'  variables for which VAR and .NOT.VAR both appear to be true.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_transfer', &
'      use,intrinsic :: iso_fortran_env, only : int32, real32', &
'      integer(kind=int32) :: i = 2143289344', &
'      real(kind=real32)   :: x', &
'      character(len=10)   :: string', &
'      character(len=1)   :: chars(10)', &
'        x=transfer(i, 1.0)    ! prints "nan" on i686', &
'        ! the bit patterns are the same', &
'        write(*,''(b0,1x,g0)'')x,x ! create a NaN', &
'        write(*,''(b0,1x,g0)'')i,i', &
'', &
'        ! a string to an array of characters', &
'        string=''abcdefghij''', &
'        chars=transfer(string,chars)', &
'        write(*,''(*("[",a,"]":,1x))'')string', &
'        write(*,''(*("[",a,"]":,1x))'')chars', &
'      end program demo_transfer', &
'', &
'  Results:', &
'', &
'       > 1111111110000000000000000000000 NaN', &
'       > 1111111110000000000000000000000 2143289344', &
'       > [abcdefghij]', &
'       > [a] [b] [c] [d] [e] [f] [g] [h] [i] [j]', &
'', &
'COMMENTS', &
'  Joe Krahn: Fortran uses MOLDING rather than CASTING.', &
'', &
'  Casting, as in C, is an in-place reinterpretation. A cast is a device that', &
'  is built around an object to change its shape.', &
'', &
'  Fortran TRANSFER(3) reinterprets data out-of-place. It can be considered', &
'  MOLDING rather than casting. A MOLD is a device that confers a shape onto an', &
'  object placed into it.', &
'', &
'  The advantage of molding is that data is always valid in the context of the', &
'  variable that holds it. For many cases, a decent compiler should optimize', &
'  TRANSFER(3) into a simple assignment.', &
'', &
'  There are disadvantages of this approach. It is problematic to define a', &
'  union of data types because you must know the largest data object, which can', &
'  vary by compiler or compile options. In many cases, an EQUIVALENCE would be', &
'  far more effective, but Fortran Standards committees seem oblivious to the', &
'  benefits of EQUIVALENCE when used sparingly.', &
'', &
'STANDARD', &
'  Fortran 90', &
'', &
'SEE ALSO', &
'  -equivalence(7) - alias storage', &
'', &
'  Fortran intrinsic descriptions', &
'', &
'                               March 16, 2025              transfer(3fortran)', &
'']

shortname="transfer"
call process()

case('237','transpose')

textblock=[character(len=256) :: &
'', &
'transpose(3fortran)                                       transpose(3fortran)', &
'', &
'NAME', &
'  TRANSPOSE(3) - [ARRAY:MANIPULATION] Transpose an array of rank two', &
'', &
'SYNOPSIS', &
'  result = transpose(matrix)', &
'', &
'          function transpose(matrix)', &
'', &
'           type(TYPE(kind=KIND))            :: transpose(N,M)', &
'           type(TYPE(kind=KIND)),intent(in) :: matrix(M,N)', &
'', &
'CHARACTERISTICS', &
'  o  MATRIX is an array of any type with a rank of two.', &
'', &
'  o  The result will be the same type and kind as MATRIX and the reversed', &
'     shape of the input array', &
'', &
'DESCRIPTION', &
'  TRANSPOSE(3) transposes an array of rank two.', &
'', &
'  An array is transposed by interchanging the rows and columns of the given', &
'  matrix. That is, element (i,j) of the result has the value of element (j,i)', &
'  of the input for all (i,j).', &
'', &
'OPTIONS', &
'  o  MATRIX : The array to transpose', &
'', &
'RESULT', &
'  The transpose of the input array. The result has the same type as MATRIX,', &
'  and has shape [ m, n ] if MATRIX has shape [ n, m ].', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_transpose', &
'      implicit none', &
'      integer,allocatable :: array(:,:)', &
'      integer,parameter   :: values(3,5)= reshape([&', &
'         1,  2,  3,  4,  5,    &', &
'        10, 20, 30, 40, 50,    &', &
'        11, 22, 33, 44, -1055  &', &
'       ],shape(values),order=[2,1])', &
'', &
'        array=values', &
'        call print_matrix_int(''array:'',array)', &
'        array=transpose(array)', &
'        call print_matrix_int(''array transposed:'',array)', &
'        array=transpose(array)', &
'        call print_matrix_int(''transposed transpose:'',array)', &
'', &
'      contains', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      ! print small 2d integer arrays in row-column format', &
'      implicit none', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'        ! print title', &
'        write(*,''(a," shape(",i0,",",i0,")")'')trim(title),shape(arr)', &
'        biggest=''          '' ! make buffer to write integer into', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''("   [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_transpose', &
'', &
'  Results:', &
'', &
'       > array: shape(3,5)', &
'       >    [    1,     2,     3,     4,     5 ]', &
'       >    [   10,    20,    30,    40,    50 ]', &
'       >    [   11,    22,    33,    44, -1055 ]', &
'       > array transposed: shape(5,3)', &
'       >    [    1,    10,    11 ]', &
'       >    [    2,    20,    22 ]', &
'       >    [    3,    30,    33 ]', &
'       >    [    4,    40,    44 ]', &
'       >    [    5,    50, -1055 ]', &
'       > transposed transpose: shape(3,5)', &
'       >    [    1,     2,     3,     4,     5 ]', &
'       >    [   10,    20,    30,    40,    50 ]', &
'       >    [   11,    22,    33,    44, -1055 ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  o  MERGE(3) - Merge variables', &
'', &
'  o  PACK(3) - Pack an array into an array of rank one', &
'', &
'  o  SPREAD(3) - Add a dimension and replicate data', &
'', &
'  o  UNPACK(3) - Scatter the elements of a vector', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025             transpose(3fortran)', &
'']

shortname="transpose"
call process()

case('238','trim')

textblock=[character(len=256) :: &
'', &
'trim(3fortran)                                                 trim(3fortran)', &
'', &
'NAME', &
'  TRIM(3) - [CHARACTER:WHITESPACE] Remove trailing blank characters from a', &
'  string', &
'', &
'SYNOPSIS', &
'  result = trim(string)', &
'', &
'          character(len=:,kind=KIND) function trim(string)', &
'', &
'           character(len=*,kind=KIND),intent(in) :: string', &
'', &
'CHARACTERISTICS', &
'  o  KIND can be any kind supported for the character type.', &
'', &
'  o  The result has the same type and kind as the input argument STRING.', &
'', &
'DESCRIPTION', &
'  TRIM(3) removes trailing blank characters from a string.', &
'', &
'OPTIONS', &
'  o  STRING : A string to trim', &
'', &
'RESULT', &
'  The result is the same as STRING except trailing blanks are removed.', &
'', &
'  If STRING is composed entirely of blanks or has zero length, the result has', &
'  zero length.', &
'', &
'EXAMPLES', &
'  Sample program:', &
'', &
'      program demo_trim', &
'      implicit none', &
'      character(len=:), allocatable :: str, strs(:)', &
'      character(len=*),parameter :: brackets=''( *("[",a,"]":,1x) )''', &
'      integer :: i', &
'', &
'        str=''  trailing    ''', &
'        print brackets, str,trim(str) ! trims it', &
'', &
'        str=''  leading''', &
'        print brackets, str,trim(str) ! no effect', &
'', &
'        str=''           ''', &
'        print brackets, str,trim(str) ! becomes zero length', &
'        print *,  len(str), len(trim(''              ''))', &
'', &
'       ! array elements are all the same length, so you often', &
'       ! want to print them', &
'        strs=[character(len=10) :: "Z"," a b c","ABC",""]', &
'', &
'        write(*,*)''untrimmed:''', &
'        ! everything prints as ten characters; nice for neat columns', &
'        print brackets, (strs(i), i=1,size(strs))', &
'        print brackets, (strs(i), i=size(strs),1,-1)', &
'        write(*,*)''trimmed:''', &
'        ! everything prints trimmed', &
'        print brackets, (trim(strs(i)), i=1,size(strs))', &
'        print brackets, (trim(strs(i)), i=size(strs),1,-1)', &
'', &
'      end program demo_trim', &
'', &
'  Results:', &
'', &
'         > [   trailing    ] [   trailing]', &
'         > [   leading] [   leading]', &
'         > [            ] []', &
'         >           12           0', &
'         >  untrimmed:', &
'         > [Z         ] [ a b c    ] [ABC       ] [          ]', &
'         > [          ] [ABC       ] [ a b c    ] [Z         ]', &
'         >  trimmed:', &
'         > [Z] [ a b c] [ABC] []', &
'         > [] [ABC] [ a b c] [Z]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3)', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                  trim(3fortran)', &
'']

shortname="trim"
call process()

case('239','ubound')

textblock=[character(len=256) :: &
'', &
'ubound(3fortran)                                             ubound(3fortran)', &
'', &
'NAME', &
'  UBOUND(3) - [ARRAY:INQUIRY] Upper dimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = ubound(array [,dim] [,kind] )', &
'', &
'          elemental TYPE(kind=KIND) function ubound(array,dim,kind)', &
'', &
'           TYPE(kind=KIND),intent(in)           :: array', &
'           integer(kind=**),intent(in),optional :: dim', &
'           integer(kind=**),intent(in),optional :: kind', &
'', &
'CHARACTERISTICS', &
'  o  ARRAY shall be assumed-rank or an array, of any type. It cannot be an', &
'     unallocated allocatable array or a pointer that is not associated.', &
'', &
'  o  DIM shall be a scalar integer. The corresponding actual argument shall', &
'     not be an optional dummy argument, a disassociated pointer, or an', &
'     unallocated allocatable.', &
'', &
'  o  KIND an integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'  o  The return value is of type integer and of kind KIND. If KIND is absent,', &
'     the return value is of default integer kind. The result is scalar if DIM', &
'     is present; otherwise, the result is an array of rank one and size n,', &
'     where n is the rank of ARRAY.', &
'', &
'  o  a kind designated as ** may be any supported kind for the type', &
'', &
'DESCRIPTION', &
'  UBOUND(3) returns the upper bounds of an array, or a single upper bound', &
'  along the DIM dimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : The assumed-rank or array of any type whose upper bounds are to', &
'     be determined. If allocatable it must be allocated; if a pointer it must', &
'     be associated. If an assumed-size array, DIM must be present.', &
'', &
'  o  DIM : a specific dimension of ARRAY to determine the bounds of. If DIM is', &
'     absent, the result is an array of the upper bounds of ARRAY.  DIM is', &
'     required if ARRAY is an assumed-size array, and in that case must be less', &
'     than or equal to the rank of ARRAY.', &
'', &
'  o  KIND : indicates the kind parameter of the result. If absent, an integer', &
'     of the default kind is returned.', &
'', &
'RESULT', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind.', &
'', &
'  If DIM is absent, the result is an array of the upper bounds of each', &
'  dimension of the ARRAY.', &
'', &
'  If DIM is present, the result is a scalar corresponding to the upper bound', &
'  of the array along that dimension.', &
'', &
'  If ARRAY is an expression rather than a whole array or array structure', &
'  component, or if it has a zero extent along the relevant dimension, the', &
'  upper bound is taken to be the number of elements along the relevant', &
'  dimension.', &
'', &
'  NOTE1 If ARRAY is assumed-rank and has rank zero, DIM cannot be present', &
'  since it cannot satisfy the requirement 1 <= DIM <= 0.', &
'', &
'EXAMPLES', &
'  Note this function should not be used on assumed-size arrays or in any', &
'  function without an explicit interface. Errors can occur if there is no', &
'  interface defined.', &
'', &
'  Sample program', &
'', &
'      ! program demo_ubound', &
'      module m2_bounds', &
'      implicit none', &
'', &
'      contains', &
'', &
'      subroutine msub(arr)', &
'      !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array', &
'      integer,intent(in) :: arr(:)', &
'        write(*,*)''MSUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'        & ''SIZE='',size(arr)', &
'      end subroutine msub', &
'', &
'      end module m2_bounds', &
'      !', &
'      program demo_ubound', &
'      use m2_bounds, only : msub', &
'      implicit none', &
'      interface', &
'        subroutine esub(arr)', &
'        integer,intent(in) :: arr(:)', &
'        end subroutine esub', &
'      end interface', &
'      integer :: arr(-10:10)', &
'        write(*,*)''MAIN: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'        & ''SIZE='',size(arr)', &
'        call csub()', &
'        call msub(arr)', &
'        call esub(arr)', &
'      contains', &
'      subroutine csub', &
'        write(*,*)''CSUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'        & ''SIZE='',size(arr)', &
'      end subroutine csub', &
'', &
'      end', &
'', &
'      subroutine esub(arr)', &
'      implicit none', &
'      integer,intent(in) :: arr(:)', &
'        ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE', &
'        ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)', &
'        write(*,*)''ESUB: LOWER='',lbound(arr),''UPPER='',ubound(arr), &', &
'        & ''SIZE='',size(arr)', &
'      end subroutine esub', &
'      !end program demo_ubound', &
'', &
'  Results:', &
'', &
'       >  MAIN: LOWER=        -10 UPPER=          10 SIZE=          21', &
'       >  CSUB: LOWER=        -10 UPPER=          10 SIZE=          21', &
'       >  MSUB: LOWER=          1 UPPER=          21 SIZE=          21', &
'       >  ESUB: LOWER=          1 UPPER=          21 SIZE=          21', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument Fortran 2003', &
'', &
'SEE ALSO', &
'  Array inquiry:', &
'', &
'  o  SIZE(3) - Determine the size of an array', &
'', &
'  o  RANK(3) - Rank of a data object', &
'', &
'  o  SHAPE(3) - Determine the shape of an array', &
'', &
'  o  LBOUND(3) - Lower dimension bounds of an array', &
'', &
'  CO_UBOUND(3), CO_LBOUND(3)', &
'', &
'  State Inquiry:', &
'', &
'  o  ALLOCATED(3) - Status of an allocatable entity', &
'', &
'  o  IS_CONTIGUOUS(3) - Test if object is contiguous', &
'', &
'  Kind Inquiry:', &
'', &
'  o  KIND(3) - Kind of an entity', &
'', &
'  Bit Inquiry:', &
'', &
'  o  STORAGE_SIZE(3) - Storage size in bits', &
'', &
'  o  BIT_SIZE(3) - Bit size inquiry function', &
'', &
'  o  BTEST(3) - Tests a bit of an integer value.', &
'', &
'  o  LBOUND(3),', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                ubound(3fortran)', &
'']

shortname="ubound"
call process()

case('240','ucobound')

textblock=[character(len=256) :: &
'', &
'ucobound(3fortran)                                         ucobound(3fortran)', &
'', &
'NAME', &
'  UCOBOUND(3) - [COLLECTIVE] Upper codimension bounds of an array', &
'', &
'SYNOPSIS', &
'  result = ucobound(coarray [,dim] [,kind] )', &
'', &
'CHARACTERISTICS', &
'DESCRIPTION', &
'  UCOBOUND(3) returns the upper cobounds of a coarray, or a single upper', &
'  cobound along the DIM codimension.', &
'', &
'OPTIONS', &
'  o  ARRAY : Shall be an coarray, of any type.', &
'', &
'  o  DIM : (Optional) Shall be a scalar integer.', &
'', &
'  o  KIND : (Optional) An integer initialization expression indicating the', &
'     kind parameter of the result.', &
'', &
'RESULT', &
'  The return value is of type integer and of kind KIND. If KIND is absent, the', &
'  return value is of default integer kind. If DIM is absent, the result is an', &
'  array of the lower cobounds of COARRAY. If DIM is present, the result is a', &
'  scalar corresponding to the lower cobound of the array along that', &
'  codimension.', &
'', &
'STANDARD', &
'  Fortran 2008', &
'', &
'SEE ALSO', &
'  LCOBOUND(3), LBOUND(3), UBOUND(3)', &
'', &
'                               March 16, 2025              ucobound(3fortran)', &
'']

shortname="ucobound"
call process()

case('241','unpack')

textblock=[character(len=256) :: &
'', &
'unpack(3fortran)                                             unpack(3fortran)', &
'', &
'NAME', &
'  UNPACK(3) - [ARRAY:CONSTRUCTION] Scatter the elements of a vector into an', &
'  array using a mask', &
'', &
'SYNOPSIS', &
'  result = unpack(vector, mask, field)', &
'', &
'          type(TYPE(kind=KIND)) unpack(vector, mask, field)', &
'', &
'           type(TYPE(kind=KIND)),intent(in) :: vector(:)', &
'           logical,intent(in)               :: mask(..)', &
'           type(TYPE(kind=KIND)),intent(in) :: field(..)', &
'', &
'CHARACTERISTICS', &
'  o  VECTOR is a rank-one array of any type', &
'', &
'  o  MASK is a logical array', &
'', &
'  o  FIELD is the same type and type parameters as VECTOR conformable with', &
'     MASK.', &
'', &
'  o  The result is an array of the same type and type parameters as VECTOR and', &
'     the same shape as MASK.', &
'', &
'DESCRIPTION', &
'  UNPACK(3) scatters the elements of VECTOR into a copy of an array FIELD of', &
'  any rank using .true. values from MASK in array element order to specify', &
'  placement of the VECTOR values.', &
'', &
'  So a copy of FIELD is generated with select elements replaced with values', &
'  from VECTOR. This allows for complex replacement patterns that would be', &
'  difficult when using array syntax or multiple assignment statements,', &
'  particularly when the replacements are conditional.', &
'', &
'OPTIONS', &
'  o  VECTOR : New values to place into specified locations in FIELD. It shall', &
'     have at least as many elements as MASK has .true. values.', &
'', &
'  o  MASK : Shall be an array that specifies which values in FIELD are to be', &
'     replaced with values from VECTOR.', &
'', &
'  o  FIELD : The input array to be altered.', &
'', &
'RESULT', &
'  The element of the result that corresponds to the ith true element of MASK,', &
'  in array element order, has the value VECTOR(I) for i = 1, 2, . .  ., t,', &
'  where t is the number of true values in MASK. Each other element has a value', &
'  equal to FIELD if FIELD is scalar or to the corresponding element of FIELD', &
'  if it is an array.', &
'', &
'  The resulting array corresponds to FIELD with .true. elements of MASK', &
'  replaced by values from VECTOR in array element order.', &
'', &
'EXAMPLES', &
'  Particular values may be "scattered" to particular positions in an array by', &
'  using', &
'', &
'    1 0 0', &
'', &
'  If M is the array', &
'    0 1 0 0 0 1', &
'', &
'    V is the array [1, 2, 3], . T .', &
'', &
'    and Q is the logical mask', &
'      T . .  . . T where "T" represents true and "." represents false, then', &
'      the result of', &
'', &
'    UNPACK (V, MASK = Q, FIELD = M) has the value', &
'', &
'      1 2 0 1 1 0 0 0 3', &
'', &
'    and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value', &
'', &
'      0 2 0 1 0 0 0 0 3', &
'', &
'  Sample program:', &
'', &
'      program demo_unpack', &
'      implicit none', &
'      logical,parameter :: T=.true., F=.false.', &
'', &
'      integer :: vector(2)  = [1,1]', &
'', &
'      ! mask and field must conform', &
'      integer,parameter :: r=2, c=2', &
'      logical :: mask(r,c)  = reshape([ T,F,F,T ],[2,2])', &
'      integer :: field(r,c) = 0, unity(2,2)', &
'', &
'        ! basic usage', &
'        unity = unpack( vector, mask, field )', &
'        call print_matrix_int(''unity='', unity)', &
'', &
'        ! if FIELD is a scalar it is used to fill all the elements', &
'        ! not assigned to by the vector and mask.', &
'        call print_matrix_int(''scalar field'',               &', &
'        & unpack(                                     &', &
'        & vector=[ 1, 2, 3, 4 ],                      &', &
'        & mask=reshape([ T,F,T,F,F,F,T,F,T ], [3,3]), &', &
'        & field=0) )', &
'', &
'      contains', &
'', &
'      subroutine print_matrix_int(title,arr)', &
'      ! convenience routine:', &
'      ! just prints small integer arrays in row-column format', &
'      implicit none', &
'      character(len=*),intent(in)  :: title', &
'      integer,intent(in)          :: arr(:,:)', &
'      integer                     :: i', &
'      character(len=:),allocatable :: biggest', &
'', &
'        write(*,*)trim(title)', &
'        ! make buffer to write integer into', &
'        biggest=''          ''', &
'        ! find how many characters to use for integers', &
'        write(biggest,''(i0)'')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2', &
'        ! use this format to write a row', &
'        biggest=''("  [",*(i''//trim(biggest)//'':,","))''', &
'        ! print one row of array at a time', &
'        do i=1,size(arr,dim=1)', &
'           write(*,fmt=biggest,advance=''no'')arr(i,:)', &
'           write(*,''(" ]")'')', &
'        enddo', &
'      end subroutine print_matrix_int', &
'', &
'      end program demo_unpack', &
'', &
'  Results:', &
'', &
'        > unity=', &
'        >  [ 1, 0 ]', &
'        >  [ 0, 1 ]', &
'        > scalar field', &
'        >  [  1,  0,  3 ]', &
'        >  [  0,  0,  0 ]', &
'        >  [  2,  0,  4 ]', &
'', &
'STANDARD', &
'  Fortran 95', &
'', &
'SEE ALSO', &
'  MERGE(3), PACK(3), SPREAD(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                unpack(3fortran)', &
'']

shortname="unpack"
call process()

case('242','use')

textblock=[character(len=256) :: &
'', &
'use(7fortran)                                                   use(7fortran)', &
'', &
'NAME', &
'  use(7f) - [FORTRAN] gives a program unit access to public entities in a', &
'  module.', &
'', &
'SYNOPSIS', &
'  There are two forms. One loads all public entities optionally renaming', &
'  selected entities:', &
'', &
'         USE [, nature ::] module_name [, rename-list]', &
'', &
'  The other makes accessible only explicitly named entities', &
'', &
'         USE [, nature ::] module_name, ONLY: only-list', &
'', &
'DESCRIPTION', &
'  The USE statement makes the entities in the specified module accessible to', &
'  the current scoping unit. It also provides a means of renaming those', &
'  entities with a rename-list and/or only importing a subset of the public', &
'  entities from the module with an only-list.', &
'', &
'  The entities accessed from the module may be named data objects,', &
'  nonintrinsic types, procedures, abstract interfaces, generic identifiers,', &
'  and namelist groups', &
'', &
'  If more than one USE statement appears in a scoping unit, the rename-lists', &
'  are treated as one rename-list and the only-lists are treated as one', &
'  concatenated only-list.', &
'', &
'  At the time a USE statement is processed, the public portions of the', &
'  specified module shall be available. That is, the module typically needs to', &
'  be compiled and found in the current search directories or previously in the', &
'  current source files.', &
'', &
'  A module shall not reference itself, either directly or indirectly.', &
'', &
'  A USE statement without ONLY provides access to all PUBLIC entities in the', &
'  specified namespace. This is true even if renamed entities are specified,', &
'  but the renamed entities will only be available with the specified local', &
'  name unless also explicitity requested with the original name. This is', &
'  particularly useful behavior when there would otherwise be name conflicts.', &
'', &
'  A USE statement with ONLY provides access only to those entities that appear', &
'  in the only-list. It does not otherwise affect what is public due to a', &
'  statement without ONLY.', &
'', &
'REMARKS', &
'  A use-associated variable is considered to have been previously declared;', &
'  any other use-associated entity is considered to have been previously', &
'  defined.', &
'', &
'  So accessed entities have their attributes (TYPE,KIND,...) specified via the', &
'  module, except that an accessed entity may have a different accessibility', &
'  attribute (eg. be declared PRIVATE or PUBLIC), it may be given the', &
'  ASYNCHRONOUS attribute even if the associated module entity does not, and if', &
'  it is not a coarray it may have the VOLATILE attribute specified even if the', &
'  associated entity from the module does not.', &
'', &
'  If two or more generic interfaces that are accessible in the same scoping', &
'  unit have the same name, same operator, or are assignments, they are', &
'  interpreted as a single generic interface (that is, if there are no', &
'  conflicts they are merged).', &
'', &
'  Two or more accessible entities, other than generic interfaces, can have the', &
'  same name only if no entity is referenced by this name in the scoping unit.', &
'  That is, there can be no other conflicts unless the entities are not used.', &
'', &
'  If local-name is absent, the use-name is available by use association.', &
'', &
'  An entity can be accessed by more than one local-name.', &
'', &
'  A local-name must not be declared with different attributes in the scoping', &
'  unit that contains the USE statement, except that it can appear in a PUBLIC', &
'  or PRIVATE statement in the scoping unit of a module.', &
'', &
'  Forward references to modules are not allowed. That is, if a module is used', &
'  in the same source file in which it resides, the module program unit must', &
'  appear before its use.', &
'', &
'  Definability of module entities can be controlled by the PROTECTED', &
'  attribute.', &
'', &
'  o  OPERATOR (use-defined-operator) shall not identify a type-bound generic', &
'     interface.', &
'', &
'  o  The generic-spec shall not identify a type-bound generic interface.', &
'', &
'  These Constraints do not prevent accessing a generic-spec that is declared', &
'  by an interface block, even if a type-bound generic interface has the same', &
'  generic-spec.', &
'', &
'  o  An only-use-name shall be a nongeneric name.', &
'', &
'  A USE statement with the ONLY option provides access only to those entities', &
'  that appear as generic-specs, use-names, or use-defined-operators in the', &
'  only-list.', &
'', &
'  There is no prohibition against a use-name or use-defined-operator appearing', &
'  multiple times in one USE state- ment or in multiple USE statements', &
'  involving the same module. As a result, it is possible for one use-', &
'  associated entity to be accessible by more than one local identifier.', &
'', &
'  An entity in a scoping unit that is accessed by use association through more', &
'  than one use path, has the ASYN- CHRONOUS or VOLATILE attribute in any of', &
'  those use paths, and is not given that attribute in that scoping unit, shall', &
'  have that attribute in all use paths.', &
'', &
'  the local-name is prohibited from appearing in a COMMON BLOCK or an', &
'  EQUIVALENCE statement or a namelist-group-name in a NAMELIST statement,', &
'  respectively. There is no prohibition against the local-name appearing as a', &
'  common-block-name or a namelist-group-object.', &
'', &
'OPTIONS', &
'  o  NATURE : Is INTRINSIC or NON_INTRINSIC. If INTRINSIC is used, namespace', &
'     must be the name of an intrinsic module. If NON_INTRINSIC is used,', &
'     namespace must be the name of an nonintrinsic module. If NATURE is not', &
'     specified, a module of name namespace must be accessible. If both an', &
'     intrinsic and non-intrinsic module of the same name exist and nature is', &
'     not specified, the non-intrinsic module is used.', &
'', &
'     It is an error to specify a user module and an intrinsic module of the', &
'     same name in the same program unit.', &
'', &
'  o  MODULE_NAME : is a publicly accessible namespace; ie. it is the name of a', &
'     module.', &
'', &
'  o  RENAME-LIST : is a comma-separated list of local-name => use-name.', &
'', &
'  o  ONLY-LIST : is a comma-separated list of access-ids or [local-name =>', &
'     use-name]', &
'', &
'     where', &
'', &
'              local-name     Is the local name for the entity in the', &
'                             program unit using the module or is', &
'                             "OPERATOR (op-name)", where op-name is', &
'                             the name of a defined operator in the', &
'                             program unit using the module.', &
'              use-name       is the name of a public entity in the', &
'                             specified namespace', &
'              access-id      is use-name or generic-spec', &
'              generic-spec   is generic-name', &
'                             or OPERATOR (defined-operator)', &
'                             or ASSIGNMENT (=)', &
'', &
'     GENERIC-NAME is the name of a generic procedure', &
'', &
'     DEFINED-OPERATOR is one of the intrinsic operators or .OP-NAME.', &
'', &
'     .OP-NAME. is a user-defined name for the operation', &
'', &
'EXAMPLES', &
'  Samples:', &
'', &
'        ! program demo_use and module examples', &
'        module example ! example is the namespace name', &
'        use,intrinsic :: iso_fortran_env , only : real64', &
'', &
'           type type1 ! type1 is the class prototype name', &
'           contains', &
'              procedure, nopass :: static_method1', &
'           end type type1', &
'', &
'           type type2 ! type1 is the class prototype name', &
'           contains', &
'              procedure, nopass :: static_method2', &
'           end type type2', &
'', &
'           real(kind=real64),parameter :: &', &
'           pi  = 3.1415926535897932_real64', &
'           ! Napier''s constant is the base of the natural logarithm', &
'           ! system. It is often denoted by "e" in honor of Euler.', &
'           real(kind=real64),parameter :: &', &
'           Napier_constant = 2.71828182845904523_real64', &
'', &
'        contains', &
'', &
'           subroutine static_method1(arg)', &
'              integer :: arg', &
'              ! code to implement method goes here', &
'           end subroutine static_method1', &
'', &
'           subroutine static_method2(arg)', &
'              integer :: arg', &
'              ! code to implement method goes here', &
'           end subroutine static_method2', &
'', &
'        end module example', &
'        program demo_use', &
'        use example, only: type1 ! class prototype type1 available,', &
'                                 ! but nothing else is made available by this', &
'                                 !', &
'        ! (additionally) within this scoping unit, type1 is referred to', &
'        ! as "mytype"', &
'        use example, mytype => type1', &
'        !', &
'        ! only: is recommended but for long lists importing everything', &
'        !       without listing it is supported:', &
'        use example ! all public objects in namespace example available', &
'        !', &
'        ! some popular intrinsic entities', &
'        !', &
'        use,intrinsic :: iso_fortran_env, only : &', &
'        stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT', &
'        ! specifying INTRINSIC or NON_INTRINSIC is typically optional but', &
'        ! indicating INTRINSIC when it is so is the norm.', &
'        use :: iso_fortran_env, only : integer_kinds,int8,int16,int32,int64', &
'        use iso_fortran_env, only : real_kinds,real32,real64,real128', &
'        ! duplicates are OK', &
'        use,intrinsic :: iso_fortran_env, only : sp=>real32,dp=>real64', &
'        use,intrinsic :: iso_fortran_env, only : integer_kinds', &
'        use,intrinsic :: iso_fortran_env, only : compiler_version', &
'        use,intrinsic :: iso_fortran_env, only : compiler_options', &
'        use,intrinsic :: iso_fortran_env, only : iostat_eor, iostat_end', &
'        end program demo_use', &
'', &
'SUBTLE ISSUES WITH MULTIPLE STATEMENTS', &
'  As stated previously,', &
'', &
'        If more than one USE statement appears in a scoping unit, the', &
'        rename-lists and only-lists are treated as one concatenated', &
'        rename-list.', &
'', &
'  That is, all the non-only statements are treated as one statement So this', &
'', &
'        use,intrinsic :: iso_fortran_env ! by itself would import all entities', &
'        use,intrinsic :: iso_fortran_env, sp=>real32, dp=>real64', &
'', &
'  is treated like this', &
'', &
'        use,intrinsic :: iso_fortran_env, sp=>real32, dp=>real64', &
'', &
'  so the names REAL32 and REAL64 are not available. If you wanted both names', &
'  you would have to add', &
'', &
'        use,intrinsic :: iso use,intrinsic , real32=>real32, real64=>real64', &
'', &
'  or', &
'', &
'        use,intrinsic :: iso use,intrinsic , only: real32, real64', &
'', &
'SEE ALSO', &
'  PRIVATE(3), PUBLIC(3), MODULE(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                   use(7fortran)', &
'']

shortname="use"
call process()

case('243','verify')

textblock=[character(len=256) :: &
'', &
'verify(3fortran)                                             verify(3fortran)', &
'', &
'NAME', &
'  VERIFY(3) - [CHARACTER:SEARCH] Position of a character in a string of', &
'  characters that does not appear in a given set of characters', &
'', &
'SYNOPSIS', &
'  result = verify(string, set [,back] [,kind] )', &
'', &
'          elemental integer(kind=KIND) function verify(string,set,back,KIND)', &
'', &
'           character(len=*,kind=**),intent(in) :: string', &
'           character(len=*,kind=**),intent(in) :: set', &
'           logical,intent(in),optional :: back', &
'           integer,intent(in),optional :: KIND', &
'', &
'CHARACTERISTICS', &
'  o  STRING and SET must be of type character and have the same kind for any', &
'     individual call, but that can be any supported character kind.', &
'', &
'  o  KIND must be a constant integer initialization expression and a valid', &
'     kind for the integer type.', &
'', &
'  o  BACK shall be of type logical.', &
'', &
'  o  the kind of the returned value is the same as KIND if present.  Otherwise', &
'     a default integer kind is returned.', &
'', &
'DESCRIPTION', &
'  VERIFY(3) verifies that all the characters in STRING belong to the set of', &
'  characters in SET by identifying the position of the first character in the', &
'  string that is not in the set.', &
'', &
'  This makes it easy to verify strings are all uppercase or lowercase, follow', &
'  a basic syntax, only contain printable characters, and many of the', &
'  conditions tested for with the C routines ISALNUM(3c), ISALPHA(3c),', &
'  ISASCII(3c), ISBLANK(3c), ISCNTRL(3c), ISDIGIT(3c), ISGRAPH(3c),', &
'  ISLOWER(3c), ISPRINT(3c), ISPUNCT(3c), ISSPACE(3c), ISUPPER(3c), and', &
'  ISXDIGIT(3c); but for a string as well as an array of strings.', &
'', &
'OPTIONS', &
'  o  STRING : The string to search in for an unmatched character.', &
'', &
'  o  SET : The set of characters that must be matched.', &
'', &
'  o  BACK : The direction to look for an unmatched character. The left-most', &
'     unmatched character position is returned unless BACK is present and', &
'     .false., which causes the position of the right-most unmatched character', &
'     to be returned instead of the left-most unmatched character.', &
'', &
'  o  KIND : An integer initialization expression indicating the kind parameter', &
'     of the result.', &
'', &
'RESULT', &
'  If all characters of STRING are found in SET, the result is zero.', &
'', &
'  If STRING is of zero length a zero (0) is always returned.', &
'', &
'  Otherwise, if an unmatched character is found The position of the first or', &
'  last (if BACK is .false.) unmatched character in STRING is returned,', &
'  starting with position one on the left end of the string.', &
'', &
'EXAMPLES', &
'  Sample program I:', &
'', &
'      program demo_verify', &
'      implicit none', &
'      ! some useful character sets', &
'      character,parameter :: &', &
'       & int*(*)   = ''1234567890'', &', &
'       & low*(*)   = ''abcdefghijklmnopqrstuvwxyz'', &', &
'       & upp*(*)   = ''ABCDEFGHIJKLMNOPQRSTUVWXYZ'', &', &
'       & punc*(*)  = "!""#$%&''()*+,-./:;<=>?@[\]^_`{|}~", &', &
'       & blank*(*) = '' '', &', &
'       & tab      = char(11), &', &
'       & prnt*(*) = int//low//upp//blank//punc', &
'', &
'      character(len=:),allocatable :: string', &
'      integer :: i', &
'         print *, ''basics:''', &
'         print *, VERIFY (''ABBA'', ''A'')            ! has the value 2.', &
'         print *, VERIFY (''ABBA'', ''A'', BACK = .TRUE.) ! has the value 3.', &
'         print *, VERIFY (''ABBA'', ''AB'')           ! has the value 0.', &
'', &
'        print *,''find first non-uppercase letter''', &
'        ! will produce the location of "d", because there is no match in UPP', &
'        write(*,*) ''something unmatched'',verify("ABCdEFG", upp)', &
'', &
'        print *,''if everything is matched return zero''', &
'        ! will produce 0 as all letters have a match', &
'        write(*,*) ''everything matched'',verify("ffoorrttrraann", "nartrof")', &
'', &
'        print *,''easily categorize strings as uppercase, lowercase, ...''', &
'        ! easy C-like functionality but does entire strings not just characters', &
'        write(*,*)''isdigit 123?'',verify("123", int) == 0', &
'        write(*,*)''islower abc?'',verify("abc", low) == 0', &
'        write(*,*)''isalpha aBc?'',verify("aBc", low//upp) == 0', &
'        write(*,*)''isblank aBc dEf?'',verify("aBc dEf", blank//tab ) /= 0', &
'        ! check if all printable characters', &
'        string="aB;cde,fgHI!Jklmno PQRSTU vwxyz"', &
'        write(*,*)''isprint?'',verify(string,prnt) == 0', &
'        ! this now has a nonprintable tab character in it', &
'        string(10:10)=char(11)', &
'        write(*,*)''isprint?'',verify(string,prnt) == 0', &
'', &
'        print *,''VERIFY(3) is very powerful using expressions as masks''', &
'        ! verify(3) is often used in a logical expression', &
'        string=" This is NOT all UPPERCASE "', &
'        write(*,*)''all uppercase/spaces?'',verify(string, blank//upp) == 0', &
'        string=" This IS all uppercase "', &
'        write(*,*) ''string=[''//string//'']''', &
'        write(*,*)''all uppercase/spaces?'',verify(string, blank//upp) == 0', &
'', &
'       ! set and show complex string to be tested', &
'        string=''  Check this out. Let me know ''', &
'        ! show the string being examined', &
'        write(*,*) ''string=[''//string//'']''', &
'        write(*,*) ''       ''//repeat(int,4) ! number line', &
'', &
'        ! the Fortran functions returns a position just not a logical like C', &
'        print *, ''returning a position not just a logical is useful''', &
'        ! which can be very useful for parsing strings', &
'        write(*,*)''first non-blank character'',verify(string, blank)', &
'        write(*,*)''last non-blank character'',verify(string, blank,back=.true.)', &
'        write(*,*)''first non-letter non-blank'',verify(string,low//upp//blank)', &
'', &
'       !VERIFY(3) is elemental so you can check an array of strings in one call', &
'       print *, ''elemental''', &
'        ! are strings all letters (or blanks)?', &
'        write(*,*) ''array of strings'',verify( &', &
'        ! strings must all be same length, so force to length 10', &
'        & [character(len=10) :: "YES","ok","000","good one","Nope!"], &', &
'        & low//upp//blank) == 0', &
'', &
'        ! rarer, but the set can be an array, not just the strings to test', &
'        ! you could do ISPRINT() this (harder) way :>', &
'        write(*,*)''isprint?'',.not.all(verify("aBc", [(char(i),i=32,126)])==1)', &
'        ! instead of this way', &
'        write(*,*)''isprint?'',verify("aBc",prnt) == 0', &
'', &
'      end program demo_verify', &
'', &
'  Results:', &
'', &
'       >  basics:', &
'       >           2', &
'       >           3', &
'       >           0', &
'       >  find first non-uppercase letter', &
'       >  something unmatched          4', &
'       >  if everything is matched return zero', &
'       >  everything matched          0', &
'       >  easily categorize strings as uppercase, lowercase, ...', &
'       >  isdigit 123? T', &
'       >  islower abc? T', &
'       >  isalpha aBc? T', &
'       >  isblank aBc dEf? T', &
'       >  isprint? T', &
'       >  isprint? F', &
'       >  VERIFY(3) is very powerful using expressions as masks', &
'       >  all uppercase/spaces? F', &
'       >  string=[ This IS all uppercase ]', &
'       >  all uppercase/spaces? F', &
'       >  string=[  Check this out. Let me know  ]', &
'       >         1234567890123456789012345678901234567890', &
'       >  returning a position not just a logical is useful', &
'       >  first non-blank character          3', &
'       >  last non-blank character         29', &
'       >  first non-letter non-blank         17', &
'       >  elemental', &
'       >  array of strings T T F T F', &
'       >  isprint? T', &
'       >  isprint? T', &
'', &
'  Sample program II:', &
'', &
'  Determine if strings are valid integer representations', &
'', &
'      program fortran_ints', &
'      implicit none', &
'      integer :: i', &
'      character(len=*),parameter :: ints(*)=[character(len=10) :: &', &
'       ''+1 '', &', &
'       ''3044848 '', &', &
'       ''30.40 '', &', &
'       ''September '', &', &
'       ''1 2 3'', &', &
'       ''  -3000 '', &', &
'       '' '']', &
'        ! show the strings to test', &
'        write(*,''("|",*(g0,"|"))'') ints', &
'        ! show if strings pass or fail the test done by isint(3)', &
'        write(*,''("|",*(1x,l1,8x,"|"))'') isint(ints)', &
'', &
'      contains', &
'', &
'      elemental function isint(line) result (lout)', &
'      !', &
'      ! determine if string is a valid integer representation', &
'      ! ignoring trailing spaces and leading spaces', &
'      !', &
'      character(len=*),parameter   :: digits=''0123456789''', &
'      character(len=*),intent(in)  :: line', &
'      character(len=:),allocatable :: name', &
'      logical                     :: lout', &
'        lout=.false.', &
'        ! make sure at least two characters long to simplify tests', &
'        name=adjustl(line)//'' ''', &
'        ! blank string', &
'        if( name == '''' )return', &
'        ! allow one leading sign', &
'        if( verify(name(1:1),''+-'') == 0 ) name=name(2:)', &
'        ! was just a sign', &
'        if( name == '''' )return', &
'        lout=verify(trim(name), digits)  == 0', &
'      end function isint', &
'', &
'      end program fortran_ints', &
'', &
'  Results:', &
'', &
'      |+1      |3044848  |30.40    |September|1 2 3    |  -3000  |         |', &
'      | T      | T       | F       | F       | F       | T       | F       |', &
'', &
'  Sample program III:', &
'', &
'  Determine if strings represent valid Fortran symbol names', &
'', &
'      program fortran_symbol_name', &
'      implicit none', &
'      integer :: i', &
'      character(len=*),parameter :: symbols(*)=[character(len=10) :: &', &
'       ''A_ '', &', &
'       ''10 '', &', &
'       ''September '', &', &
'       ''A B'', &', &
'       ''_A '', &', &
'       '' '']', &
'', &
'        write(*,''("|",*(g0,"|"))'') symbols', &
'        write(*,''("|",*(1x,l1,8x,"|"))'') fortran_name(symbols)', &
'', &
'      contains', &
'', &
'      elemental function fortran_name(line) result (lout)', &
'      !', &
'      ! determine if a string is a valid Fortran name', &
'      ! ignoring trailing spaces (but not leading spaces)', &
'      !', &
'      character(len=*),parameter   :: int=''0123456789''', &
'      character(len=*),parameter   :: lower=''abcdefghijklmnopqrstuvwxyz''', &
'      character(len=*),parameter   :: upper=''ABCDEFGHIJKLMNOPQRSTUVWXYZ''', &
'      character(len=*),parameter   :: allowed=upper//lower//int//''_''', &
'', &
'      character(len=*),intent(in)  :: line', &
'      character(len=:),allocatable :: name', &
'      logical                     :: lout', &
'        name=trim(line)', &
'        if(len(name).ne.0)then', &
'           ! first character is alphameric', &
'           lout = verify(name(1:1), lower//upper) == 0  &', &
'            ! other characters are allowed in a symbol name', &
'            & .and. verify(name,allowed) == 0           &', &
'            ! allowable length', &
'            & .and. len(name) <= 63', &
'        else', &
'           lout = .false.', &
'        endif', &
'      end function fortran_name', &
'', &
'      end program fortran_symbol_name', &
'', &
'  Results:', &
'', &
'         |A_        |10        |September |A B       |_A        |          |', &
'         | T        | F        | T        | F        | F        | F        |', &
'', &
'  Sample program IV:', &
'', &
'  check if string is of form NN-HHHHH', &
'', &
'      program checkform', &
'      ! check if string is of form NN-HHHHH', &
'      implicit none', &
'      character(len=*),parameter :: int=''1234567890''', &
'      character(len=*),parameter :: hex=''abcdefABCDEF0123456789''', &
'      logical                   :: lout', &
'      character(len=80)         :: chars', &
'', &
'        chars=''32-af43d''', &
'        lout=.true.', &
'', &
'        ! are the first two characters integer characters?', &
'        lout = lout.and.(verify(chars(1:2), int) == 0)', &
'', &
'        ! is the third character a dash?', &
'        lout = lout.and.(verify(chars(3:3), ''-'') == 0)', &
'', &
'        ! is remaining string a valid representation of a hex value?', &
'        lout = lout.and.(verify(chars(4:8), hex) == 0)', &
'', &
'        if(lout)then', &
'           write(*,*)trim(chars),'' passed''', &
'        else', &
'           write(*,*)trim(chars),'' failed''', &
'        endif', &
'      end program checkform', &
'', &
'  Results:', &
'', &
'         32-af43d passed', &
'', &
'  Sample program V:', &
'', &
'  exploring uses of elemental functionality and dusty corners', &
'', &
'      program more_verify', &
'      implicit none', &
'      character(len=*),parameter :: &', &
'       & int=''0123456789'', &', &
'       & low=''abcdefghijklmnopqrstuvwxyz'', &', &
'       & upp=''ABCDEFGHIJKLMNOPQRSTUVWXYZ'', &', &
'       & blank='' ''', &
'      ! note character variables in an array have to be of the same length', &
'      character(len=6) :: strings(3)=["Go    ","right ","home! "]', &
'      character(len=2) :: sets(3)=["do","re","me"]', &
'', &
'       ! elemental -- you can use arrays for both strings and for sets', &
'', &
'        ! check each string from right to left for non-letter/non-blank', &
'        write(*,*)''last non-letter'',verify(strings,upp//low//blank,back=.true.)', &
'', &
'        ! even BACK can be an array', &
'        ! find last non-uppercase character in "Howdy "', &
'        ! and first non-lowercase in "there "', &
'        write(*,*) verify(strings(1:2),[upp,low],back=[.true.,.false.])', &
'', &
'        ! using a null string for a set is not well defined. Avoid it', &
'        write(*,*) ''null'',verify("for tran ", "", .true.) ! 8,length of string?', &
'        ! probably what you expected', &
'        write(*,*) ''blank'',verify("for tran ", " ", .true.) ! 7,found ''n''', &
'', &
'        ! first character in  "Go    " not in "do",', &
'        ! and first letter in "right " not in "ri"', &
'        ! and first letter in "home! " not in "me"', &
'        write(*,*) verify(strings,sets)', &
'', &
'      end program more_verify', &
'', &
'  Results:', &
'', &
'         > last non-letter 0 0 5', &
'         > 6 6', &
'         > null 9', &
'         > blank 8', &
'         > 1 2 1', &
'', &
'STANDARD', &
'  Fortran 95 , with KIND argument - Fortran 2003', &
'', &
'SEE ALSO', &
'  Functions that perform operations on character strings, return lengths of', &
'  arguments, and search for certain arguments:', &
'', &
'  o  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3),', &
'', &
'  o  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3)', &
'', &
'  Fortran intrinsic descriptions (license: MIT) @urbanjost', &
'', &
'                               March 16, 2025                verify(3fortran)', &
'']

shortname="verify"
call process()

case('244','wait')

textblock=[character(len=256) :: &
'', &
'wait(7fortran)                                                 wait(7fortran)', &
'', &
'NAME', &
'  wait(7f) - [IO] statement performs a wait operation for specified pending', &
'  asynchronous data transfer operations', &
'', &
'SYNOPSIS', &
'  WAIT( [UNIT=] file-unit-number,', &
'', &
'          [END=label,]', &
'          [EOR=label,]', &
'          [ERR=label,]', &
'          [ID=scalar-int-expr,]', &
'          [IOMSG=iomsg-variable,]', &
'          [IOSTAT=scalar-int-variable]', &
'          )', &
'', &
'DESCRIPTION', &
'  The WAIT(7f) statement performs a wait operation for specified pending', &
'  asynchronous data transfer operations.', &
'', &
'  The CLOSE, INQUIRE, and file positioning statements may also perform wait', &
'  operations.', &
'', &
'  Execution of a WAIT statement specifying a unit that does not exist, has no', &
'  file connected to it, or is not open for asynchronous input/output is', &
'  permitted, provided that the WAIT statement has no ID= specifier; such a', &
'  WAIT statement does not cause an error or end-of-file condition to occur.', &
'', &
'  An EOR= specifier has no effect if the pending data transfer operation is', &
'  not a nonadvancing read.', &
'', &
'  An END= specifier has no effect if the pending data transfer operation is', &
'  not a READ.', &
'', &
'OPTIONS', &
'  No specifier shall appear more than once in a given wait-spec-list.', &
'', &
'      [UNIT=]file-unit-number    A file-unit-number shall be specified', &
'                                 in a wait-spec-list; if the optional', &
'                                 characters UNIT= are omitted, the', &
'                                 file-unit-number shall be the first item', &
'                                 in the wait-spec-list.', &
'      END=label, EOR=label, ERR=label  The label in the ERR=, EOR=,', &
'                                       or END= specifier is a statement', &
'                                       label of a branch target statement', &
'                                       that appears in the same scoping', &
'                                       unit as the WAIT statement.', &
'      ID=scalar-int-expr   The value of the expression specified in', &
'                          the ID= specifier shall be the identifier', &
'                          of a pending data transfer operation for the', &
'                          specified unit. If the ID= specifier appears, a', &
'                          wait operation for the specified data transfer', &
'                          operation is performed. If the ID= specifier is', &
'                          omitted, wait operations for all pending data', &
'                          transfers for the specified unit are performed.', &
'      IOMSG=iomsg-variable  if IOSTAT is not zero, a corresponding message', &
'                           describing the error', &
'      IOSTAT=scalar-int-variable  status value indicating if an error occurred.', &
'                                 zero (0) indicates no error occurred.', &
'', &
'EXAMPLE', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025                  wait(7fortran)', &
'']

shortname="wait"
call process()

case('245','where')

textblock=[character(len=256) :: &
'', &
'where(7fortran)                                               where(7fortran)', &
'', &
'NAME', &
'  where(7f) - [ASSIGNMENT] masked array assignment', &
'', &
'SYNTAX', &
'  WHERE statement:', &
'', &
'        WHERE ( mask-expr ) where-assignment-stmt', &
'', &
'  WHERE construct without ELSEWHERE:', &
'', &
'          [where-construct-name:] WHERE ( mask-expr )', &
'          ELSEWHERE (mask-expr ) [where-construct-name]', &
'', &
'  WHERE construct with ELSEWHEREs:', &
'', &
'          [where-construct-name:] WHERE ( mask-expr )', &
'          [ELSEWHERE (mask-expr )', &
'             elemental-statements]', &
'          [ELSEWHERE (mask-expr )', &
'             elemental-statements]', &
'                :', &
'          [ELSEWHERE', &
'             elemental-statements', &
'          ]', &
'          END WHERE [where-construct-name]', &
'', &
'DESCRIPTION', &
'  A masked array assignment is either a WHERE statement or a WHERE construct.', &
'  It is used to mask the evaluation of expressions and assignment of values in', &
'  array assignment statements, according to the value of a logical array', &
'  expression.', &
'', &
'  where-assignment-stmt that is a defined assignment shall be elemental.', &
'', &
'  A statement that is part of a where-body-construct shall not be a branch', &
'  target statement.', &
'', &
'  If a where-construct contains a where-stmt, a masked-elsewhere-stmt, or', &
'  another where-construct then each mask-expr within the where-construct shall', &
'  have the same shape. In each where-assignment-stmt, the mask-expr and the', &
'  variable being defined shall be arrays of the same shape.', &
'', &
'  Examples of a masked array assignment are:', &
'', &
'                 WHERE (TEMP > 100.0) TEMP = TEMP - REDUCE_TEMP', &
'', &
'                 where (PRESSURE <= 1.0)', &
'                    PRESSURE = PRESSURE + INC_PRESSURE', &
'                    TEMP = TEMP - 5.0', &
'                 elsewhere', &
'                    RAINING = .TRUE.', &
'                 endwhere', &
'', &
'  Interpretation of masked array assignments', &
'', &
'  When a WHERE statement or a where-construct-stmt is executed, a control mask', &
'  is established. In addition, when a WHERE construct statement is executed, a', &
'  pending control mask is established. If the statement does not appear as', &
'  part of a where-body-construct, the mask-expr of the statement is evaluated,', &
'  and the control mask is established to be the value of mask-expr . The', &
'  pending control mask is established to have the value .NOT. mask-expr upon', &
'  execution of a WHERE construct statement that does not appear as part of a', &
'  where-body-construct. The mask-expr is evaluated only once.', &
'', &
'  Each statement in a WHERE construct is executed in sequence.', &
'', &
'  Upon execution of a masked-elsewhere-stmt, the following actions take place', &
'  in sequence.', &
'', &
'  1.  The control mask mc is established to have the value of the pending', &
'      control mask.', &
'', &
'  2.  The pending control mask is established to have the value mc .AND.', &
'      (.NOT. mask-expr ).', &
'', &
'  3.  The control mask mc is established to have the value mc .AND.  mask-expr', &
'      .', &
'', &
'  The mask-expr is evaluated at most once.', &
'', &
'  Upon execution of an ELSEWHERE statement, the control mask is established to', &
'  have the value of the pending control mask. No new pending control mask', &
'  value is established.', &
'', &
'  Upon execution of an ENDWHERE statement, the control mask and pending', &
'  control mask are established to have the values they had prior to the', &
'  execution of the corresponding WHERE construct statement. Following the', &
'  execution of a WHERE statement that appears as a where-body-construct, the', &
'  control mask is established to have the value it had prior to the execution', &
'  of the WHERE statement.', &
'', &
'  The establishment of control masks and the pending control mask is', &
'  illustrated with the following example:', &
'', &
'                 where(cond1)             ! Statement 1', &
'                 . . .', &
'                 elsewhere(cond2)         ! Statement 2', &
'                 . . .', &
'                 elsewhere                ! Statement 3', &
'                 . . .', &
'                 end where', &
'', &
'  Following execution of statement 1, the control mask has the value cond1 and', &
'  the pending control mask has the value .NOT. cond1. Following execution of', &
'  statement 2, the control mask has the value (.NOT. cond1) .AND. cond2 and', &
'  the pending control mask has the value (.NOT. cond1) .AND. (.NOT. cond2).', &
'  Following execution of statement 3, the control mask has the value (.NOT.', &
'  cond1) .AND. (.NOT. cond2). The false condition values are propagated', &
'  through the execution of the masked ELSEWHERE statement.', &
'', &
'  Upon execution of a WHERE construct statement that is part of a where-body-', &
'  construct, the pending control mask is established to have the value mc', &
'  .AND. (.NOT. mask-expr ). The control mask is then established to have the', &
'  value mc .AND. mask-expr. The mask-expr is evaluated at most once.', &
'', &
'  Upon execution of a WHERE statement that is part of a where-body-construct,', &
'  the control mask is established to have the value mc .AND. mask-expr. The', &
'  pending control mask is not altered.', &
'', &
'  If a nonelemental function reference occurs in the expr or variable of a', &
'  where-assignment-stmt or in a mask-expr , the function is evaluated without', &
'  any masked control; that is, all of its argument expressions are fully', &
'  evaluated and the function is fully evaluated. If the result is an array and', &
'  the reference is not within the argument list of a nonelemental function,', &
'  elements corresponding to true values in the control mask are selected for', &
'  use in evaluating the expr, variable or mask-expr.', &
'', &
'  If an elemental operation or function reference occurs in the expr or', &
'  variable of a where-assignment-stmt or in a mask-expr , and is not within', &
'  the argument list of a nonelemental function reference, the operation is', &
'  performed or the function is evaluated only for the elements corresponding', &
'  to true values of the control mask.', &
'', &
'  If an array constructor appears in a where-assignment-stmt or in a mask-expr', &
'  , the array constructor is evaluated without any masked control and then the', &
'  where-assignment-stmt is executed or the mask-expr is evaluated.', &
'', &
'  When a where-assignment-stmt is executed, the values of expr that correspond', &
'  to true values of the control mask are assigned to the corresponding', &
'  elements of the variable.', &
'', &
'  The value of the control mask is established by the execution of a WHERE', &
'  statement, a WHERE construct statement, an ELSEWHERE statement, a masked', &
'  ELSEWHERE statement, or an ENDWHERE statement. Subsequent changes to the', &
'  value of entities in a mask-expr have no effect on the value of the control', &
'  mask. The execution of a function reference in the mask expression of a', &
'  WHERE statement is permitted to affect entities in the assignment statement.', &
'', &
'  Examples of function references in masked array assignments are:', &
'', &
'         where (A > 0.0)', &
'            A = LOG (A)           ! LOG is invoked only for positive elements.', &
'            A = A / SUM (LOG (A)) ! LOG is invoked for all elements', &
'                                  ! because SUM is transformational.', &
'         end where', &
'', &
'EXAMPLE', &
'  Sample', &
'', &
'        program demo_where', &
'        !  Example of WHERE, ELSE WHERE, END WHERE', &
'        integer,parameter :: nd=10, ndh=nd/2, nduh=nd-ndh-1', &
'        integer :: j', &
'        real, dimension(nd):: a=[ (2*j,j=1,nd) ]', &
'        real, dimension(nd):: b ! =[ ndh*1.0, 0.0, nduh*2.0 ]', &
'        real, dimension(nd):: c ! =[ nd*-77.77 ]', &
'        integer iflag(nd)', &
'        data b/ndh*1,0.0,nduh*2./,c/nd*-77.77/', &
'', &
'        where (b.ne.0) c=a/b', &
'        write (*,2000) c(1:nd)', &
'        !', &
'        ! The above protects against divide by zero, but doesn''t actually', &
'        ! assign values to elements in c when the corresponding element in', &
'        ! b is zero The following covers that, and sets a flag when a divide', &
'        ! by zero is present', &
'        !', &
'        where (b(1:nd).ne.0.0)', &
'           c=a/b', &
'           iflag=0', &
'        else where', &
'           c=0.0', &
'           iflag=1', &
'        end where', &
'', &
'        write (*,2000) c(1:nd)', &
'        write (*,1000) iflag(1:nd)', &
'        1000 format (''iflag= '',/,(10i7))', &
'        2000 format (''a/b = '',/,(10f7.2))', &
'        end program demo_where', &
'', &
'  Results:', &
'', &
'       > a/b =', &
'       >    2.00   4.00   6.00  8.00  10.00 -77.77   7.00   8.00   9.00  10.00', &
'       > a/b =', &
'       >    2.00   4.00   6.00  8.00  10.00   0.00   7.00   8.00   9.00  10.00', &
'       > iflag=', &
'       >       0      0      0     0      0      1      0      0      0      0', &
'', &
'                               March 16, 2025                 where(7fortran)', &
'']

shortname="where"
call process()

case('246','write')

textblock=[character(len=256) :: &
'', &
'write(7fortran)                                               write(7fortran)', &
'', &
'NAME', &
'SYNOPSIS', &
'DESCRIPTION', &
'OPTIONS', &
'SEE ALSO', &
'  BACKSPACE(7), CLOSE(7), ENDFILE(7), FLUSH(7), INQUIRE(7), OPEN(7), PRINT(7),', &
'  READ(7), REWIND(7), WAIT(7), WRITE(7)', &
'', &
'                               March 16, 2025                 write(7fortran)', &
'']

shortname="write"
call process()

case default
   allocate (character(len=256) :: textblock(0))
end select
contains
subroutine process()
if(present(topic))then
   if(topic)then
      textblock=[character(len=len(shortname)) :: shortname]
   endif
endif

if(present(prefix))then
   if(prefix)then
      do i=1,size(textblock)
         textblock(i)= shortname//':'//trim(textblock(i))
      enddo
   endif
endif

if(present(m_help))then
   if(m_help)then
      textblock=[character(len=len(textblock)+1) :: ' ',textblock] ! add blank line to put shortname into
      textblock=' '//textblock                                     ! shift to right by one character
      textblock(1)=shortname
   endif
endif
end subroutine process
end function help_intrinsics_one
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine sort_name(lines)
!@(#) sort_name(3fp):sort strings(a-z) over specified field using shell sort starting with [ character
character(len = *)                :: lines(:)
   character(len = :),allocatable :: ihold
   integer                        :: n, igap, i, j, k, jg
   n = size(lines)
   if(n.gt.0)then
      allocate(character(len = len(lines(1))) :: ihold)
   else
      ihold = ''
   endif
   igap = n
   INFINITE: do
      igap = igap/2
      if(igap.eq.0) exit INFINITE
      k = n-igap
      i = 1
      INNER: do
         j = i
         INSIDE: do
            jg = j+igap
            if( lle( lower(lines(j)), lower(lines(jg)) ) )exit INSIDE
            ihold = lines(j)
            lines(j) = lines(jg)
            lines(jg) = ihold
            j = j-igap
            if(j.lt.1) exit INSIDE
         enddo INSIDE
         i = i+1
         if(i.gt.k) exit INNER
      enddo INNER
   enddo INFINITE
end subroutine sort_name
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
elemental pure function lower(str) result (string)
!@(#) M_strings::lower(3f): Changes a string to lowercase over specified range
character(*), intent(In)     :: str
character(len(str))          :: string
integer                      :: i
   string = str
   do i = 1, len_trim(str)     ! step thru each letter in the string
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))+32) ! change letter to miniscule
      case default
      end select
   end do
end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_intrinsics
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================

!>>>>> build/dependencies/M_time/src/M_time__duplicate.f90
module M_time__duplicate
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT
! copy of other GPF routines used here
implicit none !(type,external)
private
public lower
public substitute
public upper
public adjustc
public compact
public s2v
public split
public string_to_values
public string_to_value
public transliterate
public v2s

interface v2s
   module procedure d2s, r2s, i2s, l2s
end interface

interface string_to_value
   module procedure a2d, a2r, a2i
end interface

character(len=*),parameter   :: gen='(*(g0))'

contains
!>
!!##NAME
!!    substitute(3f) - [M_strings:EDITING] subroutine globally substitutes one substring for another in string
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine substitute(targetline,old,new,ierr,start,end)
!!
!!     character(len=*)              :: targetline
!!     character(len=*),intent(in)   :: old
!!     character(len=*),intent(in)   :: new
!!     integer,intent(out),optional  :: ierr
!!     integer,intent(in),optional   :: start
!!     integer,intent(in),optional   :: end
!!##DESCRIPTION
!!   Globally substitute one substring for another in string.
!!
!!##OPTIONS
!!     TARGETLINE  input line to be changed. Must be long enough to
!!                 hold altered output.
!!     OLD         substring to find and replace
!!     NEW         replacement for OLD substring
!!     IERR        error code. If IER = -1 bad directive, >= 0 then
!!                 count of changes made.
!!     START       sets the left margin to be scanned for OLD in
!!                 TARGETLINE.
!!     END         sets the right margin to be scanned for OLD in
!!                 TARGETLINE.
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_substitute
!!     use M_time, only : substitute
!!     implicit none
!!     ! must be long enough to hold changed line
!!     character(len=80) :: targetline
!!
!!     targetline='this is the input string'
!!     write(*,*)'ORIGINAL    : '//trim(targetline)
!!
!!     ! changes the input to 'THis is THe input string'
!!     call substitute(targetline,'th','TH')
!!     write(*,*)'th => TH    : '//trim(targetline)
!!
!!     ! a null old substring means "at beginning of line"
!!     ! changes the input to 'BEFORE:this is the input string'
!!     call substitute(targetline,'','BEFORE:')
!!     write(*,*)'"" => BEFORE: '//trim(targetline)
!!
!!     ! a null new string deletes occurrences of the old substring
!!     ! changes the input to 'ths s the nput strng'
!!     call substitute(targetline,'i','')
!!     write(*,*)'i => ""     : '//trim(targetline)
!!
!!     end program demo_substitute
!!
!!    Expected output
!!
!!     ORIGINAL    : this is the input string
!!     th => TH    : THis is THe input string
!!     "" => BEFORE: BEFORE:THis is THe input string
!!     i => ""     : BEFORE:THs s THe nput strng
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine substitute(targetline,old,new,ierr,start,end)

!character(len=*),parameter::ident_11="@(#)M_strings::substitute(3f): Globally substitute one substring for another in string"

!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*)               :: targetline         ! input line to be changed
character(len=*),intent(in)    :: old                ! old substring to replace
character(len=*),intent(in)    :: new                ! new substring
integer,intent(out),optional   :: ierr               ! error code. if ierr = -1 bad directive, >=0 then ierr changes made
integer,intent(in),optional    :: start              ! start sets the left margin
integer,intent(in),optional    :: end                ! end sets the right margin
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=len(targetline)) :: dum1               ! scratch string buffers
integer                        :: ml, mr, ier1
integer                        :: maxlengthout       ! MAXIMUM LENGTH ALLOWED FOR NEW STRING
integer                        :: original_input_length
integer                        :: len_old, len_new
integer                        :: ladd
integer                        :: ir
integer                        :: ind
integer                        :: il
integer                        :: id
integer                        :: ic
integer                        :: ichar
!-----------------------------------------------------------------------------------------------------------------------------------
   if (present(start)) then                            ! optional starting column
      ml=start
   else
      ml=1
   endif
   if (present(end)) then                              ! optional ending column
      mr=end
   else
      mr=len(targetline)
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ier1=0                                              ! initialize error flag/change count
   maxlengthout=len(targetline)                        ! max length of output string
   original_input_length=len_trim(targetline)          ! get non-blank length of input line
   dum1(:)=' '                                         ! initialize string to build output in
   id=mr-ml                                            ! check for window option !x! change to optional parameter(s)
!-----------------------------------------------------------------------------------------------------------------------------------
   len_old=len(old)                                    ! length of old substring to be replaced
   len_new=len(new)                                    ! length of new substring to replace old substring
   if(id<=0)then                                     ! no window so change entire input string
      il=1                                             ! il is left margin of window to change
      ir=maxlengthout                                  ! ir is right margin of window to change
      dum1(:)=' '                                      ! begin with a blank line
   else                                                ! if window is set
      il=ml                                            ! use left margin
      ir=min0(mr,maxlengthout)                         ! use right margin or rightmost
      dum1=targetline(:il-1)                           ! begin with what's below margin
   endif                                               ! end of window settings
!-----------------------------------------------------------------------------------------------------------------------------------
   if(len_old==0)then                                ! c//new/ means insert new at beginning of line (or left margin)
      ichar=len_new + original_input_length
      if(ichar>maxlengthout)then
         write(stderr,gen)'<ERROR>*substitute* - new line will be too long'
         ier1=-1
         if (present(ierr))ierr=ier1
         return
      endif
      if(len_new>0)then
         dum1(il:)=new(:len_new)//targetline(il:original_input_length)
      else
         dum1(il:)=targetline(il:original_input_length)
      endif
      targetline(1:maxlengthout)=dum1(:maxlengthout)
      ier1=1                                           ! made one change. actually, c/// should maybe return 0
      if(present(ierr))ierr=ier1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   ichar=il                                            ! place to put characters into output string
   ic=il                                               ! place looking at in input string
   loop: do
      ind=index(targetline(ic:),old(:len_old))+ic-1    ! try to find start of old string in remaining part of input in change window
      if(ind==ic-1.or.ind>ir)then                 ! did not find old string or found old string past edit window
         exit loop                                     ! no more changes left to make
      endif
      ier1=ier1+1                                      ! found an old string to change, so increment count of changes
      if(ind>ic)then                                ! if found old string past at current position in input string copy unchanged
         ladd=ind-ic                                   ! find length of character range to copy as-is from input to output
         if(ichar-1+ladd>maxlengthout)then
            ier1=-1
            exit loop
         endif
         dum1(ichar:)=targetline(ic:ind-1)
         ichar=ichar+ladd
      endif
      if(ichar-1+len_new>maxlengthout)then
         ier1=-2
         exit loop
      endif
      if(len_new/=0)then
         dum1(ichar:)=new(:len_new)
         ichar=ichar+len_new
      endif
      ic=ind+len_old
   enddo loop
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ier1)
   case (:-1)
      write(stderr,gen) '<ERROR>*substitute* - new line will be too long'
   case (0)                                                ! there were no changes made to the window
   case default
      ladd=original_input_length-ic
      if(ichar+ladd>maxlengthout)then
         write(stderr,gen)'<ERROR>*substitute* - new line will be too long'
         ier1=-1
         if(present(ierr))ierr=ier1
         return
      endif
      if(ic<len(targetline))then
         dum1(ichar:)=targetline(ic:max(ic,original_input_length))
      endif
      targetline=dum1(:maxlengthout)
   end select
   if(present(ierr))ierr=ier1
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine substitute
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! upper(3f) - [M_strings:CASE] changes a string to uppercase
!! (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function upper(str,begin,end) result (string)
!!
!!     character(*), intent(in)    :: str
!!     integer,optional,intent(in) :: begin,end
!!     character(len(str))         :: string  ! output string
!!##DESCRIPTION
!!   upper(string) returns a copy of the input string with all characters
!!   converted in the optionally specified range to uppercase, assuming
!!   ASCII character sets are being used. If no range is specified the
!!   entire string is converted to uppercase.
!!
!!##OPTIONS
!!    str    string to convert to uppercase
!!    begin  optional starting position in "str" to begin converting to uppercase
!!    end    optional ending position in "str" to stop converting to uppercase
!!
!!##RESULTS
!!    upper  copy of the input string with all characters converted to uppercase
!!            over optionally specified range.
!!
!!##TRIVIA
!!   The terms "uppercase" and "lowercase" date back to the early days of
!!   the mechanical printing press. Individual metal alloy casts of each
!!   needed letter, or punctuation symbol, were meticulously added to a
!!   press block, by hand, before rolling out copies of a page. These
!!   metal casts were stored and organized in wooden cases. The more
!!   often needed miniscule letters were placed closer to hand, in the
!!   lower cases of the work bench. The less often needed, capitalized,
!!   majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_upper
!!     use M_time, only: upper
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'upper-case output string is ...',upper(s)
!!        write(*,*) 'make first character uppercase  ... ',upper('this is a sentence.',1,1)
!!        write(*,'(1x,a,*(a:,"+"))') 'upper(3f) is elemental ==>',upper(["abc","def","ghi"])
!!     end program demo_upper
!!
!!    Expected output
!!
!!     mixed-case input string is .... ABCDEFG abcdefg
!!     upper-case output string is ... ABCDEFG ABCDEFG
!!     make first character uppercase  ... This is a sentence.
!!     upper(3f) is elemental ==>ABC+DEF+GHI
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!===================================================================================================================================
elemental pure function upper(str,begin,end) result (string)

!character(len=*),parameter::ident_21="@(#)M_strings::upper(3f): Changes a string to uppercase"

character(*), intent(In)      :: str                 ! inpout string to convert to all uppercase
integer, intent(in), optional :: begin,end
character(len(str))           :: string              ! output string that contains no miniscule letters
integer                       :: i                   ! loop counter
integer                       :: ibegin,iend
   string = str                                      ! initialize output string to input string

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
       select case (str(i:i))
       case ('a':'z')                                ! located miniscule letter
          string(i:i) = achar(iachar(str(i:i))-32)   ! change miniscule letter to uppercase
       end select
   end do

end function upper
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    lower(3f) - [M_strings:CASE] changes a string to lowercase over specified range
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    elemental pure function lower(str,begin,end) result (string)
!!
!!     character(*), intent(in) :: str
!!     integer,optional         :: begin, end
!!     character(len(str))      :: string  ! output string
!!##DESCRIPTION
!!   lower(string) returns a copy of the input string with all characters
!!   converted to miniscule over the specified range, assuming ASCII
!!   character sets are being used. If no range is specified the entire
!!   string is converted to miniscule.
!!
!!##OPTIONS
!!    str    string to convert to miniscule
!!    begin  optional starting position in "str" to begin converting to miniscule
!!    end    optional ending position in "str" to stop converting to miniscule
!!
!!##RESULTS
!!    lower  copy of the input string with all characters converted to miniscule
!!           over optionally specified range.
!!
!!##TRIVIA
!!    The terms "uppercase" and "lowercase" date back to the early days of
!!    the mechanical printing press. Individual metal alloy casts of each
!!    needed letter, or punctuation symbol, were meticulously added to a
!!    press block, by hand, before rolling out copies of a page. These
!!    metal casts were stored and organized in wooden cases. The more
!!    often needed miniscule letters were placed closer to hand, in the
!!    lower cases of the work bench. The less often needed, capitalized,
!!    majuscule letters, ended up in the harder to reach upper cases.
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_lower
!!     use M_time, only: lower
!!     implicit none
!!     character(len=:),allocatable  :: s
!!        s=' ABCDEFG abcdefg '
!!        write(*,*) 'mixed-case input string is ....',s
!!        write(*,*) 'lower-case output string is ...',lower(s)
!!     end program demo_lower
!!
!!    Expected output
!!
!!       mixed-case input string is .... ABCDEFG abcdefg
!!       lower-case output string is ... abcdefg abcdefg
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
elemental pure function lower(str,begin,end) result (string)

!character(len=*),parameter::ident_22="@(#)M_strings::lower(3f): Changes a string to lowercase over specified range"

character(*), intent(In)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
   string = str

   ibegin = 1
   if (present(begin))then
      ibegin = max(ibegin,begin)
   endif

   iend = len_trim(str)
   if (present(end))then
      iend= min(iend,end)
   endif

   do i = ibegin, iend                               ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = achar(iachar(str(i:i))+32)    ! change letter to miniscule
      case default
      end select
   end do

end function lower
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!       adjustc(3f) - [M_strings:WHITESPACE] center text
!!       (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!   pure function adjustc(string[,length])
!!
!!    character(len=*),intent(in)  :: string
!!    integer,intent(in),optional  :: length
!!    character(len=:),allocatable :: adjustc
!!##DESCRIPTION
!!   Centers input text in a string of the length specified. Returns a
!!   string of length LENGTH if LENGTH is present. Otherwise returns a
!!   string of the length of the input string.
!!##OPTIONS
!!     string  input string to trim and center
!!     length  line length to center text in, optional.
!!##RETURNS
!!     adjustc  centered output string
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_adjustc
!!     use M_strings, only : adjustc
!!     !  using length of the input string
!!        write(*,'(a)')       '================================'
!!        write(*,'(a)')adjustc('centered string                 ')
!!        write(*,'(a)')adjustc('                 centered string')
!!        write(*,'(a)')adjustc('  centered string               ')
!!     !  using explicit output string length
!!        write(*,'(a)')repeat('=',50)
!!        write(*,'(a)')adjustc('this is a centered string',50)
!!        write(*,'(a)')repeat('=',50)
!!     end program demo_adjustc
!!
!!    Expected output:
!!
!!     \================================
!!             centered string
!!             centered string
!!             centered string
!!     \==================================================
!!                 this is a centered string
!!     \==================================================
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
pure function adjustc(string,length)

!character(len=*),parameter::ident_32="@(#)M_strings::adjustc(3f): center text"

!>
!! PROCEDURE   adjustc(3f)
!! DESCRIPTION center text using implicit or explicit length
!!##VERSION     2.0, 20160711
!! AUTHOR      John S. Urban
!===================================================================================================================================
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: string         ! input string to trim and center
integer,intent(in),optional  :: length         ! line length to center text in
character(len=:),allocatable :: adjustc        ! output string
integer                      :: inlen
integer                      :: ileft          ! left edge of string if it is centered
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(length))then                     ! optional length
      inlen=length                             ! length will be requested length
      if(inlen<=0)then                       ! bad input length
         inlen=len(string)                     ! could not use input value, fall back to length of input string
      endif
   else                                        ! output length was not explicitly specified, use input string length
      inlen=len(string)
   endif
   allocate(character(len=inlen):: adjustc)    ! create output at requested length
   adjustc(1:inlen)=' '                        ! initialize output string to all blanks
!-----------------------------------------------------------------------------------------------------------------------------------
   ileft =(inlen-len_trim(adjustl(string)))/2  ! find starting point to start input string to center it
   if(ileft>0)then                          ! if string will fit centered in output
      adjustc(ileft+1:inlen)=adjustl(string)   ! center the input text in the output string
   else                                        ! input string will not fit centered in output string
      adjustc(1:inlen)=adjustl(string)         ! copy as much of input to output as can
   endif
end function adjustc
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compact(3f) - [M_strings:WHITESPACE] converts contiguous whitespace to a single character (or nothing)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function compact(STR,CHAR) result (OUTSTR)
!!
!!     character(len=*),intent(in)          :: STR
!!     character(len=*),intent(in),optional :: CHAR
!!     character(len=len(str))              :: OUTSTR
!!##DESCRIPTION
!!   COMPACT(3f) converts multiple spaces, tabs and control characters
!!   (called "whitespace") to a single character or nothing. Leading
!!   whitespace is removed.
!!
!!##OPTIONS
!!    STR     input string to reduce or remove whitespace from
!!    CHAR    By default the character that replaces adjacent
!!            whitespace is a space. If the optional CHAR parameter is supplied
!!            it will be used to replace the whitespace. If a null character is
!!            supplied for CHAR whitespace is removed.
!!##RETURNS
!!    OUTSTR  string of same length as input string but with all contiguous whitespace
!!            reduced to a single space and leading whitespace removed
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_compact
!!     use M_strings, only : compact
!!     implicit none
!!     ! produces 'This is a test               '
!!     write(*,*)compact('  This     is      a     test  ')
!!     ! produces 'Thisisatest                  '
!!     write(*,*)compact('  This     is      a     test  ',char='')
!!     ! produces 'This:is:a:test               '
!!     write(*,*)compact('  This     is      a     test  ',char=':')
!!     ! note CHAR is used to replace the whitespace, but if CHAR is
!!     ! in the original string it is just copied
!!     write(*,*)compact('A  AA    A   AAAAA',char='A')
!!     ! produces (original A characters are left as-is) 'AAAAAAAAAAAA'
!!     ! not 'A'
!!     end program demo_compact
!!
!!    Expected output
!!
!!     >This is a test
!!     >Thisisatest
!!     >This:is:a:test
!!     >AAAAAAAAAAAA
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!elemental pure function compact(str,char) result (outstr)
function compact(str,char) result (outstr)

!character(len=*),parameter::ident_38="@(#)M_strings::compact(3f): Converts white-space to single spaces"

character(len=*),intent(in)          :: str
character(len=*),intent(in),optional :: char
character(len=len(str))              :: outstr
character(len=1)                     :: ch
integer                              :: i
integer                              :: position_in_output
logical                              :: last_was_space
character(len=1)                     :: char_p
logical                              :: nospace
if(present(char))then
   char_p=char
   if(len(char)==0)then
      nospace=.true.
   else
      nospace=.false.
   endif
else
   char_p=' '
   nospace=.false.
endif
   outstr=' '
   last_was_space=.false.
   position_in_output=0

   IFSPACE: do i=1,len_trim(str)
     ch=str(i:i)
     select case(ichar(ch))
       case(0:32,127)                                         ! space or tab character or control character
         if(position_in_output==0)then                      ! still at beginning so ignore leading whitespace
            cycle IFSPACE
         elseif(.not.last_was_space) then                     ! if have not already put out a space output one
           if(.not.nospace)then
              position_in_output=position_in_output+1
              outstr(position_in_output:position_in_output)=char_p
           endif
         endif
         last_was_space=.true.
       case(:-1,33:126,128:)                                  ! not a space, quote, or control character so copy it
         position_in_output=position_in_output+1
         outstr(position_in_output:position_in_output)=ch
         last_was_space=.false.
     end select
   end do IFSPACE

end function compact
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      s2v(3f) - [M_strings:NUMERIC] function returns doubleprecision numeric value from a string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function s2v(string[,ierr][,onerr])
!!
!!     character(len=*)             :: string
!!     doubleprecision              :: s2v
!!     integer,intent(out),optional :: ierr
!!     class(*),intent(in),optional :: onerr
!!##DESCRIPTION
!!   This function converts a string to a DOUBLEPRECISION numeric value.
!!
!!   The intrinsics INT(3f), REAL(3f), and DBLE(3f) are also extended to take
!!   CHARACTER variables. The KIND= keyword is not supported on the extensions.
!!##OPTIONS
!!
!!     string   holds string assumed to represent a numeric value
!!     ierr     If an error occurs the program is stopped if the optional
!!              parameter IERR is not present. If IERR returns a non-zero
!!              value an error occurred.
!!     onerr    The value to return on error. A value of zero (NaN) is
!!              returned on error by default.
!!##RETURNS
!!     s2v
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_s2v
!!
!!     use M_strings, only: s2v, int, real, dble
!!     implicit none
!!     character(len=8)              :: s=' 10.345 '
!!     integer                       :: i
!!     character(len=14),allocatable :: strings(:)
!!     doubleprecision               :: dv
!!     integer                       :: errnum
!!
!!     ! different strings representing INTEGER, REAL, and DOUBLEPRECISION
!!     strings=[&
!!     &' 10.345       ',&
!!     &'+10           ',&
!!     &'    -3        ',&
!!     &'    -4.94e-2  ',&
!!     &'0.1           ',&
!!     &'12345.678910d0',&
!!     &'              ',& ! Note: will return zero without an error message
!!     &'1 2 1 2 1 . 0 ',& ! Note: spaces will be ignored
!!     &'WHAT?         ']  ! Note: error messages will appear, zero returned
!!
!!     ! a numeric value is returned, so it can be used in numeric expression
!!     write(*,*) '1/2 value of string is ',s2v(s)/2.0d0
!!     write(*,*)
!!     write(*,*)' STRING            VALUE                    ERROR_NUMBER'
!!     do i=1,size(strings)
!!        ! Note: not a good idea to use s2v(3f) in a WRITE(3f) statement,
!!        ! as it does I/O when errors occur, so called on a separate line
!!        dv=s2v(strings(i),errnum)
!!        write(*,*) strings(i)//'=',dv,errnum
!!     enddo
!!     write(*,*)"Extended intrinsics"
!!     write(*,*)'given inputs:',s,strings(:8)
!!     write(*,*)'INT(3f):',int(s),int(strings(:8))
!!     write(*,*)'REAL(3f):',real(s),real(strings(:8))
!!     write(*,*)'DBLE(3f):',dble(s),dble(strings(:8))
!!     write(*,*)"That's all folks!"
!!
!!     end program demo_s2v
!!
!!    Expected output
!!
!!     >1/2 value of string is    5.1725000000000003
!!     >
!!     > STRING            VALUE                    ERROR_NUMBER
!!     > 10.345       =   10.345000000000001                0
!!     >+10           =   10.000000000000000                0
!!     >    -3        =  -3.0000000000000000                0
!!     >    -4.94e-2  =  -4.9399999999999999E-002           0
!!     >0.1           =  0.10000000000000001                0
!!     >12345.678910d0=   12345.678910000001                0
!!     >              =   0.0000000000000000                0
!!     >1 2 1 2 1 . 0 =   12121.000000000000                0
!!     >*a2d* - cannot produce number from string [WHAT?]
!!     >*a2d* - [Bad value during floating point read]
!!     >WHAT?         =   0.0000000000000000             5010
!!     >Extended intrinsics
!!     >given inputs: 10.345 10.345 +10 -3 -4.94e-2 0.1 12345.678910d0 1 2 1 2 1 . 0
!!     >INT(3f): 10 10 10 -3 0 0 12345 0 12121
!!     >REAL(3f): 10.3450003 10.3450003 10.0000000 -3.00000000 -4.94000018E-02
!!     >          0.100000001 12345.6787 0.00000000 12121.0000
!!     >DBLE(3f): 10.345000000000001 10.345000000000001 10.000000000000000
!!     >          -3.0000000000000000 -4.9399999999999999E-002 0.10000000000000001
!!     >          12345.678910000001 0.0000000000000000 12121.000000000000
!!     >That's all folks!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!>
!!##PROCEDURE:
!! DESCRIPTION: s2v(3f): function returns doubleprecision number from string;zero if error occurs
!!##VERSION:     2.0, 20160704
!! AUTHOR:      John S. Urban
!===================================================================================================================================
doubleprecision function s2v(chars,ierr,onerr)
!  1989 John S. Urban

!character(len=*),parameter::ident_43="@(#)M_strings::s2v(3f): returns doubleprecision number from string"

character(len=*),intent(in)  :: chars
integer,optional             :: ierr
doubleprecision              :: valu
integer                      :: ierr_local
class(*),intent(in),optional :: onerr

   ierr_local=0
   if(present(onerr))then
      call a2d(chars,valu,ierr_local,onerr)
   else
      call a2d(chars,valu,ierr_local)
   endif
   if(present(ierr))then ! if error is not returned stop program on error
      ierr=ierr_local
      s2v=valu
   elseif(ierr_local/=0)then
      write(stderr,*)'<ERROR>*s2v* - stopped while reading '//trim(chars)
      stop 1
   else
      s2v=valu
   endif
end function s2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    split(3f) - [M_strings:TOKENS] parse string into an array using specified delimiters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine split(input_line,array,delimiters,order,nulls)
!!
!!     character(len=*),intent(in)              :: input_line
!!     character(len=:),allocatable,intent(out) :: array(:)
!!     character(len=*),optional,intent(in)     :: delimiters
!!     character(len=*),optional,intent(in)     :: order
!!     character(len=*),optional,intent(in)     :: nulls
!!##DESCRIPTION
!!   SPLIT(3f) parses a string using specified delimiter characters and
!!   store tokens into an allocatable array
!!
!!##OPTIONS
!!
!!    INPUT_LINE  Input string to tokenize
!!
!!    ARRAY       Output array of tokens
!!
!!    DELIMITERS  List of delimiter characters.
!!                The default delimiters are the "whitespace" characters
!!                (space, tab,new line, vertical tab, formfeed, carriage
!!                return, and null). You may specify an alternate set of
!!                delimiter characters.
!!
!!                Multi-character delimiters are not supported (Each
!!                character in the DELIMITERS list is considered to be
!!                a delimiter).
!!
!!                Quoting of delimiter characters is not supported.
!!
!!    ORDER SEQUENTIAL|REVERSE|RIGHT  Order of output array.
!!                By default ARRAY contains the tokens having parsed
!!                the INPUT_LINE from left to right. If ORDER='RIGHT'
!!                or ORDER='REVERSE' the parsing goes from right to left.
!!
!!    NULLS IGNORE|RETURN|IGNOREEND  Treatment of null fields.
!!                By default adjacent delimiters in the input string
!!                do not create an empty string in the output array. if
!!                NULLS='return' adjacent delimiters create an empty element
!!                in the output ARRAY. If NULLS='ignoreend' then only
!!                trailing delimiters at the right of the string are ignored.
!!
!!##EXAMPLES
!!
!!  Sample program:
!!
!!       program demo_split
!!       use M_strings, only: split
!!       character(len=*),parameter     :: &
!!       & line='  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    '
!!       character(len=:),allocatable :: array(:) ! output array of tokens
!!          write(*,*)'INPUT LINE:['//LINE//']'
!!          write(*,'(80("="))')
!!          write(*,*)'typical call:'
!!          CALL split(line,array)
!!          write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!          write(*,*)'SIZE:',SIZE(array)
!!          write(*,'(80("-"))')
!!          write(*,*)'custom list of delimiters (colon and vertical line):'
!!          CALL split(line,array,delimiters=':|',order='sequential',nulls='ignore')
!!          write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!          write(*,*)'SIZE:',SIZE(array)
!!          write(*,'(80("-"))')
!!          write(*,*)&
!!          &'custom list of delimiters, reverse array order and count null fields:'
!!          CALL split(line,array,delimiters=':|',order='reverse',nulls='return')
!!          write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!          write(*,*)'SIZE:',SIZE(array)
!!          write(*,'(80("-"))')
!!          write(*,*)'INPUT LINE:['//LINE//']'
!!          write(*,*)&
!!          &'default delimiters and reverse array order and return null fields:'
!!          CALL split(line,array,delimiters='',order='reverse',nulls='return')
!!          write(*,'(i0," ==> ",a)')(i,trim(array(i)),i=1,size(array))
!!          write(*,*)'SIZE:',SIZE(array)
!!      end program demo_split
!!
!!   Output
!!
!!        > INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!        > ===========================================================================
!!        >  typical call:
!!        > 1 ==> aBcdef
!!        > 2 ==> ghijklmnop
!!        > 3 ==> qrstuvwxyz
!!        > 4 ==> 1:|:2
!!        > 5 ==> 333|333
!!        > 6 ==> a
!!        > 7 ==> B
!!        > 8 ==> cc
!!        >  SIZE:           8
!!        > --------------------------------------------------------------------------
!!        >  custom list of delimiters (colon and vertical line):
!!        > 1 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!        > 2 ==> 2     333
!!        > 3 ==> 333 a B cc
!!        >  SIZE:           3
!!        > --------------------------------------------------------------------------
!!        >  custom list of delimiters, reverse array order and return null fields:
!!        > 1 ==> 333 a B cc
!!        > 2 ==> 2     333
!!        > 3 ==>
!!        > 4 ==>
!!        > 5 ==>   aBcdef   ghijklmnop qrstuvwxyz  1
!!        >  SIZE:           5
!!        > --------------------------------------------------------------------------
!!        >  INPUT LINE:[  aBcdef   ghijklmnop qrstuvwxyz  1:|:2     333|333 a B cc    ]
!!        >  default delimiters and reverse array order and count null fields:
!!        > 1 ==>
!!        > 2 ==>
!!        > 3 ==>
!!        > 4 ==> cc
!!        > 5 ==> B
!!        > 6 ==> a
!!        > 7 ==> 333|333
!!        > 8 ==>
!!        > 9 ==>
!!        > 10 ==>
!!        > 11 ==>
!!        > 12 ==> 1:|:2
!!        > 13 ==>
!!        > 14 ==> qrstuvwxyz
!!        > 15 ==> ghijklmnop
!!        > 16 ==>
!!        > 17 ==>
!!        > 18 ==> aBcdef
!!        > 19 ==>
!!        > 20 ==>
!!        >  SIZE:          20
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine split(input_line,array,delimiters,order,nulls)
!-----------------------------------------------------------------------------------------------------------------------------------

!character(len=*),parameter::ident_7="&
!&@(#)M_strings::split(3f): parse string on delimiter characters and store tokens into an allocatable array"

!  John S. Urban
!-----------------------------------------------------------------------------------------------------------------------------------
intrinsic index, min, present, len
!-----------------------------------------------------------------------------------------------------------------------------------
!  given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.
!    o by default adjacent delimiters in the input string do not create an empty string in the output array
!    o no quoting of delimiters is supported
character(len=*),intent(in)              :: input_line  ! input string to tokenize
character(len=*),optional,intent(in)     :: delimiters  ! list of delimiter characters
character(len=*),optional,intent(in)     :: order       ! order of output array sequential|[reverse|right]
character(len=*),optional,intent(in)     :: nulls       ! return strings composed of delimiters or not ignore|return|ignoreend
character(len=:),allocatable,intent(out) :: array(:)    ! output array of tokens
!-----------------------------------------------------------------------------------------------------------------------------------
integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter
integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start
integer,allocatable           :: iterm(:)               ! positions in input string where tokens end
character(len=:),allocatable  :: dlim                   ! string containing delimiter characters
character(len=:),allocatable  :: ordr                   ! string containing order keyword
character(len=:),allocatable  :: nlls                   ! string containing nulls keyword
integer                       :: ii,iiii                ! loop parameters used to control print order
integer                       :: icount                 ! number of tokens found
integer                       :: ilen                   ! length of input string with trailing spaces trimmed
integer                       :: i10,i20,i30            ! loop counters
integer                       :: icol                   ! pointer into input string as it is being parsed
integer                       :: idlim                  ! number of delimiter characters
integer                       :: ifound                 ! where next delimiter character is found in remaining input string data
integer                       :: inotnull               ! count strings not composed of delimiters
integer                       :: ireturn                ! number of tokens returned
integer                       :: imax                   ! length of longest token
!-----------------------------------------------------------------------------------------------------------------------------------
   ! decide on value for optional DELIMITERS parameter
   if (present(delimiters)) then                                     ! optional delimiter list was present
      if(delimiters/='')then                                       ! if DELIMITERS was specified and not null use it
         dlim=delimiters
      else                                                           ! DELIMITERS was specified on call as empty string
         dlim=' '//achar(9)//achar(10)//achar(11)//achar(12)//achar(13)//achar(0) ! use default delimiter when not specified
      endif
   else                                                              ! no delimiter value was specified
      dlim=' '//achar(9)//achar(10)//achar(11)//achar(12)//achar(13)//achar(0)    ! use default delimiter when not specified
   endif
   idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string
!-----------------------------------------------------------------------------------------------------------------------------------
   if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter
   if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter
!-----------------------------------------------------------------------------------------------------------------------------------
   n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter
   allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens
   allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens
   ibegin(:)=1
   iterm(:)=1
!-----------------------------------------------------------------------------------------------------------------------------------
   ilen=len(input_line)                                           ! ILEN is the column position of the last non-blank character
   icount=0                                                       ! how many tokens found
   inotnull=0                                                     ! how many tokens found not composed of delimiters
   imax=0                                                         ! length of longest token found
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (ilen)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (:0)                                                      ! command was totally blank
!-----------------------------------------------------------------------------------------------------------------------------------
   case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here
      icol=1                                                      ! initialize pointer into input line
      INFINITE: do i30=1,ilen,1                                   ! store into each array element
         ibegin(i30)=icol                                         ! assume start new token on the character
         if(index(dlim(1:idlim),input_line(icol:icol))==0)then  ! if current character is not a delimiter
            iterm(i30)=ilen                                       ! initially assume no more tokens
            do i10=1,idlim                                        ! search for next delimiter
               ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))
               IF(ifound>0)then
                  iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)
               endif
            enddo
            icol=iterm(i30)+2                                     ! next place to look as found end of this token
            inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters
         else                                                     ! character is a delimiter for a null string
            iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning
            icol=icol+1                                           ! advance pointer into input string
         endif
         imax=max(imax,iterm(i30)-ibegin(i30)+1)
         icount=i30                                               ! increment count of number of tokens found
         if(icol>ilen)then                                     ! no text left
            exit INFINITE
         endif
      enddo INFINITE
!-----------------------------------------------------------------------------------------------------------------------------------
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(nlls)))
   case ('ignore','','ignoreend')
      ireturn=inotnull
   case default
      ireturn=icount
   end select
   allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return
   !allocate(array(ireturn))                                       ! allocate the array to turn
!-----------------------------------------------------------------------------------------------------------------------------------
   select case (trim(adjustl(ordr)))                              ! decide which order to store tokens
   case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first
   case default             ; ii=1       ; iiii=1                 ! first to last
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   do i20=1,icount                                                ! fill the array with the tokens that were found
      if(iterm(i20)<ibegin(i20))then
         select case (trim(adjustl(nlls)))
         case ('ignore','','ignoreend')
         case default
            array(ii)=' '
            ii=ii+iiii
         end select
      else
         array(ii)=input_line(ibegin(i20):iterm(i20))
         ii=ii+iiii
      endif
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   end subroutine split
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_values(3f) - [M_strings:NUMERIC] read a string representing numbers into a numeric array
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine string_to_values(line,iread,values,inums,delims,ierr)
!!
!!        character(len=*) :: line
!!        integer          :: iread
!!        real             :: values(*)
!!        integer          :: inums
!!        character(len=*) :: delims
!!        integer          :: ierr
!!##DESCRIPTION
!!   This routine can take a string representing a series of numbers and
!!   convert it to a numeric array and return how many numbers were found.
!!
!!##OPTIONS
!!
!!       LINE     Input string containing numbers
!!       IREAD    maximum number of values to try to read from input string
!!
!!##RESULTS
!!
!!       VALUES   real array to be filled with numbers
!!       INUMS    number of values successfully read (before error occurs
!!                if one does)
!!       DELIMS   delimiter character(s), usually a space. must not be a
!!                null string. If more than one character, a space must
!!                not be the last character or it will be ignored.
!!       IERR     error flag (0=no error, else column number string starts
!!                at that error occurred on).
!!
!!##EXAMPLES
!!
!!  Sample Program:
!!
!!       program demo_string_to_values
!!        use M_strings, only : string_to_values
!!        character(len=80)  :: s=' 10 20e3;3.45 -400.3e-2;1234; 5678 '
!!        integer,parameter  :: isz=10
!!        real               :: array(isz)
!!
!!        call string_to_values(s,10,array,inums,' ;',ierr)
!!        call reportit()
!!
!!        call string_to_values('10;2.3;3.1416',isz,array,inums,' ;',ierr)
!!        call reportit()
!!
!!        contains
!!           subroutine reportit()
!!              write(*,*)'string_to_values:'
!!              write(*,*)'input string.............',trim(s)
!!              write(*,*)'number of values found...',inums
!!              write(*,*)'values...................',(array(ii),ii=1,inums)
!!           end subroutine reportit
!!       end program demo_string_to_values
!!
!!    Expected output
!!
!!        string_to_values:
!!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!        number of values found...           6
!!        values...................   10.0000000  20000.0000  3.45000005  -4.00299978  1234.00000  5678.00000
!!        string_to_values:
!!        input string............. 10 20e3;3.45 -400.3e-2;1234; 5678
!!        number of values found...           3
!!        values...................   10.0000000  2.29999995  3.14159989
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine string_to_values(line,iread,values,inums,delims,ierr)
!----------------------------------------------------------------------------------------------------------------------------------
!   1989,1997-12-31,2014 John S. Urban

!   given a line of structure , string , string , string process each
!   string as a numeric value and store into an array.
!   DELIMS contain the legal delimiters. If a space is an allowed delimiter, it must not appear last in DELIMS.
!   There is no direct checking for more values than can fit in VALUES.
!   Quits if encounters any errors in read.
!----------------------------------------------------------------------------------------------------------------------------------

!character(len=*),parameter::ident_54="@(#)M_strings::string_to_values(3f): reads an array of numbers from a numeric string"

character(len=*),intent(in)  :: line          ! input string
integer,intent(in)           :: iread         ! maximum number of values to try to read into values
real,intent(inout)           :: values(iread) ! real array to be filled with values
integer,intent(out)          :: inums         ! number of values successfully read from string
character(len=*),intent(in)  :: delims        ! allowed delimiters
integer,intent(out)          :: ierr          ! 0 if no error, else column number undecipherable string starts at
!----------------------------------------------------------------------------------------------------------------------------------
character(len=256)           :: delims_local        ! mutable copy of allowed delimiters
integer                      :: istart,iend,ilen,icol
integer                      :: i10,i20,i40
real                         :: rval
integer                      :: ier
integer                      :: delimiters_length
!----------------------------------------------------------------------------------------------------------------------------------
      delims_local=delims                                 ! need a mutable copy of the delimiter list
      if(delims_local=='')then                          ! if delimiter list is null or all spaces make it a space
         delims_local=' '                                 ! delimiter is a single space
         delimiters_length=1                        ! length of delimiter list
      else
         delimiters_length=len_trim(delims)         ! length of variable WITH TRAILING WHITESPACE TRIMMED
      endif
!----------------------------------------------------------------------------------------------------------------------------------
      ierr=0                                        ! initialize error code returned
      inums=0                                       ! initialize count of values successfully returned
      istart=0
!----------------------------------------------------------------------------------------------------------------------------------
      ilen=0                                        ! ilen will be the position of the right-most non-delimiter in the input line
      do i20=len(line),1,-1                         ! loop from end of string to beginning to find right-most non-delimiter
         if(index(delims_local(:delimiters_length),line(i20:i20))==0)then   ! found a non-delimiter
            ilen=i20
            exit
         endif
      enddo
      if(ilen==0)then                             ! command was totally composed of delimiters
         write(stderr,gen) '<ERROR>*string_to_values* - blank line passed as a list of numbers'
         return
      endif
!----------------------------------------------------------------------------------------------------------------------------------
!     there is at least one non-delimiter sub-string
!     ilen is the column position of the last non-delimiter character
!     now, starting at beginning of string find next non-delimiter
      icol=1                                                     ! pointer to beginning of unprocessed part of LINE
      LOOP: dO i10=1,iread,1                                     ! each pass should find a value
         if(icol>ilen) EXIT LOOP                              ! everything is done
         INFINITE: do
            if(index(delims_local(:delimiters_length),line(icol:icol))==0)then           ! found non-delimiter
               istart=icol
               iend=0                                            ! FIND END OF SUBSTRING
               do i40=istart,ilen                                ! look at each character starting at left
                  if(index(delims_local(:delimiters_length),line(i40:i40))/=0)then       ! determine if character is a delimiter
                     iend=i40                                    ! found a delimiter. record where it was found
                     EXIT                                        ! found end of substring so leave loop
                  endif
               enddo
              if(iend==0)iend=ilen+1                           ! no delimiters found, so this substring goes to end of line
               iend=iend-1                                       ! do not want to pass delimiter to be converted
               rval=0.0
               call string_to_value(line(istart:iend),rval,ier)  ! call procedure to convert string to a numeric value
               if(ier==0)then                                  ! a substring was successfully converted to a numeric value
                  values(i10)=rval                               ! store numeric value in return array
                  inums=inums+1                                  ! increment number of values converted to a numeric value
               else                                              ! an error occurred converting string to value
                  ierr=istart                                    ! return starting position of substring that could not be converted
                  return
               endif
               icol=iend+2                                       ! set to next character to look at
               CYCLE LOOP                                        ! start looking for next value
            else                                                 ! this is a delimiter so keep looking for start of next string
               icol=icol+1                                       ! increment pointer into LINE
               CYCLE INFINITE
            endif
         enddo INFINITE
      enddo LOOP
!     error >>>>> more than iread numbers were in the line.
end subroutine string_to_values
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    transliterate(3f) - [M_strings:EDITING] replace characters from old set with new set
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    pure function transliterate(instr,old_set,new_set) result(outstr)
!!
!!     character(len=*),intent(in)  :: instr
!!     character(len=*),intent(in)  :: old_set
!!     character(len=*),intent(in)  :: new_set
!!     character(len=len(instr))    :: outstr
!!##DESCRIPTION
!!   Translate, squeeze, and/or delete characters from the input string.
!!
!!##OPTIONS
!!    instr    input string to change
!!    old_set  list of letters to change in INSTR if found
!!
!!             Each character in the input string that matches a character in
!!             the old set is replaced.
!!    new_set  list of letters to replace letters in OLD_SET with.
!!
!!             If the new_set is the empty set the matched characters are deleted.
!!
!!             If the new_set is shorter than the old set the last character in the
!!             new set is used to replace the remaining characters in the new set.
!!##RETURNS
!!    outstr   instr with substitutions applied
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_transliterate
!!
!!     use M_strings, only : transliterate
!!     implicit none
!!     character(len=80)   :: STRING
!!
!!     STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ'
!!     write(*,'(a)') STRING
!!
!!     ! convert a string to uppercase:
!!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','ABCDEFGHIJKLMNOPQRSTUVWXYZ')
!!
!!     ! change all miniscule letters to a colon (":"):
!!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz',':')
!!
!!     ! delete all miniscule letters
!!     write(*,*) TRANSLITERATE(STRING,'abcdefghijklmnopqrstuvwxyz','')
!!
!!     end program demo_transliterate
!!
!!    Expected output
!!
!!     > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
!!     > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ
!!     > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z
!!     > ABCDEFGHIJKLMNOPQRSTUVWXYZ
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
PURE FUNCTION transliterate(instr,old_set,new_set) RESULT(outstr)

!character(len=*),parameter::ident_16="@(#)M_strings::transliterate(3f): replace characters from old set with new set"

!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=*),INTENT(IN)  :: instr                             ! input string to change
CHARACTER(LEN=*),intent(in)  :: old_set
CHARACTER(LEN=*),intent(in)  :: new_set
!-----------------------------------------------------------------------------------------------------------------------------------
CHARACTER(LEN=LEN(instr))    :: outstr                            ! output string to generate
!-----------------------------------------------------------------------------------------------------------------------------------
INTEGER                      :: i10                               ! loop counter for stepping thru string
INTEGER                      :: ii,jj
!-----------------------------------------------------------------------------------------------------------------------------------
   jj=LEN(new_set)
   IF(jj /= 0)THEN
      outstr=instr                                                ! initially assume output string equals input string
      stepthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii /= 0)THEN
            if(ii<=jj)then                                      ! use corresponding character in new_set
               outstr(i10:i10) = new_set(ii:ii)
            else
               outstr(i10:i10) = new_set(jj:jj)                   ! new_set not as long as old_set; use last character in new_set
            endif
         ENDIF
      ENDDO stepthru
   else                                                           ! new_set is null string so delete characters in old_set
      outstr=' '
      hopthru: DO i10 = 1, LEN(instr)
         ii=iNDEX(old_set,instr(i10:i10))                         ! see if current character is in old_set
         IF (ii == 0)THEN                                         ! only keep characters not in old_set
            jj=jj+1
            outstr(jj:jj) = instr(i10:i10)
         ENDIF
      ENDDO hopthru
   endif
END FUNCTION transliterate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      v2s(3f) - [M_strings:NUMERIC] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       function v2s(value) result(outstr)
!!
!!        integer|real|doubleprecision|logical,intent(in ) :: value
!!        character(len=:),allocatable :: outstr
!!        character(len=*),optional,intent(in) :: fmt
!!
!!##DESCRIPTION
!!
!!   v2s(3f) returns a representation of a numeric value as a
!!   string when given a numeric value of type REAL, DOUBLEPRECISION,
!!   INTEGER or LOGICAL. It creates the strings using internal WRITE()
!!   statements. Trailing zeros are removed from non-zero values, and the
!!   string is left-justified.
!!
!!##OPTIONS
!!    VALUE   input value to be converted to a string
!!    FMT     format can be explicitly given, but is limited to
!!            generating a string of eighty or less characters.
!!
!!##RETURNS
!!    OUTSTR  returned string representing input value,
!!
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_v2s
!!     use M_strings, only: v2s
!!     write(*,*) 'The value of 3.0/4.0 is ['//v2s(3.0/4.0)//']'
!!     write(*,*) 'The value of 1234    is ['//v2s(1234)//']'
!!     write(*,*) 'The value of 0d0     is ['//v2s(0d0)//']'
!!     write(*,*) 'The value of .false. is ['//v2s(.false.)//']'
!!     write(*,*) 'The value of .true. is  ['//v2s(.true.)//']'
!!     end program demo_v2s
!!
!!    Expected output
!!
!!     The value of 3.0/4.0 is [0.75]
!!     The value of 1234    is [1234]
!!     The value of 0d0     is [0]
!!     The value of .false. is [F]
!!     The value of .true. is  [T]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
function d2s(dvalue,fmt) result(outstr)

!character(len=*),parameter::ident_45="@(#)M_strings::d2s(3fp): private function returns string given doubleprecision value"

doubleprecision,intent(in)   :: dvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(dvalue,string,fmt=fmt)
   else
      call value_to_string(dvalue,string)
   endif
   outstr=trim(string)
end function d2s
!===================================================================================================================================
function r2s(rvalue,fmt) result(outstr)

!character(len=*),parameter::ident_46="@(#)M_strings::r2s(3fp): private function returns string given real value"

real,intent(in)              :: rvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(rvalue,string,fmt=fmt)
   else
      call value_to_string(rvalue,string)
   endif
   outstr=trim(string)
end function r2s
!===================================================================================================================================
function i2s(ivalue,fmt) result(outstr)

!character(len=*),parameter::ident_47="@(#)M_strings::i2s(3fp): private function returns string given integer value"

integer,intent(in)           :: ivalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)            :: string
   if(present(fmt))then
      call value_to_string(ivalue,string,fmt=fmt)
   else
      call value_to_string(ivalue,string)
   endif
   outstr=trim(string)
end function i2s
!===================================================================================================================================
function l2s(lvalue,fmt) result(outstr)

!character(len=*),parameter::ident_48="@(#)M_strings::l2s(3fp): private function returns string given logical value"

logical,intent(in)           :: lvalue                         ! input value to convert to a string
character(len=*),intent(in),optional :: fmt
character(len=:),allocatable :: outstr                         ! output string to generate
character(len=80)             :: string
   if(present(fmt))then
      call value_to_string(lvalue,string,fmt=fmt)
   else
      call value_to_string(lvalue,string)
   endif
   outstr=trim(string)
end function l2s
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      value_to_string(3f) - [M_strings:NUMERIC] return numeric string from a numeric value
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine value_to_string(value,chars[,ilen,ierr,fmt,trimz])
!!
!!     character(len=*) :: chars  ! minimum of 23 characters required
!!     !--------
!!     ! VALUE may be any <em>one</em> of the following types:
!!     doubleprecision,intent(in)               :: value
!!     real,intent(in)                          :: value
!!     integer,intent(in)                       :: value
!!     logical,intent(in)                       :: value
!!     !--------
!!     character(len=*),intent(out)             :: chars
!!     integer,intent(out),optional             :: ilen
!!     integer,optional                         :: ierr
!!     character(len=*),intent(in),optional     :: fmt
!!     logical,intent(in)                       :: trimz
!!##DESCRIPTION
!!
!!   value_to_string(3f) returns a numeric representation of a numeric
!!   value in a string given a numeric value of type REAL, DOUBLEPRECISION,
!!   INTEGER or LOGICAL. It creates the string using internal writes. It
!!   then removes trailing zeros from non-zero values, and left-justifies
!!   the string.
!!
!!##OPTIONS
!!       VALUE   input value to be converted to a string
!!       FMT     You may specify a specific format that produces a string
!!               up to the length of CHARS; optional.
!!       TRIMZ   If a format is supplied the default is not to try to trim
!!               trailing zeros. Set TRIMZ to .true. to trim zeros from a
!!               string assumed to represent a simple numeric value.
!!
!!##RETURNS
!!       CHARS   returned string representing input value, must be at least
!!               23 characters long; or what is required by optional FMT if longer.
!!       ILEN    position of last non-blank character in returned string; optional.
!!       IERR    If not zero, error occurred; optional.
!!##EXAMPLES
!!
!!    Sample program:
!!
!!      program demo_value_to_string
!!      use M_strings, only: value_to_string
!!      implicit none
!!      character(len=80) :: string
!!      integer           :: ilen
!!         call value_to_string(3.0/4.0,string,ilen)
!!         write(*,*) 'The value is [',string(:ilen),']'
!!
!!         call value_to_string(3.0/4.0,string,ilen,fmt='')
!!         write(*,*) 'The value is [',string(:ilen),']'
!!
!!         call value_to_string(3.0/4.0,string,ilen,fmt='("THE VALUE IS ",g0)')
!!         write(*,*) 'The value is [',string(:ilen),']'
!!
!!         call value_to_string(1234,string,ilen)
!!         write(*,*) 'The value is [',string(:ilen),']'
!!
!!         call value_to_string(1.0d0/3.0d0,string,ilen)
!!         write(*,*) 'The value is [',string(:ilen),']'
!!
!!      end program demo_value_to_string
!!
!!    Expected output
!!
!!     The value is [0.75]
!!     The value is [      0.7500000000]
!!     The value is [THE VALUE IS .750000000]
!!     The value is [1234]
!!     The value is [0.33333333333333331]
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!===================================================================================================================================
subroutine value_to_string(gval,chars,length,err,fmt,trimz)

!character(len=*),parameter::ident_40="@(#)M_strings::value_to_string(3fp): subroutine returns a string from a value"

class(*),intent(in)                      :: gval
character(len=*),intent(out)             :: chars
integer,intent(out),optional             :: length
integer,optional                         :: err
integer                                  :: err_local
character(len=*),optional,intent(in)     :: fmt         ! format to write value with
logical,intent(in),optional              :: trimz
character(len=:),allocatable             :: fmt_local
character(len=1024)                      :: msg

!  Notice that the value GVAL can be any of several types ( INTEGER,REAL,DOUBLEPRECISION,LOGICAL)

   if (present(fmt)) then
      select type(gval)
      type is (integer)
         fmt_local='(i0)'
         if(fmt/='') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (real)
         fmt_local='(bz,g23.10e3)'
         fmt_local='(bz,g0.8)'
         if(fmt/='') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         fmt_local='(bz,g0)'
         if(fmt/='') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      type is (logical)
         fmt_local='(l1)'
         if(fmt/='') fmt_local=fmt
         write(chars,fmt_local,iostat=err_local,iomsg=msg)gval
      class default
         write(stderr,gen) '<ERROR>*value_to_string* - UNKNOWN TYPE'
         chars=' '
      end select
      if(fmt=='') then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   else                                                  ! no explicit format option present
      err_local=-1
      select type(gval)
      type is (integer)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (real)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (doubleprecision)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      type is (logical)
         write(chars,*,iostat=err_local,iomsg=msg)gval
      class default
         chars=''
      end select
      chars=adjustl(chars)
      if(index(chars,'.')/=0) call trimzeros(chars)
   endif
   if(present(trimz))then
      if(trimz)then
         chars=adjustl(chars)
         call trimzeros(chars)
      endif
   endif

   if(present(length)) then
      length=len_trim(chars)
   endif

   if(present(err)) then
      err=err_local
   elseif(err_local/=0)then
      !x! cannot currently do I/O from a function being called from I/O
      !x!write(ERROR_UNIT,'(a)')'*value_to_string* WARNING:['//trim(msg)//']'
      chars=chars//' *value_to_string* WARNING:['//trim(msg)//']'
   endif

end subroutine value_to_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    trimzeros(3fp) - [M_strings:NUMERIC] Delete trailing zeros from numeric decimal string
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    subroutine trimzeros(str)
!!
!!     character(len=*)  :: str
!!##DESCRIPTION
!!   TRIMZEROS(3f) deletes trailing zeros from a string representing a
!!   number. If the resulting string would end in a decimal point, one
!!   trailing zero is added.
!!##OPTIONS
!!    str   input string will be assumed to be a numeric value and have trailing
!!          zeros removed
!!##EXAMPLES
!!
!!    Sample program:
!!
!!       program demo_trimzeros
!!       use M_strings, only : trimzeros
!!       character(len=:),allocatable :: string
!!          write(*,*)trimzeros('123.450000000000')
!!          write(*,*)trimzeros('12345')
!!          write(*,*)trimzeros('12345.')
!!          write(*,*)trimzeros('12345.00e3')
!!       end program demo_trimzeros
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine trimzeros(string)

!character(len=*),parameter::ident_50="@(#)M_strings::trimzeros(3fp): Delete trailing zeros from numeric decimal string"

! if zero needs added at end assumes input string has room
character(len=*)             :: string
character(len=len(string)+2) :: str
character(len=len(string))   :: exp          ! the exponent string if present
integer                      :: ipos         ! where exponent letter appears if present
integer                      :: i, ii
   str=string                                ! working copy of string
   ipos=scan(str,'eEdD')                     ! find end of real number if string uses exponent notation
   if(ipos>0) then                           ! letter was found
      exp=str(ipos:)                         ! keep exponent string so it can be added back as a suffix
      str=str(1:ipos-1)                      ! just the real part, exponent removed will not have trailing zeros removed
   endif
   if(index(str,'.')==0)then               ! if no decimal character in original string add one to end of string
      ii=len_trim(str)
      str(ii+1:ii+1)='.'                     ! add decimal to end of string
   endif
   do i=len_trim(str),1,-1                   ! scanning from end find a non-zero character
      select case(str(i:i))
      case('0')                              ! found a trailing zero so keep trimming
         cycle
      case('.')                              ! found a decimal character at end of remaining string
         if(i<=1)then
            str='0'
         else
            str=str(1:i-1)
         endif
         exit
      case default
         str=str(1:i)                        ! found a non-zero character so trim string and exit
         exit
      end select
   end do
   if(ipos>0)then                            ! if originally had an exponent place it back on
      string=trim(str)//trim(exp)
   else
      string=str
   endif
end subroutine trimzeros
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!      string_to_value(3f) - [M_strings:NUMERIC] subroutine returns numeric value from string
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine string_to_value(chars,valu,ierr)
!!
!!     character(len=*),intent(in)              :: chars   ! input string
!!     integer|real|doubleprecision,intent(out) :: valu
!!     integer,intent(out)                      :: ierr
!!##DESCRIPTION
!!   returns a numeric value from a numeric character string.
!!
!!   works with any g-format input, including integer, real, and
!!   exponential. If the input string begins with "B", "Z", or "O"
!!   and otherwise represents a positive whole number it is assumed to
!!   be a binary, hexadecimal, or octal value. If the string contains
!!   commas they are removed. If the string is of the form NN:MMM... or
!!   NN#MMM then NN is assumed to be the base of the whole number.
!!
!!   if an error occurs in the READ, IOSTAT is returned in IERR and
!!   value is set to zero. if no error occurs, IERR=0.
!!##OPTIONS
!!       CHARS  input string to read numeric value from
!!##RETURNS
!!       VALU   numeric value returned. May be INTEGER, REAL, or DOUBLEPRECISION.
!!       IERR   error flag (0 == no error)
!!##EXAMPLES
!!
!!    Sample Program:
!!
!!     program demo_string_to_value
!!     use M_strings, only: string_to_value
!!     character(len=80) :: string
!!        string=' -40.5e-2 '
!!        call string_to_value(string,value,ierr)
!!        write(*,*) 'value of string ['//trim(string)//'] is ',value
!!     end program demo_string_to_value
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
subroutine a2r(chars,valu,ierr)
!>
!! subroutine returns real value from string

!character(len=*),parameter::ident_40="@(#)M_strings::a2r(3fp): subroutine returns real value from string"

character(len=*),intent(in) :: chars                      ! input string
real,intent(out)            :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(ierr==0)then
      if(valu8<=huge(valu))then
         valu=real(valu8)
      else
         write(stderr,gen) '<ERROR>*a2r* - value too large',valu8,'>',huge(valu)
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2r
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2i(chars,valu,ierr)
!>
!! subroutine returns integer value from string

!character(len=*),parameter::ident_41="@(#)M_strings::a2i(3fp): subroutine returns integer value from string"

character(len=*),intent(in) :: chars                      ! input string
integer,intent(out)         :: valu                       ! value read from input string
integer,intent(out)         :: ierr                       ! error flag (0 == no error)
doubleprecision             :: valu8
   valu8=0.0d0
   call a2d(chars,valu8,ierr,onerr=0.0d0)
   if(valu8<=huge(valu))then
      if(valu8<=huge(valu))then
         valu=int(valu8)
      else
         write(stderr,gen) '<ERROR>*a2i*','- value too large',valu8,'>',huge(valu)
         valu=huge(valu)
         ierr=-1
      endif
   endif
end subroutine a2i
!----------------------------------------------------------------------------------------------------------------------------------
subroutine a2d(chars,valu,ierr,onerr)
!>
!! subroutine returns doubleprecision value from string

!character(len=*),parameter::ident_42="@(#)M_strings::a2d(3fp): subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o  works with any g-format input, including integer, real, and exponential.
!  o  if an error occurs in the read, iostat is returned in ierr and value is set to zero.  if no error occurs, ierr=0.
!  o  if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!     IERR will still be non-zero in this case.
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)
class(*),optional,intent(in) :: onerr
!----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
integer                      :: intg
integer                      :: pnd
integer                      :: basevalue, ivalu
character(len=3),save        :: nan_string='NaN'
!----------------------------------------------------------------------------------------------------------------------------------
   ierr=0                                                       ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars)==0)local_chars=' '
   call substitute(local_chars,',','')                          ! remove any comma characters
   pnd=scan(local_chars,'#:')
   if(pnd/=0)then
      write(frmt,fmt)pnd-1                                      ! build format of form '(BN,Gn.0)'
      read(local_chars(:pnd-1),fmt=frmt,iostat=ierr,iomsg=msg)basevalue   ! try to read value from string
      if(decodebase(local_chars(pnd+1:),basevalue,ivalu))then
         valu=real(ivalu,kind=kind(0.0d0))
      else
         valu=0.0d0
         ierr=-1
      endif
   else
      select case(local_chars(1:1))
      case('z','Z','h','H')                                     ! assume hexadecimal
         frmt='(Z'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('b','B')                                             ! assume binary (base 2)
         frmt='(B'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case('o','O')                                             ! assume octal
         frmt='(O'//v2s(len(local_chars))//')'
         read(local_chars(2:),frmt,iostat=ierr,iomsg=msg)intg
         valu=dble(intg)
      case default
         write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
         read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
      end select
   endif
   if(ierr/=0)then                                            ! if an error occurred ierr will be non-zero.
      if(present(onerr))then
         select type(onerr)
         type is (integer)
            valu=onerr
         type is (real)
            valu=onerr
         type is (doubleprecision)
            valu=onerr
         end select
      else                                                      ! set return value to NaN
         read(nan_string,'(g3.3)')valu
      endif
      if(local_chars/='eod')then                           ! print warning message except for special value "eod"
         write(stderr,gen) '<ERROR>*a2d* - cannot produce number from string ['//trim(chars)//']'
         if(msg/='')then
            write(stderr,gen) '       *a2d* - ['//trim(msg)//']'
         endif
      endif
   endif
end subroutine a2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!
!!   decodebase(3f) - [M_strings:BASE] convert whole number string in base [2-36] to base 10 number
!!   (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function decodebase(string,basein,out10)
!!
!!     character(len=*),intent(in)  :: string
!!     integer,intent(in)           :: basein
!!     integer,intent(out)          :: out10
!!##DESCRIPTION
!!
!!   Convert a numeric string representing a whole number in base BASEIN
!!   to base 10. The function returns FALSE if BASEIN is not in the range
!!   [2..36] or if string STRING contains invalid characters in base BASEIN
!!   or if result OUT10 is too big
!!
!!   The letters A,B,...,Z represent 10,11,...,36 in the base > 10.
!!
!!##OPTIONS
!!    string   input string. It represents a whole number in
!!             the base specified by BASEIN unless BASEIN is set
!!             to zero. When BASEIN is zero STRING is assumed to
!!             be of the form BASE#VALUE where BASE represents
!!             the function normally provided by BASEIN.
!!    basein   base of input string; either 0 or from 2 to 36.
!!    out10    output value in base 10
!!
!!##EXAMPLES
!!
!!    Sample program:
!!
!!     program demo_decodebase
!!     use M_strings, only : codebase, decodebase
!!     implicit none
!!     integer           :: ba,bd
!!     character(len=40) :: x,y
!!     integer           :: r
!!
!!     print *,' BASE CONVERSION'
!!     write(*,'("Start   Base (2 to 36): ")',advance='no'); read *, bd
!!     write(*,'("Arrival Base (2 to 36): ")',advance='no'); read *, ba
!!     INFINITE: do
!!        print *,''
!!        write(*,'("Enter number in start base: ")',advance='no'); read *, x
!!        if(x=='0') exit INFINITE
!!        if(decodebase(x,bd,r)) then
!!           if(codebase(r,ba,y)) then
!!             write(*,'("In base ",I2,": ",A20)')  ba, y
!!           else
!!             print *,'Error in coding number.'
!!           endif
!!        else
!!           print *,'Error in decoding number.'
!!        endif
!!     enddo INFINITE
!!
!!     end program demo_decodebase
!!
!!##AUTHOR
!!    John S. Urban
!!
!!       Ref.: "Math matiques en Turbo-Pascal by
!!              M. Ducamp and A. Reverchon (2),
!!              Eyrolles, Paris, 1988".
!!
!!    based on a F90 Version By J-P Moreau (www.jpmoreau.fr)
!!
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
logical function decodebase(string,basein,out_baseten)

!character(len=*),parameter::ident_72="@(#)M_strings::decodebase(3f): convert whole number string in base [2-36] to base 10 number"

character(len=*),intent(in)  :: string
integer,intent(in)           :: basein
integer,intent(out)          :: out_baseten

character(len=len(string))   :: string_local
integer           :: long, i, j, k
real              :: y
real              :: mult
character(len=1)  :: ch
real,parameter    :: XMAXREAL=real(huge(1))
integer           :: out_sign
integer           :: basein_local
integer           :: ipound
integer           :: ierr

  string_local=upper(trim(adjustl(string)))
  decodebase=.false.

  ipound=index(string_local,'#')                                       ! determine if in form [-]base#whole
  if(basein==0.and.ipound>1)then                                  ! split string into two values
     call string_to_value(string_local(:ipound-1),basein_local,ierr)   ! get the decimal value of the base
     string_local=string_local(ipound+1:)                              ! now that base is known make string just the value
     if(basein_local>=0)then                                         ! allow for a negative sign prefix
        out_sign=1
     else
        out_sign=-1
     endif
     basein_local=abs(basein_local)
  else                                                                 ! assume string is a simple positive value
     basein_local=abs(basein)
     out_sign=1
  endif

  out_baseten=0
  y=0.0
  ALL: if(basein_local<2.or.basein_local>36) then
    print gen,'(*decodebase* ERROR: Base must be between 2 and 36. base=',basein_local
  else ALL
     out_baseten=0;y=0.0; mult=1.0
     long=LEN_TRIM(string_local)
     do i=1, long
        k=long+1-i
        ch=string_local(k:k)
        if(ch=='-'.and.k==1)then
           out_sign=-1
           cycle
        endif
        if(ch<'0'.or.ch>'Z'.or.(ch>'9'.and.ch<'A'))then
           write(stderr,*)'<ERROR>*decodebase* - invalid character ',ch
           exit ALL
        endif
        if(ch<='9') then
              j=IACHAR(ch)-IACHAR('0')
        else
              j=IACHAR(ch)-IACHAR('A')+10
        endif
        if(j>=basein_local)then
           exit ALL
        endif
        y=y+mult*j
        if(mult>XMAXREAL/basein_local)then
           exit ALL
        endif
        mult=mult*basein_local
     enddo
     decodebase=.true.
     out_baseten=nint(out_sign*y)*sign(1,basein)
  endif ALL
end function decodebase
end module M_time__duplicate

!>>>>> build/dependencies/M_framework/src/M_framework__journal.f90
!>
!!##NAME
!!     M_framework__journal(3fm) - [M_framework__journal::INTRO] write
!!     program messages to stdout and/or
!!     a log file
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!     use, M_framework__journal , only : journal
!!##DESCRIPTION
!!
!!    For large interactive programs in particular it is useful if all
!!    messages go thru a JOURNAL(3f) call. This makes it easy to
!!    write messages to a log file as well as standard output; to toggle
!!    time prefixes on and off; to turn on and off debug-mode messages;
!!    control output paging and create replayable input journals.
!!
!!    The primary use of JOURNAL(3f) is to create journal files for
!!    interactive programs that
!!
!!        + provide various levels of verbosity on demand, often for
!!          debugging purposes.
!!        + can be replayed even when interactive input was provided
!!        + and/or be used to verify program executions
!!
!!    Typically, you would echo what the user typed to the trail file as-is,
!!    and write output you write to stdout as comments to the trail file so
!!    that the trail file can easily be read back in (by ignoring comments).
!!
!!    Even though there is essentially one procedure (journal(3f) calls
!!    that are more than just a single message have an action specified as
!!    the first parameter. This action might specify to open a log file, to
!!    change the "level" required by messages for them to appear, whether
!!    output it written as a comment or not, and on what files the output
!!    should appear. So the interface can be used in a very simple manner
!!    but has more options than is evident at first glance, as detailed in
!!    the man-page for journal(3f).
!!
!!    to stdout is written with WHERE='SC' in the JOURNAL(3f) call.
!!
!!     >      :
!!     >      :
!!     > call journal('O','my_trail_file')  ! open trail file
!!     > ! write output to stdout as-is and as comment to trail file
!!     > call journal(output)
!!     > ! echo message to trail/log file only
!!     > call journal('T',userline)
!!     > ! write to stdout as-is and trail as a comment.
!!     > ! up to twenty scalar values of any intrinsic type are allowed
!!     > call journal('SC','i1=',i1,'i2=',i2,'i3=',i3)
!!     > ! for more complex messages you can build them with non-advancing
!!     > ! I/O journal calls, or build the message with internal writes
!!     > ! into a string and print that.
!!
!!       I=10
!!       R=20.3
!!       ! write to stdout and trail file without advancing I/O
!!       call journal('+SC','I=',i)
!!       ! write to stdout and trail file without advancing I/O
!!       call journal('SC','AND R=',r)
!!
!!    writes to the trail file(s) are ignored unless a trail file was opened,
!!    but output continues to stdout by default.
!!
!!    That is, destinations 'T' and 'C' are ignored unless a trail file
!!    has been requested, allowing journal to be used with programs that
!!    do not generate trails or journals.
!!
!!    Note that with no parameters, the trail file is flushed.
!!
!!##EXAMPLES
!!
!!
!!    The man-page for journal(3f) describes all the options for the
!!    action field WHERE.  In addition to being used to generate a journal,
!!    the routine can be used for producing optional debug messages and
!!    timing information.
!!
!!    Sample program for debug messages:
!!
!!      program demo_journal
!!      !! showing creating debug messages
!!      use M_framework__journal, only : journal
!!      implicit none
!!      !! produces no output because trail is not on
!!      call journal('D','*demo* DEBUG MESSAGE 001 IGNORED')
!!      !! turn on debug messages
!!      call journal('>','debug on')
!!      !! produces output on stdout because debug mode
!!      !! is on but no named trail file
!!      call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT')
!!      !! open trail file
!!      call journal('O','mytrail.txt')
!!      !! debug messages now go to the trail file only
!!      call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL')
!!      !! or always to stdout and trail file only if on
!!      call journal('DS','*demo* DEBUG MESSAGE 003 TO TRAIL')
!!      !! close trail file so messages go only to stdout again
!!      call journal('O','')
!!      !! debug on stdout now
!!      call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT')
!!      !! turn off debug messages
!!      call journal('<','debug off')
!!      !! back to no output from the next message
!!      call journal('D','*demo* DEBUG MESSAGE 005 IGNORED')
!!      end program demo_journal
!!
!!
!!   Sample program for trail messages with optional timing information:
!!
!!      program testit
!!      use M_framework__journal,only : journal
!!      implicit none
!!      call journal('a single string A -should be on S')
!!
!!      ! add time prefix to output
!!      call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b')
!!      !
!!      call journal('a single string B -should be on S with prefix')
!!      ! change to CPU time and number of calls prefix
!!      call journal('%','CPU_TIME: %c:CALLS: %C: %b')
!!      !
!!      call journal('a single string B-1 -should be on S with prefix')
!!      call journal('a single string B-2 -should be on S with prefix')
!!      call journal('a single string B-3 -should be on S with prefix')
!!      !  Other useful time formats:
!!      !     %E -- Unix Epoch time
!!      !     %e -- integer value of Unix Epoch time
!!      !     %C -- number of times this format is used
!!      !     %c -- CPU_time(3f) output
!!      !     %S -- seconds since last use of this format
!!      !     %k -- CPU time in seconds from system_clock
!!      call journal('%','') ! turn off time prefix
!!      !
!!      call journal('a single string C -should be on S')
!!      !
!!      call journal('O','aaa.out') ! turn on trail file
!!      call journal('a single string D -should be on SC')
!!      call journal('a single string E -should be on SC')
!!      call journal('a single string F -should be on SC')
!!      call journal('O','') ! turn off trail file
!!      !
!!      call journal('a single string G -should be on S')
!!      call journal('a single string H -should be on S')
!!      call journal('a single string I -should be on S')
!!
!!      ! build one line of output with intrinsic scalar values added
!!      call journal('+sc','APPEND:')
!!      call journal('+sc',' integer',         1234)
!!      call journal('+sc',' and real',        1234.5678)
!!      call journal('+sc',' and double',1234567890.123456d0)
!!      call journal('+sc',' and logical',    .true.)
!!      call journal('sc','')
!!      !
!!      end program testit
!!
!!##AUTHOR
!!     John S. Urban
!!##LICENSE
!!     Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_framework__journal
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT     ! access computing environment
use :: M_framework__msg,                      only : str
implicit none
private

!>
!!##NAME
!!      journal(3f) - [M_framework__journal] provides public message routine, no paging or graphic mode change
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!    subroutine journal([where,],[VALUE(s)])
!!
!!     character(len=*),intent(in) :: where
!!     class(*),optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!
!!   WRITE MESSAGES
!!    basic messages
!!
!!       call journal(where,[VALUE(S)])
!!       call journal(message) # a shortcut for "call journal('sc',message)":
!!   OPEN OR CLOSE TRAIL FILE
!!    trail file
!!
!!       call journal('O',trailfile_name) # open trail file
!!       call journal('O','')             # close trail file
!!   SET OUTPUT TIME PREFIX
!!    set the function display format for timestamps. See the NOW(3f)
!!    procedure for allowable timestamp macros
!!
!!       call journal('%',time_stamp_prefix_specification)
!!
!!   MODES
!!
!!    Turn on/off writing DEBUG messages to trail file
!!
!!       call journal('>','debug on') # turn on debug mode
!!       call journal('<','debug off') # turn off debug mode
!!
!!   ASSIGN STDOUT TO AN ALTERNATE FILE
!!    change stdout to iunit and open filename; or close unit and go back to stdout if filename=''
!!
!!       call journal(iunit,filename)
!!
!!    change stdout to iunit to use a file already open
!!
!!       call journal(iunit)
!!
!!##DESCRIPTION
!!
!!    If a user procedure is used for outputting messages instead of calling
!!    WRITE(3f) it is easy to provide control of when messages are printed
!!    (ie. a "verbose" mode, or "quite" mode), creating files to replay
!!    program execution, duplicating output, ...
!!
!!##OPTIONS
!!   WHERE  indicates where messages are written. A combination of the
!!          following characters can be used...
!!
!!      Usually one of these to write to the standard output files ...
!!
!!      S   write to stdout or iounit set with journal(unit) or
!!          journal(unit,filename).
!!      E   write to stderr
!!
!!      And one of these to write to trail file (ignore if no trail file
!!      defined) ...
!!
!!      C   write to trail file as a comment (if file is open)
!!          Writing output "as a comment" means it is preceded by a pound(#)
!!          character.
!!      T   write to trail file (if file is open)
!!
!!      Usually used by itself
!!
!!      D   write to trail file as a comment with "DEBUG:" prefix in front
!!          of message (if file is open) if debug mode is on. Write to stdout
!!          if no trail file and debug mode is on.
!!
!!      Modifier for S|E|C|T|D specifiers
!!
!!      +   subsequent files are written to with advance='no'. Position is
!!          important. '+sc' does an advance='no' on both files, 's+c'
!!          only does the advance='no' for the trail file.
!!
!!      Mode changing options used by themselves:
!!
!!      >   turn off debug messages
!!      <   turn on debug messages
!!      O   open trail file using value of "message" parameter or close
!!          trail file if no filename or a blank filename.
!!      A   Auxiliary programs that also want to write to the current log file
!!          (a2b, z2a, ...) call this routine to see if there is a trail file
!!          being generated and then add to it so that a program like ush(1f)
!!          can call the auxiliary programs and still just generate one log file,
!!          but if the auxiliary program is used as a stand-alone program no trail
!!          is generated.
!!
!!   VALUES(S)   message to write to stdout, stderr, and the trail file.
!!               a numeric or character value to optionally be appended
!!               to the message. Up to twenty values are allowed. The WHERE
!!               field is required if there is anything other than a single
!!               character string or not values at all.
!!   FILENAME    when WHERE="O" to turn the trail file on or off, the "message"
!!               field becomes the trail filename to open. If blank, writing
!!               to the trail file is turned off.
!!   TIMEFORMAT  when WHERE="%" the message is treated as a time format
!!               specification as described under now(3f).
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_journal
!!    use M_framework__journal, only : journal
!!    !! BASIC USAGE
!!    call journal(&
!!    & 'write to standard output as-is, and trail file as a comment if open')
!!    ! since trail file is not yet open, only stdout will display output
!!    call journal('c','ignored, as trail file is not open')
!!    ! now open trail file "trail"
!!    call journal('o','trail')
!!    call journal('sc','same thing except now trail file is open')
!!    ! only write to trail file if open
!!    call journal('c',&
!!    & 'not ignored, as trail file is open. Written with # suffix')
!!    call journal('t',&
!!    & 'not ignored, as trail file is open. Written as-is')
!!    ! turn off trail file
!!    call journal('o','')
!!    end program demo_journal
!!
!!   Adding intrinsic scalar values to the message:
!!
!!    program test_journal
!!    use M_framework__journal, only: journal
!!    implicit none
!!       call journal('S','This is a test with no optional value')
!!       call journal('S','This is a test with a logical value',.true.)
!!       call journal('S', &
!!         & 'This is a test with a double value',1234567890.123456789d0)
!!       call journal('S', &
!!         & 'This is a test with a real value',1234567890.123456789)
!!       call journal('S','This is a test with an integer value',1234567890)
!!       call journal('STDC','This is a test using STDC',1234567890)
!!       call journal('stdc','This is a test using stdc',1234567890)
!!       call journal('o','journal.txt')  ! open trail file
!!       call journal('S', &
!!         & 1,12.34,56789.111111111d0,.false.,'a bunch of values')
!!       ! the combinations that make sense
!!       call journal('st','stdout and trail')
!!       call journal('s' ,'stdout only')
!!       call journal('t' ,'trail only')
!!       call journal('sc','stdout and trail_comment')
!!       call journal('c' ,'trail_comment only ')
!!       call journal('d' ,'debug only')
!!       call journal('e' ,'stderr only')
!!       call journal('o' ,' ') ! closing trail file
!!    end program test_journal
!!
!!    program testit
!!    ! this is a utility program that calls the module routines. It is
!!    ! typically built using ccall(1).
!!    use M_framework__journal, only : journal
!!    character(len=:),allocatable :: time_stamp_prefix
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES')
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() but did not generate a log file')
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES WITH LOG FILE')
!!     call journal('o','journal.txt')     ! open trail file
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() and generated log file journal.txt')
!!     call journal('','journal.txt')      ! close trail file
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!     call journal('s','SIMPLE WRITES WITH TIMING INFORMATION')
!!     ! change time prefix
!!     time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b'
!!     call journal('%',time_stamp_prefix) ! set a message time prefix
!!     call journal('o','timed.txt')       ! open trail file
!!     call one()
!!     call two()
!!     call journal('sc', &
!!     & 'called ONE() and TWO() and generate log file timed.txt')
!!     call journal('','timed.txt')        ! close trail file
!!     call journal('%','')                ! turn off time prefix
!!     call journal('o','timed.txt')       ! open trail file
!!     call journal('s', &
!!     & '------------------------------------------------------------')
!!
!!    contains
!!
!!       subroutine two()
!!          call journal('Entered subroutine two')
!!          call journal('Exited subroutine two')
!!       end subroutine two
!!
!!       subroutine one()
!!          call journal('Entered subroutine one')
!!          sum=-HUGE(1.0)
!!          do i=1,10000000
!!            sum=sum+sqrt(real(i))
!!          enddo
!!          write(*,*)'SUM=',sum
!!          call journal('Exited subroutine one')
!!       end subroutine one
!!
!!    end program testit
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
public journal

interface journal
   module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

! ident_1="@(#) M_framework__journal journal(3fg) provides public message routine no paging or graphic mode change"

! global variables

!integer,parameter,private  :: stdin=INPUT_UNIT
integer,save,private       :: my_stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0

integer,parameter,private :: dp=kind(0.0d0)
real(kind=dp)             :: secday=86400.0d0              ! 24:00:00 hours as seconds

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

! ident_2="@(#) M_framework__journal where_write_message(3fp) basic message routine used for journal files"

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
!
!  writes error messages and general information text to stdout and the trace file
!     where=*C* write to trail file as a comment (if file is open)
!     where=*D* write to trail file as a comment with DEBUG: prefix in front of message (if file is open and debug mode on)
!     where=*E* write to stderr
!     where=*S* write to stdout or iounit set with journal(unit) or journal(unit,filename)
!     where=*T* write to trail file (if file is open)
!     where=*+* subsequent writes for this call are written with advance='no'

!     where=> turn on debug messages (change mode), which are ones with WHERE='D'
!     where=< turn off debug messages  (change mode), which are ones with WHERE='D'

!     where=O open trail file "msg" or close trail file if blank filename is given
!     where=% set prefix to run thru now(3f) to generate time prefix strings, blank turns off time prefix
!     where=N open new file and assign stdout to the file unless file name is blank; then revert to my_stdout being original stdout.
!
!  the trail file messages are preceded by a pound character (#) by default so they can easily be interpreted as comments
!  if the trace file is subsequently used as input data for a program
!
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save  :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable       :: prefix            ! the prefix string to add to output
logical,save                       :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)                :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   if(prefix_it)then
      prefix=now_ex(prefix_template)
   else
      prefix=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
         !!elseif(times == 0)then
         !!   write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         !!   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)prefix,trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()

! ident_3="@(#) M_framework__journal flush_trail(3fp) flush trail file"

call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_stdout_lun(iounit)

! ident_4="@(#) M_framework__journal set_stdout_lun(3fp) change I/O logical unit value for standard writes"

integer,intent(in)                   :: iounit
   my_stdout=iounit
end subroutine set_stdout_lun
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    where_write_message_all(3f) - [M_framework__journal] converts any
!!    standard scalar type to a string and calls journal(3f)
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine where_write_message_all(where,g0,g1,g2,..,gj,sep)
!!
!!     character(len=*),intent(in)   :: where
!!     class(*),intent(in)           :: g0
!!     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     class(*),intent(in),optional  :: ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     character,intent(in),optional :: sep
!!
!!##DESCRIPTION
!!    where_write_message_all(3f) builds and writes a space-separated string
!!    from up to twenty scalar values.
!!
!!##OPTIONS
!!
!!    where       string designating where to write message, as with journal(3f)
!!    g0          value to print. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!                or CHARACTER.
!!    g[1-9a-j]   optional additional values to print the value of after g0.
!!    sep         separator to add between values. Default is a space. Should
!!                always be called with a keyword, as in "sep=VALUE".
!!##RETURNS
!!    where_write_message_all  description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wm_all
!!    use M_framework__journal, only : where_write_message_all
!!    implicit none
!!    end program program demo_wm_all
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine where_write_message_all(where,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,sep)
implicit none

! ident_5="@(#) M_framework__journal where_write_message_all(3f) writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
class(*),intent(in),optional  :: ga, gb, gc, gd, ge, gf, gg, gh, gi, gj
character,intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, ga, gb, gc, gd, ge, gf, gg, gh, gi, gj, sep=sep))
end subroutine where_write_message_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

! ident_6="@(#) M_framework__journal write_message_only(3fp) calls JOURNAL('sc' message)"

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2j(dat,julian,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
! * Author:    John S. Urban
! * Version:   1.0 2015-12-21
! * Reference: From Wikipedia, the free encyclopedia 2015-12-19
! * There is no year zero
! * Julian Day must be non-negative
! * Julian Day starts at noon; while Civil Calendar date starts at midnight
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_7="@(#) d2j(3f) Converts proleptic Gregorian date array to Julian Day"
integer,intent(in)         :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
real(kind=dp),intent(out)  :: julian   ! Julian Day (non-negative, but may be non-integer)
integer,intent(out)        :: ierr     ! Error return, 0 for successful execution,-1=invalid year,-2=invalid month,-3=invalid day,
                                       ! -4=invalid date (29th Feb, non leap-year)
   integer                 :: year, month, day, utc, hour, minute
   real(kind=dp)           :: second
   integer                 :: A, Y, M, JDN
!-----------------------------------------------------------------------------------------------------------------------------------
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0d0    ! Second   ! correction for time zone and milliseconds
!-----------------------------------------------------------------------------------------------------------------------------------
   julian = -HUGE(99999)                  ! this is the date if an error occurs and IERR is < 0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(year==0 .or. year .lt. -4713) then
      ierr=-1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or Febuary, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for Febuary
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian date given the JDN (Julian day number) and time of day
   julian=JDN + dble(hour-12)/24.0d0 + dble(minute)/1440.0d0 + second/86400.0d0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(julian.lt.0.d0) then                  ! Julian Day must be non-negative
      ierr=1
   else
      ierr=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine d2j
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2u(dat,unixtime,ierr)
! ident_8="@(#) d2u(3f) Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970)"
integer,intent(in)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
real(kind=dp),intent(out)  :: unixtime                ! Unix time (seconds)
integer,intent(out)        :: ierr                    ! return 0 on successful, otherwise 1
   real(kind=dp)           :: julian
   real(kind=dp),save      :: julian_at_epoch
   logical,save            :: first=.true.
!-----------------------------------------------------------------------------------------------------------------------------------
if(first) then                                        ! Compute zero of Unix Time in Julian days and save
   call d2j([1970,1,1,0,0,0,0,0],julian_at_epoch,ierr)
   if(ierr.ne.0) return                               ! Error
   first=.false.
endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call d2j(dat,julian,ierr)
   if(ierr.ne.0) return                               ! Error
   unixtime=(julian-julian_at_epoch)*secday
end subroutine d2u
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION d2o(dat) RESULT (ordinal)
! ident_9="@(#) d2o(3f) Converts date-time array to Ordinal day"
INTEGER,INTENT(IN)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
INTEGER                    :: ordinal                 ! the returned number of days
   REAL(KIND=dp)           :: unixtime                ! Unix time (seconds)
   REAL(KIND=dp)           :: unix_first_day
   INTEGER                 :: ierr                    ! return 0 on successful, otherwise 1 from d2u(3f)
   CALL d2u(dat,unixtime,ierr)                        ! convert date to Unix Epoch Time
   IF(ierr.NE.0)THEN
      write(*,*)'*d2o* bad date array'
      ordinal=-1                                      ! initialize to bad value
   ELSE
      CALL d2u([dat(1),1,1,dat(4),0,0,0,0],unix_first_day,ierr)
      ordinal=int((unixtime-unix_first_day)/secday)+1
   ENDIF
END FUNCTION d2o
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION v2mo(imonth) RESULT(month_name)
! ident_10="@(#) v2mo(3f) returns the month name of a Common month"
CHARACTER(LEN=:),ALLOCATABLE :: month_name                                        ! string containing month name or abbreviation.
INTEGER,INTENT(IN)           :: imonth                                            ! the number of the month(1-12)
CHARACTER(LEN=*),PARAMETER   :: names(12)=[ character(len=9) ::  &
&'January  ', 'February ', 'March    ', 'April    ', 'May      ', 'June     ', &
&'July     ', 'August   ', 'September', 'October  ', 'November ', 'December ']
   SELECT CASE(imonth)
   CASE (1:12);  month_name=TRIM(names(imonth))
   CASE DEFAULT; month_name='UNKNOWN'
   END SELECT
END FUNCTION v2mo
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION now(format)
! ident_11="@(#) JSU 2015-10-24"
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: format
CHARACTER(LEN=:),ALLOCATABLE         :: now
   INTEGER                           :: values(8)
!-----------------------------------------------------------------------------------------------------------------------------------
   CALL DATE_AND_TIME(VALUES=values)
   IF(PRESENT(format))THEN
      IF(format.NE.' ')THEN
         now=fmtdate(values,format)
      ELSE
         now=fmtdate(values,'%Y-%M-%D %h:%m:%s %z')
      ENDIF
   ELSE
      NOW=fmtdate(values,'%Y-%M-%D %h:%m:%s %z Julian date is %J Epoch time is %E ')
   ENDIF
END FUNCTION now
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION fmtdate(values,format) RESULT (timestring)
! Read the FORMAT string and replace the "%" strings per the following rules:
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_12="@(#) fmtdate(3f) given date array return date as string using format"
CHARACTER(LEN=*),INTENT(IN)     :: format    ! input format string
INTEGER,DIMENSION(8),INTENT(IN) :: values    ! numeric time values as DATE_AND_TIME(3f) intrinsic returns
CHARACTER(LEN=:),ALLOCATABLE    :: timestring
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   INTEGER              :: i10
   LOGICAL              :: keyword   ! flag that previous character was a % character
   CHARACTER(LEN=9)     :: day       ! day of week
   CHARACTER(LEN=1)     :: chara     ! character being looked at in format string
   CHARACTER(LEN=4096)  :: text      ! character array
   INTEGER              :: iout
   INTEGER              :: weekday
   INTEGER              :: ierr
   INTEGER,SAVE         :: called=0
   LOGICAL,SAVE         :: since=.FALSE.
   REAL(KIND=dp)        :: julian
   REAL(KIND=dp)        :: cputime
   INTEGER              :: ii
   REAL(KIND=dp)        :: unixtime
   REAL(KIND=dp),save   :: unixtime_last
   INTEGER              :: systemclock, countrate
   INTEGER              :: iso_year, iso_week, iso_weekday
   CHARACTER(LEN=10)    :: iso_name
   CHARACTER(LEN=2)     :: dayend

   text=' '
!  write string, when encounter a percent character do a substitution
   keyword=.FALSE.
   iout=1
   DO i10=1,LEN(format)
      chara=format(i10:i10)
      IF(chara.eq.'%'.and..not.keyword)THEN
            keyword=.TRUE.
            CYCLE
      ENDIF
      IF(keyword)THEN
         keyword=.FALSE.
         SELECT CASE(chara)
         !=====================================================================================
         CASE('%'); WRITE(text(iout:),'(A1)')chara                        ! literal percent character
         !=====================================================================================
         CASE('b'); WRITE(text(iout:),'(A1)')' '                          ! space character
         !=====================================================================================
         CASE('c'); CALL cpu_time(cputime)                                ! CPU_TIME()
                    WRITE(text(iout:),'(G0)')cputime
         !=====================================================================================
         CASE('C'); called = called + 1                                   ! number of times this routine called
                    WRITE(text(iout:),'(I0)')called
         !=====================================================================================
         CASE('d');                                                       ! the day of the month 1st..31st
                    dayend='  '
                    select case(values(3))
                    case(1,21,31); dayend='st'
                    case(2,22); dayend='nd'
                    case(3,23); dayend='rd'
                    case(4:20,24:30); dayend='th'
                    case default
                    end select
                    WRITE(text(iout:),'(I2,a)')values(3),dayend
         !=====================================================================================
         CASE('D'); WRITE(text(iout:),'(I2.2)')values(3)                  ! the day of the month 1..31
         !=====================================================================================
         CASE('e'); CALL d2u(values,unixtime,ierr)                        ! integer Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')int(unixtime)
         !=====================================================================================
         CASE('E'); CALL d2u(values,unixtime,ierr)                        ! Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')unixtime
         !=====================================================================================
         CASE('h'); WRITE(text(iout:),'(I2.2)')values(5)                  ! the hour of the day, in the range of 0 to 23
         !=====================================================================================
         CASE('H'); ii=mod(values(5),12)                                  ! hour of day in range 1..12
                    if(ii.eq.0)then
                       ii=12
                    endif
                    WRITE(text(iout:),'(I2.2)')ii
         !=====================================================================================
         CASE('i'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! ISO week of year
                    WRITE(text(iout:),'(I0)')iso_week
         !=====================================================================================
         CASE('I'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! iso-8601 Week-numbering year date
                    WRITE(text(iout:),'(a)')iso_name
         !=====================================================================================
         CASE('j'); CALL d2j(values,julian,ierr)                          ! integer Julian date (truncated to integer)
                    WRITE(text(iout:),'(I0)')int(julian)
         !=====================================================================================
         CASE('J'); CALL d2j(values,julian,ierr)                          ! Julian date to milliseconds
                    WRITE(text(iout:),'(I0,".",i3.3)')int(julian),int((julian-int(julian))*1000.0)
         !=====================================================================================
         CASE('k'); call system_clock(count=systemclock,count_rate=countrate)  ! systemclock/countrate
                    WRITE(text(iout:),'(G0)')real(systemclock)/countrate
         !=====================================================================================
         CASE('l'); WRITE(text(iout:),'(A3)')v2mo(values(2))              ! three characters of the name of the month of the year
         !=====================================================================================
         CASE('L'); WRITE(text(iout:),'(A)')v2mo(values(2))               ! name of the month of the year
         !=====================================================================================
         CASE('m'); WRITE(text(iout:),'(I2.2)')values(6)                  ! the minutes of the hour, in the range 0 to 59
         !=====================================================================================
         CASE('M'); WRITE(text(iout:),'(I2.2)')values(2)                  ! month of year (1..12)
         !=====================================================================================
         CASE('N'); if( values(5).ge.12)then                              ! AM||PM
                       WRITE(text(iout:),'("PM")')
                    else
                       WRITE(text(iout:),'("AM")')
                    endif
         !=====================================================================================
         CASE('O'); WRITE(text(iout:),'(I3.3)')d2o(values)                ! Ordinal day of year
         !=====================================================================================
         CASE('s'); WRITE(text(iout:),'(I2.2)')values(7)                  ! the seconds of the minute, in the range 0 to 60
         !=====================================================================================
         CASE('S'); IF(.NOT.since)THEN                                    ! seconds since last called
                       since=.TRUE.
                       CALL d2u(values,unixtime_last,ierr)
                    ENDIF
                    CALL d2u(values,unixtime,ierr)
                    WRITE(text(iout:),'(G0)')unixtime-unixtime_last
                    unixtime_last=unixtime
         !=====================================================================================
         CASE('t'); WRITE(text(iout:),'(A1)')CHAR(9)                      ! tab character
         !=====================================================================================
         CASE('U'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Sunday=1
                    WRITE(text(iout:),'(I1)')weekday
         !=====================================================================================
         CASE('u'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Monday=1
                    WRITE(text(iout:),'(I1)')mod(weekday+5,7)+1
         !=====================================================================================
         CASE('W'); CALL dow(values,weekday,day,ierr)                     ! Return the name of the day of the week
                    WRITE(text(iout:),'(a)')day
         !=====================================================================================
         CASE('w'); CALL dow(values,weekday,day,ierr)                     ! Return the first three characters of the day of the week
                    WRITE(text(iout:),'(A3)')day(1:3)
         !=====================================================================================
         CASE('x'); WRITE(text(iout:),'(I3.3)')values(8)                  ! the milliseconds of the second, in the range 0 to 999
         !=====================================================================================
         CASE('Y'); WRITE(text(iout:),'(I4.4)')values(1)                  ! the year, including the century (for example, 1990)
         !=====================================================================================
         CASE('Z'); WRITE(text(iout:),'(SP,I5.4)')values(4)               ! time difference with respect to UTC in minutes
         !=====================================================================================
         CASE('z'); WRITE(text(iout:),'(I3.2,":",I2.2)')int(values(4)/60),abs(mod(values(4),60)) ! time from UTC as +-hh:mm
         !=====================================================================================
         CASE DEFAULT
            WRITE(text(iout:),'(A1)')chara
         !=====================================================================================
         END SELECT
         !=====================================================================================
         iout=len_trim(text)+1
      ELSE
         WRITE(text(iout:),'(A1)')chara;iout=iout+1
      ENDIF
   ENDDO
   timestring=trim(text)
END FUNCTION fmtdate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine dow(values, weekday, day, ierr)
! ident_13="@(#) dow(3f) Return the day of the week"
real(kind=dp)                      :: julian    ! the julian day for which the weekday is required,
integer,intent(in)                 :: values(8) ! date and time array used to get time zone
integer,intent(out),optional       :: weekday   ! The day of the week, 1 = Sunday
character*(*),intent(out),optional :: day       ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9
integer,intent(out)                :: ierr      ! Error return,0=correct,-1=invalid Julian day,-2=neither day nor weekday specified
   integer                         :: iweekday

   call d2j(values,julian,ierr)                 ! need julian date to calculate day of week for first day of month
   ierr = 0

   if(julian < 0) then
      ierr = -1
      return
   endif

   if(.not.present(day).and. .not.present(weekday)) then
      ierr=-2
      return
   endif

   ! julian day starts at noon so add 1/2 day
   ! add time zone
   iweekday = mod(int((julian+dble(values(4)/60.0d0/24.0d0)+0.5d0)+1.0d0), 7)
   iweekday = iweekday +1

   if(present(day)) then
      select case(iweekday)
      case(1)     ;day = 'Sunday'
      case(2)     ;day = 'Monday'
      case(3)     ;day = 'Tuesday'
      case(4)     ;day = 'Wednesday'
      case(5)     ;day = 'Thursday'
      case(6)     ;day = 'Friday'
      case(7)     ;day = 'Saturday'
      case default;day = 'E-R-R-O-R'
      end select
   endif

   if(present(weekday))then
      weekday=iweekday
   endif

end subroutine dow
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine woy(dat,iso_year,iso_week,iso_weekday,iso_name)
!-----------------------------------------------------------------------------------------------------------------------------------
!  The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO).
!  It is used (mainly) in government and business for fiscal years, as well as in timekeeping.
!  The system specifies a week year atop the Gregorian calendar by defining a notation for ordinal weeks of the year.
!
!  An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks.
!  That is 364 or 371 days instead of the usual 365 or 366 days.
!  The extra week is referred to here as a leap week, although ISO 8601 does not use this term.
!  Weeks start with Monday.
!  The first week of a year is the week that contains the first Thursday of the year (and, hence, always contains 4 January).
!  ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January.
!-----------------------------------------------------------------------------------------------------------------------------------
!CALCULATION:
!  The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year)
!  and its day of the week.

!METHOD:
!   Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday),
!   subtract the weekday from the ordinal date, then add 10. Divide the result
!   by 7. Ignore the remainder; the quotient equals the week number. If
!   the week number thus obtained equals 0, it means that the given date
!   belongs to the preceding (week-based) year. If a week number of 53 is
!   obtained, one must check that the date is not actually in week 1 of the
!   following year.
! These two statements are assumed true when correcting the dates around January 1st ...
!   o  The number of weeks in a given year is equal to the corresponding week number of 28 December.
!   o  January 4th is always in the first week.
!
!ISO_NAME:
!  Week date representations are in the format YYYYWww-D.
!  o [YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year.
!  o [Www] is the week number prefixed by the letter W, from W01 through W53.
!  o [D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.
!
!  For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written
!     2006-W52-7 (extended form)
!  or 2006W527 (compact form).
!
!REFERENCE:
!  From Wikipedia, the free encyclopedia 2015-12-19
!AUTHOR:
!  John S. Urban, 2015-12-19
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_14="@(#) woy(3f) Calculate iso-8601 Week-numbering year date yyyy-Www-d"
integer,parameter               :: dp=kind(0.0d0)
integer,intent(in)              :: dat(8)     ! input date array
integer,intent(out)             :: iso_year, iso_week, iso_weekday
character(len=10),intent(out)   :: iso_name
integer                         :: shared_weekday
integer                         :: last_week_this_year
integer                         :: dec28_lastyear(8)   ! December 28th is always in last week
integer                         :: dec28_thisyear(8)   ! December 28th is always in last week
character(len=9)                :: day
integer                         :: ierr
   iso_year=dat(1)                                               ! initially assume the iso_year is the same as the data array year
   iso_week=uncorrected_week_of_year(dat)                        ! this is the week number unless around January 1st
   iso_weekday=shared_weekday                                    ! this is the number of the day of the week assuming Monday=1
   dec28_thisyear=[dat(1),12,28,dat(4),0,0,0,0]                  ! Dec 28th is always in last week; use this to get number of weeks
   last_week_this_year=uncorrected_week_of_year(dec28_thisyear)  ! get the number of the last week of the year (52 or 53)
   ! correct dates around January 1st
   if(iso_week  < 1)then                                         ! if week < 1 then week = lastWeek(year -1)
      dec28_lastyear=[dat(1)-1,12,28,dat(4),0,0,0,0]             ! Dec 28th is always in last week, we want its week number
      iso_week=uncorrected_week_of_year(dec28_lastyear)          ! got the week number for the last week of last year (52 or 53)
      iso_year=dat(1)-1                                          ! our date belongs to last year
   elseif(iso_week >last_week_this_year)then                     ! if week > lastweek(year) then week = 1
      iso_week=iso_week-last_week_this_year                      ! our date belongs to next year
      iso_year=dat(1)+1
   endif

   write(iso_name,'(i4.4,"-W",i2.2,"-",i1)')iso_year,iso_week,iso_weekday ! create ISO string designation for our date

contains
   function uncorrected_week_of_year(datin)
   implicit none
   integer            :: uncorrected_week_of_year
   integer,intent(in) :: datin(8)
      integer         :: ordinal
      call dow(datin,shared_weekday,day,ierr)                 ! formula needs day of week 1..7 where Monday=1
      shared_weekday=mod(shared_weekday+5,7)+1                ! change from Sunday=1 to Monday=1
      ordinal=d2o(datin)                                      ! formula needs ordinal day of year where Jan 1st=1
      uncorrected_week_of_year=(ordinal-shared_weekday+10)/7
   end function uncorrected_week_of_year

end subroutine woy
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function now_ex(format)

! ident_15="@(#) M_time now_ex(3f) use of now(3f) outside of a module"

character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: now_ex
   now_ex=now(format)
end function now_ex
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_framework__journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_framework/src/M_framework__verify.F90
!>
!!##NAME
!!    M_framework__verify(3f) - [M_framework__verify::INTRO] unit test framework
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!  Module procedures
!!
!!    use M_framework, only : unit_test, unit_test_start,    &
!!                            unit_test_end, unit_test_stop, &
!!                            unit_test_msg, unit_test_mode, &
!!                            unit_test_system,              &
!!                            unit_test_expected
!!  Module values
!!
!!    use M_framework, only : unit_test_level, unit_test_flags
!!
!!##QUOTE
!!    Do not let your victories go to your head, nor let your failures go
!!    to your heart.
!!
!!##DESCRIPTION
!!    The M_framework(3f) module is a collection of Fortran routines for
!!    supporting code development by providing logging, error processing,
!!    debugging, comparison and unit testing procedures.
!!
!!    The M_framework__verify(3f) module specifically brings together a
!!    few procedures for creating unit testing. It ...
!!
!!     o allows for a user-defined command to be called to collect results or
!!       produce mail alerts, or other custom bookkeeping operations.
!!
!!     o supports easily composing a message from up to twenty scalar
!!       intrinsic values and different strings
!!
!!     o allows stopping on failure or continuing
!!
!!     o provides for a non-zero exit code if any tests fail
!!
!!     o is designed for with integration with the fpm
!!      (Fortran Package Manager) "test" subcommand.
!!
!!    If default modes need changed it can be done via the unit_test_mode(3f)
!!    procedure or as command line options.
!!
!!    messages by default are writing to stderr, but may be written to any
!!    list of LUNs of preassigned or open files.
!!
!!    SET MODES
!!
!!    Some of the most common options are
!!
!!       call unit_test_mode(command,keep_going,level,luns=[K,L,M,N,...])
!!
!!        keep_going  logical variable that can be used to turn on or off
!!                    program termination on errors.
!!        luns        array of Fortran LUNs to write messages to
!!        level       An integer that can be used to specify
!!                    different debug levels
!!        command     name of optional command to execute for a start,
!!                    check, or finish.
!!
!!  PROCEDURES
!!
!!  The unit test procedures are
!!
!!       unit_test_start()     start tests of a procedure
!!       unit_test()           report if expression is false or true
!!                              and if .false. stop program when keep_going=.false.
!!       unit_test_end()       ends test of a procedure
!!       unit_test_msg()       write message
!!       unit_test_stop()      stop program with exit value of 0 if no failures
!!                              else with an exit value of 1
!!       unit_test_system()    execute system command, recursively if requested.
!!
!!  The unit test short-cut procedures are
!!
!!       unit_test_expected()  report if two values are equal
!!
!!    For custom unit testing reports, a command can be given that will be
!!    passed information on the command line in NAMELIST format.
!!
!!    This command is generally a script that makes entries for each unit,
!!    perhaps in an SQLite data file for example.
!!
!!    It might also send an email if a test fails in batch environments.
!!
!!    It could also convert the information to CSV for use in spreadsheets,
!!    or generate an HTML report, for example.
!!
!!    A sample command written in the bash(1) shell and using the sqlite3(1)
!!    command should be included in this distribution as an example.
!!
!!    The flexibility introduced by calling an external script or program
!!    is that the command can be changed as desired without changing the
!!    test programs.
!!
!!    RELATED FUNCTIONS
!!
!!    The routines in M_framework__verify(3f) are often combined with other
!!    small modules such as Comparisons of real values can be done with a
!!    tolerance with M_Compare_Float_Numbers(3f) and M_framework__approx(3f).
!!    M_hashkeys(3f) routines and various math and statistical routines can
!!    be helpful to quickly create unit tests.
!!
!!    The intrinsics ANY(3f) and ALL(3f) are particularly useful in calls
!!    to unit_test(3f).
!!
!!##EXAMPLES
!!
!!   Sample program
!!
!!     !! program demo_M_framework__verify
!!     module M_framework__verify_demo
!!     private
!!     public one ! some regular routine
!!     public two ! some regular routine
!!     contains
!!
!!     subroutine one(array)
!!     integer,intent(out),allocatable :: array(:)
!!        array=[21,51,14,45]
!!     end subroutine one
!!
!!     subroutine two(array)
!!     integer,intent(inout),allocatable :: array(:)
!!        array=2*array
!!     end subroutine two
!!
!!     end module M_framework__verify_demo
!!
!!     program demo_M_framework__verify
!!     use M_framework, only: unit_test_start, unit_test,   &
!!         & unit_test_end, unit_test_msg, unit_test_stop, &
!!         & unit_test_system, unit_test_mode
!!     use M_framework__verify_demo,   only: one, two
!!     ! set-up
!!     call unit_test_mode(command='',flags=[0],keep_going=.true.)
!!     ! call a test procedure for each routine to test
!!        call test_one()
!!        call test_two()
!!     ! tear-down
!!     call unit_test_stop()
!!     contains
!!
!!     subroutine test_one()
!!     integer,allocatable :: results(:)
!!     integer,parameter   :: expected(*)=[21,51,14,45]
!!     call unit_test_start('one')
!!     call one(results)
!!     call unit_test('one',all(expected>0), &
!!        & 'testing if everyone greater than zero')
!!     call unit_test('one',all(expected==results), &
!!        & 'testing if all values are expected')
!!     call unit_test_end('one','checks on "one" ended')
!!     end subroutine test_one
!!
!!     subroutine test_two
!!     integer,allocatable :: results(:)
!!     integer,parameter   :: expected(*)=[2,20,200]
!!     results=[1,10,100]
!!     call two(results)
!!     call unit_test_start('two','check procedure "two" ')
!!     call unit_test('two', all(expected == results) .and. &
!!        & all(expected > 0) .and. maxval(expected) <201,msg='long expression')
!!     call unit_test_end('two','checks on "two" ended')
!!     end subroutine test_two
!!
!!     end program demo_M_framework__verify
!!
!!   Expected output:
!!
!!    check_start: one   START   :
!!    check:       one   SUCCESS : testing if everyone greater than zero
!!    check:       one   SUCCESS : testing if all values are expected
!!    check_end:   one   PASSED  : GOOD:  2 BAD:  0 DURATION:00000001
!!    check_start: two   START   :
!!    check:       two   SUCCESS : long expression
!!    check_end:   two   PASSED  : GOOD:   1 BAD:  0 DURATION:00000000
!!    check_stop:  TALLY PASSED  : GOOD:    3 BAD:  0 DURATION:00000001
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_framework__verify
use,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64, real32, real64, real128
use,intrinsic :: iso_fortran_env,  only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
use           :: M_framework__msg, only : str, wrt
implicit none
private

type called
   logical :: preset_globals=.true.
   logical :: cmdline=.true.
   logical :: unit_test_mode=.true.
end type called

type(called),save             :: G_virgin

integer,save,allocatable      :: G_luns(:)              ! output units
logical,save                  :: G_debug=.false.
logical,save                  :: G_verbose=.false.
logical,save                  :: G_silent =.false.
logical,save                  :: G_brief=.false.    ! flag on whether to display SUCCESS: messages
character(len=:),allocatable  :: G_match

integer,save,public             :: unit_test_level=0      ! a value that can be used to select different debug levels
integer,save,public,allocatable :: unit_test_flags(:)     ! an array of flags that can be used to select different options
logical,save                    :: G_keep_going=.false.    ! can be used to turn on program termination on errors.
logical,save                    :: G_interactive=.false.
character(len=:),allocatable    :: G_command                         ! name of command to execute. Defaults to the name
logical,save                    :: G_cmdline=.true.                  ! flag whether to parse command line for arguments or not

integer,parameter,public   :: realtime=kind(0.0d0)      ! type for julian days
integer,parameter,public   :: EXIT_SUCCESS=0
integer,parameter,public   :: EXIT_FAILURE=1
real(kind=realtime),save   :: duration=0.0d0
real(kind=realtime),save   :: duration_all=0.0d0
integer(kind=int64),save   :: clicks=0_int64
integer(kind=int64),save   :: clicks_all=0_int64

integer,save :: IPASSED_G=0              ! counter of successes initialized by unit_test_start(3f)
integer,save :: IFAILED_G=0              ! counter of failures  initialized by unit_test_start(3f)
integer,save :: IPASSED_ALL_G=0          ! counter of successes initialized at program start
integer,save :: IFAILED_ALL_G=0          ! counter of failures  initialized at program start
integer,save :: G_LONGEST=20

public unit_test_mode      ! optionally set some non-default modes

public unit_test_start     ! start testing a procedure
public unit_test           ! report results of a test
public unit_test_end       ! end  testing a procedure

public unit_test_stop      ! produce tally of all procedures tested and end program

public unit_test_msg       ! maybe write some message
public unit_test_system    ! usually used for recursive calls when testing program termination status

public unit_test_expected  ! shortcut for common call to unit_test with expression and expected result

private atleast_
private cmdline_
private getarg0_
private getall_
private glob_

type :: force_keywd_hack  ! force keywords, using @awvwgk method
end type force_keywd_hack
! so then any argument that comes after "force_keywd" is a compile time error
! if not done with a keyword unless someone "breaks" it by passing something
! of this type:
!    type(force_keywd_hack), optional, intent(in) :: force_keywd

!===================================================
! for backward compatibility 2023-04-30. Otherwise, ignore these
public unit_test_good  ! report results of a test
public unit_test_bad   ! report results of a test

interface  unit_test_done;    module  procedure  unit_test_end;    end  interface  unit_test_done;    public  unit_test_done
interface  unit_check_start;  module  procedure  unit_test_start;  end  interface  unit_check_start;  public  unit_check_start
interface  unit_check;        module  procedure  unit_test;        end  interface  unit_check;        public  unit_check
interface  unit_check_done;   module  procedure  unit_test_end;    end  interface  unit_check_done;   public  unit_check_done
interface  unit_check_mode;   module  procedure  unit_test_mode;   end  interface  unit_check_mode;   public  unit_check_mode
interface  unit_check_stop;   module  procedure  unit_test_stop;   end  interface  unit_check_stop;   public  unit_check_stop
interface  unit_check_msg;    module  procedure  unit_test_msg;    end  interface  unit_check_msg;    public  unit_check_msg
interface  unit_check_good;   module  procedure  unit_test_good;   end  interface  unit_check_good;   public  unit_check_good
interface  unit_check_bad;    module  procedure  unit_test_bad;    end  interface  unit_check_bad;    public  unit_check_bad

interface unit_test_expected
   module procedure unit_test_expected_int32
   module procedure unit_test_expected_int64
   module procedure unit_test_expected_char
   module procedure unit_test_expected_boolean
   module procedure unit_test_expected_onoff
   module procedure unit_test_expected_real32
   module procedure unit_test_expected_real64
   module procedure unit_test_expected_cmplx32
   module procedure unit_test_expected_cmplx64
end interface

public unit_check_level
integer :: unit_check_level
equivalence (unit_test_level, unit_check_level)

! labels for PREFIX COLUMN OF MESSAGES

type prefix
   character(len=:),allocatable :: CHECK_MSG    !  'check_msg:    '
   character(len=:),allocatable :: CHECK        !  'check:        '
   character(len=:),allocatable :: CHECK_START  !  'check_start:  '
   character(len=:),allocatable :: CHECK_STOP   !  'check_stop:   '
   character(len=:),allocatable :: CHECK_END    !  'check_end:    '
end type prefix

!type(prefix),save :: CHECK_PREFIX=prefix( &
!   CHECK_MSG    =  'check_msg:   ', &
!   CHECK        =  'check:       ', &
!   CHECK_START  =  'check_start: ', &
!   CHECK_STOP   =  'check_stop:  ', &
!   CHECK_END    =  'check_end:   '  &
!&)

type(prefix),save :: CHECK_PREFIX=prefix( null(),null(),null(),null(),null())

public :: CHECK_PREFIX

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_msg(3f) - [M_framework__verify] converts up to twenty
!!    standard scalar values to a message for unit testing
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function unit_test_msg(name, msg, &
!!    & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,if)
!!
!!     character(len=*),intent(in)  :: name
!!     class(*),intent(in),optional :: msg, &
!!     & g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!##DESCRIPTION
!!    unit_test_msg(3f) builds a string from up to twenty scalar values and
!!    prints it to the error log.
!!
!!##OPTIONS
!!    name        name of unit being tested
!!    msg,g[1-j]  optional values to print the value of. May
!!                be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION,
!!                COMPLEX, or CHARACTER.
!!    if          expression must be true or message is not output.
!!                Must be specified by keyword as "if=expression".
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_msg
!!    use M_framework, only : unit_test_start,unit_test_msg, &
!!            & unit_test_end
!!    implicit none
!!
!!    call unit_test_start('myroutine')
!!    call unit_test_msg('myroutine','HUGE(3f) integers', &
!!            & huge(0),'and real',huge(0.0),'and double',huge(0.0d0))
!!    call unit_test_msg('myroutine','real            :', &
!!            & huge(0.0),0.0,12345.6789,tiny(0.0) )
!!    call unit_test_msg('myroutine','doubleprecision :', &
!!            & huge(0.0d0),0.0d0,12345.6789d0,tiny(0.0d0) )
!!    call unit_test_msg('myroutine','complex         :', &
!!            & cmplx(huge(0.0),tiny(0.0)) )
!!    call unit_test_end('myroutine')
!!
!!    end program demo_unit_test_msg
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_msg(name,msg, g1, g2, g3, g4, g5, g6, g7, g8, g9 ,ga, gb, gc, gd, ge, gf, gg, gh, gi, gj,force_keywd,if)
implicit none

! ident_1="@(#) M_framework__verify unit_test_msg(3f) writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: name
class(*),intent(in),optional  :: msg, g1 ,g2 ,g3 ,g4 ,g5, g6 ,g7 ,g8 ,g9, ga ,gb ,gc ,gd ,ge, gf ,gg ,gh ,gi, gj
type(force_keywd_hack), optional, intent(in) :: force_keywd
logical,intent(in),optional   :: if
character(len=:),allocatable  :: msg_all
logical                       :: if_local

G_LONGEST=max(G_LONGEST,len_trim(name))

if(present(if))then
   if_local=if
else
   if_local=.true.
endif
   if(G_virgin%cmdline) call cmdline_()

   if(if_local)then
      msg_all=str(msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)

      if(.not.G_brief)then
         ! write message to standard error
         call wrt(G_luns,CHECK_PREFIX%check_msg//atleast_(name,G_LONGEST)//' INFO    : '// msg_all)
      endif
      if(G_command /= '') call run(G_command//' type="message"  name="'//trim(name)//'" msg="'//ndq(msg_all)//'"')
   endif

end subroutine unit_test_msg
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test(3f) - [M_framework__verify] report if logical expression is
!!    true or false, optionally call command and/or stop program.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test(name,expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!    & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,only_on_fail)
!!
!!     character(len=*),intent(in) :: name
!!     logical,intent(in) :: expression
!!     class(*),intent(in),optional :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,&
!!     & ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
!!     logical,intent(in),optional :: only_on_fail
!!
!!##DESCRIPTION
!!    unit_test(3f) tests the expression and displays a message composed
!!    of the generic intrinsic values msg, and g1 thorough gj. Additionally,
!!    if the expression is false
!!
!!    o if unit_test_mode(command) is not blank calls the
!!    specified shell command
!!
!!       $COMMAND name="NAME" type="check" passed="passed|failed" ...
!!       msg="all messages"
!!
!!    o if keep_going = .false. stop the program on a failed test
!!
!!##OPTIONS
!!     NAME          the unit test name
!!     EXPRESSION    the logical expression to evaluate
!!     msg,g1...gj   optional message to display when performing test,
!!                   composed of any scalar intrinsics of type INTEGER,
!!                   REAL, DOUBLEPRECISION, COMPLEX, LOGICAL, or
!!                   CHARACTER. A space is placed between each value.
!!     wordy         If .false. The message MSG is only displayed if the expression
!!                   is .false. . Must be used as a keyword. Default is .true. .
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_unit_test
!!       use M_framework, only: &
!!          & unit_test_mode,     &
!!          & unit_test_start,    &
!!          & unit_test,          &
!!          & unit_test_end,      &
!!          & unit_test_stop
!!       use M_framework, only: almost
!!
!!       implicit none
!!       integer :: i
!!       integer :: x
!!       integer,allocatable :: arr(:)
!!       real,allocatable :: arr1(:)
!!       real,allocatable :: arr2(:)
!!
!!          call unit_test_mode(keep_going=.true.,debug=.false.,command='')
!!
!!          x=10
!!          arr1=[1.0,10.0,100.0]
!!          arr2=[1.0001,10.001,100.01]
!!          call unit_test_start('myroutine')
!!
!!          call unit_test('myroutine', x > 3 ,' if big enough')
!!          call unit_test('myroutine', x < 100 ,' if small enough')
!!
!!          do i=1,size(arr1)
!!             call unit_test('myroutine', &
!!             & almost(arr1(i),arr2(i),3.9,verbose=.true.) )
!!          enddo
!!
!!          arr=[10,20,30]
!!          call unit_test('myroutine', .not.any(arr < 0) , &
!!          & 'fail if any negative values in array ARR')
!!          call unit_test('myroutine', all(arr < 100) , &
!!          & 'fail unless all values are less than 100 in array ARR')
!!
!!          call unit_test_end('myroutine', &
!!          & msg='checks on "myroutine" all passed')
!!
!!          call unit_test_stop()
!!
!!       end program demo_unit_test
!!
!! Results:
!!
!!  Sample output (varies with what optional command or modes is used):
!!
!!      >check_start: myroutine            START   :
!!      >check:       myroutine            SUCCESS :  if big enough
!!      >check:       myroutine            SUCCESS :  if small enough
!!      >*almost* for values 1.00000000 1.00010002 agreement of 3.99997139 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >*almost* for values 10.0000000 10.0010004 agreement of 3.99986792 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >*almost* for values 100.000000 100.010002 agreement of 3.99995065 ...
!!      >digits out of requested 3.90000010
!!      >check:       myroutine            SUCCESS :
!!      >check:       myroutine            SUCCESS : fail if any negative ...
!!      >values in array ARR
!!      >check:       myroutine            SUCCESS : fail unless all values ...
!!      >are less than 100 in array ARR
!!      >check_end:   myroutine            PASSED  : GOOD:7         BAD: ...
!!      >0 DURATION:00000000294709: checks on "myroutine" all passed
!!      >check_stop:  TALLY                PASSED  : GOOD:7         BAD: ...
!!      >0 DURATION:00000000267059
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test(name,logical_expression,msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,force_keywd,wordy)

! ident_2="@(#) M_framework__verify unit_test(3f) assert if expression is .true. or .false. and optionally call command or stop on .false."

character(len=*),intent(in)          :: name
logical,intent(in)                   :: logical_expression
class(*),intent(in),optional         :: msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj
type(force_keywd_hack),optional,intent(in) :: force_keywd
logical,intent(in),optional          :: wordy
character(len=:),allocatable         :: msg_all
logical                              :: wordy_local

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(present(wordy))then
      wordy_local=wordy
   else
      wordy_local=.true.
   endif

   if(G_virgin%cmdline) call cmdline_()

   msg_all=str(msg,g1,g2,g3,g4,g5,g6,g7,g8,g9,ga,gb,gc,gd,ge,gf,gg,gh,gi,gj)

   if(.not.logical_expression)then
      call wrt(G_luns,CHECK_PREFIX%check//atleast_(name,G_LONGEST)//' FAILURE : '//msg_all)
      if(G_command /= '') call run(G_command//' type="check" name="'//trim(name)//'" passed="failed" msg="'//ndq(msg_all)//'"')
      if(.not.G_keep_going) then
         call wrt(G_luns,CHECK_PREFIX%check//'STOPPING PROGRAM ON FAILED TEST OF '//trim(name))
         stop 1
      endif
      IFAILED_G=IFAILED_G+1
      IFAILED_ALL_G=IFAILED_ALL_G+1
   else
      if(.not.G_brief)then
         if(wordy_local)call wrt(G_luns,CHECK_PREFIX%check//atleast_(name,G_LONGEST)//' SUCCESS : '//msg_all)
      endif
      if(G_command /= '') call run(G_command//' type="check" name="'//trim(name)//'" passed="passed" msg="'//ndq(msg_all)//'"')
      IPASSED_G=IPASSED_G+1
      IPASSED_ALL_G=IPASSED_ALL_G+1
   endif

end subroutine unit_test
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_start(3f) - [M_framework__verify] reset counters
!!    and start a new test block
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_start(name,msg,opts,matched)
!!
!!     character(len=*),intent(in)          :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!     logical,intent(out),optional         :: matched
!!
!!##DESCRIPTION
!!    unit_test_start(3f) is an initialization procedure for starting a
!!    new procedure test.
!!
!!##OPTIONS
!!    NAME   name of the procedure to test
!!    MSG    message to print
!!    OPTS   pass additional options to the optional shell command that
!!           can be assigned on the command line or by unit_test_mode(3f).
!!    MATCHED  if the match string has been set with unit_test_mode(3f)
!!             or on the command line this will return true if the name
!!             and msg concatenated with a space match the entire match
!!             string, where "*" matches any string and "?" matches any
!!             single character. This allows you to skip a test set if
!!             you wish by exiting.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_start
!!     use M_framework, only: unit_test_start, unit_test, &
!!      & unit_test_end, unit_test_mode, unit_test_stop
!!     implicit none
!!     integer :: ival
!!     logical :: matched
!!     call unit_test_mode()
!!     call test_mysub1()
!!     call test_mysub2()
!!     call unit_test_stop()
!!     contains
!!     subroutine test_mysub1() ! first test
!!     call unit_test_start('mysub1')
!!     ! the example goodbad(1) command called here takes many options
!!     ! used to build an SQLite3 entry
!!     ival=10
!!     call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
!!     call unit_test('mysub1', ival < 100 , msg=' if small enough')
!!     call unit_test_end('mysub1',msg='completed checks of "mysub1"')
!!     end subroutine test_mysub1
!!
!!     subroutine test_mysub2() ! second test
!!     call unit_test_start('mysub1','',matched=matched)
!!     ival=200
!!        if(.not.matched)return ! makes it skippable
!!        call unit_test('mysub1', ival > 3 ,   msg=' if big enough')
!!        call unit_test('mysub1', ival < 100 , msg=' if small enough')
!!        call unit_test_end('mysub1',msg='completed checks of "mysub2"')
!!     end subroutine test_mysub2
!!
!!     end program demo_unit_test_start
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_start(name,msg,opts,force_keywd,matched)

! ident_3="@(#) M_framework__verify unit_test_start(3f) start testing procedure "name""

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: msg
character(len=*),intent(in),optional :: opts
type(force_keywd_hack), optional, intent(in) :: force_keywd
logical,intent(out),optional         :: matched
character(len=:),allocatable         :: msg_local
logical,save                         :: called=.false.

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(present(msg))then
      msg_local=trim(msg)
   else
      msg_local=''
   endif

   if(G_virgin%cmdline) call cmdline_()

   ! check optional matched string and return if string is not blank and not matched.
   ! It is assumed program will skip the subsequent test
   if(present(matched))then
      if(G_match.ne.'')then
         matched=glob_(name//' '//msg_local,G_match)
         if(.not.matched)return
      endif
      matched=.true.
   endif

   if(present(opts))then
      if(G_command /= '') call run(G_command//' type="start" name="'//trim(name)//'" msg="'//ndq(msg_local)//'" '//opts)
   else
      if(G_command /= '') call run(G_command//' type="start" name="'//trim(name)//'" msg="'//ndq(msg_local)//'"')
   endif

   call system_clock(clicks)
   duration=julian()
   if(.not.called)then
      call system_clock(clicks_all)
      duration_all=julian()
      called=.true.
   endif

   if(.not.G_brief)then
      call wrt(G_luns,CHECK_PREFIX%check_start//atleast_(name,G_LONGEST)//' START   : '//msg_local)
   endif

   IPASSED_G=0
   IFAILED_G=0

end subroutine unit_test_start
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_stop(3f) - [M_framework__verify] report tally of all checks
!!    and stop program
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_stop(msg,opts)
!!
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    give a tally of all calls to unit_test(3f) and stop program.
!!
!!    Tally up the test result totals and stop the program.
!!    If a command is set via unit_test_mode(3f) or the command line
!!    call it appending OPTS to the end of the command.
!!
!!##OPTIONS
!!     MSG  additional message to display
!!     OPTS add string to filter command line if any is specified.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_stop
!!     use M_framework, only: unit_test_start, unit_test_end, &
!!     & unit_test, unit_test_stop, unit_test_mode
!!     use,intrinsic :: iso_fortran_env, stdout=>OUTPUT_UNIT
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_mode(luns=[stdout])
!!     ! do a test
!!     call unit_test_start('proc1')
!!     call unit_test('proc1', x > 3 , 'if big enough')
!!     call unit_test('proc1', x < 100 , 'if small enough')
!!     call unit_test_end  ('proc1',msg='checks all done' )
!!     ! do another test
!!     call unit_test_start('proc2')
!!     call unit_test('proc2', x > 3 , 'if big enough')
!!     call unit_test('proc2', x < 100 , 'if small enough')
!!     call unit_test_end  ('proc2',msg='checks all done' )
!!
!!     ! tally up test results and stop program
!!     call unit_test_stop()
!!
!!     end program demo_unit_test_stop
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_stop(msg)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64

! ident_4="@(#) M_framework__verify unit_test_stop(3f) stop program with report on calls to unit_test(3f)"

character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=4096)                  :: out
character(len=:),allocatable         :: PF
integer(kind=int64)                  :: milliseconds
integer(kind=int64)                  :: clicks_now

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif
   call system_clock(clicks_now)
   milliseconds=(julian()-duration_all)*1000
   milliseconds=clicks_now-clicks_all
   PF=merge('PASSED  :','FAILED  :',ifailed_all_G == 0)
   if(PF == 'PASSED  :'.and.ipassed_all_G == 0)then
      PF='UNTESTED:'
   endif
      write(out,'("'//CHECK_PREFIX%check_stop//'",a,1x,a," GOOD: ",a," BAD: ",a," DURATION: ",i20.20)') &
       & atleast_("TALLY",G_LONGEST),     &
       & PF,                              &
       & atleast_(str(IPASSED_ALL_G),9),  &
       & atleast_(str(IFAILED_ALL_G),9),  &
       & milliseconds
   if(present(msg))then
           if(.not.G_brief.or.(IFAILED_ALL_G+IPASSED_ALL_G.eq.0).or.IFAILED_ALL_G.ne.0) &
                   & call wrt(G_luns,trim(out)//': '//trim(msg))
   else
           if(.not.G_brief.or.(IFAILED_ALL_G+IPASSED_ALL_G.eq.0).or.IFAILED_ALL_G.ne.0) &
                   & call wrt(G_luns,out)
   endif

   if(PF=='UNTESTED')then
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="untested" clicks=0 msg="',ndq(msg_local),'"',sep='') )
      stop ! EXIT_SUCCESS
   elseif(IFAILED_ALL_G == 0)then
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="passed" clicks=',milliseconds,' msg="',ndq(msg_local),'"',sep='') )
      stop ! EXIT_SUCCESS
   else
      if(G_command /= '') &
      & call run( str(G_command,' type="stop" passed="failed" clicks=',milliseconds,' msg="',ndq(msg_local),'"',sep='') )
      stop EXIT_FAILURE
   endif
end subroutine unit_test_stop
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!! unit_test_end(3f) - [M_framework__verify] end test of procedure started
!! by unit_test_start(3f)
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_end(name,msg,opts)
!!
!!     character(len=*),intent(in) :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    A message is shown including the duration of the tests
!!    If there have been no failures the optional shell command
!!
!!        $COMMAND name="name" type="end" passed="passed|failed|untested" ...
!!        clicks=NNNN msg="message" opts
!!
!!    is executed
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_end
!!     use M_framework, only: unit_test_start
!!     use M_framework, only: unit_test
!!     use M_framework, only: unit_test_end
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     ! program execution stopped
!!     call unit_test_end ('myroutine',msg='checks on "myroutine"' )
!!
!!     end program demo_unit_test_end
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_end(name,msg,opts)
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64

! ident_5="@(#) M_framework__verify unit_test_end(3f) end checking procedure "name""

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: msg
character(len=*),intent(in),optional :: opts
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local
character(len=4096)                  :: out
character(len=9)                     :: pf
integer(kind=int64)                  :: milliseconds
integer(kind=int64)                  :: clicks_now

   G_LONGEST=max(G_LONGEST,len_trim(name))

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   PF=merge('PASSED  :','FAILED  :',ifailed_G == 0)
   if(PF == 'PASSED  :'.and.ipassed_G == 0)then
      PF='UNTESTED:'
   endif
   if(duration /= 0.0d0)then
      call system_clock(clicks_now)
      milliseconds=(julian()-duration)*1000
      milliseconds=clicks_now-clicks
      write(out,'("'//CHECK_PREFIX%check_end//'",a,  &
       & 1x,a,                            &
       & " GOOD: ",a,                     &
       & " BAD: " ,a,                     &
       & " DURATION: ",i20.20             &
       & )')                              &
       & atleast_(name,G_LONGEST),        &
       & PF,                              &
       & atleast_(str(IPASSED_G),9),      &
       & atleast_(str(IFAILED_G),9),      &
       & milliseconds
   else
      milliseconds=0
      write(out,'("'//CHECK_PREFIX%check_end//'",a,1x,a," GOOD: ",a,1x," BAD: ",a)') &
       & atleast_(name,G_LONGEST),PF,atleast_(str(IPASSED_G),9),atleast_(str(IFAILED_G),9)
   endif
   if(present(msg))then
      if(.not.G_brief.or.(IFAILED_G+IPASSED_G.eq.0).or.IFAILED_G.ne.0) then
         call wrt(G_luns,trim(out)//': '//trim(msg))
         call wrt(G_luns,'')
      endif
   else
      if(.not.G_brief.or.(IFAILED_G+IPASSED_G.eq.0).or.IFAILED_G.ne.0) then
         call wrt(G_luns,out)
         call wrt(G_luns,'')
      endif
   endif

   if(G_command /= '')then                           ! if system command name is not blank call system command
      if(ipassed_G+ifailed_G == 0)then
         call run(str(G_command,' type="end" name="',name,'" passed="untested" clicks=0',' msg="',ndq(msg),'" ',sep='') )

      elseif(ifailed_G == 0)then
         call run(str(G_command,' type="end" name="',name,'" passed="passed" clicks=',milliseconds,' msg="',ndq(msg),'" ',sep='') )
      else
         call run(str(G_command,' type="end" name="',name,'" passed="failed" clicks=',milliseconds,' msg="',ndq(msg),'" ',sep='') )
      endif
   endif

   if(ifailed_G == 0)then
      if(.not.G_keep_going) stop 1             ! stop program depending on mode
   endif

   IPASSED_G=0
   IFAILED_G=0
   duration=0.0d0

   if(paws())continue

end subroutine unit_test_end
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_bad(3f) - [M_framework__verify] call command "goodbad NAME
!!    bad" and stop program
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_bad(name,msg,opts)
!!
!!     character(len=*),intent(in) :: name
!!     character(len=*),intent(in),optional :: msg
!!     character(len=*),intent(in),optional :: opts
!!
!!##DESCRIPTION
!!
!!    unit_test_bad(3f) calls the shell command
!!
!!         goodbad NAME bad [opts]
!!
!!    and stops the program. It is just a shortcut for calling
!!         call unit_test(name,.false.)
!!         call unit_test_end(name,msg,opts)
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_bad
!!     use M_framework, only: unit_test_start, unit_test
!!     use M_framework, only: unit_test_end, unit_test_stop
!!     use M_framework, only: unit_test_bad
!!
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     if(x /= 0)then
!!       call unit_test_bad ('myroutine',msg='checks on "myroutine" failed')
!!       ! program execution stopped
!!     endif
!!     call unit_test_end ('myroutine')
!!     call unit_test_stop ('myroutine')
!!
!!     end program demo_unit_test_bad
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
subroutine unit_test_bad(name,opts,msg)

! ident_6="@(#) M_framework__verify unit_test_bad(3f) call 'goodbad NAME bad'"

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: opts
character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   call unit_test(name,.false.)
   call unit_test_end(name,opts_local,msg_local)

end subroutine unit_test_bad
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_good(3f) - [M_framework__verify] call command "goodbad
!!    NAME good"
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    subroutine unit_test_good(name,msg,opts)
!!
!!     character(len=*),intent(in)          :: name
!!     character(len=*),intent(in),optional :: opts
!!     character(len=*),intent(in),optional :: msg
!!
!!##DESCRIPTION
!!    A shortcut for
!!
!!       call unit_test(name,.true.)
!!       call unit_test_end(name,opts,msg)
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!     program demo_unit_test_good
!!     use M_framework, only: unit_test_start, unit_test_end
!!     use M_framework, only: unit_test, unit_test_good
!!
!!     implicit none
!!     integer :: x
!!     x=10
!!     call unit_test_start('myroutine')
!!
!!     call unit_test('myroutine', x > 3 ,'if big enough')
!!     call unit_test('myroutine', x < 100 ,'if small enough')
!!
!!     call unit_test_good('myroutine',msg='checks on "myroutine" ')
!!
!!     end program demo_unit_test_good
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_good(name,msg,opts)

! ident_7="@(#) M_framework__verify unit_test_good(3f) call 'goodbad NAME good'"

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: opts
character(len=*),intent(in),optional :: msg
character(len=:),allocatable         :: msg_local
character(len=:),allocatable         :: opts_local

   if(G_virgin%cmdline) call cmdline_()

   if(present(msg))then
      msg_local=msg
   else
      msg_local=''
   endif

   if(present(opts))then
      opts_local=opts
   else
      opts_local=''
   endif

   call unit_test(name,.true.,msg=msg_local)
   call unit_test_end(name,opts_local)

end subroutine unit_test_good
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function atleast_(line,length) result(strout)

! ident_8="@(#) M_framework__verify atleast_(3f) return string padded to at least specified length"

character(len=*),intent(in)  ::  line
integer,intent(in)           ::  length
character(len=max(length,len(trim(line)))) ::  strout
   strout=line
end function atleast_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function julian()
! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19

! ident_9="@(#) M_framework__verify julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date"

real(kind=realtime)              :: julian   ! Julian Date (non-negative, but may be non-integer)
integer                          :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
integer                          :: year, month, day, utc, hour, minute
real(kind=realtime)              :: second
integer                          :: A, Y, M, JDN

   call date_and_time(values=dat)
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0d0    ! Second   ! correction for time zone and milliseconds

!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or February, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for February
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian Calendar date given the JDN (Julian day number) and time of day
   julian=JDN + dble(hour-12)/24.0d0 + dble(minute)/1440.0d0 + second/86400.0d0
end function julian
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine preset_globals()
integer :: iostat
character(len=:),allocatable :: arg0
   G_virgin%preset_globals=.false.
   G_cmdline=.true.
   G_debug=.false.
   G_keep_going=.true.
   unit_test_level=0
   unit_test_flags=[integer :: ]
   !x!G_luns=[stderr]
   G_luns=[stdout]
   G_interactive=.false.
   G_match=repeat(' ',4096)
   G_command=repeat(' ',4096)
   open(unit=999,status='scratch',iostat=iostat)
   !  values used in prefix column for various messages
   !CHECK_PREFIX=prefix( null(),null(),null(),null(),null())
   !x!CHECK_PREFIX=prefix(                  &
   !x! check_MSG    =  'check_msg:   ', &
   !x! check        =  'check:       ', &
   !x! check_START  =  'check_start: ', &
   !x! check_STOP   =  'check_stop:  ', &
   !x! check_END    =  'check_end:   '  &
   !x!)
   !x!CHECK_PREFIX=prefix(             &
   !x! check_MSG    =  ':       ', &
   !x! check        =  ':       ', &
   !x! check_START  =  ':start: ', &
   !x! check_STOP   =  ':stop:  ', &
   !x! check_END    =  ':end:   '  &
   !x!)
   arg0=getarg0_()//': '
   CHECK_PREFIX=prefix(   &
    check_MSG    =  arg0, &
    check        =  arg0, &
    check_START  =  arg0, &
    check_STOP   =  arg0, &
    check_END    =  arg0  &
   )
end subroutine preset_globals
!===================================================================================================================================
subroutine cmdline_()
use, intrinsic :: iso_fortran_env, only: compiler_version, compiler_options
! define arguments and their default values
! use naming convention of global variables to make parsing easier
logical             :: G_help = .false.
integer,allocatable :: G_flags(:)
integer             :: G_level
integer,allocatable :: G_luns_hold(:)

! NOTE: assume all names in namelist start with G_ or unit_test
namelist /args/ G_match
namelist /args/ G_level
namelist /args/ G_debug                   ! debug mode
namelist /args/ G_flags                   ! values that can be used to select different tests or any conditional integer test
namelist /args/ G_keep_going              ! logical variable that can be used to turn off program termination on errors.
namelist /args/ G_command                 ! name of command to execute. Defaults to " ".
namelist /args/ G_brief
namelist /args/ G_luns
namelist /args/ G_interactive
namelist /args/ G_help
namelist /args/ G_verbose
namelist /args/ G_silent

!    Report the beginning and end of execution of each test case or suite
!    Only run cases or collections whose description contains the given string
!    Don't colorize the output

character(len=4096), save :: input(3) = [character(len=4096) :: '&args', '', ' /'], arg
character(len=256) :: message1, message2
integer :: i, j, k, iostat, equal_pos, iend

   if (G_virgin%preset_globals) then
      call preset_globals()
   endif

   if (G_virgin%cmdline) then
      G_virgin%cmdline = .false.
      ! read arguments from command line
      G_level=-1
      G_luns_hold=G_luns
      G_luns = [ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
      G_flags = [(-1, i=1, 1000)]
      do i = 1, command_argument_count()
         call get_command_argument(i, arg)
         do j = 1, len_trim(arg) ! blank out leading - or / so "--name=value" or "/name=value" works
            if (index('/- ', arg(j:j))  ==  0) exit
            arg(j:j) = ' '
         enddo
         ! if variable name does not start with "unit_test" add "G_" prefix so can use a nice name
         ! on command line, on unit_test_mode, and public variables
         arg= adjustl(arg)
         if (index(arg, 'unit_test_')  ==  1) then
            arg = ' '//adjustl(arg)
         else
            arg = ' G_'//adjustl(arg)
         endif
         ! if no equal sign add =T
         if (index(arg, '=')  ==  0) then
            arg = trim(arg)//'=T'
         endif

         iend=len_trim(arg)
         input(2)=arg
         if(arg(iend:iend).ne.',')input(2)=trim(input(2))//','
         read (input, nml=args, iostat=iostat, iomsg=message1)
         ! assume first failure might be because of missing quotes
         if (iostat  /=  0) then
            equal_pos = index(arg, '=')        ! find position of '='
            if(any(G_luns < -1) ) then
               G_luns=[integer ::]
            else
               G_luns = pack(G_luns, G_luns  /=  -1)     ! if G_luns is all negative at this point set it to [stderr]
               if (size(G_luns)  ==  0) G_luns = G_luns_hold
            endif
            if (equal_pos  /=  0) then
               ! requote and try again
               arg = arg (:equal_pos)//'"'//arg (equal_pos + 1:len_trim(arg))//'"'
               iend=len_trim(arg)
               input(2)=arg
               if(arg(iend:iend).ne.',')input(2)=trim(input(2))//' ,'
               read (input, nml=args, iostat=iostat, iomsg=message2)
               if (iostat  /=  0) then
                  call wrt(G_luns, 'ERROR UNQUOTED:'//trim(message1)//': when reading '//trim(input(2)))
                  call wrt(G_luns, 'ERROR QUOTED  :'//trim(message2)//': when reading '//trim(input(2)))
                  G_command=trim(G_command)
                  G_match=trim(G_match)
                  if(G_level == -1) G_level=unit_test_level
                  do k = 1, size(G_luns)
                     write (G_luns(k), nml=args, delim='quote')
                  enddo
                  stop 2
               endif
            else
               call wrt(G_luns, 'ERROR:'//trim(message1)//': when reading '//trim(input(2)))
               G_command=trim(G_command)
               G_match=trim(G_match)
               if(G_level == -1) G_level=unit_test_level
               do k = 1, size(G_luns)
                  write (G_luns(k), nml=args, delim='quote')
               enddo
               stop 4
            endif
         endif
      enddo

      if(any(G_luns < -1) ) then
         G_luns=[integer ::]
      else
         G_luns = pack(G_luns, G_luns  /=  -1)     ! if G_luns is all negative at this point set it to [stderr]
         if (size(G_luns)  ==  0) G_luns = G_luns_hold
      endif
      G_command = trim(G_command)
      G_match=trim(G_match)
      G_flags = pack(G_flags, G_flags  >=  0)
      if(G_verbose) G_flags=[G_flags,9997,9998,9999] ! turn on these flags if verbose mode
      if(G_silent) G_luns=[999] ! turn on these flags if verbose mode
      if (size(G_flags)  /=  0) unit_test_flags = G_flags
      if(G_level /= -1) unit_test_level = G_level

      ! some pre-defined level numbers
      if (any(unit_test_flags  ==  9997)) then
         call wrt(G_luns, 'This file was compiled by ', compiler_version())
      endif

      if (any(unit_test_flags  ==  9998)) then
         call wrt(G_luns, ' using the options ', compiler_options())
      endif

      if (any(unit_test_flags  ==  9999)) then
         do i = 1, size(G_luns)
            write (G_luns(i), nml=args, delim='quote')
         enddo
      endif
   endif

   if (G_help) then
      write (*, '(g0)') [character(len=80) :: &
      'NAME                                                                            ', &
      '    unit_tests(1f) -- unit test command line options                            ', &
      'SYNOPSIS                                                                        ', &
      ' CMD --level=0 --keep_going --flags=''10000*-1'' --command="" --match=""          ', &
      ' luns=stderr,-1,-1,-1,-1 --verbose=F --brief=F --silent=F interactive=F         ', &
      '                                                                                ', &
      'DESCRIPTION                                                                     ', &
      '   When using the M_framework unit test routines options are read from the      ', &
      '   command line of any program built with the interface by default. To prevent  ', &
      '   the command line from being parsed in case the program already parses the    ', &
      '   command line add "call unit_test_mode(cmdline=.false.)" to the calling       ', &
      '   program.                                                                     ', &
      'OPTIONS                                                                         ', &
      '--command="system_command"  program to call after each test                     ', &
      '--luns=L,M,N,...    list of unit numbers to write to, assumed opened by program ', &
      '                            * 6   typically stdout                              ', &
      '                            * 0   typically stderr                              ', &
      '                            * 999 scratch file deleted when program ends        ', &
      '--match="glob expression"   string to be tested by "matched" argument on        ', &
      '                            unit_test_start(3f)                                 ', &
      '--level=N                   user-requested debug level. Sets "unit_test_level". ', &
      '--keep_going=F              turn on program termination on test failure         ', &
      '--flags=L,M,N,...           set value for user to set different test flags      ', &
      '                               values >= 9990 are reserved                      ', &
      '                                  * 9997 compiler version                       ', &
      '                                  * 9998 compiler options                       ', &
      '                                  * 9999 command line options NAMELIST group    ', &
      '--help                      display this text and exit                          ', &
      '--verbose                   verbose mode                                        ', &
      '--brief                     only display messages of failed tests               ', &
      '--silent                    no messages from unit_test procedures is produced   ', &
      '--interactive                                                                   ', &
      '--debug                                                                         ', &
      '                                                                                ', &
      'Note flags => unit_test_flags(:) and level => unit_test_level, which are        ', &
      'public members of M_framework.                                                  ', &
      'EXAMPLES                                                                        ', &
      ' sample commands:                                                               ', &
      '  fpm test                                                                      ', &
      '  fpm test -- luns=6 # write to stdout instead of stderr                        ', &
      '  fpm test ''*regression*''  # run tests containing specified start string      ', &
      '                                                                                ', &
      '  # run a test called "crash" with gdb(1)                                       ', &
      '  fpm test --target crash --runner "gdb -ex run --quiet"                        ', &
      '                                                                                ', &
      '  # run all the tests in the gdb(1) debugger (you can enter                     ', &
      '  # "q" after each test has run; or enter gdb commands at the prompt):          ', &
      '  fpm test --target ''*'' --verbose \                                           ', &
      '     --runner ''gdb -ex "list, 0" -ex run --quiet --args'' \                    ', &
      '     -- flags=9997,9998,9999 luns=6 level=3                                     ', &
      ' ']
      G_help=.false.
      stop
   endif

end subroutine cmdline_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_mode(3f) - [M_framework__verify] set testing modes
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!      subroutine unit_test_mode( keep_going, flags, luns, command, &
!!      brief, interactive, CMDLINE, debug, match)
!!
!!      logical,intent(in) :: keep_going, brief, interactive,debug
!!      integer,intent(in),allocatable :: luns(:), flags(:)
!!      character(len=*),intent(in) :: command
!!##DESCRIPTION
!!    unit_test_mode(3f) changes testing mode defaults
!!
!!##OPTIONS
!!    keep_going   keep running if a test fails. Default to TRUE
!!    flags        a list of integer values that can be accessed from
!!                 M_framework as unit_test_flags(:) for use in
!!                 selecting various tests conditionally
!!    luns         list of Fortran units to unit test messages to. Defaults
!!                 to the the value of ERROR_UNIT from the intrinsic module
!!                 ISO_FORTRAN_ENV (ie. defaults to "stderr"). It is
!!                 Assumed the units have been opened by the program.
!!    match        the string that is tested against the name and msg
!!                 specified on unit_test_start() to set the "matched"
!!                 argument.
!!    command      filter command, typically to generate reports. It is
!!                 passed data on the command line. See the example filter
!!                 "bookkeeper" for examples.
!!    brief        If present only "FAIL" messages are produced.
!!
!!    brief        Only display FAIL messages and related information
!!    verbose      verbose mode displays compiler version and options and
!!                 all standard messages.
!!    silent       no output from unit_test_*(3f) procedures
!!    interactive  prompt as each test case starts as to continue.
!!    cmdline      If set to .false. do not parse command line for options.
!!    debug        Debug mode for the M_framework package
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_mode
!!    use M_framework
!!    implicit none
!!
!!    call unit_test_mode(keep_going=.false.,luns=[6], &
!!            & brief=.true.)
!!
!!    end program demo_unit_test_mode
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine unit_test_mode(debug, keep_going, level, flags, command, brief,verbose,silent,cmdline,interactive,luns,match)
logical,optional, intent(in)           :: debug
logical,optional, intent(in)           :: keep_going     ! logical variable that can be used to turn off program termination on errors.
logical,optional, intent(in)           :: cmdline        ! flag whether to parse command line for arguments or not
logical,optional, intent(in)           :: interactive
logical,optional, intent(in)           :: brief          ! flag on whether to display SUCCESS: messages
logical,optional, intent(in)           :: verbose        ! flag on whether to display all messages including additional information
logical,optional, intent(in)           :: silent         ! do not output any messages from unit_test_*(3f) procedures
character(len=*),optional, intent(in)  :: command        ! name of command to execute. Defaults to the name
integer,optional, intent(in)           :: flags(:)       ! an  array that can be used to select different options
integer,optional, intent(in)           :: level          ! an  integer that can be used to select different debug levels
integer,optional, intent(in)           :: luns(:)        ! logical unit number to write output to
character(len=*), optional, intent(in) :: match

   if (G_virgin%preset_globals) then
      call preset_globals()
   endif

   if (present(match))                G_match=match
   if (present(luns))                 G_luns=luns
   if (present(command))              G_command=command
   if (present(debug))                G_debug=debug
   if (present(cmdline))              G_cmdline=cmdline
   if (present(interactive))          G_interactive=interactive
   if (present(keep_going))           G_keep_going=keep_going
   if (present(flags))                unit_test_flags=flags
   if (present(level))                unit_test_level=level
   if (present(brief))                G_brief=brief
   if (present(verbose))              G_verbose=verbose
   if (present(silent))               G_silent=silent

!integer,parameter,public   :: realtime=kind(0.0d0)    ! type for julian days
!integer,parameter,public   :: EXIT_SUCCESS=0
!integer,parameter,public   :: EXIT_FAILURE=1

end subroutine unit_test_mode
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unit_test_system(3f) - [M_framework__verify] return status from
!!    system command
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    function unit_test_system(cmd,verbose)
!!
!!     character(len=*),intent(in)  :: cmd
!!     logical,intent(in),optional  :: verbose
!!##DESCRIPTION
!!    unit_test_system(3f) executes a system command and returns the
!!    exit status of the command.
!!
!!##OPTIONS
!!    command    system command to execute. If it starts with "* " the
!!               asterisk is replaced by the name of the current command.
!!               If it starts with "** " the asterisks are replaced by
!!               the current command including arguments.
!!
!!    verbose    if .true. the executed command is echoed to output. The
!!               default is .false.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_unit_test_system
!!    use M_framework, only: &
!!       unit_test_start,  &
!!       unit_test,        &
!!       unit_test_system, &
!!       unit_test_end
!!    implicit none
!!    if (command_argument_count()  ==  0) then
!!       call unit_test_start('myroutine')
!!       call unit_test('false', unit_test_system('false') == 0, 'check false')
!!       call unit_test('true', unit_test_system('true') == 0, 'check true')
!!       call unit_test('notthere', unit_test_system('notthere') == 0, &
!!       & 'check notthere')
!!       call unit_test('*',&
!!       & unit_test_system('* and options', verbose=.true.) == 0, 'check "*"')
!!       call unit_test_end('myroutine')
!!    else
!!       write (*, *) 'called with an option'
!!    endif
!!    end program demo_unit_test_system
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
function unit_test_system(command,verbose) result(istat)
!  EXITSTAT contains the integer exit code of the command, as returned by SYSTEM.
!  CMDSTAT is set to zero if the command line was executed (whatever its exit status was).
!          If an error condition occurs and CMDSTAT is not present, error termination of execution of the image is initiated.
!     It is assigned
!      + the value -1 if the processor does not support command line execution,
!      + a processor-dependent positive value if an error condition occurs
!      + the value -2 if no error condition occurs but WAIT is present
!        with the value false and the processor does not support asynchronous
!        execution.
!      + Otherwise it is assigned the value 0.
!  CMDMSG is assigned an error message if an error has occurred. (exitstat or cmdstat or both?)
!         If an error condition occurs, it is assigned a processor- dependent explanatory message. Otherwise, it is unchanged.
character(len=*),intent(in)  :: command
logical,intent(in),optional  :: verbose
logical                      :: verbose_
integer                      :: istat
logical,parameter            :: wait=.true.
integer                      :: exitstat
integer                      :: cmdstat
character(len=256)           :: cmdmsg
character(len=:),allocatable :: command_
   if(present(verbose))then
      verbose_=verbose
   else
      verbose_=.false.
   endif
   command_=adjustl(command)//'   '
   if(index(command_,'* ') == 1)then
      command_=getarg0_()//command_(2:)
   elseif(index(command_,'** ') == 1)then
      command_=getall_()//command_(2:)
   endif
   if(verbose_)call wrt(G_luns,"command: ",command_)
   cmdmsg=' '
   call execute_command_line(command_,wait,exitstat,cmdstat,cmdmsg)
   flush(unit=6)
   if(cmdstat /= 0)then
      call wrt(G_luns,"cmdstat: ",cmdmsg,'for command :',command_)
   elseif(cmdmsg /= '')then
      call wrt(G_luns,"exitstat: ",cmdmsg,'for command :',command_)
   endif
   istat=merge(-cmdstat,exitstat,exitstat == 0.and.cmdstat /= 0)
end function unit_test_system
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getarg0_(3f) - [M_framework__verify:QUERY] get basename of the current executable
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getarg0_() result(name)
!!
!!     character(len=:),allocatable         :: getarg0_
!!
!!##DESCRIPTION
!!    getarg0_(3f) returns the name of the current executable using
!!    get_command_argument(3f) and inquire(3f). It returns only
!!    the leaf name past the last backslash or slash and trims
!!    the suffix ".exe" as well.
!!
!!##EXAMPLES
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getarg0_
!!      use M_framework__verify, only : getarg0_
!!      implicit none
!!         write(*,'(*(a))')'Running ',getarg0_()
!!      end program demo_getarg0_
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getarg0_()
! get the pathname of getarg0_
implicit none
integer                      :: getarg0__length
integer                      :: ios
integer                      :: iend
character(len=4096)          :: long_name
character(len=:),allocatable :: getarg0_
   getarg0__length=0
   getarg0_=''
   long_name=''
   call get_command_argument(0,length=getarg0__length,status=ios)
   if(ios == 0)then
      if(allocated(getarg0_))deallocate(getarg0_)
      allocate(character(len=getarg0__length) :: getarg0_)
      call get_command_argument(0,getarg0_,status=ios)
      if(ios == 0)then
         inquire(file=getarg0_,iostat=ios,name=long_name)
         if(ios == 0)then
            getarg0_=trim(long_name)
         else
            getarg0_=getarg0_
         endif
      else
         getarg0_=''
      endif
   else
      getarg0_=''
   endif
   iend=index(getarg0_,'\',back=.true.)
   if(iend.ne.0) then
      getarg0_=getarg0_(iend+1:)
   else
      iend=index(getarg0_,'/',back=.true.)
      if(iend.ne.0)getarg0_=getarg0_(iend+1:)
   endif
   iend=len_trim(getarg0_)
   if(iend.gt.4)then
      if(getarg0_(iend-3:iend)=='.exe')getarg0_=getarg0_(:iend-4)
   endif
end function getarg0_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    getall_(3f) - [M_framework__verify:QUERY] get name of the current executable and options
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    function getall_() result(name)
!!
!!     character(len=:),allocatable         :: getall_
!!
!!##DESCRIPTION
!!    getall_(3f) returns the name of the current executable
!!    and all the arguments surrounded with double-quotes
!!
!!##EXAMPLES
!!
!!    Sample getting a pathname of current executable:
!!
!!      program demo_getall_
!!      use M_framework__verify, only : getall_
!!      implicit none
!!         write(*,'(*(a))')'Running ',getall_()
!!      end program demo_getall_
!!
!!##AUTHOR
!!        John S. Urban
!!
!!##LICENSE
!!        Public Domain
function getall_() result(command)
! get the pathname of arg
implicit none
character(len=:),allocatable :: arg
integer                      :: length
integer                      :: ios
integer                      :: i
character(len=:),allocatable :: command
   length=0
   command=''
   do i=1,command_argument_count()
      call get_command_argument(i,length=length,status=ios)
      if(ios == 0)then
         if(allocated(arg))deallocate(arg)
         allocate(character(len=length) :: arg)
         call get_command_argument(0,arg,status=ios)
         if(ios == 0)then
                 command=command//' "'//arg//'"'
         endif
      endif
   enddo
   command=getarg0_()//command
end function getall_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine run(command) ! convenience routine so command does not cause program to stop
character(len=*)             :: command
logical,parameter            :: wait=.true.
integer                      :: exitstat
integer                      :: cmdstat
character(len=256)           :: cmdmsg
   if(G_verbose)call wrt(G_luns,"+ ",command)
   cmdmsg=' '
   call execute_command_line(command,wait,exitstat,cmdstat,cmdmsg)
   if(cmdstat /= 0)then
      call wrt(G_luns,"cmdstat: ",cmdmsg,'for command :',command)
   elseif(cmdmsg /= '')then
      call wrt(G_luns,"exitstat: ",cmdmsg,'for command :',command)
   endif
end subroutine run
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! because of shell expansion just remove doublequote character from messages for now
function ndq(string) result(out)
character(len=*),intent(in)  :: string
character(len=len(string))   :: out
integer                      :: i
   do i=1,len(string)
      select case(string(i:i))
      case('"');    out(i:i)=' '
      case default; out(i:i)=string(i:i)
      end select
   enddo
end function ndq
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    glob_(3f) - [M_strings:COMPARE] compare given string for match to
!!    a pattern which may contain globbing wildcard characters
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    logical function glob_(string, pattern )
!!
!!     character(len=*),intent(in) :: string
!!     character(len=*),intent(in) :: pattern
!!
!!##DESCRIPTION
!!    glob_(3f) compares given (entire) STRING for a match to PATTERN which may
!!    contain basic wildcard "globbing" characters.
!!
!!    To get a match the entire string must be described
!!    by PATTERN. Trailing whitespace is significant, so trim the input
!!    string to have trailing whitespace ignored.
!!
!!    Patterns like "b*ba" fail on a string like "babababa" because the
!!    algorithm finds an early match. To skip over the early matches insert
!!    an extra character at the end of the string and pattern that does
!!    not occur in the pattern. Typically a NULL is used (char(0)).
!!
!!##OPTIONS
!!    string   the input string to test to see if it contains the pattern.
!!    pattern  the following simple globbing options are available
!!
!!             o "?" matching any one character
!!             o "*" matching zero or more characters.
!!               Do NOT use adjacent asterisks.
!!             o spaces are significant and must be matched or pretrimmed
!!             o There is no escape character, so matching strings with
!!               literal question mark and asterisk is problematic.
!!
!!##EXAMPLES
!!
!!   Example program
!!
!!    program demo_glob
!!    use M_framework, only : unit_test_glob
!!    implicit none
!!    write(*,*)glob_('abcdabcd','*cd*')
!!    write(*,*)glob_('abcdabcd','*no*')
!!    end program demo_glob
!!
!!##AUTHOR
!!   John S. Urban
!!
!!##REFERENCE
!!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm"
!!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014
!!
!!##LICENSE
!!   Public Domain
function glob_(tame,wild)

! ident_10="@(#) M_strings glob_(3f) function compares text strings one of which can have wildcards ('*' or '?')."

logical                    :: glob_
character(len=*)           :: tame       ! A string without wildcards
character(len=*)           :: wild       ! A (potentially) corresponding string with wildcards
character(len=len(tame)+1) :: tametext
character(len=len(wild)+1) :: wildtext
character(len=1),parameter :: NULL=char(0)
integer                    :: wlen
integer                    :: ti, wi
integer                    :: i
character(len=:),allocatable :: tbookmark, wbookmark
! These two values are set when we observe a wildcard character. They
! represent the locations, in the two strings, from which we start once we have observed it.
   tametext=tame//NULL
   wildtext=wild//NULL
   tbookmark = NULL
   wbookmark = NULL
   wlen=len(wild)
   wi=1
   ti=1
   do                                            ! Walk the text strings one character at a time.
      if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?
         do i=wi,wlen                            ! Easy: unique up on it!
            if(wildtext(wi:wi) == '*')then
               wi=wi+1
            else
               exit
            endif
         enddo
         if(wildtext(wi:wi) == NULL) then        ! "x" matches "*"
            glob_=.true.
            return
         endif
         if(wildtext(wi:wi)  /=  '?') then
            ! Fast-forward to next possible match.
            do while (tametext(ti:ti)  /=  wildtext(wi:wi))
               ti=ti+1
               if (tametext(ti:ti) == NULL)then
                  glob_=.false.
                  return                         ! "x" doesn't match "*y*"
               endif
            enddo
         endif
         wbookmark = wildtext(wi:)
         tbookmark = tametext(ti:)
      elseif(tametext(ti:ti)  /=  wildtext(wi:wi) .and. wildtext(wi:wi)  /=  '?') then
         ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.
         if(wbookmark /= NULL) then
            if(wildtext(wi:) /=  wbookmark) then
               wildtext = wbookmark
               wlen=len_trim(wbookmark)
               wi=1
               ! Don't go this far back again.
               if (tametext(ti:ti)  /=  wildtext(wi:wi)) then
                  tbookmark=tbookmark(2:)
                  tametext = tbookmark
                  ti=1
                  cycle                          ! "xy" matches "*y"
               else
                  wi=wi+1
               endif
            endif
            if (tametext(ti:ti) /= NULL) then
               ti=ti+1
               cycle                             ! "mississippi" matches "*sip*"
            endif
         endif
         glob_=.false.
         return                                  ! "xy" doesn't match "x"
      endif
      ti=ti+1
      wi=wi+1
      if (ti > len(tametext)) then
         glob_=.false.
         return
      elseif (tametext(ti:ti) == NULL) then          ! How do you match a tame text string?
         if(wildtext(wi:wi) /= NULL)then
            do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!
               wi=wi+1                           ! "x" matches "x*"
               if(wildtext(wi:wi) == NULL)exit
            enddo
         endif
         if (wildtext(wi:wi) == NULL)then
            glob_=.true.
            return                               ! "x" matches "x"
         endif
         glob_=.false.
         return                                  ! "x" doesn't match "xy"
      endif
   enddo
end function glob_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function paws()
! prompt for a letter and return try if "y" or "Y"
! maybe choice if default is T or F; maybe raw read (not portable though)
! originally was interactive with NAMELIST group for "expected" and "answer" that could be viewed
! option to pause on each unit_test(3f) as well or not; allow system commands; ...
character(len=1) :: value
integer :: iostat
logical :: paws
   paws=.false.
   if(G_interactive)then
      write(*,'(*(g0))',advance='no')'enter RETURN to continue:'
      read(*,'(a)',iostat=iostat)value
      if(iostat.eq.0)then
         select case(value)
         case('y','Y')
            paws=.true.
         case default
            paws=.false.
         end select
      endif
   endif
end function paws
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!
!!##NAME
!!    unit_test_expected(3f) - [M_framework__verify] report if two scalar values
!!    of like type and kind are equal.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    impure elemental subroutine unit_test_example(name,result,expected)
!!
!!     character(len=*),intent(in)  :: name
!!     class(*),intent(in)          :: result
!!     class(*),intent(in),optional :: expected
!!
!!##DESCRIPTION
!!    A shortcut for a common call to unit_test(3f) tests the two values
!!    of like type and kind. It is equivalent to
!!
!!        call unit_test(name,result,expected,'result=',result,'expected=',.true.)
!!
!!##OPTIONS
!!     RESULT    A generated value or expression of integer, real, character,
!!               or complex type.
!!     EXPECTED  The expected value for RESULT, of the same type and kind
!!               as RESULT. If not present, it is equivalent to .TRUE.
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!       program demo_unit_test_expected
!!       use, intrinsic :: iso_fortran_env, only: &
!!       & stdin => input_unit, stdout => output_unit, stderr => error_unit
!!       use M_framework, only:                &
!!       &  unit_test_mode,                    &
!!       &  start     =>  unit_test_start,     &
!!       &  expected  =>  unit_test_expected,  &
!!       &  stop      =>  unit_test_stop,      &
!!       & unit_test_level, unit_test_flags
!!       implicit none
!!       logical, parameter :: T=.true., F=.false.
!!       ! optional call to change default modes
!!          call unit_test_mode(  &
!!              keep_going=T,     &
!!              flags=[0],        &
!!              luns=[stderr],    &
!!              command='',       &
!!              brief=F,          &
!!              match='',         &
!!              interactive=F,    &
!!              CMDLINE=T,        &
!!              debug=F)
!!
!!          unit_test_level=0
!!          ! unit tests for ABS(3f) intrinsic
!!          call start('abs')
!!          ! integer
!!          call expected('abs',abs(-10),10)
!!          call expected('abs',abs( 10),10)
!!          ! real and elemental
!!          call expected('abs',abs( [-10.0, 10.0]),10.0)
!!          ! complex
!!          call expected('abs',abs(( 3.0,-4.0)),5.0)
!!          call expected('abs',abs((-3.0, 4.0)),5.0)
!!          call expected('abs',abs((-3.0,-4.0)),5.0)
!!          call expected('abs',abs(( 3.0, 4.0)),5.0)
!!          call stop('abs')
!!       end program demo_unit_test_expected
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
impure elemental subroutine unit_test_expected_int32(name,result,expected)
character(len=*),intent(in) :: name
integer(kind=int32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_int32

impure elemental subroutine unit_test_expected_int64(name,result,expected)
character(len=*),intent(in) :: name
integer(kind=int64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_int64

impure elemental subroutine unit_test_expected_real32(name,result,expected)
character(len=*),intent(in) :: name
real(kind=real32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_real32

impure elemental subroutine unit_test_expected_real64(name,result,expected)
character(len=*),intent(in) :: name
real(kind=real64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_real64

impure elemental subroutine unit_test_expected_cmplx32(name,result,expected)
character(len=*),intent(in) :: name
complex(kind=real32),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_cmplx32

impure elemental subroutine unit_test_expected_cmplx64(name,result,expected)
character(len=*),intent(in) :: name
complex(kind=real64),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_cmplx64

impure elemental subroutine unit_test_expected_char(name,result,expected)
character(len=*),intent(in) :: name
character(len=*),intent(in) :: result,expected
   call unit_test(name,result == expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_char

impure elemental subroutine unit_test_expected_boolean(name,result,expected)
character(len=*),intent(in) :: name
logical,intent(in) :: result,expected
   call unit_test(name,result .eqv. expected,'result=',result,'expected=',expected)
end subroutine unit_test_expected_boolean

impure elemental subroutine unit_test_expected_onoff(name,result)
character(len=*),intent(in) :: name
logical,intent(in) :: result
   call unit_test(name,result,'result=',result,'expected=',.true.)
end subroutine unit_test_expected_onoff
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__verify
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_msg/src/M_journal.f90
!>
!!##NAME
!!     M_journal(3fm) - [M_journal::INTRO] write program messages to stdout and/or
!!     a log file
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!     use, M_journal , only : journal
!!##DESCRIPTION
!!
!!    For interactive programs in particular it is useful if all messages
!!    go thru the JOURNAL(3f) routine. This makes it easy to write messages
!!    to a log file as well as standard output; to toggle time prefixes
!!    on and off; to turn on and off debug-mode messages; control output
!!    paging and create replayable input journals.
!!
!!    The primary use of JOURNAL(3f) is to create journal files for
!!    interactive programs that can be replayed and/or be used to verify
!!    program executions. Typically, you would echo what the user typed to
!!    the trail file as-is, and write output you write to stdout as comments
!!    to the trail file so that the trail file can easily be read back in
!!    (by ignoring comments). So usually things that are read from user
!!    input are using output with WHERE='T' and output that usually goes
!!    to stdout is written with WHERE='SC' in the JOURNAL(3f) call.
!!
!!     >      :
!!     >      :
!!     > character(len=256) userline, output
!!     > call journal('O','my_trail_file')  ! open trail file
!!     >      :
!!     >      :
!!     > do
!!     >    read(*,'(a)',iostat=ios) userline  ! read user input
!!     >    if(ios /= 0)exit
!!     >    ! echo user input to trail file
!!     >    call journal('T',userline)
!!     >    ! assume user input causes values i1, i2, and i3 to be calculated
!!     >    write(output,'(i0,1x,i0,1x)')i1,i2,i3 ! build an output line
!!     >    ! write output to stdout and as comment to trail file
!!     >    call journal(output)
!!     >    !or you can specify the WHERE parameter and up to ten scalar values
!!     >    call journal('SC','i1=',i1,'i2=',i2,'i3=',i3)
!!     > enddo
!!
!!    In this example an output line was built with an internal write; but calls
!!    to journal(3f) with numeric values with and without advancing I/O turned on
!!    are often used for simpler output:
!!
!!       I=10
!!       R=20.3
!!       ! write to stdout and trail file without advancing I/O
!!       call journal('+SC','I=',i)
!!       call journal('SC','AND R=',r)
!!
!!    writes to the trail file are ignored unless a trail file was opened with
!!
!!       CALL JOURNAL('O',filename)
!!
!!
!!    So that routines that do their output via JOURNAL(3f) can be used with and
!!    without programs generating trail files. That is, destinations 'T' and 'C'
!!    are ignored unless a trail file has been requested.
!!
!!    With no parameters, the trail file is flushed.
!!
!!##EXAMPLES
!!
!!
!!    The man(1) page for journal(3f) describes all the options for the WHERE field.
!!    In addition to being used to generate a journal, the routine can be used for
!!    producing optional debug messages and timing information.
!!
!!    Sample program for debug messages:
!!
!!      program demo_journal
!!      !! showing creating debug messages
!!      use M_journal, only : journal
!!      implicit none
!!      !! produces no output because trail is not on
!!      call journal('D','*demo* DEBUG MESSAGE 001 IGNORED')
!!      !! turn on debug messages
!!      call journal('>','debug on')
!!      !! produces output on stdout because debug mode
!!      !! is on but no named trail file
!!      call journal('D','*demo* DEBUG MESSAGE 002 ON STDOUT')
!!      !! open trail file
!!      call journal('O','mytrail.txt')
!!      !! debug messages now go to the trail file
!!      call journal('D','*demo* DEBUG MESSAGE 003 TO TRAIL')
!!      !! close trail file so messages go to stdout again
!!      call journal('O','')
!!      !! debug on stdout now
!!      call journal('D','*demo* DEBUG MESSAGE 004 TO STDOUT')
!!      call journal('<','debug off')
!!      !! back to no output from the next message
!!      call journal('D','*demo* DEBUG MESSAGE 005 IGNORED')
!!      end program demo_journal
!!
!!   Sample program for trail messages with optional timing information:
!!
!!      program testit
!!      use M_journal,only : journal
!!      implicit none
!!      call journal('a single string A -should be on S')
!!
!!      ! add time prefix to output
!!      call journal('%','%Y-%M-%DT%h:%m:%s.%x%u:%b')
!!      call journal('a single string B -should be on S with prefix')
!!      call journal('%','CPU_TIME: %c:CALLS: %C: %b')  ! change time prefix
!!      call journal('a single string B-1 -should be on S with prefix')
!!      call journal('a single string B-2 -should be on S with prefix')
!!      call journal('a single string B-3 -should be on S with prefix')
!!      !  Other useful time formats:
!!      !     %E -- Unix Epoch time
!!      !     %e -- integer value of Unix Epoch time
!!      !     %C -- number of times this format is used
!!      !     %c -- CPU_time(3f) output
!!      !     %S -- seconds since last use of this format
!!      !     %k -- CPU time in seconds from system_clock
!!      call journal('%','') ! turn off time prefix
!!      !
!!      call journal('a single string C -should be on S')
!!      !
!!      call journal('O','aaa.out') ! turn on trail file
!!      call journal('a single string D -should be on SC')
!!      call journal('a single string E -should be on SC')
!!      call journal('a single string F -should be on SC')
!!      call journal('O','') ! turn off trail file
!!      !
!!      call journal('a single string G -should be on S')
!!      call journal('a single string H -should be on S')
!!      call journal('a single string I -should be on S')
!!
!!      ! build one line of output with intrinsic scalar values added
!!      call journal('+sc','APPEND:')
!!      call journal('+sc',' integer',         1234)
!!      call journal('+sc',' and real',        1234.5678)
!!      call journal('+sc',' and double',1234567890.123456d0)
!!      call journal('+sc',' and logical',    .true.)
!!      call journal('sc','')
!!      !
!!      end program testit
!!
!!##AUTHOR
!!     John S. Urban
!!##LICENSE
!!     Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_journal
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, INPUT_UNIT, OUTPUT_UNIT     ! access computing environment
use :: M_msg,                      only : str
implicit none
private

!>
!!##NAME
!!      journal(3f) - [M_journal] provides public message routine, no paging or graphic mode change
!!      (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!!    subroutine journal([where,],[VALUE(s)])
!!
!!     character(len=*),intent(in) :: where
!!     character(len=*)|real|integer|doubleprecision|complex,optional :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!
!!   WRITE MESSAGES
!!    basic messages
!!
!!       call journal(where,[VALUE(S)])
!!       call journal(message) # a shortcut for "call journal('sc',message)":
!!   OPEN OR CLOSE TRAIL FILE
!!    trail file
!!
!!       call journal('O',trailfile_name) # open trail file
!!       call journal('O','')             # close trail file
!!   SET OUTPUT TIME PREFIX
!!    set the function display format for timestamps. See the NOW(3f)
!!    procedure for allowable timestamp macros
!!
!!       call journal('%',time_stamp_prefix_specification)
!!
!!   MODES
!!
!!    Turn on/off writing DEBUG messages to trail file
!!
!!       call journal('>','debug on') # turn on debug mode
!!       call journal('<','debug off') # turn off debug mode
!!
!!   ASSIGN STDOUT TO AN ALTERNATE FILE
!!    change stdout to iunit and open filename; or close unit and go back to stdout if filename=''
!!
!!       call journal(iunit,filename)
!!
!!    change stdout to iunit to use a file already open
!!
!!       call journal(iunit)
!!
!!##DESCRIPTION
!!
!!    If a user procedure is used for outputting messages instead of calling
!!    WRITE(3f) it is easy to provide control of when messages are printed
!!    (ie. a "verbose" mode, or "quite" mode), creating files to replay
!!    program execution, duplicating output, ...
!!
!!##OPTIONS
!!   WHERE  indicates where messages are written. A combination of the
!!          following characters can be used...
!!
!!      Usually one of these to write to the standard output files ...
!!
!!      S   write to stdout or iounit set with journal(unit) or
!!          journal(unit,filename).
!!      E   write to stderr
!!
!!      And one of these to write to trail file (ignore if no trail file
!!      defined) ...
!!
!!      C   write to trail file as a comment (if file is open)
!!          Writing output "as a comment" means it is preceded by a pound(#)
!!          character.
!!      T   write to trail file (if file is open)
!!
!!      Usually used by itself
!!
!!      D   write to trail file as a comment with "DEBUG:" prefix in front
!!          of message (if file is open) if debug mode is on. Write to stdout
!!          if no trail file and debug mode is on.
!!
!!      Modifier for S|E|C|T|D specifiers
!!
!!      +   subsequent files are written to with advance='no'. Position is
!!          important. '+sc' does an advance='no' on both files, 's+c'
!!          only does the advance='no' for the trail file.
!!
!!      Mode changing options used by themselves:
!!
!!      >   turn off debug messages
!!      <   turn on debug messages
!!      O   open trail file using value of "message" parameter or close
!!          trail file if no filename or a blank filename.
!!      A   Auxiliary programs that also want to write to the current log file
!!          (a2b, z2a, ...) call this routine to see if there is a trail file
!!          being generated and then add to it so that a program like ush(1f)
!!          can call the auxiliary programs and still just generate one log file,
!!          but if the auxiliary program is used as a stand-alone program no trail
!!          is generated.
!!
!!   VALUES(S)   message to write to stdout, stderr, and the trail file.
!!               a numeric or character value to optionally be appended
!!               to the message. Up to nine values are allowed. The WHERE
!!               field is required if values are added.
!!   FILENAME    when WHERE="O" to turn the trail file on or off, the "message"
!!               field becomes the trail filename to open. If blank, writing
!!               to the trail file is turned off.
!!   TFORMAT     when WHERE="%" the message is treated as a time format
!!               specification as described under now(3f).
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_journal
!!    use M_journal, only : journal
!!    !! BASIC USAGE
!!    call journal('write to standard output as-is, and trail file as a comment if open')
!!    ! since we have not opened a trail file yet, only stdout will display output
!!    call journal('c','ignored, as trail file is not open')
!!    ! now open trail file "trail"
!!    call journal('o','trail')
!!    call journal('sc','same thing except now trail file is open')
!!    ! only write to trail file if open
!!    call journal('c','not ignored, as trail file is open. Written with # suffix')
!!    call journal('t','not ignored, as trail file is open. Written as-is')
!!    ! turn off trail file
!!    call journal('o','')
!!    end program demo_journal
!!
!!   Adding intrinsic scalar values to the message:
!!
!!    program test_journal
!!    use M_journal, only: journal
!!    implicit none
!!       call journal('S','This is a test with no optional value')
!!       call journal('S','This is a test with a logical value',.true.)
!!       call journal('S','This is a test with a double value',1234567890.123456789d0)
!!       call journal('S','This is a test with a real value',1234567890.123456789)
!!       call journal('S','This is a test with an integer value',1234567890)
!!       call journal('STDC','This is a test using STDC',1234567890)
!!       call journal('stdc','This is a test using stdc',1234567890)
!!       call journal('o','journal.txt')                        ! open trail file
!!       call journal('S',1,12.34,56789.111111111d0,.false.,'a bunch of values')
!!       ! the combinations that make sense
!!       call journal('st','stdout and trail')
!!       call journal('s' ,'stdout only')
!!       call journal('t' ,'trail only')
!!       call journal('sc','stdout and trail_comment')
!!       call journal('c' ,'trail_comment only ')
!!       call journal('d' ,'debug only')
!!       call journal('e' ,'stderr only')
!!       call journal('o' ,' ') ! closing trail file
!!    end program test_journal
!!
!!    program testit
!!    ! this is a utility program that calls the module routines. It is typically built using ccall(1).
!!    use M_journal, only : journal
!!       character(len=:),allocatable :: time_stamp_prefix
!!       call journal('s','--------------------------------------------------------------------------------')
!!       call journal('s','SIMPLE WRITES')
!!       call one()
!!       call two()
!!       call journal('sc','called ONE() and TWO() but did not generate a log file')
!!       call journal('s','--------------------------------------------------------------------------------')
!!       call journal('s','SIMPLE WRITES WITH LOG FILE')
!!       call journal('o','journal.txt')                        ! open trail file
!!       call one()
!!       call two()
!!       call journal('sc','called ONE() and TWO() and generated log file journal.txt')
!!       call journal('','journal.txt')                         ! close trail file
!!       call journal('s','--------------------------------------------------------------------------------')
!!       call journal('s','SIMPLE WRITES WITH TIMING INFORMATION')
!!       time_stamp_prefix='CPU_TIME=%c:CALLS=%C:SINCE=%S:%b'  ! change time prefix
!!       call journal('%',time_stamp_prefix) ! set a time prefix in front of messages
!!       call journal('o','timed.txt')                          ! open trail file
!!       call one()
!!       call two()
!!       call journal('sc','called ONE() and TWO() and generate log file timed.txt')
!!       call journal('','timed.txt')                           ! close trail file
!!       call journal('%','')                                   ! turn off time prefix
!!       call journal('o','timed.txt')                          ! open trail file
!!       call journal('s','--------------------------------------------------------------------------------')
!!
!!    contains
!!
!!       subroutine two()
!!          call journal('Entered subroutine two')
!!          call journal('Exited subroutine two')
!!       end subroutine two
!!
!!       subroutine one()
!!          call journal('Entered subroutine one')
!!          sum=-HUGE(1.0)
!!          do i=1,10000000
!!            sum=sum+sqrt(real(i))
!!          enddo
!!          write(*,*)'SUM=',sum
!!          call journal('Exited subroutine one')
!!       end subroutine one
!!
!!    end program testit
!!
!!##AUTHOR
!!    John S. Urban
!!
!!##LICENSE
!!    Public Domain
public journal

interface journal
   module procedure flush_trail               ! journal()                ! no options
   module procedure write_message_only        ! journal(c)               ! must have one string
   module procedure where_write_message_all   ! journal(where,[g1-g9])   ! must have two strings
   module procedure set_stdout_lun            ! journal(i)               ! first is not a string
end interface journal

! ident_1="@(#) M_journal journal(3fg) provides public message routine no paging or graphic mode change"

! global variables

!integer,parameter,private  :: stdin=INPUT_UNIT
integer,save,private       :: my_stdout=OUTPUT_UNIT
logical,save               :: debug=.false.
integer,save               :: last_int=0

integer,parameter,private :: dp=kind(0.0d0)
real(kind=dp)             :: secday=86400.0d0              ! 24:00:00 hours as seconds

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine where_write_message(where,msg)

! ident_2="@(#) M_journal where_write_message(3fp) basic message routine used for journal files"

character(len=*),intent(in)  :: where
character(len=*),intent(in)  :: msg
!
!  writes error messages and general information text to stdout and the trace file
!     where=*C* write to trail file as a comment (if file is open)
!     where=*D* write to trail file as a comment with DEBUG: prefix in front of message (if file is open and debug mode on)
!     where=*E* write to stderr
!     where=*S* write to stdout or iounit set with journal(unit) or journal(unit,filename)
!     where=*T* write to trail file (if file is open)
!     where=*+* subsequent writes for this call are written with advance='no'

!     where=> turn on debug messages (change mode), which are ones with WHERE='D'
!     where=< turn off debug messages  (change mode), which are ones with WHERE='D'

!     where=O open trail file "msg" or close trail file if blank filename is given
!     where=% set prefix to run thru now(3f) to generate time prefix strings, blank turns off time prefix
!     where=N open new file and assign stdout to the file unless file name is blank; then revert to my_stdout being original stdout.
!
!  the trail file messages are preceded by a pound character (#) by default so they can easily be interpreted as comments
!  if the trace file is subsequently used as input data for a program
!
logical,save                       :: trailopen=.false.
integer,save                       :: itrail
character,save                     :: comment='#'
integer                            :: i
integer                            :: ios
integer                            :: times             ! number of times written to stdout
character(len=3)                   :: adv               ! whether remaining writes from this call use advancing I/O

character(len=:),allocatable,save  :: prefix_template   ! string to run thru now_ex(3f) to make prefix
character(len=:),allocatable       :: prefix            ! the prefix string to add to output
logical,save                       :: prefix_it=.false. ! flag whether time prefix mode is on or not
character(len=4096)                :: mssge
!-----------------------------------------------------------------------------------------------------------------------------------
!-----------------------------------------------------------------------------------------------------------------------------------
   adv='yes'
!-----------------------------------------------------------------------------------------------------------------------------------
   if(prefix_it)then
      prefix=now_ex(prefix_template)
   else
      prefix=''
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   times=0
   do i=1,len_trim(where)
      select case(where(i:i))
      case('T','t')
         if(trailopen) then
            write(itrail,'(a)',advance=adv)prefix//trim(msg)
         !!elseif(times == 0)then
         !!   write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         !!   times=times+1
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('S','s')
         write(my_stdout,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('E','e')
         write(stderr,'(a)',advance=adv)prefix//trim(msg)
         times=times+1
      !-----------------------------------------------------------------------------------------------------------------------------
      case('+'); adv='no'
      !-----------------------------------------------------------------------------------------------------------------------------
      case('>'); debug=.true.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('<'); debug=.false.
      !-----------------------------------------------------------------------------------------------------------------------------
      case('%')                       ! setting timestamp prefix
         if(msg == '')then            ! if message is blank turn off prefix
            prefix_it=.false.
         else                         ! store message as string to pass to now_ex() on subsequent calls to make prefix
            prefix_template=msg
            prefix_it=.true.
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('N')                                                   ! new name for my_stdout
         if(msg /= ' '.and.msg /= '#N#'.and.msg /= '"#N#"')then   ! if filename not special or blank open new file
            close(unit=last_int,iostat=ios)
            open(unit=last_int,file=adjustl(trim(msg)),iostat=ios)
            if(ios == 0)then
               my_stdout=last_int
            else
               write(*,*)'*journal* error opening redirected output file, ioerr=',ios
               write(*,*)'*journal* msg='//trim(msg)
            endif
         elseif(msg == ' ')then
            close(unit=last_int,iostat=ios)
            my_stdout=6
         endif
      !-----------------------------------------------------------------------------------------------------------------------------
      case('C','c')
         if(trailopen)then
            write(itrail,'(3a)',advance=adv)prefix,comment,trim(msg)
         elseif(times == 0)then
            !! write(my_stdout,'(2a)',advance=adv)prefix,trim(msg)
            !! times=times+1
         endif
      case('D','d')
         if(debug)then
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'DEBUG: ',trim(msg)
            elseif(times == 0)then
               write(my_stdout,'(3a)',advance=adv)prefix,'DEBUG:',trim(msg)
               times=times+1
            endif
         endif
      case('F','f')
         flush(unit=itrail,iostat=ios,iomsg=mssge)
         if(ios /= 0)then
            write(*,'(a)') trim(mssge)
         endif
      case('A','a')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential',file=adjustl(trim(msg)),&
            & form='formatted',iostat=ios,position='append')
            trailopen=.true.
         endif
      case('O','o')
         if(msg /= '')then
            open(newunit=itrail,status='unknown',access='sequential', file=adjustl(trim(msg)),form='formatted',iostat=ios)
            trailopen=.true.
         else
            if(trailopen)then
               write(itrail,'(4a)',advance=adv)prefix,comment,'closing trail file:',trim(msg)
            endif
            close(unit=itrail,iostat=ios)
            trailopen=.false.
         endif
      case default
         write(my_stdout,'(a)',advance=adv)'*journal* bad WHERE value '//trim(where)//' when msg=['//trim(msg)//']'
      end select
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine where_write_message
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine flush_trail()

! ident_3="@(#) M_journal flush_trail(3fp) flush trail file"

call where_write_message('F','IGNORE THIS STRING')
end subroutine flush_trail
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine set_stdout_lun(iounit)

! ident_4="@(#) M_journal set_stdout_lun(3fp) change I/O logical unit value for standard writes"

integer,intent(in)                   :: iounit
   my_stdout=iounit
end subroutine set_stdout_lun
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    where_write_message_all(3f) - [M_journal] converts any standard scalar type to a string and calls journal(3f)
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!   subroutine where_write_message_all(where,g0,g1,g2g3,g4,g5,g6,g7,g8,g9,sep)
!!
!!     character(len=*),intent(in)   :: where
!!     class(*),intent(in)           :: g0
!!     class(*),intent(in),optional  :: g1,g2,g3,g4,g5,g6,g7,g8,g9
!!     character,intent(in),optional :: sep
!!
!!##DESCRIPTION
!!    where_write_message_all(3f) builds and writes a space-separated string from up to nine scalar values.
!!
!!##OPTIONS
!!
!!    where    string designating where to write message, as with journal(3f)
!!    g0       value to print. May
!!             be of type INTEGER, LOGICAL, REAL, DOUBLEPRECISION, COMPLEX,
!!             or CHARACTER.
!!    g[1-9]   optional additional values to print the value of after g0.
!!    sep      separator to add between values. Default is a space
!!##RETURNS
!!    where_write_message_all  description to print
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_wm_all
!!    use M_journal, only : where_write_message_all
!!    implicit none
!!    end program program demo_wm_all
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
subroutine where_write_message_all(where, g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, sep)
implicit none

! ident_5="@(#) M_journal where_write_message_all(3f) writes a message to a string composed of any standard scalar types"

character(len=*),intent(in)   :: where
class(*),intent(in)           :: g0
class(*),intent(in),optional  :: g1, g2, g3, g4, g5, g6, g7, g8 ,g9
character,intent(in),optional :: sep
call where_write_message(where,str(g0, g1, g2, g3, g4, g5, g6, g7, g8, g9,sep))
end subroutine where_write_message_all
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine write_message_only(message)

! ident_6="@(#) M_journal write_message_only(3fp) calls JOURNAL('sc' message)"

character(len=*),intent(in)          :: message
!-----------------------------------------------------------------------------------------------------------------------------------
   call where_write_message('sc',trim(message))
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine write_message_only
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2j(dat,julian,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
! * Author:    John S. Urban
! * Version:   1.0 2015-12-21
! * Reference: From Wikipedia, the free encyclopedia 2015-12-19
! * There is no year zero
! * Julian Day must be non-negative
! * Julian Day starts at noon; while Civil Calendar date starts at midnight
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_7="@(#) d2j(3f) Converts proleptic Gregorian date array to Julian Day"
integer,intent(in)         :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
real(kind=dp),intent(out)  :: julian   ! Julian Day (non-negative, but may be non-integer)
integer,intent(out)        :: ierr     ! Error return, 0 for successful execution,-1=invalid year,-2=invalid month,-3=invalid day,
                                       ! -4=invalid date (29th Feb, non leap-year)
   integer                 :: year, month, day, utc, hour, minute
   real(kind=dp)           :: second
   integer                 :: A, Y, M, JDN
!-----------------------------------------------------------------------------------------------------------------------------------
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0d0    ! Second   ! correction for time zone and milliseconds
!-----------------------------------------------------------------------------------------------------------------------------------
   julian = -HUGE(99999)                  ! this is the date if an error occurs and IERR is < 0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(year==0 .or. year .lt. -4713) then
      ierr=-1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or Febuary, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for Febuary
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian date given the JDN (Julian day number) and time of day
   julian=JDN + dble(hour-12)/24.0d0 + dble(minute)/1440.0d0 + second/86400.0d0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(julian.lt.0.d0) then                  ! Julian Day must be non-negative
      ierr=1
   else
      ierr=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine d2j
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine j2d(dat,julian,ierr)
! ident_8="@(#) j2d(3f) Converts Julian Day to date array"
integer,intent(out)        :: dat(8)
integer                    :: timezone(8), tz
real(kind=dp),intent(in)   :: julian            ! Julian Day (non-negative)
integer,intent(out)        :: ierr              ! 0 for successful execution, otherwise 1
   real(kind=dp)           :: second
   integer                 :: year
   integer                 :: month
   integer                 :: day
   integer                 :: hour
   integer                 :: minute
   integer                 :: jalpha,ja,jb,jc,jd,je,ijul

   if(julian.lt.0.d0) then                      ! Negative Julian Day not allowed
      ierr=1
      return
   else
      ierr=0
   endif
   call date_and_time(values=timezone)
   tz=timezone(4)

   ijul=idint(julian)                           ! Integral Julian Day
   second=sngl((julian-dble(ijul))*secday)      ! Seconds from beginning of Jul. Day
   second=second+(tz*60)

   if(second.ge.(secday/2.0d0)) then            ! In next calendar day
      ijul=ijul+1
      second=second-(secday/2.0d0)              ! Adjust from noon to midnight
   else                                         ! In same calendar day
      second=second+(secday/2.0d0)              ! Adjust from noon to midnight
   endif

   if(second.ge.secday) then                    ! Final check to prevent time 24:00:00
      ijul=ijul+1
      second=second-secday
   endif

   minute=int(second/60.0)                      ! Integral minutes from beginning of day
   second=second-float(minute*60)               ! Seconds from beginning of minute
   hour=minute/60                               ! Integral hours from beginning of day
   minute=minute-hour*60                        ! Integral minutes from beginning of hour

   !---------------------------------------------
   jalpha=idint((dble(ijul-1867216)-0.25d0)/36524.25d0) ! Correction for Gregorian Calendar
   ja=ijul+1+jalpha-idint(0.25d0*dble(jalpha))
   !---------------------------------------------

   jb=ja+1524
   jc=idint(6680.d0+(dble(jb-2439870)-122.1d0)/365.25d0)
   jd=365*jc+idint(0.25d0*dble(jc))
   je=idint(dble(jb-jd)/30.6001d0)
   day=jb-jd-idint(30.6001d0*dble(je))
   month=je-1

   if(month.gt.12)then
      month=month-12
   endif

   year=jc-4715
   if(month.gt.2)then
      year=year-1
   endif

   if(year.le.0)then
      year=year-1
   endif

   dat(1)=year
   dat(2)=month
   dat(3)=day
   dat(4)=tz
   dat(5)=hour
   dat(6)=minute
   dat(7)=int(second)
   dat(8)=int((second-int(second))*1000.0)
   ierr=0

end subroutine j2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine d2u(dat,unixtime,ierr)
! ident_9="@(#) d2u(3f) Converts date array to Unix Time (UT starts at 0000 on 1 Jan. 1970)"
integer,intent(in)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
real(kind=dp),intent(out)  :: unixtime                ! Unix time (seconds)
integer,intent(out)        :: ierr                    ! return 0 on successful, otherwise 1
   real(kind=dp)           :: julian
   real(kind=dp),save      :: julian_at_epoch
   logical,save            :: first=.true.
!-----------------------------------------------------------------------------------------------------------------------------------
if(first) then                                        ! Compute zero of Unix Time in Julian days and save
   call d2j([1970,1,1,0,0,0,0,0],julian_at_epoch,ierr)
   if(ierr.ne.0) return                               ! Error
   first=.false.
endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call d2j(dat,julian,ierr)
   if(ierr.ne.0) return                               ! Error
   unixtime=(julian-julian_at_epoch)*secday
end subroutine d2u
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine u2d(dat,unixtime,ierr)
! REF:JRH:1991-05-23
! REF:JSU:2015-12-12
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_10="@(#) u2d(3f) Converts Unix Time to date array"
integer,intent(out)        :: dat(8)                           ! date and time array
real(kind=dp),intent(in)   :: unixtime                         ! Unix time (seconds)
integer,intent(out)        :: ierr                             ! 0 for successful execution, otherwise 1
real(kind=dp)              :: julian                           ! Unix time converted to a Julian date
real(kind=dp),save         :: Unix_Origin_as_Julian            ! start of Unix Time as Julian date
logical,save               :: first=.TRUE.
integer                    :: v(8)                             ! date and time array used to get time zone
!-----------------------------------------------------------------------------------------------------------------------------------
if(first)then                                                  ! Initialize calculated constants on first call
   call d2j([1970,1,1,0,0,0,0,0],Unix_Origin_as_Julian,ierr)   ! Compute start of Unix Time in Julian days
   if(ierr.ne.0) return                                        ! Error
   first=.FALSE.
endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call date_and_time(values=v)                                ! need to get time zone
   julian=(unixtime/secday)+Unix_Origin_as_Julian              ! convert seconds from Unix Epoch to Julian days
   call j2d(dat,julian,ierr)                                   ! calculate date array from Julian date
   dat(4)=v(4)
end subroutine u2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION d2o(dat) RESULT (ordinal)
! ident_11="@(#) d2o(3f) Converts date-time array to Ordinal day"
INTEGER,INTENT(IN)         :: dat(8)                  ! date time array similar to that returned by DATE_AND_TIME
INTEGER                    :: ordinal                 ! the returned number of days
   REAL(KIND=dp)           :: unixtime                ! Unix time (seconds)
   REAL(KIND=dp)           :: unix_first_day
   INTEGER                 :: ierr                    ! return 0 on successful, otherwise 1 from d2u(3f)
   CALL d2u(dat,unixtime,ierr)                        ! convert date to Unix Epoch Time
   IF(ierr.NE.0)THEN
      write(*,*)'*d2o* bad date array'
      ordinal=-1                                      ! initialize to bad value
   ELSE
      CALL d2u([dat(1),1,1,dat(4),0,0,0,0],unix_first_day,ierr)
      ordinal=int((unixtime-unix_first_day)/secday)+1
   ENDIF
END FUNCTION d2o
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION v2mo(imonth) RESULT(month_name)
! ident_12="@(#) v2mo(3f) returns the month name of a Common month"
CHARACTER(LEN=:),ALLOCATABLE :: month_name                                        ! string containing month name or abbreviation.
INTEGER,INTENT(IN)           :: imonth                                            ! the number of the month(1-12)
CHARACTER(LEN=*),PARAMETER   :: names(12)=[ character(len=9) ::  &
&'January  ', 'February ', 'March    ', 'April    ', 'May      ', 'June     ', &
&'July     ', 'August   ', 'September', 'October  ', 'November ', 'December ']
   SELECT CASE(imonth)
   CASE (1:12);  month_name=TRIM(names(imonth))
   CASE DEFAULT; month_name='UNKNOWN'
   END SELECT
END FUNCTION v2mo
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION now(format)
! ident_13="@(#) JSU 2015-10-24"
CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: format
CHARACTER(LEN=:),ALLOCATABLE         :: now
   INTEGER                           :: values(8)
!-----------------------------------------------------------------------------------------------------------------------------------
   CALL DATE_AND_TIME(VALUES=values)
   IF(PRESENT(format))THEN
      IF(format.NE.' ')THEN
         now=fmtdate(values,format)
      ELSE
         now=fmtdate(values,'%Y-%M-%D %h:%m:%s %z')
      ENDIF
   ELSE
      NOW=fmtdate(values,'%Y-%M-%D %h:%m:%s %z Julian date is %J Epoch time is %E ')
   ENDIF
END FUNCTION now
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
FUNCTION fmtdate(values,format) RESULT (timestring)
! Read the FORMAT string and replace the "%" strings per the following rules:
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_14="@(#) fmtdate(3f) given date array return date as string using format"
CHARACTER(LEN=*),INTENT(IN)     :: format    ! input format string
INTEGER,DIMENSION(8),INTENT(IN) :: values    ! numeric time values as DATE_AND_TIME(3f) intrinsic returns
CHARACTER(LEN=:),ALLOCATABLE    :: timestring
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
   INTEGER              :: i10
   LOGICAL              :: keyword   ! flag that previous character was a % character
   CHARACTER(LEN=9)     :: day       ! day of week
   CHARACTER(LEN=1)     :: chara     ! character being looked at in format string
   CHARACTER(LEN=4096)  :: text      ! character array
   INTEGER              :: iout
   INTEGER              :: weekday
   INTEGER              :: ierr
   INTEGER,SAVE         :: called=0
   LOGICAL,SAVE         :: since=.FALSE.
   REAL(KIND=dp)        :: julian
   REAL(KIND=dp)        :: cputime
   INTEGER              :: ii
   REAL(KIND=dp)        :: unixtime
   REAL(KIND=dp),save   :: unixtime_last
   INTEGER              :: systemclock, countrate
   INTEGER              :: iso_year, iso_week, iso_weekday
   CHARACTER(LEN=10)    :: iso_name
   CHARACTER(LEN=2)     :: dayend

   text=' '
!  write string, when encounter a percent character do a substitution
   keyword=.FALSE.
   iout=1
   DO i10=1,LEN(format)
      chara=format(i10:i10)
      IF(chara.eq.'%'.and..not.keyword)THEN
            keyword=.TRUE.
            CYCLE
      ENDIF
      IF(keyword)THEN
         keyword=.FALSE.
         SELECT CASE(chara)
         !=====================================================================================
         CASE('%'); WRITE(text(iout:),'(A1)')chara                        ! literal percent character
         !=====================================================================================
         CASE('b'); WRITE(text(iout:),'(A1)')' '                          ! space character
         !=====================================================================================
         CASE('c'); CALL cpu_time(cputime)                                ! CPU_TIME()
                    WRITE(text(iout:),'(G0)')cputime
         !=====================================================================================
         CASE('C'); called = called + 1                                   ! number of times this routine called
                    WRITE(text(iout:),'(I0)')called
         !=====================================================================================
         CASE('d');                                                       ! the day of the month 1st..31st
                    dayend='  '
                    select case(values(3))
                    case(1,21,31); dayend='st'
                    case(2,22); dayend='nd'
                    case(3,23); dayend='rd'
                    case(4:20,24:30); dayend='th'
                    case default
                    end select
                    WRITE(text(iout:),'(I2,a)')values(3),dayend
         !=====================================================================================
         CASE('D'); WRITE(text(iout:),'(I2.2)')values(3)                  ! the day of the month 1..31
         !=====================================================================================
         CASE('e'); CALL d2u(values,unixtime,ierr)                        ! integer Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')int(unixtime)
         !=====================================================================================
         CASE('E'); CALL d2u(values,unixtime,ierr)                        ! Unix Epoch time in seconds
                    WRITE(text(iout:),'(G0)')unixtime
         !=====================================================================================
         CASE('h'); WRITE(text(iout:),'(I2.2)')values(5)                  ! the hour of the day, in the range of 0 to 23
         !=====================================================================================
         CASE('H'); ii=mod(values(5),12)                                  ! hour of day in range 1..12
                    if(ii.eq.0)then
                       ii=12
                    endif
                    WRITE(text(iout:),'(I2.2)')ii
         !=====================================================================================
         CASE('i'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! ISO week of year
                    WRITE(text(iout:),'(I0)')iso_week
         !=====================================================================================
         CASE('I'); CALL woy(values,iso_year,iso_week,iso_weekday,iso_name) ! iso-8601 Week-numbering year date
                    WRITE(text(iout:),'(a)')iso_name
         !=====================================================================================
         CASE('j'); CALL d2j(values,julian,ierr)                          ! integer Julian date (truncated to integer)
                    WRITE(text(iout:),'(I0)')int(julian)
         !=====================================================================================
         CASE('J'); CALL d2j(values,julian,ierr)                          ! Julian date to milliseconds
                    WRITE(text(iout:),'(I0,".",i3.3)')int(julian),int((julian-int(julian))*1000.0)
         !=====================================================================================
         CASE('k'); call system_clock(count=systemclock,count_rate=countrate)  ! systemclock/countrate
                    WRITE(text(iout:),'(G0)')real(systemclock)/countrate
         !=====================================================================================
         CASE('l'); WRITE(text(iout:),'(A3)')v2mo(values(2))              ! three characters of the name of the month of the year
         !=====================================================================================
         CASE('L'); WRITE(text(iout:),'(A)')v2mo(values(2))               ! name of the month of the year
         !=====================================================================================
         CASE('m'); WRITE(text(iout:),'(I2.2)')values(6)                  ! the minutes of the hour, in the range 0 to 59
         !=====================================================================================
         CASE('M'); WRITE(text(iout:),'(I2.2)')values(2)                  ! month of year (1..12)
         !=====================================================================================
         CASE('N'); if( values(5).ge.12)then                              ! AM||PM
                       WRITE(text(iout:),'("PM")')
                    else
                       WRITE(text(iout:),'("AM")')
                    endif
         !=====================================================================================
         CASE('O'); WRITE(text(iout:),'(I3.3)')d2o(values)                ! Ordinal day of year
         !=====================================================================================
         CASE('s'); WRITE(text(iout:),'(I2.2)')values(7)                  ! the seconds of the minute, in the range 0 to 60
         !=====================================================================================
         CASE('S'); IF(.NOT.since)THEN                                    ! seconds since last called
                       since=.TRUE.
                       CALL d2u(values,unixtime_last,ierr)
                    ENDIF
                    CALL d2u(values,unixtime,ierr)
                    WRITE(text(iout:),'(G0)')unixtime-unixtime_last
                    unixtime_last=unixtime
         !=====================================================================================
         CASE('t'); WRITE(text(iout:),'(A1)')CHAR(9)                      ! tab character
         !=====================================================================================
         CASE('U'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Sunday=1
                    WRITE(text(iout:),'(I1)')weekday
         !=====================================================================================
         CASE('u'); CALL dow(values,weekday,day,ierr)                     ! Return the day of the week, 1..7 Monday=1
                    WRITE(text(iout:),'(I1)')mod(weekday+5,7)+1
         !=====================================================================================
         CASE('W'); CALL dow(values,weekday,day,ierr)                     ! Return the name of the day of the week
                    WRITE(text(iout:),'(a)')day
         !=====================================================================================
         CASE('w'); CALL dow(values,weekday,day,ierr)                     ! Return the first three characters of the day of the week
                    WRITE(text(iout:),'(A3)')day(1:3)
         !=====================================================================================
         CASE('x'); WRITE(text(iout:),'(I3.3)')values(8)                  ! the milliseconds of the second, in the range 0 to 999
         !=====================================================================================
         CASE('Y'); WRITE(text(iout:),'(I4.4)')values(1)                  ! the year, including the century (for example, 1990)
         !=====================================================================================
         CASE('Z'); WRITE(text(iout:),'(SP,I5.4)')values(4)               ! time difference with respect to UTC in minutes
         !=====================================================================================
         CASE('z'); WRITE(text(iout:),'(I3.2,":",I2.2)')int(values(4)/60),abs(mod(values(4),60)) ! time from UTC as +-hh:mm
         !=====================================================================================
         CASE DEFAULT
            WRITE(text(iout:),'(A1)')chara
         !=====================================================================================
         END SELECT
         !=====================================================================================
         iout=len_trim(text)+1
      ELSE
         WRITE(text(iout:),'(A1)')chara;iout=iout+1
      ENDIF
   ENDDO
   timestring=trim(text)
END FUNCTION fmtdate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine fmtdate_usage(ii)
! ident_15="@(#) JSU 2015-10-24"
character(len=51),allocatable :: usage(:)
integer                       :: i,ii
character(len=ii)             :: blanks
usage=[ &                                               !date(1) COMMAND
&' Base time array:                                  ',&
&' (1) %Y -- year, yyyy                              ',&
&' (2) %M -- month of year, 01 to 12                 ',&
&' (3) %D -- day of month, 01 to 31                  ',&
&'     %d -- day of month, with suffix (1st, 2nd,...)',&
&' (4) %Z -- minutes from UTC                        ',&
&'     %z -- -+hh:mm from UTC                        ',&
&' (5) %h -- hours, 00 to 23                         ',&
&'     %H -- hour (1 to 12, or twelve-hour clock)    ',&
&'     %N -- AM (before noon) PM (>=after noon)      ',&
&' (6) %m -- minutes, 00 to 59                       ',&
&' (7) %s -- sec, 00 to 60                           ',&
&' (8) %x -- milliseconds 000 to 999                 ',&
&'Conversions                                        ',&
&'     %E -- Unix Epoch time                         ',&
&'     %e -- integer value of Unix Epoch time        ',&
&'     %J -- Julian  date                            ',&
&'     %j -- integer value of Julian date            ',&
&'     %O -- Ordinal day (day of year)               ',&
&'     %U -- day of week, 1..7 Sunday=1              ',&
&'     %u -- day of week, 1..7 Monday=1              ',&
&'     %i -- ISO week of year 1..53                  ',&
&'     %I -- iso-8601 week-numbering date(yyyy-Www-d)',&
&' Names                                             ',&
&'     %l -- abbreviated month name                  ',&
&'     %L -- full month name                         ',&
&'     %w -- first three characters of weekday       ',&
&'     %W -- weekday name                            ',&
&' Literals                                          ',&
&'     %% -- a literal %%                            ',&
&'     %t -- tab character                           ',&
&'     %b -- blank character                         ',&
&' Program timing:                                   ',&
&'     %c -- CPU_TIME(3f) output                     ',&
&'     %C -- number of times this routine is used    ',&
&'     %k -- time in seconds from SYSTEM_CLOCK(3f)   ',&
&'                                                   ']
   blanks=' '
   WRITE(*,'(a,a)')(blanks(:ii),usage(i),i=1,size(usage))
end subroutine fmtdate_usage
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine dow(values, weekday, day, ierr)
! ident_16="@(#) dow(3f) Return the day of the week"
real(kind=dp)                      :: julian    ! the julian day for which the weekday is required,
integer,intent(in)                 :: values(8) ! date and time array used to get time zone
integer,intent(out),optional       :: weekday   ! The day of the week, 1 = Sunday
character*(*),intent(out),optional :: day       ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9
integer,intent(out)                :: ierr      ! Error return,0=correct,-1=invalid Julian day,-2=neither day nor weekday specified
   integer                         :: iweekday

   call d2j(values,julian,ierr)                 ! need julian date to calculate day of week for first day of month
   ierr = 0

   if(julian < 0) then
      ierr = -1
      return
   endif

   if(.not.present(day).and. .not.present(weekday)) then
      ierr=-2
      return
   endif

   ! julian day starts at noon so add 1/2 day
   ! add time zone
   iweekday = mod(int((julian+dble(values(4)/60.0d0/24.0d0)+0.5d0)+1.0d0), 7)
   iweekday = iweekday +1

   if(present(day)) then
      select case(iweekday)
      case(1)     ;day = 'Sunday'
      case(2)     ;day = 'Monday'
      case(3)     ;day = 'Tuesday'
      case(4)     ;day = 'Wednesday'
      case(5)     ;day = 'Thursday'
      case(6)     ;day = 'Friday'
      case(7)     ;day = 'Saturday'
      case default;day = 'E-R-R-O-R'
      end select
   endif

   if(present(weekday))then
      weekday=iweekday
   endif

end subroutine dow
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine woy(dat,iso_year,iso_week,iso_weekday,iso_name)
!-----------------------------------------------------------------------------------------------------------------------------------
!  The ISO-8601 date and time standard was issued by the International Organization for Standardization (ISO).
!  It is used (mainly) in government and business for fiscal years, as well as in timekeeping.
!  The system specifies a week year atop the Gregorian calendar by defining a notation for ordinal weeks of the year.
!
!  An ISO week-numbering year (also called ISO year informally) has 52 or 53 full weeks.
!  That is 364 or 371 days instead of the usual 365 or 366 days.
!  The extra week is referred to here as a leap week, although ISO 8601 does not use this term.
!  Weeks start with Monday.
!  The first week of a year is the week that contains the first Thursday of the year (and, hence, always contains 4 January).
!  ISO week year numbering therefore slightly deviates from the Gregorian for some days close to 1 January.
!-----------------------------------------------------------------------------------------------------------------------------------
!CALCULATION:
!  The ISO-8601 week number of any date can be calculated, given its ordinal date (i.e. position within the year)
!  and its day of the week.

!METHOD:
!   Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday),
!   subtract the weekday from the ordinal date, then add 10. Divide the result
!   by 7. Ignore the remainder; the quotient equals the week number. If
!   the week number thus obtained equals 0, it means that the given date
!   belongs to the preceding (week-based) year. If a week number of 53 is
!   obtained, one must check that the date is not actually in week 1 of the
!   following year.
! These two statements are assumed true when correcting the dates around January 1st ...
!   o  The number of weeks in a given year is equal to the corresponding week number of 28 December.
!   o  January 4th is always in the first week.
!
!ISO_NAME:
!  Week date representations are in the format YYYYWww-D.
!  o [YYYY] indicates the ISO week-numbering year which is slightly different from the traditional Gregorian calendar year.
!  o [Www] is the week number prefixed by the letter W, from W01 through W53.
!  o [D] is the weekday number, from 1 through 7, beginning with Monday and ending with Sunday.
!
!  For example, the Gregorian date 31 December 2006 corresponds to the Sunday of the 52nd week of 2006, and is written
!     2006-W52-7 (extended form)
!  or 2006W527 (compact form).
!
!REFERENCE:
!  From Wikipedia, the free encyclopedia 2015-12-19
!AUTHOR:
!  John S. Urban, 2015-12-19
!-----------------------------------------------------------------------------------------------------------------------------------
! ident_17="@(#) woy(3f) Calculate iso-8601 Week-numbering year date yyyy-Www-d"
integer,parameter               :: dp=kind(0.0d0)
integer,intent(in)              :: dat(8)     ! input date array
integer,intent(out)             :: iso_year, iso_week, iso_weekday
character(len=10),intent(out)   :: iso_name
integer                         :: shared_weekday
integer                         :: last_week_this_year
integer                         :: dec28_lastyear(8)   ! December 28th is always in last week
integer                         :: dec28_thisyear(8)   ! December 28th is always in last week
character(len=9)                :: day
integer                         :: ierr
   iso_year=dat(1)                                               ! initially assume the iso_year is the same as the data array year
   iso_week=uncorrected_week_of_year(dat)                        ! this is the week number unless around January 1st
   iso_weekday=shared_weekday                                    ! this is the number of the day of the week assuming Monday=1
   dec28_thisyear=[dat(1),12,28,dat(4),0,0,0,0]                  ! Dec 28th is always in last week; use this to get number of weeks
   last_week_this_year=uncorrected_week_of_year(dec28_thisyear)  ! get the number of the last week of the year (52 or 53)
   ! correct dates around January 1st
   if(iso_week  < 1)then                                         ! if week < 1 then week = lastWeek(year -1)
      dec28_lastyear=[dat(1)-1,12,28,dat(4),0,0,0,0]             ! Dec 28th is always in last week, we want its week number
      iso_week=uncorrected_week_of_year(dec28_lastyear)          ! got the week number for the last week of last year (52 or 53)
      iso_year=dat(1)-1                                          ! our date belongs to last year
   elseif(iso_week >last_week_this_year)then                     ! if week > lastweek(year) then week = 1
      iso_week=iso_week-last_week_this_year                      ! our date belongs to next year
      iso_year=dat(1)+1
   endif

   write(iso_name,'(i4.4,"-W",i2.2,"-",i1)')iso_year,iso_week,iso_weekday ! create ISO string designation for our date

contains
   function uncorrected_week_of_year(datin)
   implicit none
   integer            :: uncorrected_week_of_year
   integer,intent(in) :: datin(8)
      integer         :: ordinal
      call dow(datin,shared_weekday,day,ierr)                 ! formula needs day of week 1..7 where Monday=1
      shared_weekday=mod(shared_weekday+5,7)+1                ! change from Sunday=1 to Monday=1
      ordinal=d2o(datin)                                      ! formula needs ordinal day of year where Jan 1st=1
      uncorrected_week_of_year=(ordinal-shared_weekday+10)/7
   end function uncorrected_week_of_year

end subroutine woy
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function dj(dat) result (julian)
! ident_18="@(#) dj(3f) Given date array returns Julian Day"
real(kind=dp)              :: julian
integer,intent(in)         :: dat(8)
   integer                 :: ierr
call d2j(dat,julian,ierr)
end function dj

function jd(julian) result (dat)
! ident_19="@(#) jd(3f) Given Julian Day returns date array"
real(kind=dp),intent(in)   :: julian
integer                    :: dat(8)
   integer                 :: ierr
call j2d(dat,julian,ierr)
end function jd

function du(dat) result (unixtime)
! ident_20="@(#) du(3f) Given date array returns Unix Epoch time"
real(kind=dp)              :: unixtime
integer,intent(in)         :: dat(8)
   integer                 :: ierr
call d2u(dat,unixtime,ierr)
end function du

function ud(unixtime) result (dat)
! ident_21="@(#) ud(3f) Given Unix Epoch Time returns date array"
real(kind=dp),intent(in)   :: unixtime
integer                    :: dat(8)
   integer                 :: ierr
call u2d(dat,unixtime,ierr)
end function ud
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!
!   XXXX
!  X    X
! X
! X
! X
! X
! X
!  X    X
!   XXXX
!
subroutine sys_sleep(wait_seconds)
use, intrinsic  :: iso_c_binding, only: c_int

! ident_22="@(#) sys_sleep(3f) call sleep(3c)"

integer (c_int) :: wait_seconds, how_long
interface
      function c_sleep (seconds)  bind ( C, name="sleep" )
          import
          integer (c_int) :: c_sleep !  should be unsigned int (not available in Fortran).  OK until highest bit gets set.
          integer (c_int), intent (in), VALUE :: seconds
      end function c_sleep
end interface
   if(wait_seconds.gt.0)then
      how_long = c_sleep(wait_seconds)
   endif
end subroutine sys_sleep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function now_ex(format)

! ident_23="@(#) M_time now_ex(3f) use of now(3f) outside of a module"

character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: now_ex
   now_ex=now(format)
end function now_ex
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_journal
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_time/src/M_time.F90
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
module M_time
!>
!! AUTHOR:    John S. Urban
!!##VERSION:   2.0 2022-01-16
!! REFERENCE: From Wikipedia, the free encyclopedia 2015-12-19
use M_time__duplicate
use, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64
use, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdout=>OUTPUT_UNIT,stdin=>INPUT_UNIT
implicit none !(external,type)

! ident_1="@(#) M_time M_time(3f) date and time function module"

private
!-----------------------------------------------------------------------------------------------------------------------------------
! version: 6E61627255202E53206E686F4A-2022-03-18
! version: 25aaf2ab-e76c-45ab-4811-8de9fa78cb69
!-----------------------------------------------------------------------------------------------------------------------------------
! EPOCH TIME (UT starts at 0000 on 1 Jan. 1970)
   public date_to_unix   !(dat,UNIXTIME,IERR)                 ! Convert date array to Unix Time
   public unix_to_date   !(unixtime,DAT,IERR)                 ! Convert Unix Time to date array
   public d2u            !(dat) result(UNIXTIME)              ! Convert date array to Unix Time
   public u2d            !(unixtime) result(DAT)              ! Convert Unix Time to date array
! JULIAN
   public julian_to_date !(julian,DAT,IERR)                   ! Convert Julian Date to date array
   public date_to_julian !(dat,JULIAN,IERR)                   ! Convert date array to Julian Date
   public d2j            !(dat) result(JULIAN)                ! Convert date array to Julian Date
   public j2d            !(julian) result(DAT)                ! Convert Julian Date to date array
! MODIFIED JULIAN
   public modified_julian_to_date !(julian,DAT,IERR)          ! Convert Modified Julian Date to date array
   public date_to_modified_julian !(dat,JULIAN,IERR)          ! Convert date array to Modified Julian Date
   public d2m            !(dat) result(MODIFIED_JULIAN)       ! Convert date array to Modified Julian Date
   public m2d            !(modified_julian) result(DAT)       ! Convert Modified Julian Date to date array
! BASEDAY AND SECONDS
   public bas_to_date    !(bas,DAT,IERR)                      ! Convert Baseday And Seconds to date array
   public date_to_bas    !(dat,BAS,IERR)                      ! Convert date array to Baseday And Seconds
   public d2b            !(dat) result(BAS)                   ! Convert date array to Baseday And Seconds
   public b2d            !(bas) result(DAT)                   ! Convert Baseday And Seconds to date array
! DAY OF WEEK
   public dow            !(dat,[WEEKDAY],[DAY],[IERR],[SHORT])! Convert date array to day of the week as number(Mon=1) and name
! WEEK OF YEAR
   public d2w !(dat,ISO_YEAR,ISO_WEEK,ISO_WEEKDAY,ISO_NAME)   ! Calculate iso-8601 Week numerically and as string "yyyy-Www-d"
   public w2d !(iso_year,iso_week,iso_weekday,DAT)            ! given iso-8601 Week-numbering year date yyyy-Www-d calculate date
              !(iso_wee_string,DAT,IERR)
! ORDINAL DAY
   public d2o            !(dat) result(ORDINAL)               ! given date array return ordinal day of year, Jan 1st=1
   public o2d            !(ordinal) result(DAT)               ! given ordinal day of year return date array, Jan 1st=1
   public ordinal_to_date!(year,ordinal_day,DAT)              ! given ordinal day of year return date array, Jan 1st=1
   public ordinal_seconds!()                                  ! seconds since the beginning of current year
! PRINTING DATES
   public fmtdate        !(dat,format) result(TIMESTR)        ! Convert date array to string using format
   public fmtdate_usage  !(indent)                            ! display macros recognized by fmtdate(3f)
   public now            !(format) result(NOW)                ! return string representing current time given format
   public box_month      !(dat,CALEN)                         ! print specified month into character array
! PRINTING DURATIONS
   public sec2days       !(seconds) result(dhms)              ! converts seconds to string D-HH:MM:SS
   public days2sec       !(str) result(seconds)               ! converts string D-HH:MM:SS or dNNhNNmNNssNN to seconds
! MONTH NAME
   public mo2v           !(month_name) result(MONTH_NUMBER)       ! given month name return month number
   public v2mo           !(month_number,short) result(MONTH_NAME) ! given month number return month name
   public mo2d           !(month_name,year) result(DAT)           ! given month name and year return date array for 1st day of month
! LOCALE
   public locale         !(locale_name,mths,wkds,mths_abbr,wkds_abbr,ierr)  ! user-specified strings to use for month and weekday
! ASTROLOGICAL
   public easter         !(year,dat)                          ! calculate month and day Easter falls on for given year
   public moon_fullness  !(dat) result(FULLNESS)              ! percentage of moon phase from new to full
   public phase_of_moon  !(dat) result(PHASE)                 ! return name for phase of moon for given date
!x! public ephemeris      !(dat,planet,DD,DM,DC,AH,AM)         ! ephemeris position of planets for adjusting an equatorial telescope
! READING DATES
   public guessdate      !(anot,dat)                          ! Converts a date string to a date array, in various formats
! C INTERFACE
   public system_sleep   !(wait_seconds)                      ! Call sleep(3c)
   private call_sleep
   private call_usleep
!-----------------------------------------------------------------------------------------------------------------------------------
integer,parameter          :: dp=kind(0.0d0)
integer,parameter,public   :: realtime=kind(0.0d0)           ! type for unix epoch time and julian days
!-----------------------------------------------------------------------------------------------------------------------------------
! INTERNAL
real(kind=realtime),parameter,private :: SECDAY=86400.0_dp    ! 24:00:00 hours as seconds
!-----------------------------------------------------------------------------------------------------------------------------------
!  integer,parameter       :: igreg_1582=15+31*(10+12*1582)   ! ASSUMES: Gregorian Calendar was adopted 15 Oct. 1582 (588829)
!  integer,parameter       :: igreg_1752=03+31*( 9+12*1752)   ! ASSUMES: Gregorian Calendar was adopted 3 Sep. 1752 (652026)
!  integer,save            :: igreg=igreg_1582
!-----------------------------------------------------------------------------------------------------------------------------------
! CONVENIENT CONSTANTS FOR USE WITH + AND - OPERATORS
real(kind=realtime),public,parameter :: dt_minute=60.0_dp     ! one minute in seconds
real(kind=realtime),public,parameter :: dt_hour=3600.0_dp     ! one hour in seconds
real(kind=realtime),public,parameter :: dt_day=86400.0_dp     ! 24:00:00 hours in seconds
real(kind=realtime),public,parameter :: dt_week=dt_day*7.0_dp ! one week in seconds
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: gen='(*(g0,1x))'
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=:),save,allocatable,public :: M_time_weekday_names(:)
character(len=:),save,allocatable,public :: M_time_month_names(:)
character(len=:),save,allocatable,public :: M_time_weekday_names_abbr(:)
character(len=:),save,allocatable,public :: M_time_month_names_abbr(:)
!-----------------------------------------------------------------------------------------------------------------------------------
character(len=*),parameter   :: G_month_names(12)=[                               &
   &'January  ', 'February ', 'March    ', 'April    ', 'May      ', 'June     ', &
   &'July     ', 'August   ', 'September', 'October  ', 'November ', 'December ']

character(len=3),parameter   :: G_month_names_abbr(12)=G_month_names(:)(1:3)

character(len=*),parameter   :: G_weekday_names(7)=[character(len=9) :: &
   & 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday' ]

character(len=3),parameter   :: G_weekday_names_abbr(7)=G_weekday_names(:)(1:3)
!-----------------------------------------------------------------------------------------------------------------------------------
interface w2d
   module procedure w2d_numeric
   module procedure w2d_string
end interface w2d
!-----------------------------------------------------------------------------------------------------------------------------------
type BAStime
      ! COMPONENTS:
      integer           :: base_day ! number of days since the MJD Epoch date
      real(kind=real64) :: secs     ! seconds from start of base_day
   contains
      ! METHODS:
      procedure  :: reduce => bas_reduce
      procedure  :: format => bas_format
      !   procedure  :: datout => dt2d_
      !   procedure  :: epoch  => epoch_
      !   procedure  :: julian => julian_
      !   procedure  :: ordinal
      !   procedure  :: delta
      !   procedure  :: init => init_dt
      !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(BAStime)
      procedure,public  :: bas_plus;  generic :: operator(+)  => bas_plus
      procedure,public  :: bas_minus; generic :: operator(-)  => bas_minus
      procedure,public  :: bas_multiply; generic :: operator(*)  => bas_multiply
      procedure,public  :: bas_divide;   generic :: operator(/)  => bas_divide
      procedure,private :: bas_eq;    generic :: operator(==) => bas_eq
      procedure,private :: bas_lt;    generic :: operator(<)  => bas_lt
      procedure,private :: bas_gt;    generic :: operator(>)  => bas_gt
      procedure,private :: bas_ge;    generic :: operator(>=) => bas_ge
      procedure,private :: bas_le;    generic :: operator(<=) => bas_le
      procedure,private :: bas_ne;    generic :: operator(/=) => bas_ne
      !-! procedure,private :: construct_from_dat; generic :: assignment(=)  => construct_from_dat

end type BAStime

public BAStime
public bas_plus
public bas_minus
public bas_multiply
public bas_divide
public bas_format
!-----------------------------------------------------------------------------------------------------------------------------------
 contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    date_to_julian(3f) - [M_time:JULIAN] converts DAT date-time array to
!!    Julian Date
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine date_to_julian(dat,juliandate,ierr)
!!
!!     integer,intent(in)               :: dat(8)
!!     real(kind=realtime),intent(out)  :: juliandate
!!     integer,intent(out)              :: ierr
!!
!!##DESCRIPTION
!!   Converts a DAT date-time array to a Julian Date value.
!!
!!   Julian Dates (abbreviated JD) are simply a continuous count
!!   of days and fractions since noon Universal Time on January 1, 4713
!!   BC (on the Julian calendar). Julian dates are widely used as time
!!   variables within astronomical software. Typically, a 64-bit floating
!!   point (double precision) variable can represent an epoch expressed as
!!   a Julian date to about 20 microsecond precision.
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!           dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!##RETURNS
!!    juliandate  A Julian Date (JD) is the number of days since
!!                noon (not midnight) on January 1st, 4713 BC.
!!
!!    ierr        Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_date_to_julian
!!     use M_time, only : date_to_julian,realtime
!!     implicit none
!!     integer             :: dat(8)
!!     real(kind=realtime) :: juliandate
!!     integer             :: ierr
!!        ! generate DAT array
!!        call date_and_time(values=dat)
!!        ! show DAT array
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        ! convert DAT to Julian Date
!!        call date_to_julian(dat,juliandate,ierr)
!!        write(*,*)'Julian Date is ',juliandate
!!        write(*,*)'ierr is ',ierr
!!     end program demo_date_to_julian
!!
!!    results:
!!
!!     Today is:2016:7:19:-240:11:3:13:821
!!     Julian Date is    2457589.1272432986
!!     ierr is            0
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
pure subroutine date_to_julian(dat,julian,ierr)

! * There is no year zero
! * Julian Date must be non-negative
! * Julian Date starts at noon; while Civil Calendar date starts at midnight
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_2="@(#) M_time date_to_julian(3f) Converts proleptic Gregorian DAT date-time array to Julian Date"

integer,intent(in)               :: dat(8)   ! array like returned by DATE_AND_TIME(3f)
real(kind=realtime),intent(out)  :: julian   ! Julian Date (non-negative, but may be non-integer)
integer,intent(out)              :: ierr     ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day
                                             ! -4=invalid date (29th Feb, non leap-year)
integer                          :: year, month, day, utc, hour, minute
real(kind=realtime)              :: second
integer                          :: A, Y, M, JDN
!-----------------------------------------------------------------------------------------------------------------------------------
   year   = dat(1)                        ! Year
   month  = dat(2)                        ! Month
   day    = dat(3)                        ! Day
   utc    = dat(4)*60                     ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                        ! Hour
   minute = dat(6)                        ! Minute
   second = dat(7)-utc+dat(8)/1000.0_dp   ! Second   ! correction for time zone and milliseconds
!-----------------------------------------------------------------------------------------------------------------------------------
   julian = -HUGE(99999)                  ! this is the date if an error occurs and IERR is < 0
!-----------------------------------------------------------------------------------------------------------------------------------
   if(year==0 .or. year < -4713) then
      ierr=-1
      return
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
!  You must compute first the number of years (Y) and months (M) since March 1st -4800 (March 1, 4801 BC)
   A=(14-month)/12 ! A will be 1 for January or February, and 0 for other months, with integer truncation
   Y=year+4800-A
   M=month+12*A-3  ! M will be 0 for March and 11 for February
!  All years in the BC era must be converted to astronomical years, so that 1BC is year 0, 2 BC is year "-1", etc.
!  Convert to a negative number, then increment towards zero
!  Staring from a Gregorian calendar date
   JDN=day + (153*M+2)/5 + 365*Y + Y/4 - Y/100 + Y/400 - 32045  !  with integer truncation
!  Finding the Julian Calendar date given the JDN (Julian day number) and time of day
   julian=JDN + real(hour-12,kind=real64)/24.0_dp + real(minute,kind=real64)/1440.0_dp + second/86400.0_dp
!-----------------------------------------------------------------------------------------------------------------------------------
   if(julian<0.0_dp) then                  ! Julian Day must be non-negative
      ierr=1
   else
      ierr=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine date_to_julian
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    julian_to_date(3f) - [M_time:JULIAN] converts a JD(Julian Date)
!!    to a DAT date-time array.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine julian_to_date(julian,dat,ierr)
!!
!!     real(kind=realtime),intent(in) :: julian
!!     integer,intent(out)            :: dat(8)
!!     integer,intent(out)            :: ierr
!!
!!##DESCRIPTION
!!   Converts a Julian Date(JD) value to a DAT date-time
!!   array.
!!
!!   Julian dates are simply a continuous count of days and
!!   fractions since noon Universal Time on January 1, 4713 BC (on the
!!   Julian calendar). Julian dates are widely used as time variables
!!   within astronomical software. Typically, a 64-bit floating point
!!   (double precision) variable can represent an epoch expressed as a
!!   Julian date to about 20 microsecond precision.
!!
!!##OPTIONS
!!     julian  Julian Date (days)
!!
!!##RETURNS
!!     dat     Integer array holding a "DAT" array, similar in structure
!!             to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!    ierr      Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!     Sample program:
!!
!!      program demo_julian_to_date
!!      use M_time, only : julian_to_date, fmtdate, realtime
!!      implicit none
!!      integer,parameter   :: dp=kind(0.0d0)
!!      real(kind=realtime) :: juliandate
!!      integer             :: dat(8)
!!      integer             :: ierr
!!         ! set sample Julian Date
!!         juliandate=2457589.129_dp
!!         ! create DAT array for this date
!!         call julian_to_date(juliandate,dat,ierr)
!!         write(*,*)'Sample Date=',fmtdate(dat)
!!         ! go back one day
!!         call julian_to_date(juliandate-1.0_dp,dat,ierr)
!!         write(*,*)'Day Before =',fmtdate(dat)
!!         ! go forward one day
!!         call julian_to_date(juliandate+1.0_dp,dat,ierr)
!!         write(*,*)'Day After  =',fmtdate(dat)
!!      end program demo_julian_to_date
!!
!!     Results:
!!
!!      Sample Date=Tuesday, July 19th, 2016 11:05:45 AM UTC-04:00
!!      Day Before =Monday, July 18th, 2016 11:05:45 AM UTC-04:00
!!      Day After  =Wednesday, July 20th, 2016 11:05:45 AM UTC-04:00
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
subroutine julian_to_date(julian,dat,ierr)

! ident_3="@(#) M_time julian_to_date(3f) Converts Julian Date to DAT date-time array"

real(kind=realtime),intent(in) :: julian            ! Julian Date (non-negative)
integer,intent(out)            :: dat(8)
integer,intent(out)            :: ierr              ! 0 for successful execution, otherwise 1
integer                        :: tz
real(kind=realtime)            :: second
integer                        :: year
integer                        :: month
integer                        :: day
integer                        :: hour
integer                        :: minute
integer                        :: jalpha,ja,jb,jc,jd,je,ijul

   if(julian<0.0_dp) then                     ! Negative Julian Date not allowed
      ierr=1
      return
   else
      ierr=0
   endif
   tz=get_timezone()

   ijul=int(julian)                             ! Integral Julian Date
   second=sngl((julian-real(ijul,kind=real64))*secday)      ! Seconds from beginning of Jul. Day
   second=second+(tz*60)

   if(second>=(secday/2.0_dp)) then           ! In next calendar day
      ijul=ijul+1
      second=second-(secday/2.0_dp)             ! Adjust from noon to midnight
   else                                         ! In same calendar day
      second=second+(secday/2.0_dp)             ! Adjust from noon to midnight
   endif

   if(second>=secday) then                    ! Final check to prevent time 24:00:00
      ijul=ijul+1
      second=second-secday
   endif

   minute=int(second/60.0_dp)                   ! Integral minutes from beginning of day
   second=second-real(minute*60,kind=real64)                ! Seconds from beginning of minute
   hour=minute/60                               ! Integral hours from beginning of day
   minute=minute-hour*60                        ! Integral minutes from beginning of hour

   !---------------------------------------------
   jalpha=int((real(ijul-1867216,kind=real64)-0.25_dp)/36524.25_dp) ! Correction for Gregorian Calendar
   ja=ijul+1+jalpha-int(0.25_dp*real(jalpha,kind=real64))
   !---------------------------------------------

   jb=ja+1524
   jc=int(6680.0_dp+(real(jb-2439870,kind=real64)-122.1_dp)/365.25_dp)
   jd=365*jc+int(0.25_dp*real(jc,kind=real64))
   je=int(real(jb-jd,kind=real64)/30.6001_dp)
   day=jb-jd-int(30.6001_dp*real(je,kind=real64))
   month=je-1

   if(month>12)then
      month=month-12
   endif

   year=jc-4715
   if(month>2)then
      year=year-1
   endif

   if(year<=0)then
      year=year-1
   endif

   dat=[ year, month, day, tz, hour, minute, int(second), int((second-int(second))*1000.0)]
   ierr=0

end subroutine julian_to_date
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    date_to_unix(3f) - [M_time:UNIX_EPOCH] converts DAT date-time array to Unix
!!    Epoch Time
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine date_to_unix(dat,unixtime,ierr)
!!
!!     integer,intent(in)               :: dat(8)
!!     real(kind=realtime),intent(out)  :: unixtime
!!     integer,intent(out)              :: ierr
!!
!!##DESCRIPTION
!!   Converts a DAT date-time array to a UET (Unix Epoch Time).
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!##RETURNS
!!    unixtime  The "Unix Epoch" time, or the number of seconds since
!!              00:00:00 on January 1st, 1970, UTC.
!!
!!    ierr      Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!     Sample program:
!!
!!      program demo_date_to_unix
!!      use M_time, only : date_to_unix, realtime
!!      implicit none
!!      integer             :: dat(8)
!!      real(kind=realtime) :: unixtime
!!      integer             :: ierr
!!         call date_and_time(values=dat)
!!         write(*,'(" Today is:",*(i0:,":"))')dat
!!         call date_to_unix(dat,unixtime,ierr)
!!         write(*,*)'Unix Epoch time is ',unixtime
!!         write(*,*)'ierr is ',ierr
!!      end program demo_date_to_unix
!!
!!     results:
!!
!!      Today is:2016:7:18:-240:23:44:20:434
!!      Unix Epoch time is    1468899860.4340105
!!      ierr is            0
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
subroutine date_to_unix(dat,unixtime,ierr)

! ident_4="@(#) M_time date_to_unix(3f) Convert DAT date-time array to Unix Epoch Time"

integer,intent(in)              :: dat(8)       ! date time array similar to that returned by DATE_AND_TIME
real(kind=realtime),intent(out) :: unixtime     ! Unix time (seconds)
integer,intent(out)             :: ierr         ! return 0 on success, otherwise 1
real(kind=realtime)             :: julian
real(kind=realtime),save        :: julian_at_epoch
logical,save                    :: first=.true.
integer,parameter               :: ref(*)=[1970,1,1,0,0,0,0,0]
!-----------------------------------------------------------------------------------------------------------------------------------
   if (first) then                                    ! Convert zero of Unix Epoch Time to Julian Date and save
      call date_to_julian(ref,julian_at_epoch,ierr)
      if(ierr /= 0) return                            ! Error
      first=.false.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   call date_to_julian(dat,julian,ierr)
   if(ierr /= 0) return                               ! Error
   unixtime=(julian-julian_at_epoch)*secday
end subroutine date_to_unix
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    unix_to_date(3f) - [M_time:UNIX_EPOCH] converts Unix Epoch Time to
!!    DAT date-time
!!    array
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine unix_to_date(unixtime,dat,ierr)
!!
!!     real(kind=realtime),intent(in) :: unixtime
!!     integer,intent(out)            :: dat(8)
!!     integer,intent(out)            :: ierr
!!
!!##DESCRIPTION
!!   Converts a Unix Epoch Time (UET) to a DAT date-time array.
!!
!!##OPTIONS
!!
!!    unixtime  The "Unix Epoch" time, or the number of seconds since
!!              00:00:00 on January 1st, 1970, UTC; of type
!!              real(kind=realtime).
!!
!!##RETURNS
!!     dat      Integer array holding a "DAT" array, similar in structure
!!              to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!               dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!    ierr      Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!     Sample program:
!!
!!      program demo_unix_to_date
!!      use M_time, only : unix_to_date, u2d, fmtdate, realtime
!!      implicit none
!!      integer,parameter :: dp=kind(0.0d0)
!!      real(kind=realtime)           :: unixtime
!!      ! seconds in a day
!!      real(kind=realtime),parameter :: DAY=86400.0_dp
!!      integer                       :: dat(8)
!!      integer                       :: ierr
!!         ! sample Unix Epoch time
!!         unixtime=1468939038.4639933_dp
!!         ! create DAT array for today
!!         call unix_to_date(unixtime,dat,ierr)
!!         write(*,*)'Sample Date=',fmtdate(dat)
!!         ! go back one day
!!         call unix_to_date(unixtime-DAY,dat,ierr)
!!         ! subtract day and print
!!         write(*,*)'Day Before =',fmtdate(dat)
!!         ! go forward one day
!!         call unix_to_date(unixtime+DAY,dat,ierr)
!!         ! add day print
!!         write(*,*)'Day After  =',fmtdate(dat)
!!      end program demo_unix_to_date
!!
!!    Results:
!!
!!     Sample Date=Tuesday, July 19th, 2016 10:37:18 AM
!!     Day Before =Monday, July 18th, 2016 10:37:18 AM
!!     Day After  =Wednesday, July 20th, 2016 10:37:18 AM
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
subroutine unix_to_date(unixtime,dat,ierr)

! ident_5="@(#) M_time unix_to_date(3f) Converts Unix Time to DAT date-time array"

class(*),intent(in)      :: unixtime                             ! Unix time (seconds)
integer,intent(out)      :: dat(8)                               ! date and time array
integer,intent(out)      :: ierr                                 ! 0 for successful execution, otherwise 1
real(kind=realtime)      :: julian                               ! Unix time converted to a Julian Date
real(kind=realtime)      :: local_unixtime
real(kind=realtime),save :: Unix_Origin_as_Julian                ! start of Unix Time as Julian Date
logical,save             :: first=.TRUE.
integer,parameter        :: ref(8)=[1970,1,1,0,0,0,0,0]
!  Notice that the value UNIXTIME can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME))
   select type(unixtime)
   type is (integer);             local_unixtime=real(unixtime,kind=real64)
   type is (real);                local_unixtime=real(unixtime,kind=real64)  ! typically not precise enough for UET values.
   type is (real(kind=realtime)); local_unixtime=unixtime
   end select
!-----------------------------------------------------------------------------------------------------------------------------------
   if(first)then                                                 ! Initialize calculated constants on first call
      call date_to_julian(ref,Unix_Origin_as_Julian,ierr)        ! Compute start of Unix Time as a Julian Date
      if(ierr/=0) return                                         ! Error
      first=.FALSE.
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
   julian=(local_unixtime/secday)+Unix_Origin_as_Julian          ! convert seconds from Unix Epoch to Julian Date
   call julian_to_date(julian,dat,ierr)                          ! calculate date-time array from Julian Date
   !dat(4)=get_timezone()                                        ! need to get time zone
end subroutine unix_to_date
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2o(3f) - [M_time:ORDINAL_DAY] converts DAT date-time array to Ordinal day
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function d2o(dat) result(ordinal)
!!
!!     integer,intent(in),optional :: dat(8)
!!     integer                     :: ordinal
!!
!!##DESCRIPTION
!!   Given a date in the form of a "DAT" array return the Ordinal Day,
!!   (ie. "the day of the year").
!!
!!##OPTIONS
!!     dat  Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!##RETURNS
!!     ordinal  The day of the year calculated for the given input date,
!!              where Jan 1st=1.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2o
!!     use M_time, only : d2o
!!     implicit none
!!     integer :: dat(8)
!!        call date_and_time(values=dat)
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        write(*,*)'Day of year is:',d2o(dat)
!!
!!        ! year,month,day,timezone,hour,minute,seconds,milliseconds
!!        dat=[2020,12,31,-240,12,0,0,0]
!!        write(*,*)dat(1),' Days in year is:',d2o(dat)
!!
!!        dat=[2021,12,31,-240,12,0,0,0]
!!        write(*,*)dat(1),' Days in year is:',d2o(dat)
!!
!!        dat=[2022,12,31,-240,12,0,0,0]
!!        write(*,*)dat(1),' Days in year is:',d2o(dat)
!!
!!        dat=[2023,12,31,-240,12,0,0,0]
!!        write(*,*)dat(1),' Days in year is:',d2o(dat)
!!
!!        dat=[2024,12,31,-240,12,0,0,0]
!!        write(*,*)dat(1),' Days in year is:',d2o(dat)
!!
!!     end program demo_d2o
!!
!!    results:
!!
!!     Today is:2016:7:19:-240:20:1:19:829
!!     Day of year is:         201
!!            2020  Days in year is:         366
!!            2021  Days in year is:         365
!!            2022  Days in year is:         365
!!            2023  Days in year is:         365
!!            2024  Days in year is:         366
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function d2o(dat) result(ordinal)

! ident_6="@(#) M_time d2o(3f) Converts DAT date-time array to Ordinal day"

! JSU 2015-12-13
integer,intent(in),optional :: dat(8)                 ! date time array similar to that returned by DATE_AND_TIME
integer                     :: dat_local(8)
integer                     :: ordinal                ! the returned number of days
real(kind=realtime)         :: unixtime               ! Unix time (seconds)
real(kind=realtime)         :: unix_first_day
integer                     :: ierr                   ! return 0 on success, otherwise 1 from date_to_unix(3f)
integer                     :: temp_dat(8)
   if(present(dat))then
     dat_local=dat
   else
     dat_local=getnow()
   endif
   call date_to_unix(dat_local,unixtime,ierr)         ! convert date to Unix Epoch Time
   if(ierr/=0)then
      write(stderr,gen)'<ERROR>*d2o*: bad date array'
      ordinal=-1                                      ! initialize to bad value
   else
      temp_dat=[dat_local(1),1,1,dat_local(4),0,0,0,0]
      call date_to_unix(temp_dat,unix_first_day,ierr)
      ordinal=int((unixtime-unix_first_day)/secday)+1
   endif
end function d2o
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    ordinal_seconds(3f) - [M_time:ORDINAL_DAY] seconds since beginning of year
!!    (LICENSE:MIT)
!!##SYNOPSIS
!!
!!    function ordinal_seconds()
!!
!!     integer :: ordinal_seconds
!!##DESCRIPTION
!!   Return number of seconds since beginning of current year.
!!
!!   Before using this routine consider the consequences if the application
!!   is running at the moment a new year begins.
!!
!!##EXAMPLE
!!
!!    sample program
!!
!!     program demo_ordinal_seconds
!!     use M_time, only : ordinal_seconds
!!     implicit none
!!     character(len=*),parameter :: gen='(*(g0))'
!!     integer          :: i, istart, iend
!!     real,volatile    :: x
!!     istart = ordinal_seconds()
!!     x = 0.0
!!     do i = 1, 1000000000
!!        x = x+sqrt(real(i))
!!     enddo
!!     print gen, 'x=',x
!!     iend = ordinal_seconds()
!!     print gen, 'that took ',iend-istart,' seconds'
!!     print gen, iend,'-',istart,'=',iend-istart
!!     end program demo_ordinal_seconds
!!
!!    Results:
!!
!!     > x=0.549755814E+12
!!     > that took 4 seconds
!!     > 23659912-23659908=4
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
integer function ordinal_seconds()

! ident_7="@(#) M_time ordinal_seconds(3f) seconds since beginning of year"

integer   :: v(8)
integer   :: ordinal_day_of_year
   associate(year=>v(1), month=>v(2), day=>v(3), timezone=>v(4), hour=>v(5), minutes=>v(6), seconds=>v(7), milliseconds=>v(8))
    v=getnow()
    ordinal_day_of_year=d2o(v)
    ordinal_seconds=ordinal_day_of_year*24*60*60 +hour*60*60 +minutes*60 +seconds
   end associate
end function ordinal_seconds
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    ordinal_to_date(3f) - [M_time:ORDINAL_DAY] when given a valid year and
!!    day of the year returns the DAT array for the date
!!    (LICENSE:MIT)
!!##SYNOPSIS
!!
!!      subroutine ordinal_to_date(yyyy, ddd, dat)
!!
!!       integer, intent(in)   :: yyyy
!!       integer, intent(in)   :: ddd
!!       integer, intent(out)  :: dat
!!##DESCRIPTION
!!   When given a valid year, YYYY, and day of the year, DDD, returns the
!!   date as a DAT date array
!!##OPTIONS
!!       yyyy  known year
!!       ddd   known ordinal day of the year
!!##RETURNS
!!       dat   DAT array describing the date
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_ordinal_to_date
!!     use M_time, only : ordinal_to_date
!!     implicit none
!!     integer :: yyyy, ddd, mm, dd, yy
!!     integer :: dat(8)
!!     integer :: i, iostat
!!     character(len=:),allocatable :: fakefile(:)
!!       fakefile=[character(len=80) :: ' 2024 273 ','2024 001']
!!       do i=1,size(fakefile)
!!          ! Enter year YYYY and ordinal day of year DD
!!          read(fakefile(i),*,iostat=iostat)yyyy,ddd
!!          if(iostat/=0)exit
!!          ! recover month and day from year and day number.
!!          call ordinal_to_date(yyyy, ddd, dat)
!!          yy=dat(1)
!!          mm=dat(2)
!!          dd=dat(3)
!!          write(*,'(*(g0))')'For Year ',yyyy,' and Ordinal day ',ddd
!!          write(*,'(*(g0))')' Month is ',mm,' and Day of Month is ',dd, &
!!          & ' and Year is ',yy
!!       enddo
!!     end program demo_ordinal_to_date
!!
!!    Result:
!!
!!     > For Year 2024 and Ordinal day 273
!!     > Month is 9 and Day of Month is 29 and Year is 2024
!!     > For Year 2024 and Ordinal day 1
!!     > Month is 1 and Day of Month is 1 and Year is 2024
subroutine ordinal_to_date(yyyy,ddd,dat)
!x!use M_time, only : d2j,j2d, realtime

! ident_8="@(#) M_time ordinal_to_date(3f) given a valid year and day of the year returns the DAT array for the date"

integer :: yyyy
integer :: ddd
integer :: dat(8)
integer :: temp_dat(8)
   !dat=[year,month,day,timezone,hour,minutes,seconds,milliseconds]
   ! find Julian day for first day of given year and add ordinal day -1 and convert back to a DAT
   temp_dat=[yyyy,1,1,0,12,0,0,0]
   dat=j2d( d2j(temp_dat) + real(ddd-1,kind=realtime) )
end subroutine ordinal_to_date
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    o2d(3f) - [M_time:ORDINAL_DAY] converts Ordinal day to DAT date-time array
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function o2d(ordinal,[year]) result(dat)
!!
!!     integer,intent(in) :: ordinal  ! the day of the year
!!     integer,optional   :: year     ! year
!!     integer            :: dat(8)   ! date time array
!!
!!##DESCRIPTION
!!   Given an Ordinal day of the year return a date in the form of a
!!   "DAT" array.
!!
!!##OPTIONS
!!     ordinal  The day of the year for the given year, where Jan 1st=1.
!!
!!     year     An optional year for the ordinal day. If not present the
!!              current year is assumed.
!!
!!##RETURNS
!!     dat   Integer array holding a "DAT" array, similar in structure
!!           to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!           The timezone value is from the current time on the current
!!           platform.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_o2d
!!     use M_time, only : o2d,fmtdate
!!     implicit none
!!     integer :: year
!!        do year=2004,2008
!!           write(*,'(*(g0))')&
!!           & '100th day of ',year,' is ',fmtdate(o2d(100,year))
!!        enddo
!!        write(*,'(*(g0))')'100th day of this year is ',fmtdate(o2d(100))
!!     end program demo_o2d
!!
!!    Results:
!!
!!     > 100th day of 2004 is Friday, April 9th, 2004 12:00:00 AM UTC-05:00
!!     > 100th day of 2005 is Sunday, April 10th, 2005 12:00:00 AM UTC-05:00
!!     > 100th day of 2006 is Monday, April 10th, 2006 12:00:00 AM UTC-05:00
!!     > 100th day of 2007 is Tuesday, April 10th, 2007 12:00:00 AM UTC-05:00
!!     > 100th day of 2008 is Wednesday, April 9th, 2008 12:00:00 AM UTC-05:00
!!     > 100th day of this year is Monday, April 10th, 2023 12:00:00 AM UTC-05:00
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function o2d(ordinal,year) result(dat)

! ident_9="@(#) M_time o2d(3f) Converts ordinal day to DAT date-time array"

integer                     :: dat(8)                 ! date time array similar to that returned by DATE_AND_TIME
integer,intent(in)          :: ordinal                ! the returned number of days
integer,intent(in),optional :: year
real(kind=realtime)         :: unixtime               ! Unix time (seconds)
integer                     :: ierr                   ! return 0 on success, otherwise 1 from date_to_unix(3f)
   if(present(year))then
      dat=[year,1,ordinal,get_timezone(),0,0,0,0]     ! initialize DAT with parameters and set timezone, set HH:MM:SS.XX to zero
   else
      dat=getnow()                                    ! set year and timezone to current values
      dat=[dat(1),1,ordinal,dat(4),0,0,0,0]           ! apply ordinal parameter to January of current year, set HH:MM:SS.XX to zero
   endif
   ierr=0
   call date_to_unix(dat,unixtime,ierr)               ! convert date to Unix Epoch Time
   if(ierr/=0)then
      write(stderr,gen) '<ERROR>*o2d*: bad date array'
   else
      dat=u2d(unixtime)
   endif
end function o2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    v2mo(3f) - [M_time:MONTH_NAME] returns the month name of a Common
!!    month number
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function v2mo(imonth,short) result(month_name)
!!
!!     integer,intent(in)           :: imonth      ! month number (1-12)
!!     character(len=:),allocatable :: month_name  ! month name
!!     logical,intent(in),optional  :: short
!!
!!##DESCRIPTION
!!   Given a Common Calendar month number, return the name of the month
!!   as a string.
!!
!!##OPTIONS
!!    imonth      Common month number (1-12). If out of the allowable range
!!                the month name returned will be 'UNKNOWN'.
!!    short       Flag whether to return short or long name
!!##RETURNS
!!    month_name  A string representing a month name or the word 'UNKNOWN'
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_v2mo
!!     use M_time, only : v2mo
!!     implicit none
!!     integer :: i
!!        write(*,*)(v2mo(i),i=1,13)
!!     end program demo_v2mo
!!
!!    results:
!!
!!     January
!!     February
!!     March
!!     April
!!     May
!!     June
!!     July
!!     August
!!     September
!!     October
!!     November
!!     December
!!     UNKNOWN.
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function v2mo(imonth,short) result(month_name)

! ident_10="@(#) M_time v2mo(3f) returns the month name of a Common month number"

! JSU 2015-12-13
character(len=:),allocatable :: month_name                                        ! string containing month name or abbreviation.
integer,intent(in)           :: imonth                                            ! the number of the month(1-12)
logical,intent(in),optional  :: short
logical                      :: short_

   if(present(short))then
      short_=short
   else
      short_=.false.
   endif

   if(short_)then ! short names
      if(allocated(M_time_month_names_abbr))then                                          ! user user-specified month names
         if(size(M_time_month_names_abbr).ne.12)then
            write(stderr,gen) '<ERROR>*v2mo*: month name abbr. count not 12:',size(M_time_month_names_abbr)
            month_name='UNKNOWN'
         else
            select case(imonth)
            case (1:12);     month_name=trim(M_time_month_names_abbr(imonth))
            case default;    month_name='UNKNOWN'
            end select
         endif
      else
         select case(imonth)
         case (1:12);        month_name=trim(G_month_names(imonth)(1:3))
         case default;       month_name='UNKNOWN'
         end select
      endif
   else  ! long names
      if(allocated(M_time_month_names))then                                          ! user user-specified month names
         if(size(M_time_month_names).ne.12)then
            write(stderr,gen) '<ERROR>*v2mo*: month name count not 12:',size(M_time_month_names)
            month_name='UNKNOWN'
         else
            select case(imonth)
            case (1:12);     month_name=trim(M_time_month_names(imonth))
            case default;    month_name='UNKNOWN'
            end select
         endif
      else
         select case(imonth)
         case (1:12);        month_name=trim(G_month_names(imonth))
         case default;       month_name='UNKNOWN'
         end select
      endif
   endif

end function v2mo
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    mo2d(3f) - [M_time:MONTH_NAME] given month name return DAT date-time
!!    array for beginning of that month in specified year
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!       function mo2d(month_name,year) result(dat)
!!
!!        character(len=*),intent(in) :: month_name
!!        integer,intent(in),optional :: year
!!        integer                     :: dat(8)
!!
!!##DESCRIPTION
!!   Given a Common Calendar month name, return the date as a "DAT" array
!!   for the 1st day of the month. An optional year that defaults to the
!!   current year may be specified.
!!
!!##OPTIONS
!!    month_name  A string representing a Common Calendar month name.
!!    year        Optional year. Defaults to current year
!!##RETURNS
!!    dat         An integer array that has the same structure as the array
!!                returned by the Fortran intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_mo2d
!!     use M_time, only : mo2d
!!     implicit none
!!        write(*,'("MARCH:",*(i0:,":"))')mo2d('March')
!!     end program demo_mo2d
!!
!!    Results:
!!
!!          > MARCH:2016:3:1:-240:0:0:0:0
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function mo2d(month_name,year) result(dat)

! ident_11="@(#) M_time mo2d(3f) month name to DAT date-time array for 1st of that month in specified year"

character(len=*),intent(in) :: month_name
integer,intent(in),optional :: year
integer                     :: dat(8)
   dat=getnow()
   if(present(year))then
      dat(1)=year
   endif
   dat(2)=mo2v(month_name) ! convert given month name to a number
   if(dat(2)<=0)then
      write(stderr,gen) '<ERROR>*mo2d*: bad month name:',trim(month_name)
      dat(2)=1
   endif
   dat(3)=1  ! set day to first of month
   dat(5)=0  ! set hour to zero
   dat(6)=0  ! set minutes to zero
   dat(7)=0  ! set seconds to zero
   dat(8)=0  ! set milliseconds to zero
end function mo2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    mo2v(3f) - [M_time:MONTH_NAME] given month name return month number
!!    (1-12) of that month
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    elemental function mo2v(month_name) result(imonth)
!!
!!      character(len=*),intent(in):: month_name ! month name
!!      integer                    :: imonth     ! month number
!!
!!##DESCRIPTION
!!   Given a string representing the name or abbreviation of a Gregorian
!!   Calendar month return a number representing the position of the
!!   month in the calendar starting with 1 for January and ending with
!!   12 for December.
!!
!!##OPTIONS
!!    month_name  name or abbreviation of month. Case is ignored.
!!##RETURNS
!!    imonth      month number returned. If the name is not recognized a -1
!!                is returned.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_mo2v
!!     use M_time, only : mo2v
!!     implicit none
!!        write(*,*)mo2v("April")
!!        write(*,*)mo2v('Apr')
!!        write(*,*)mo2v('sexember')
!!        write(*,*)mo2v('unknown')  ! returns -1
!!     end program demo_mo2v
!!
!!    results:
!!
!!       >  4
!!       >  4
!!       > -1
!!       > -1
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
elemental impure function mo2v(month_name) result(imonth)

! ident_12="@(#) M_time mo2v(3f) given month name return month number (1-12) of that month"

! JSU 2015-12-13
character(len=*),intent(in)  :: month_name   ! string containing month name or abbreviation.
integer                      :: imonth       ! the number of the month(1-12), or -1 if the name could not be recognized.
character(len=:),allocatable :: months(:)
character(len=:),allocatable :: upper_months(:)
character(len=:),allocatable :: upper_month_name
  upper_month_name = upper(month_name)     ! Case is ignored; test string now guaranteed to have three characters
  imonth = 0
  if(allocated(M_time_month_names))then
     upper_months=upper(M_time_month_names)
  else
     upper_months=upper(G_month_names)
  endif
  if(size(upper_months).ne.12)then
     write(stderr,gen) '<ERROR>*mo2v*: month name count not 12:',size(upper_months)
     months=['UNKNOWN']
  else
     months=pack(upper_months//'',upper_month_name.eq.upper_months(:)(:len_trim(upper_month_name))) ! concatenate for gfortran bug
     if(size(months).gt.1)months=pack(months//'',upper_month_name.eq.months)
     if(size(months).eq.0)months=['UNKNOWN']
  endif
  imonth=findloc(upper_months//'', months(1)//'',dim=1) ! concatenation avoids gfortran bug
  if(imonth.eq.0)imonth=-1
end function mo2v
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    now(3f) - [M_time:DATE_PRINTING] return string representing current
!!    time given one of many formats to present with
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function now(format) result(timestr)
!!
!!     character(len=*),intent(in)     :: format  ! input format string
!!     character(len=:),allocatable    :: timestr ! formatted date
!!
!!##DESCRIPTION
!!   The now(3f) function is a call to the fmtdate(3f) function using the
!!   current date and time. That is, it is a convenient way to print the
!!   current date and time.
!!
!!##OPTIONS
!!     format      string describing how to format the current date and time.
!!                 For a complete description of the formatting macros
!!                 supported see fmtdate_usage(3f).
!!##RETURNS
!!     timestr     formatted output string representing date
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_now
!!     use M_time, only : now, locale
!!     implicit none
!!       ! MACROS
!!        write(*,*)now("The current date is &
!!           &%w, %l %d, %Y %H:%m:%s %N")
!!       ! If macros are not found substitute values for KEYWORDS
!!        write(*,*)now("The current date is &
!!           &year/month/day hour:minute:second timezone")
!!        write(*,*)now("The current date is &
!!           &longweekday at HOUR GOOD, longmonth shortday, year")
!!       ! including some HIGH-LEVEL KEYWORDS
!!        write(*,*)now("iso")
!!       ! and if no keywords are found, ABBREVIATED MACROS
!!        write(*,*)now("Y-M-D h:m:s")
!!       ! and basic INTERNATIONALIZATION is available
!!        call locale('french')
!!        write(*,*)now("%W, %L %D, %Y %h:%m:%s ")
!!        call locale('slovak')
!!        write(*,*)now("%W, %L %D, %Y %h:%m:%s ")
!!        call locale('spanish')
!!        write(*,*)now("%W, %L %D, %Y %h:%m:%s ")
!!     end program demo_now
!! ```
!! Results:
!!
!!     > The current date is Wed, Feb 5th, 2025 11:45:57 PM
!!     > The current date is 2025/02/05 23:45:57 -0500
!!     > The current date is Wednesday at 11 PM, February 5th, 2025
!!     > 2025-02-05T23:45:57-05:00
!!     > 2025-02-05 23:45:57
!!     > mercredi, fvrier 05, 2025 23:45:57
!!     > streda, februr 05, 2025 23:45:57
!!     > mircoles, febrero 05, 2025 23:45:57
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function now(format)

! ident_13="@(#) M_time now(3f) return string representing current time given format"

! JSU 2015-10-24
character(len=*),intent(in),optional :: format
character(len=:),allocatable         :: now
integer                              :: values(8)
!-----------------------------------------------------------------------------------------------------------------------------------
   values=getnow()
   if(present(format))then
      now=fmtdate(values,format)
   else
      now=trim(fmtdate(values))
   endif
end function now
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmtdate(3f) - [M_time:DATE_PRINTING] given DAT date-time array return
!!    date as string using specified format
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function fmtdate(values,format) result(timestr)
!!
!!     integer,dimension(8),intent(in)      :: values
!!     character(len=*),intent(in),optional :: format
!!     character(len=:),allocatable         :: timestr
!!
!!##DESCRIPTION
!!   The fmtdate(3f) procedure lets you reformat a DAT array in
!!   many common formats using a special string containing macro names
!!   beginning with '%'. To see the allowable macros call or see the
!!   fmtdate_usage(3f) routine.
!!
!!##OPTIONS
!!     values   date in a "DAT" array, which is the same format as
!!              the values returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!     format   string describing how to format the "DAT" array.
!!              For a complete description of the formatting macros
!!              supported see fmtdate_usage(3f).
!!##RETURNS
!!     timestr  formatted output string representing date
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_fmtdate
!!     use M_time, only : fmtdate
!!     implicit none
!!     integer :: dat(8)
!!        call date_and_time(values=dat)
!!        write(*,*)fmtdate(dat,"current date: %w, %l %d, %Y %H:%m:%s %N")
!!     end program demo_fmtdate
!!
!!    results:
!!
!!       The current date is Sun, Jul 17th, 2016 01:21:35 PM
!!
!!##AUTHOR
!!    John S. Urban, 2015-12-19
!!
!!##LICENSE
!!    MIT
function fmtdate(values,format) result(timestr)

! ident_14="@(#) M_time fmtdate(3f) given DAT date-time array return date as string using format"

! JSU 2015-10-24
integer,dimension(8),intent(in)      :: values    ! numeric time values as DATE_AND_TIME(3f) intrinsic returns
character(len=*),intent(in),optional :: format    ! input format string
character(len=:),allocatable         :: timestr
!- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
integer,dimension(8)                 :: valloc    ! numeric time values as DATE_AND_TIME(3f) intrinsic returns
integer,parameter                    :: longest=4096
character(len=1)                     :: chara     ! character being looked at in format string
character(len=10)                    :: iso_name
character(len=2)                     :: dayend
character(len=:),allocatable         :: day       ! day of week
character(len=:),allocatable         :: local_format
character(len=:),allocatable         :: dayth
character(len=longest)               :: text      ! character array
character(len=longest)               :: xxxx
integer                              :: i,ii,i10
integer                              :: ierr
integer                              :: iout
integer                              :: iso_year, iso_week, iso_weekday
integer                              :: systemclock, countrate
integer                              :: weekday
integer,save                         :: called=0
logical                              :: keyword   ! flag that previous character was a % character
logical,save                         :: since=.FALSE.
real(kind=realtime)                  :: cputime
real(kind=realtime)                  :: julian
real(kind=realtime)                  :: modified_julian
real(kind=realtime)                  :: unixtime
real(kind=realtime),save             :: unixtime_last
type(BAStime)                        :: bas

   valloc=values
   if(present(format))then
      local_format=format
   else
      local_format=' '
   endif

   if(allocated(M_time_weekday_names))then      ! day must be allocated, make sure long enough for user-define names
      day=repeat(' ',len(M_time_weekday_names))
   else
      day=repeat(' ',len(G_weekday_names))
   endif

   select case(local_format)
   case('iso-8601W','isoweek') ; local_format='%I'                    ! 2016-W24-5 (yyyy-Www-d)
   case('iso-8601','iso')      ; local_format='%Y-%M-%DT%h:%m:%s%z'   ! 2006-08-14T02:34:56-0600
   case('sql')       ; local_format='"%Y-%M-%D %h:%m:%s.%x"'          !
   case('sqlday')    ; local_format='"%Y-%M-%D"'                      !
   case('sqltime')   ; local_format='"%h:%m:%s.%x"'                   !
   case('dash')      ; local_format='%Y-%M-%D'                        !
   case('rfc-2822')  ; local_format='%w, %D %l %Y %h:%m:%s %T'        ! Mon, 14 Aug 2006 02:34:56 -0600
   case('rfc-3339')  ; local_format='%Y-%M-%DT%h:%m:%s%z'             ! 2006-08-14 02:34:56-06:00
   case('suffix')    ; local_format='%Y%D%M%h%m%s'                    ! 20170122210327
   case('date')      ; local_format='%w %l %D %h:%m:%s UTC%z %Y'      ! Mon Jul 25 03:19:21 UTC-4:00 2016
   case('short')     ; local_format='%w, %l %d, %Y %H:%m:%s %N UTC%z' ! Fri, Jun 17th, 2016 06:31:00 PM UTC-04:00
   case('long')      ; local_format='%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00
   case(' ')         ; local_format='%W, %L %d, %Y %H:%m:%s %N UTC%z' ! Friday, June 17th, 2016 06:31:00 PM UTC-04:00
   case('formal')    ; local_format='The %d of %L %Y'                 ! The 9th of November 2014
   case('lord')  ; local_format='the %d day of %L in the year of our Lord %Y' ! the 9th day of November in the year of our Lord 2014
   case('usage','?','help') ; local_format='%?'                       ! call fmtdate_usage
   case('easter')
      call easter(values(1), valloc)                                  ! given year get month and day Easter falls on
      local_format="Easter day: the %d day of %L in the year of our Lord %Y"
   case('all')
     local_format='&
     & Civil Calendar:%t%W %L %d%n&
     & Civil Date:%t%t%Y-%M-%D %h:%m:%s %z%n&
     & Julian Date:%t%t%J%n&
     & Unix Epoch Time:%t%E%n&
     & Day Of Year:%t%t%O%n&
     & ISO-8601 week:%t%t%I&
     &'
   case default
      xxxx=local_format
      if(index(xxxx,'%')==0)then               ! if no % characters try to guess what macros are present

         call substitute(xxxx,'year','%Y')
         call substitute(xxxx,'longmonth','%L')
         call substitute(xxxx,'shortmonth','%l')
         call substitute(xxxx,'month','%M')
         call substitute(xxxx,'MONTH','%L')
         call substitute(xxxx,'Month','%l')
         call substitute(xxxx,'Mth','%l')

         call substitute(xxxx,'longweekday','%W')
         call substitute(xxxx,'shortweekday','%w')
         call substitute(xxxx,'weekday','%u')
         call substitute(xxxx,'WEEKDAY','%W')
         call substitute(xxxx,'Weekday','%w')
         call substitute(xxxx,'wkday','%w')
         call substitute(xxxx,'today','%Y%M%D')
         call substitute(xxxx,'shortday','%d')
         call substitute(xxxx,'longday','%X')
         call substitute(xxxx,'day','%D')
         call substitute(xxxx,'DAY','%d')

         call substitute(xxxx,'GOOD','%N')
         call substitute(xxxx,'HOUR','%H')

         call substitute(xxxx,'goodhour','%H')
         call substitute(xxxx,'hour','%h')
         call substitute(xxxx,'minute','%m')
         call substitute(xxxx,'timezone','%T')
         call substitute(xxxx,'TIMEZONE','%z')
         call substitute(xxxx,'Timezone','%Z')

         call substitute(xxxx,'millisecond','%x')
         call substitute(xxxx,'second','%s')

         call substitute(xxxx,'epoch','%e')
         call substitute(xxxx,'julian','%j')
         call substitute(xxxx,'ordinal','%O')
         call substitute(xxxx,'AGE','%a')
         call substitute(xxxx,'age','%A')

         if(index(xxxx,'%')==0)then            ! if no % characters change every char to %char if a format macro letter
            do i=65,122
             select case(achar(i))
             case('A','B':'E','F','H':'J','L':'Q','S','T','U','W','Y','Z','a','b':'e','f','h':'m','n','o':'q','s':'u','w','x','z')
                 call substitute(xxxx,achar(i),'%'//achar(i))
             end select
            enddo
         endif
      endif
      local_format=trim(xxxx)
   end select

   text=' '
!  write string, when encounter a percent character do a substitution
   keyword=.FALSE.
   iout=1

   do i10=1,len(local_format)                  ! Read the FORMAT string and replace the "%" strings per the following rules:
      chara=local_format(i10:i10)
      if(chara=='%'.and..not.keyword)then
            keyword=.TRUE.
            cycle
      endif
      if(keyword)then
         keyword=.FALSE.
         select case(chara)
         !=====================================================================================
         case('%'); write(text(iout:),'(A1)')chara                        ! literal percent character
         !=====================================================================================
         case('a'); write(text(iout:),'(G0)')sec2days(d2u()-d2u(valloc))  ! time since now in d-h:m:s format
         !=====================================================================================
         case('A'); write(text(iout:),'(G0)')(d2u()-d2u(valloc))          ! time since now in seconds
         !=====================================================================================
         case('b'); write(text(iout:),'(A1)')' '                          ! space character
         !=====================================================================================
         case('B'); write(text(iout:),'(A1)')'!'                          ! exclamation (bang) character
         !=====================================================================================
         case('c'); call cpu_time(cputime)                                ! CPU_TIME()
                    write(text(iout:),'(G0)')cputime
         !=====================================================================================
         case('C'); called = called + 1                                   ! number of times this routine called
                    write(text(iout:),'(I0)')called
         !=====================================================================================
         case('d');                                                       ! the day of the month 1st..31st
                    dayend='  '
                    select case(valloc(3))
                    case(1,21,31); dayend='st'
                    case(2,22); dayend='nd'
                    case(3,23); dayend='rd'
                    case(4:20,24:30); dayend='th'
                    case default
                    end select
                    write(text(iout:),'(I0,a)')valloc(3),dayend
         !=====================================================================================
         case('D'); write(text(iout:),'(I2.2)')valloc(3)                  ! the day of the month 1..31
         !=====================================================================================
         case('e'); call date_to_unix(valloc,unixtime,ierr)               ! integer Unix Epoch time in seconds
                    write(text(iout:),'(G0)')nint(unixtime)
         !=====================================================================================
         case('E'); call date_to_unix(valloc,unixtime,ierr)               ! Unix Epoch time in seconds
                    write(text(iout:),'(G0)')unixtime
         !=====================================================================================
         case('f'); call date_to_modified_julian(valloc,modified_julian,ierr)  ! integer Modified Julian Day (truncated to integer)
                    write(text(iout:),'(I0)')int(modified_julian)
         !=====================================================================================
         case('F'); call date_to_modified_julian(valloc,modified_julian,ierr)  ! Modified Julian Date
                    write(text(iout:),'(g0)')modified_julian
         !=====================================================================================
         case('g'); call date_to_bas(valloc,bas,ierr)                     ! Baseday Seconds (days should be same as MJD)
                    write(text(iout:),'(g0)')bas%secs
         !=====================================================================================
         case('G'); call date_to_bas(valloc,bas,ierr)                     ! Baseday and Seconds
                    write(text(iout:),'("(",g0,",",g0,")")')bas%base_day,bas%secs
         !=====================================================================================
         case('h'); write(text(iout:),'(I2.2)')valloc(5)                  ! the hour of the day, in the range of 0 to 23
         !=====================================================================================
         case('H'); ii=mod(valloc(5),12)                                  ! hour of day in range 1..12
                    if(ii==0)then
                       ii=12
                    endif
                    write(text(iout:),'(I0)')ii
         !=====================================================================================
         case('i'); call d2w(valloc,iso_year,iso_week,iso_weekday,iso_name) ! return ISO-8601 week of year
                    write(text(iout:),'(I0)')iso_week
         !=====================================================================================
         case('I'); call d2w(valloc,iso_year,iso_week,iso_weekday,iso_name) ! return ISO-8601 Week as string of form "yyyy-Www-d"
                    write(text(iout:),'(a)')iso_name
         !=====================================================================================
         case('j'); call date_to_julian(valloc,julian,ierr)               ! integer Julian Day (truncated to integer)
                    write(text(iout:),'(I0)')int(julian)
         !=====================================================================================
         case('J'); call date_to_julian(valloc,julian,ierr)               ! Julian Date out to milliseconds
                    !write(text(iout:),'(I0,".",i3.3)')int(julian),nint((julian-int(julian))*1000.0)
                    write(text(iout:),'(g0)')julian
         !=====================================================================================
         case('k'); call system_clock(count=systemclock,count_rate=countrate)  ! systemclock/countrate
                    write(text(iout:),'(G0)')real(systemclock)/countrate
         !=====================================================================================
         case('K'); call system_clock(count=systemclock,count_rate=countrate)  ! system clock count
                    write(text(iout:),'(I0)') systemclock
         !=====================================================================================
         case('l'); write(text(iout:),'(A)')v2mo(valloc(2),short=.true.)  ! short name of the month of the year
         !=====================================================================================
         case('L'); write(text(iout:),'(A)')v2mo(valloc(2))               ! name of the month of the year
         !=====================================================================================
         case('m'); write(text(iout:),'(I2.2)')valloc(6)                  ! the minutes of the hour, in the range 0 to 59
         !=====================================================================================
         case('M'); write(text(iout:),'(I2.2)')valloc(2)                  ! month of year (1..12)
         !=====================================================================================
         case('N'); if( valloc(5)>=12)then                              ! AM||PM
                       write(text(iout:),'("PM")')
                    else
                       write(text(iout:),'("AM")')
                    endif
         !=====================================================================================
         case('n');
                    write(text(iout:),'(a)')new_line("A")
         !=====================================================================================
         case('O'); write(text(iout:),'(I3.3)')d2o(valloc)                ! Ordinal day of year
         !=====================================================================================
         case('o'); call date_to_unix(valloc,unixtime,ierr)               ! integer Unix Epoch time in seconds
                    write(text(iout:),'(G0)')floor(unixtime/86400)        ! number of whole days since Epoch time
         !=====================================================================================
         !=====================================================================================
         case('p'); write(text(iout:),'(A)')phase_of_moon(valloc)         ! phase of moon
         !=====================================================================================
         case('P'); write(text(iout:),'(i0,"%")')moon_fullness(valloc)    ! percent of fullness
         !=====================================================================================
         case('q'); write(text(iout:),'("''")')                           ! single quote (apostrophe)
         !=====================================================================================
         case('Q'); write(text(iout:),'(''"'')')                          ! double quote
         !=====================================================================================
         case('s'); write(text(iout:),'(I2.2)')valloc(7)                  ! the seconds of the minute, in the range 0 to 59
         !=====================================================================================
         case('S'); if(.not.since)then                                    ! seconds since last called
                       since=.TRUE.
                       call date_to_unix(valloc,unixtime_last,ierr)
                    endif
                    call date_to_unix(valloc,unixtime,ierr)
                    write(text(iout:),'(G0)')unixtime-unixtime_last
                    unixtime_last=unixtime
         !=====================================================================================
         case('t'); write(text(iout:),'(a1)')achar(9)                     ! tab character
         !=====================================================================================
         case('T'); write(text(iout:),'(SP,I3.2,SS,I2.2)')int(valloc(4)/60),abs(mod(valloc(4),60)) ! time from UTC as +-hhmm
         !=====================================================================================
         case('U'); call dow(valloc,weekday,day,ierr)
                    write(text(iout:),'(I1)')mod(weekday+7,7)+1           ! Return the day of the week, 1..7 Sunday=1
         !=====================================================================================
         case('u'); call dow(valloc,weekday,day,ierr)                     ! Return the day of the week, 1..7 Monday=1
                    write(text(iout:),'(I1)')weekday
         !=====================================================================================
         case('W'); call dow(valloc,weekday,day,ierr)                     ! Return the name of the day of the week
                    write(text(iout:),'(a)')day
         !=====================================================================================
         case('w'); call dow(valloc,weekday,day,ierr)                     ! Return the first abbreviation of the day of the week
                    if(ierr.ne.0)then
                       text(iout:)='ERROR'
                    else
                       if(allocated(M_time_weekday_names_abbr))then
                          text(iout:)=trim(M_time_weekday_names_abbr(weekday))
                       else
                          write(text(iout:),'(A)')trim(G_weekday_names_abbr(weekday))
                       endif
                    endif
         !=====================================================================================
         case('X');                                                       ! the day of the month 1st..31st
                    dayth='  '
                    select case(valloc(3))
                    case(1); dayth='first'
                    case(2); dayth='second'
                    case(3); dayth='third'
                    case(4); dayth='fourth'
                    case(5); dayth='fifth'
                    case(6); dayth='sixth'
                    case(7); dayth='seventh'
                    case(8); dayth='eigth'
                    case(9); dayth='ninth'
                    case(10); dayth='tenth'
                    case(11); dayth='eleventh'
                    case(12); dayth='twelveth'
                    case(13); dayth='thirteenth'
                    case(14); dayth='fourteenth'
                    case(15); dayth='fifteenth'
                    case(16); dayth='sixteenth'
                    case(17); dayth='seventeenth'
                    case(18); dayth='eigthteenth'
                    case(19); dayth='nineteenth'
                    case(20); dayth='twentieth'
                    case(21); dayth='twenty-first'
                    case(22); dayth='twenty-second'
                    case(23); dayth='twenty-third'
                    case(24); dayth='twenty-fourth'
                    case(25); dayth='twenty-fifth'
                    case(26); dayth='twenty-sixth'
                    case(27); dayth='twenty-seventh'
                    case(28); dayth='twenty-eigth'
                    case(29); dayth='twenty-ninth'
                    case(30); dayth='thirtieth'
                    case(31); dayth='thirty-first'
                    case default
                    end select
                    write(text(iout:),'(a)')dayth
         !=====================================================================================
         case('x'); write(text(iout:),'(I3.3)')valloc(8)                  ! the milliseconds of the second, in the range 0 to 999
         !=====================================================================================
         case('Y'); write(text(iout:),'(I0.4)')valloc(1)                  ! the year, including the century (for example, 1990)
         !=====================================================================================
         case('Z'); write(text(iout:),'(SP,I5.4,"m")')valloc(4)           ! time difference with respect to UTC in minutes
         !=====================================================================================
         case('z'); write(text(iout:),'(SP,I3.2,":",SS,I2.2)')int(valloc(4)/60),abs(mod(valloc(4),60)) ! time from UTC as +-hh:mm
         case('?'); write(text(iout:),'()'); call fmtdate_usage()
         !=====================================================================================
         case default
            write(text(iout:),'(A1)')chara
         !=====================================================================================
         end select
         !=====================================================================================
         iout=len_trim(text)+1
         if(iout>=longest)exit
      else
         write(text(iout:),'(A1)')chara;iout=iout+1
      endif
   enddo
   timestr=trim(text)
end function fmtdate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    fmtdate_usage(3f) - [M_time:DATE_PRINTING] display macros recognized
!!    by fmtdate(3f) and now(3f)
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine fmtdate_usage(indent)
!!
!!     integer,intent(in),optional      :: indent
!!
!!##DESCRIPTION
!!
!!   The fmtdate_usage(3f) subroutine displays the formatting options
!!   available for use in procedures such as fmtdate(3f) and now(3f).
!!   It is typically used to produce up-to-date help text in commands
!!   that use the M_time(3fm) module, so that the formatting information
!!   only needs maintained in one place (this routine) and is easily
!!   displayed so users can quickly obtain a description of the formatting
!!   macros.
!!
!!##OPTIONS
!!     indent      how many spaces to prefix the output with, so that
!!                 calling programs can position the output. Default
!!                 for this optional parameter is three (3).
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_fmtdate_usage
!!     use M_time, only : fmtdate_usage
!!     implicit none
!!        call fmtdate_usage() ! see all formatting options
!!     end program demo_fmtdate_usage
!!
!!    results (actually call the routine to ensure this is up to date):
!!
!!     Description                                        Example
!!
!!     Base time array:
!!     (1) %Y -- year, yyyy                                2016
!!     (2) %M -- month of year, 01 to 12                   07
!!     (3) %D -- day of month, 01 to 31                    29
!!         %d -- day of month, with suffix (1st, 2nd,...)  29th
!!     (4) %Z -- minutes from UTC                          -0240m
!!         %z -- -+hh:mm from UTC                          -04:00
!!         %T -- -+hhmm  from UTC                          -0400
!!     (5) %h -- hours, 00 to 23                           10
!!         %H -- hour (1 to 12, or twelve-hour clock)      10
!!         %N -- midnight< AM <=noon; noon<= PM <midnight  AM
!!     (6) %m -- minutes, 00 to 59                         54
!!     (7) %s -- sec, 00 to 59                             08
!!     (8) %x -- milliseconds 000 to 999                   521
!!     Conversions:
!!         %E -- Unix Epoch time                           1469804048.5220029
!!         %e -- integer value of Unix Epoch time          1469804049
!!         %F -- Modified Julian  date                     57599.121
!!         %f -- integer value of Modified Julian Date     57599
!!         %G -- Baseday and Seconds                       (57599,40223.12139393)
!!         %g -- Baseday seconds                           40223.12139393
!!         %J -- Julian  date                              2457599.121
!!         %j -- integer value of Julian Date(Julian Day)  2457599
!!         %O -- Ordinal day (day of year)                 211
!!         %o -- Whole days since Unix Epoch date          17011
!!         %U -- day of week, 1..7 Sunday=1                6
!!         %u -- day of week, 1..7 Monday=1                5
!!         %i -- ISO week of year 1..53                    30
!!         %I -- iso-8601 week with weekday: (yyyy-Www-d)  2016-W30-5
!!      Names:
!!         %l -- abbreviated month name                    Jul
!!         %L -- full month name                           July
!!         %w -- first three characters of weekday         Fri
!!         %W -- weekday name                              Friday
!!         %p -- phase of moon                             New
!!         %P -- percent of way from new to full moon      -1%
!!         %X -- day of month in English                   twenty-first
!!      Literals:
!!         %% -- a literal %                               %
!!         %t -- tab character
!!         %b -- blank character
!!         %B -- exclamation(bang) character
!!         %n -- new line (system dependent)
!!         %q -- single quote (apostrophe)
!!         %Q -- double quote
!!      Duration:
!!         %a -- Time since now as d-h:m:s               1-12:34:30
!!         %A -- TIme since now as seconds               12810.4500
!!      Program timing:
!!         %c -- CPU_TIME(3f) output                     .21875000000000000
!!         %C -- number of times this routine is used    1
!!         %S -- seconds since last use of this format   .0000000000000000
!!         %k -- time in seconds from SYSTEM_CLOCK(3f)   723258.812
!!         %K -- time in clicks from SYSTEM_CLOCK(3f)    723258812
!!   Help:
!!         %? -- call fmtdate_usage
!!
!!    If no percent (%) is found in the format one of several
!!    alternate substitutions occurs.
!!
!!    If the format is composed entirely of one of the following
!!    keywords the following substitutions occur:
!!
!!     iso-8601,
!!     iso          ==> %Y-%M-%DT%h:%m:%s%z
!!     iso-8601W,
!!     isoweek      ==> %I 2016-W30-5
!!     sql          ==> %Y-%M-%D %h:%m:%s.%x
!!     sqlday       ==> %Y-%M-%D
!!     dash         ==> %Y-%M-%D
!!     sqltime      ==> %h:%m:%s.%x
!!     rfc-2822     ==> %w, %D %l %Y %h:%m:%s %T
!!     rfc-3339     ==> %Y-%M-%DT%h:%m:%s%z
!!     date         ==> %w %l %D %h:%m:%s UTC%z %Y
!!     short        ==> %w, %l %d, %Y %H:%m:%s %N UTC%z
!!     long," "     ==> %W, %L %d, %Y %H:%m:%s %N UTC%z
!!     suffix       ==> %Y%D%M%h%m%s
!!     formal       ==> The %d of %L %Y
!!     lord         ==> the %d day of %L in the year of our Lord %Y
!!     easter       ==> FOR THE YEAR OF THE CURRENT DATE:
!!                      Easter day: the %d day of %L in the year of our Lord %Y
!!     all          ==> A SAMPLE OF DATE FORMATS
!!     usage|help|? ==> %?
!!
!!   Examples of single keywords
!!
!!    iso-8601
!!    iso       : 2024-06-29T08:56:48-04:00
!!    iso-8601W
!!    isoweek   : 2024-W26-6
!!    sql       : "2024-06-29 08:56:48.750"
!!    sqlday    : "2024-06-29"
!!    dash      : 2024-06-29
!!    sqltime   : 08:56:48.833
!!    rfc-2822  : Sat, 29 Jun 2024 08:56:48 -0400
!!    rfc-3339  : 2024-06-29T08:56:48-04:00
!!    date      : Sat Jun 29 08:56:48 UTC-04:00 2024
!!    short     : Sat, Jun 29th, 2024 8:56:48 AM UTC-04:00
!!    long      : Saturday, June 29th, 2024 8:56:48 AM UTC-04:00
!!    suffix    : 20242906085648
!!    formal    : The 29th of June 2024
!!    lord      : the 29th day of June in the year of our Lord 2024
!!    easter    : Easter day: the 31st day of March in the year of our Lord 2024
!!    all       : Civil Calendar: Saturday June 29th
!!                Civil Date: 2024-06-29 08:56:49 -04:00
!!                Julian Date: 2460491.0394568751
!!                Unix Epoch Time: 1719665809.0740056
!!                Day Of Year: 181
!!                ISO-8601 week: 2024-W26-6
!!
!!    otherwise the following words are replaced with the most
!!    common macros:
!!
!!    numeric values:
!!
!!       year     %Y  2016
!!       month    %M  07
!!       day      %D  29
!!       hour     %h  10
!!       minute   %m  54
!!       second   %s  08
!!       timezone %T  0400
!!
!!       epoch    %e  1469804049
!!       julian   %j  2457599
!!       ordinal  %O  211
!!       weekday  %u  5
!!       age      %A  13238944.3030
!!
!!    string values:
!!
!!       longmonth|MONTH             %L  July
!!       shortmonth|Month|Mth        %l  Jul
!!       longweekday|WEEKDAY         %W  Thursday
!!       shortweekday|Weekday|wkday  %w  Thu
!!       shortday|DAY                %d  7th
!!       longday                     %X  seventh
!!       TIMEZONE                    %z  -04:00
!!       Timezone                    %Z  -240m
!!       GOOD                        %N  AM
!!       goodhour|HOUR               %H  10
!!       AGE                         %a  1200-10:30:40
!!
!!    If none of these keywords are found then every letter that
!!    is a macro is assumed to have an implied percent in front
!!    of it. For example:
!!
!!       YMDhms ==> %Y%M%D%h%m%s ==> 20160729105408
!!
!!##AUTHOR
!!    John S. Urban, 2015-10-24
!!
!!##LICENSE
!!    MIT
subroutine fmtdate_usage(indent)

! ident_15="@(#) M_time fmtdate_usage(3f) display macros recognized by fmtdate(3f)"

integer,intent(in),optional    :: indent
character(len=128),allocatable :: usage(:)
integer                        :: i,ii
character(len=:),allocatable   :: blanks
   if(present(indent))then ! set indent to passed value or, if value is not present, set indent to 3
      ii=indent
   else
      ii=3
   endif
   blanks=repeat(' ',ii)   ! define a prefix string to create specified indent
usage=[ CHARACTER(LEN=128) :: &
! 123456789 123456789 123456789 123456789 123456789 123456789 123456789 1234567890 123456789 123456789 123456789 123456789 12345678
&'Description                                        Example%b ',&
&'%b                                                           ',&
&'%bBase time array:                                           ',&
&' 1) %%Y | year, yyyy                             %Y      ',&
&' 2) %%M | month of year, 01 to 12                %M      ',&
&' 3) %%D | day of month, 01 to 31                 %D      ',&
&'    %%d | day of month with suffix (1st,2nd,...) %d      ',&
&'    %%K | day of month in English (eg. first)    %K      ',&
&' 4) %%Z | minutes from UTC                       %Z      ',&
&'    %%z | -+hh:mm from UTC                       %z      ',&
&'    %%T | -+hhmm  from UTC                       %T      ',&
&' 5) %%h | hours, 00 to 23                        %h      ',&
&'    %%H | hour (1 to 12, or twelve-hour clock)   %H      ',&
&'    %%N | midnight<AM<=noon; noon<=PM<midnight   %N      ',&
&' 6) %%m | minutes, 00 to 59                      %m      ',&
&' 7) %%s | sec, 00 to 59                          %s      ',&
&' 8) %%x | milliseconds 000 to 999                %x      ',&
&'%bConversions:                                           ',&
&'    %%E | Unix Epoch time                        %E      ',&
&'    %%e | integer value of Unix Epoch time       %e      ',&
&'    %%F | Modified Julian date                   %F      ',&
&'    %%f | integer value of Modified Julian Date  %f      ',&
&'    %%G | Baseday and Seconds                    %G      ',&
&'    %%g | Baseday seconds                        %g      ',&
&'    %%J | Julian  date                           %J      ',&
&'    %%j | integer Julian Date(Julian Day)        %j      ',&
&'    %%O | Ordinal day (day of year)              %O      ',&
&'    %%o | Whole days since Unix Epoch date       %o      ',&
&'    %%U | day of week, 1..7 Sunday=1             %U      ',&
&'    %%u | day of week, 1..7 Monday=1             %u      ',&
&'    %%i | ISO week of year 1..53                 %i      ',&
&'    %%I | iso-8601 week with weekday: yyyy-Www-d %I      ',&
&'%b Names:                                                ',&
&'    %%l | abbreviated month name                 %l      ',&
&'    %%L | full month name                        %L      ',&
&'    %%w | first three characters of weekday      %w      ',&
&'    %%W | weekday name                           %W      ',&
&'    %%p | phase of moon                          %p      ',&
&'    %%P | percent of way from new to full moon   %P      ',&
&'    %%X | day of the month in English            %X      ',&
&'%b Literals:                                             ',&
&'    %%%% | a literal %%                             %%    ',&
&'    %%t | tab character                          %t      ',&
&'    %%b | blank character                        %b      ',&
&'    %%B | exclamation(bang) character            %B      ',&
&'    %%n | new line (system dependent)            %n      ',&
&'    %%q | single quote (apostrophe)              %q      ',&
&'    %%Q | double quote                           %Q      ',&
&'%b Duration:                                             ',&
&'    %%a | Time since now as d-hh:mm:ss           %a      ',&
&'    %%A | Time since now as seconds              %A      ',&
&'%b Program timing:                                       ',&
&'    %%c | CPU_TIME(3f) output                    %c      ',&
&'    %%C | number of times this routine is used   %C      ',&
&'    %%S | seconds since last use of this format  %S      ',&
&'    %%k | time in seconds from SYSTEM_CLOCK(3f)  %k      ',&
&'    %%K | time in clicks from SYSTEM_CLOCK(3f)   %K      ',&
&'%b Help:                                                 ',&
&'    %%? | call fmtdate_usage()                           ',&
&'%b                                                           ',&
&'%bIf no percent (%%) is found in the format one of several   ',&
&'%balternate substitutions occurs.                            ',&
&'%b                                                           ',&
&'%bIf the format is composed entirely of one of the following ',&
&'%bkeywords the following substitutions occur:                ',&
&'%b iso-8601,                                               ',&
&'%b iso          ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z ==> %Y-%M-%DT%h:%m:%s%z   ',&
&'%b iso-8601W,                                                                  ',&
&'%b isoweek      ==> %%I ==> %I                             ',&
&'%b sql          ==> %%Y-%%M-%%D %%h:%%m:%%s.%%x ==> %Y-%M-%D %h:%m:%s.%x',&
&'%b sqlday       ==> %%Y-%%M-%%D ==> %Y-%M-%D           ',&
&'%b sqltime      ==> %%h:%%m:%%s.%%x ==> %h:%m:%s.%x    ',&
&'%b dash         ==> %%Y-%%M-%%D ==> %Y-%M-%D               ',&
&'%b rfc-2822     ==> %%w, %%D %%l %%Y %%h:%%m:%%s %%T       ',&
&'%b                   %w, %D %l %Y %h:%m:%s %T               ',&
&'%b rfc-3339     ==> %%Y-%%M-%%DT%%h:%%m:%%s%%z ==> %Y-%M-%DT%h:%m:%s%z   ',&
&'%b date         ==> %%w %%l %%D %%h:%%m:%%s UTC%%z %%Y      ',&
&'%b                   %w %l %D %h:%m:%s UTC%z %Y              ',&
&'%b short        ==> %%w, %%l %%d, %%Y %%H:%%m:%%s %%N UTC%%z',&
&'%b                   %w, %l %d, %Y %H:%m:%s %N UTC%z         ',&
&'%b long," "     ==> %%W, %%L %%d, %%Y %%H:%%m:%%s %%N UTC%%z',&
&'%b                   %W, %L %d, %Y %H:%m:%s %N UTC%z         ',&
&'%b suffix       ==> %%Y%%D%%M%%h%%m%%s ==> %Y%D%M%h%m%s           ',&
&'%b formal       ==> The %%d of %%L %%Y ==> The %d of %L %Y           ',&
&'%b lord         ==> the %%d day of %%L in the year of our Lord %%Y               ',&
&'%b                   the %d day of %L in the year of our Lord %Y                  ',&
&'%b easter       ==> FOR THE YEAR OF THE CURRENT DATE:       ',&
&'%b                   Easter day: the %%d day of %%L in the year of our Lord %%Y ',&
&'%b all          ==> A SAMPLE OF DATE FORMATS               ',&
&'%b usage|help|? ==> call fmtdate_usage                     ',&
&'%botherwise the following words are replaced with the most   ',&
&'%bcommon macros:                                             ',&
&'%b   year                        %%Y  %Y                     ',&
&'%b   month                       %%M  %M                     ',&
&'%b   day                         %%D  %D                     ',&
&'%b   timezone                    %%z  %z                     ',&
&'%b   hour                        %%h  %h                     ',&
&'%b   minute                      %%m  %m                     ',&
&'%b   second                      %%s  %s                     ',&
&'%b   millisecond                 %%x  %x                     ',&
&'%b   epoch                       %%e  %e                     ',&
&'%b   julian                      %%j  %j                     ',&
&'%b   ordinal                     %%O  %O                     ',&
&'%b   weekday                     %%u  %u                     ',&
&'%b   longmonth|MONTH             %%L  %L                     ',&
&'%b   shortmonth|Month|Mth        %%l  %l                     ',&
&'%b   shortday|DAY                %%d  %d                     ',&
&'%b   longday                     %%X  %X                     ',&
&'%b   goodhour|HOUR               %%H  %H                     ',&
&'%b   GOOD                        %%N  %N                     ',&
&'%b   shortweekday|Weekday|wkday  %%w  %w                     ',&
&'%b   longweekday|WEEKDAY         %%W  %W                     ',&
&'%b   Timezone                    %%Z  %Z                     ',&
&'%b   TIMEZONE                    %%z  %z                     ',&
&'%b   age                         %%a  %a                     ',&
&'%b   AGE                         %%A  %A                     ',&
&'%bIf none of these keywords are found then every letter that ',&
&'%bis a macro is assumed to have an implied percent in front  ',&
&'%bof it. For example:                                        ',&
&'%b   YMDhms ==> %%Y%%M%%D%%h%%m%%s ==> %Y%M%D%h%m%s          ',&
&'%b                                                           ']
   write(*,'(a,a)')(blanks,(trim(now(usage(i)))),i=1,size(usage))
end subroutine fmtdate_usage
!-----------------------------------------------------------------------------------------------------------------------------------
! C for reference
! %U     week number of year, with Sunday as first day of week (00..53)
! %Z     alphabetic time zone abbreviation (e.g., EDT)
!        By default, date pads numeric fields with zeroes. The following optional flags may follow '%':
!        -      (hyphen) do not pad the field
!        _      (underscore) pad with spaces
!        0      (zero) pad with zeros
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    guessdate(3f) - [M_time:READING_DATES] reads in a date, in various formats
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine guessdate(anot,dat)
!!
!!     character(len=*),intent(in) :: anot
!!     integer,intent(out)         :: dat(8)
!!
!!##DESCRIPTION
!!
!!   Read in strings and except for looking for month names remove
!!   non-numeric characters and try to convert a string assumed to represent
!!   a date to a date-time array.
!!
!!   Years should always be expressed as four-digit numbers, and except for
!!   the special format yyyy-mm-dd the day should come after the year. Named
!!   months are preferred. If ambiguous the order is assumed to be day -
!!   month - year. Times are assumed to be of the form HH:MM:SS
!!
!!   It is planned that this routine will be superseded. As an alternative,
!!   a C routine exists in the standard C libraries that allows for
!!   expansive features when reading dates that can be called via the
!!   ISO_C_BINDING interface.
!!
!!##OPTIONS
!!    anot  A string assumed to represent a date including a year, month
!!          and day.
!!
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_guessdate
!!     use M_time, only : guessdate, fmtdate
!!     implicit none
!!     character(len=20),allocatable :: datestrings(:)
!!     character(len=:),allocatable  :: answer
!!     integer                       :: dat(8)
!!     integer                       :: i
!!        datestrings=[ &
!!        & 'January 9th, 2001   ',&
!!        & ' Tue Jul 19 2016    ',&
!!        & ' 21/12/2016         ',&
!!        & ' 4th of Jul 2004    ' ]
!!        do i=1,size(datestrings)
!!           write(*,'(a)')repeat('-',80)
!!           write(*,*)'TRYING ',datestrings(i)
!!           call guessdate(datestrings(i),dat)
!!           write(*,*)'DAT ARRAY ',dat
!!           answer=fmtdate(dat)
!!           write(*,*)'FOR '//datestrings(i)//' GOT '//trim(answer)
!!        enddo
!!     end program demo_guessdate
!!
!!    results:
!!
!!     ---------------------------------------------------------------------
!!     TRYING January 9th, 2001
!!     DAT ARRAY         2001  1  9   -240    0   0   0    0
!!     FOR January 9th, 2001  GOT Tuesday, January 9th, 2001 12:00:00 AM
!!     ---------------------------------------------------------------------
!!     TRYING  Tue Jul 19 2016
!!     DAT ARRAY         2016  7  19  -240    0   0   0    0
!!     FOR  Tue Jul 19 2016   GOT Tuesday, July 19th, 2016 12:00:00 AM
!!     ---------------------------------------------------------------------
!!     TRYING  21/12/2016
!!     DAT ARRAY         2016  12 21  -240    0   0   0    0
!!     FOR  21/12/2016        GOT Wednesday, December 21st, 2016 12:00:00 AM
!!     ---------------------------------------------------------------------
!!     TRYING  4th of Jul 2004
!!     DAT ARRAY         2004  7  4   -240    0   0   0    0
!!     FOR  4th of Jul 2004   GOT Sunday, July 4th, 2004 12:00:00 AM
!!
!!##LICENSE
!!    MIT
subroutine guessdate(datestring,dat,ier)

! ident_16="@(#) M_time guessdate(3f) Guess format of a date string to create a DAT date-time array"

! partially based on a concept from JRH 1991-03-19
! JSU, 20160729
!
! makes an odd number of assumptions trying to guess what date format is being used. If you know the format of your date
! values READ(3f) and parse them directly instead of using this procedure, even though it does a good job with common USA formats.
!
!x! REDO more rigorously with regular expressions and recognize standard formats directly

! NOTE : Main constraint is that day is input BEFORE year unless use YYYY-MM-DD and a : implies HH:MM:SS, no timezone names
!        Not rigorous. Gets most common formats but can easily make errors in all but simple unambiguous common date formats
character(len=*),intent(in)       :: datestring ! Date in string format
character(len=:),allocatable      :: datestring_local ! Date in string format
character(len=:),allocatable      :: temp
integer,intent(out)               :: dat(8)
integer,optional                  :: ier
integer                           :: ier_local
integer                           :: iye,mon,idy  ! Year, Month, Day
integer                           :: ihr,imi,ise  ! Hour, Minute, Second
integer                           :: itz, imill   ! Timezone, Milliseconds
character(len=len(datestring)*2)  :: buff
integer                           :: i,idum,ind
logical                           :: alpha
integer                           :: ios
integer                           :: itries
character(len=3),parameter        :: amon(12)=['JAN','FEB','MAR','APR','MAY','JUN', 'JUL','AUG','SEP','OCT','NOV','DEC']
integer,parameter                 :: idmon(12)=[31 , 28  , 31  , 30  , 31  , 30 , 31 , 31  , 30  , 31  , 30  , 31]
character(len=:),allocatable      :: scratch(:)
integer,parameter                 :: isize=40
real                              :: rvalues(isize)
character(len=2)                  :: ampm
integer                           :: iend, inums, ierr
logical                           :: number
logical                           :: verbose
integer                           :: loops

   dat=getnow()                                             ! get time zone of current process and set defaults
   iye=dat(1)
   mon=dat(2)
   idy=dat(3)
   itz=dat(4)                                               ! default is to use current timezone
   ihr=0
   imi=0
   ise=0
   imill=0

   ier_local=0
   rvalues=0.0
   datestring_local=''
   verbose=.false.

!-----------------------------------------------------------------------------------------------------------------------------------
   temp=' '//trim(upper(datestring))
   if(len(temp)>=2)then
      if(temp(2:2)=='?')then
         verbose=.true.
         temp=temp(3:)
      endif
   endif
   if(verbose)write(*,gen)'*guessdate* a',temp,'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   number=.false.                                        ! when transition from letter to number add a space
   do i=1,len(temp)
      select case(temp(i:i))
      case('A':'Z','/')
         if(number)then
            datestring_local=datestring_local//' '
         endif
         number=.false.
      case default
         number=.true.
      end select
      datestring_local=datestring_local//temp(i:i)
   enddo
!-----------------------------------------------------------------------------------------------------------------------------------

   if(verbose)write(*,gen)'*guessdate* b',datestring_local,'::',iye,mon,idy,itz,ihr,imi,ise,imill
   datestring_local=datestring_local//'                 '  ! pad string so substitute will fit if old string shorter than new string
   !make sure spaces are around month names
   call substitute(datestring_local,'JANUARY',' JAN ')
   call substitute(datestring_local,'FEBRUARY',' FEB ')
   call substitute(datestring_local,'MARCH',' MAR ')
   call substitute(datestring_local,'APRIL',' APR ')
   call substitute(datestring_local,'MAY',' MAY ')
   call substitute(datestring_local,'JUNE',' JUN ')
   call substitute(datestring_local,'JULY',' JUL ')
   call substitute(datestring_local,'AUGUST',' AUG ')
   call substitute(datestring_local,'SEPTEMBER',' SEP ')
   call substitute(datestring_local,'OCTOBER',' OCT ')
   call substitute(datestring_local,'NOVEMBER',' NOV ')
   call substitute(datestring_local,'DECEMBER',' DEC ')
   call substitute(datestring_local,'SEPT',' SEP ')

   call substitute(datestring_local,'JAN',' JAN ')
   call substitute(datestring_local,'FEB',' FEB ')
   call substitute(datestring_local,'MAR',' MAR ')
   call substitute(datestring_local,'APR',' APR ')
   call substitute(datestring_local,'MAY',' MAY ')
   call substitute(datestring_local,'JUN',' JUN ')
   call substitute(datestring_local,'JUL',' JUL ')
   call substitute(datestring_local,'AUG',' AUG ')
   call substitute(datestring_local,'SEP',' SEP ')
   call substitute(datestring_local,'OCT',' OCT ')
   call substitute(datestring_local,'NOV',' NOV ')
   call substitute(datestring_local,'DEC',' DEC ')

   ! assume T[0=9] is from yyyyy-mm-ddThh:mm:ss.xx ISO-8601 format (or SEPTnn,OCTnn AUGUSTnn, where space was added or name changed)
   call substitute(datestring_local,'T0',' 0')
   call substitute(datestring_local,'T1',' 1')
   call substitute(datestring_local,'T2',' 2')
   call substitute(datestring_local,'T3',' 3')
   call substitute(datestring_local,'T4',' 4')
   call substitute(datestring_local,'T5',' 5')
   call substitute(datestring_local,'T6',' 6')
   call substitute(datestring_local,'T7',' 7')
   call substitute(datestring_local,'T8',' 8')
   call substitute(datestring_local,'T9',' 9')

   call substitute(datestring_local,': ',':')
   call substitute(datestring_local,' :',':')

   if(verbose)write(*,gen)'*guessdate* A ',datestring_local,'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   call substitute(datestring_local,'UTC',' ')
!-----------------------------------------------------------------------------------------------------------------------------------
   call split(datestring_local,scratch,' ;,"''')
   if(verbose)write(*,gen)'*guessdate* B ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   do i=1,size(scratch)                                                       ! a leading +/- is assumed to be a timezone
      if( index("+-",scratch(i)(1:1)) /= 0)then
         if(index(scratch(i),':')/=0)then                                   ! assumed to be +-hh:mm
            call string_to_values(scratch(i),isize,rvalues,inums,':',ierr)
            if(inums>=2)then
               itz=60*nint(rvalues(1))+nint(rvalues(2))
            elseif(inums==1)then
               itz=60*nint(rvalues(1))
            endif
         else                                                                ! assumed to be +-mm
            itz=nint(s2v(scratch(i)))
         endif
         scratch(i)=' '
      endif
   enddo
   if(verbose)write(*,gen)'*guessdate* C ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   do i=1,size(scratch)                      ! AM and PM are assumed to only occur significantly (not end of day or month name, ...)
      if(len_trim(scratch(i))>=2)then
         iend=len_trim(scratch(i))
         ampm=scratch(i)(iend-1:iend)
         select case (ampm)
         case('AM')
            call substitute(scratch(i),'AM',':')
         case('PM')
            ihr=ihr+12
            call substitute(scratch(i),'PM',':')
         end select
      endif
   enddo
   if(verbose)write(*,gen)'*guessdate* E ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   do i=1,size(scratch)                                                      ! look for HH:MM:SS
      if(index(scratch(i),':')/=0)then
         buff=scratch(i)
         call substitute(buff,'-',' -')
         call substitute(buff,'+',' +')
         call string_to_values(buff,isize,rvalues,inums,':/',ierr)
         if(inums>=1) ihr=ihr+nint(rvalues(1))
         if(inums>=2) imi=nint(rvalues(2))
         if(inums>=3) ise=nint(rvalues(3))
         if(inums>=4) itz=nint(rvalues(4))
         scratch(i)=' '
      endif
   enddo
   if(verbose)write(*,gen)'*guessdate* F ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   do i=1,size(scratch)                                                       ! assume yyyy-mm-dd if found a dash
      if(index(scratch(i),"-")/=0)then
            call string_to_values(scratch(i),isize,rvalues,inums,'-',ierr)
            select case(inums)
            case(3)
               iye=nint(rvalues(1))
               mon=nint(rvalues(2))
               idy=nint(rvalues(3))
               scratch(i)=v2s(nint(rvalues(3)))//' '//v2s(nint(rvalues(2)))//' '//v2s(nint(rvalues(1)))
            case(2)
               iye=nint(rvalues(1))
               mon=nint(rvalues(2))
               scratch(i)=v2s(nint(rvalues(2)))//' '//v2s(nint(rvalues(1)))
            case default
            end select
      endif
   enddo
   if(verbose)write(*,gen)'*guessdate* D ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   datestring_local=''
   do i=1,size(scratch)
      datestring_local=datestring_local//' '//adjustl(trim(scratch(i)))
   enddo
   if(verbose)write(*,gen)'*guessdate* G ',(trim(scratch(i)),'|',i=1,size(scratch)),'::',iye,mon,idy,itz,ihr,imi,ise,imill
!-----------------------------------------------------------------------------------------------------------------------------------
   if(datestring_local==' ')then
     loops=0
   else
     loops=1000
   endif
   if(verbose)write(*,gen)'*guessdate* Ga',datestring_local,'::',iye,mon,idy,itz,ihr,imi,ise,imill,loops
   INFINITE: do itries=1,loops                              ! give up after 1000 passes
      buff=datestring_local                                 ! copy to buffer
      alpha=.false.

      do i=1,12
         ind=index(buff,amon(i))
         if(ind/=0) then                                  ! Found a matching month
            mon=i
            buff(ind:ind+2)='   '                           ! Delete month
            alpha=.true.                                    ! Alphabetic month
            exit
         endif
      enddo

      do i=1,len(buff)                                      ! First remove all non-numeric characters
         idum=iachar(buff(i:i))
         if(idum<48.or.idum>57)then
            buff(i:i)=' '
         endif
      enddo

      if(alpha) then                                        ! Alphabetic month
         read(buff,*,iostat=ios) idy,iye
         if(ios/=0)cycle INFINITE
      else
         read(buff,*,iostat=ios) idy,mon,iye
         if(ios/=0)cycle INFINITE
      endif
      !x!if(iye<=99)then
      !x!   iye=iye+2000                                       ! Cope with two digit year (assume 21st century.)
      !x!endif
      if(mon<1.or.mon>12) cycle INFINITE              ! Check range of months
      if(mon==2) then                                     ! Special check for Feb.
         if((iye/4)*4==iye) then                          ! Leap year
            if(idy<1.or.idy>29) cycle INFINITE
         else                                               ! Non-leap year
            if(idy<1.or.idy>28) cycle INFINITE
         endif
      else
         if(idy<1.or.idy>idmon(mon)) cycle INFINITE   ! Error ..... re-input
      endif
      exit
   enddo INFINITE
   if(verbose)write(*,gen)'*guessdate* H ',datestring_local,'::',iye,mon,idy,itz,ihr,imi,ise,imill
   if(itries>=1000)then
      write(stderr,gen)'<ERROR>*guessdate*: could not extract date for',trim(datestring)
   endif
   dat(1)=iye
   dat(2)=mon
   dat(3)=idy
   dat(4)=itz
   dat(5)=ihr
   dat(6)=imi
   dat(7)=ise
   dat(8)=imill
   if(present(ier))ier=ier_local
end subroutine guessdate
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    dow(3f) - [M_time:DAY_OF_WEEK] given a date-time array DAT return
!!    the day of the week
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine dow(values, weekday, day, ierr, short)
!!
!!     integer,intent(in)                    :: values(8)
!!     integer,intent(out),optional          :: weekday
!!     character(len=*),intent(out),optional :: day
!!     integer,intent(out),optional          :: ierr
!!     logical,intent(in),optional           :: short
!!
!!##DESCRIPTION
!!   Given a date array DAT
!!   return the day of the week as a number and a name, Mon=1.
!!
!!##OPTIONS
!!    values   "DAT" array (an integer array of the same format as
!!             the array returned by the intrinsic DATE_AND_TIME(3f))
!!             describing the date to be used to calculate the day
!!             of the week.
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!##RETURNS
!!    weekday  The numeric day of the week, starting with Monday=1.
!!             Optional.
!!    day      The name of the day of the week.
!!             Optional.
!!    ierr     Error code
!!
!!             o [ 0] correct
!!             o [-1] invalid input date
!!             o [-2] neither day nor weekday
!!               return values were requested.
!!
!!             If the error code is not returned and an error occurs,
!!             the program is stopped.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_dow
!!     use M_time, only : dow
!!     implicit none
!!     integer          :: dat(8)     ! input date array
!!     integer          :: weekday
!!     character(len=9) :: day
!!     integer          :: ierr
!!       call date_and_time(values=dat)
!!       call dow(dat, weekday, day, ierr)
!!       write(*,'(a,i0)')'weekday=',weekday
!!       write(*,'(a,a)')'day=',trim(day)
!!       write(*,'(a,i0)')'ierr=',ierr
!!     end program demo_dow
!!
!!    results:
!!
!!     weekday=1
!!     day=Monday
!!     ierr=0
!!
!!##AUTHOR
!!    John S. Urban, 2015-12-19
!!
!!##LICENSE
!!    MIT
subroutine dow(values, weekday, day, ierr, short)

! ident_17="@(#) M_time dow(3f) Given DAT date-time array return the day of the week"

integer,intent(in)                    :: values(8) ! date and time array used to get time zone
integer,intent(out),optional          :: weekday   ! The day of the week, 1 = Monday, 7 = Sunday
character(len=*),intent(out),optional :: day       ! The name of the day of the week, e.g. 'Sunday'. Minimum length = 9
integer,intent(out),optional          :: ierr      ! Error code,0=correct,-1=invalid input date,-2=neither day nor weekday specified
logical,intent(in),optional           :: short
real(kind=realtime)                   :: julian    ! the Julian Date for which the weekday is required,
integer                               :: iweekday
integer                               :: ierr_local
logical                               :: short_

   call date_to_julian(values,julian,ierr_local)   ! need Julian Date to calculate day of week for first day of month
   ierr_local = 0
   iweekday=0  ! bad value.

   if(julian < 0) then
      ierr_local = -1
   elseif(.not.present(day).and. .not.present(weekday)) then
      ierr_local=-2
   else
      ! Julian Day is in Z time zone and starts at noon so add 1/2 day; and add time zone
      !iweekday = mod(int((julian+real(values(4)/60.0_dp/24.0_dp,kind=real64)+0.5_dp)+1.0_dp), 7)
      ! REAL nint() changed to int(anint()) added to avoid bug in OpenBSD gfortran on i386
      iweekday = mod(int(anint(julian+real(values(4)/60.0_dp/24.0_dp,kind=real64)))+1, 7)
      iweekday = iweekday +1  ! change range from 0 to 6 to 1 to 7
      iweekday = mod(iweekday+5,7)+1  ! change from Sunday=1 to Monday=1

      if(present(day)) then
         if(present(short))then
            short_=short
         else
            short_=.false.
         endif
         if(short_)then
            if(allocated(M_time_weekday_names_abbr))then
               if(size(M_time_weekday_names_abbr).ne.7)then
                  write(stderr,gen) '<ERROR>*dow*: weekday name abbr. count not 7:',size(M_time_weekday_names_abbr)
                  day='error'
               else
                  select case(iweekday)
                  case(1:7)   ;day = trim(M_time_weekday_names_abbr(iweekday))
                  case default;day = 'error'
                  end select
               endif
            else
               select case(iweekday)
               case(1:7)   ;day = trim(G_weekday_names_abbr(iweekday))
               case default;day = 'error'
               end select
            endif
         else
            if(allocated(M_time_weekday_names))then
               if(size(M_time_weekday_names).ne.7)then
                  write(stderr,gen) '<ERROR>*dow*: weekday name count not 7:',size(M_time_weekday_names)
                  day='error'
               else
                  select case(iweekday)
                  case(1:7)   ;day = M_time_weekday_names(iweekday)
                  case default;day = 'error'
                  end select
               endif
            else
               select case(iweekday)
               case(1:7)   ;day = G_weekday_names(iweekday)
               case default;day = 'error'
               end select
            endif
         endif
      endif

   endif

   if(present(ierr))then
      ierr=ierr_local
   elseif(ierr_local/=0)then
      write(stderr,gen) '<ERROR>*dow*: Unprocessed Error',ierr_local,'stopping.'
      stop 2
   endif

   if(present(weekday))then
      weekday=iweekday
   endif

end subroutine dow
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2w(3f) - [M_time:WEEK_OF_YEAR] calculate iso-8601 Week, both
!!    numerically and as a string of the form "yyyy-Wmm-d" given a DAT
!!    date-time array
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine d2w(dat,iso_year,iso_week,iso_weekday,iso_name)
!!
!!     integer,intent(in)              :: dat(8)     ! input date array
!!     integer,intent(out)             :: iso_year, iso_week, iso_weekday
!!     character(len=10),intent(out)   :: iso_name
!!
!!##DESCRIPTION
!!   Given a "DAT" array defining a date and time, return the ISO-8601
!!   Week in two formats -- as three integer values defining the ISO year,
!!   week of year and weekday; and as a string of the form "yyyy-Www-d".
!!
!!##OPTIONS
!!    dat          "DAT" array (an integer array of the same format as
!!                 the array returned by the intrinsic DATE_AND_TIME(3f))
!!                 describing the date,
!!
!!                     dat=[ year,month,day,timezone,hour,&
!!                      & minutes,seconds,milliseconds]
!!##RETURNS
!!    iso_year     ISO-8601 year number for the given date
!!    iso_week     ISO-8601 week number for the given date
!!    iso_weekday  ISO-8601 weekday number for the given date
!!    iso_name     ISO-8601 Week string for the data in the form "yyyy-Www-d".
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2w
!!     use M_time, only : d2w
!!     implicit none
!!     integer           :: dat(8)     ! input date array
!!     integer           :: iso_year, iso_week, iso_weekday
!!     character(len=10) :: iso_name
!!        call date_and_time(values=dat)
!!        call d2w(dat,iso_year,iso_week,iso_weekday,iso_name)
!!        write(*,'("ISO-8601 Week:   ",a)')iso_name
!!        write(*,'(a,i0)')'ISO-8601 year    ',iso_year
!!        write(*,'(a,i0)')'ISO-8601 week    ',iso_week
!!        write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
!!     end program demo_d2w
!!
!!    results:
!!
!!     ISO-8601 Week:   2016-W29-1
!!     ISO-8601 year    2016
!!     ISO-8601 week    29
!!     ISO-8601 weekday 1
!!
!!##DEFINITION
!!   The ISO-8601 date and time standard was issued by the International
!!   Organization for Standardization (ISO). It is used (mainly) in
!!   government and business for fiscal years, as well as in timekeeping.
!!   The system specifies a week year atop the Gregorian calendar by defining
!!   a notation for ordinal weeks of the year.
!!
!!   o An ISO week-numbering year (also called ISO year informally) has 52
!!     or 53 full weeks. That is 364 or 371 days instead of the usual 365
!!     or 366 days.
!!   o The extra week is referred to here as a leap week, although ISO-8601
!!     does not use this term. Weeks start with Monday.
!!   o The first week of a year is the week that contains the first Thursday
!!     of the year (and, hence, always contains 4 January). ISO week year
!!     numbering therefore slightly deviates from the Gregorian for some days
!!     close to January 1st.
!!
!!##CALCULATION
!!   The ISO-8601 week number of any date can be calculated, given its
!!   ordinal date (i.e. position within the year) and its day of the week.
!!
!!##METHOD
!!     Using ISO weekday numbers (running from 1 for Monday to 7 for Sunday),
!!     subtract the weekday from the ordinal date, then add 10. Divide the
!!     result by 7. Ignore the remainder; the quotient equals the week
!!     number. If the week number thus obtained equals 0, it means that
!!     the given date belongs to the preceding (week-based) year. If a
!!     week number of 53 is obtained, one must check that the date is not
!!     actually in week 1 of the following year.
!!
!!     These two statements are assumed true when correcting the dates
!!     around January 1st:
!!
!!     o The number of weeks in a given year is equal to the corresponding
!!       week number of 28 December.
!!     o January 4th is always in the first week.
!!
!!##ISO_NAME
!!   Week date representations are in the format YYYYWww-D.
!!
!!     o [YYYY] indicates the ISO week-numbering year which is slightly
!!       different from the traditional Gregorian calendar year.
!!     o [Www] is the week number prefixed by the letter W, from W01
!!       through W53.
!!     o [D] is the weekday number, from 1 through 7, beginning with Monday
!!       and ending with Sunday.
!!
!!   For example, the Gregorian date 31 December 2006 corresponds to the
!!   Sunday of the 52nd week of 2006, and is written
!!
!!     2006-W52-7 (extended form)
!!     or
!!     2006W527 (compact form).
!!
!!##REFERENCE
!!    From Wikipedia, the free encyclopedia 2015-12-19
!!
!!##AUTHOR
!!    John S. Urban, 2015-12-19
!!
!!##LICENSE
!!    MIT
subroutine d2w(dat,iso_year,iso_week,iso_weekday,iso_name)

! ident_18="@(#) M_time d2w(3f) DAT date-time array to iso-8601 Week-numbering year date yyyy-Www-d"

integer,intent(in)              :: dat(8)     ! input date array
integer,intent(out)             :: iso_year, iso_week, iso_weekday
character(len=10),intent(out)   :: iso_name
integer                         :: shared_weekday
integer                         :: last_week_this_year
integer                         :: dec28_lastyear(8)   ! December 28th is always in last week
integer                         :: dec28_thisyear(8)   ! December 28th is always in last week
character(len=9)                :: day
integer                         :: ierr
   iso_year=dat(1)                                               ! initially assume the iso_year is the same as the data array year
   iso_week=uncorrected_week_of_year(dat)                        ! this is the week number unless around January 1st
   iso_weekday=shared_weekday                                    ! this is the number of the day of the week assuming Monday=1
   dec28_thisyear=[dat(1),12,28,dat(4),0,0,0,0]                  ! Dec 28th is always in last week; use this to get number of weeks
   last_week_this_year=uncorrected_week_of_year(dec28_thisyear)  ! get the number of the last week of the year (52 or 53)

   ! correct dates around January 1st
   if(iso_week  < 1)then                                         ! if week < 1 then week = lastWeek(year -1)
      dec28_lastyear=[dat(1)-1,12,28,dat(4),0,0,0,0]             ! Dec 28th is always in last week, we want its week number
      iso_week=uncorrected_week_of_year(dec28_lastyear)          ! got the week number for the last week of last year (52 or 53)
      iso_year=dat(1)-1                                          ! our date belongs to last year
   elseif(iso_week >last_week_this_year)then                     ! if week > lastweek(year) then week = 1
      iso_week=iso_week-last_week_this_year                      ! our date belongs to next year
      iso_year=dat(1)+1
   endif

   write(iso_name,'(i4.4,"-W",i2.2,"-",i1)')iso_year,iso_week,iso_weekday ! create ISO string designation for our date

contains
   function uncorrected_week_of_year(datin)
   implicit none
   integer            :: uncorrected_week_of_year
   integer,intent(in) :: datin(8)
   integer            :: ordinal
      call dow(datin,shared_weekday,day,ierr)                 ! formula needs day of week 1..7 where Monday=1
      ordinal=d2o(datin)                                      ! formula needs ordinal day of year where Jan 1st=1
      uncorrected_week_of_year=(ordinal-shared_weekday+10)/7
   end function uncorrected_week_of_year

end subroutine d2w
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    w2d(3f) - [M_time:WEEK_OF_YEAR] calculate DAT date-time array from iso-8601
!!    numeric Week values or from string "yyyy-Www-d"
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    either
!!
!!       subroutine w2d(iso_year,iso_week,iso_weekday,dat)
!!
!!        integer,intent(in)      :: iso_year, iso_week, iso_weekday
!!        integer,intent(out)     :: dat(8)     ! output date array
!!
!!    or
!!
!!       subroutine w2d(iso_week,dat,ierr)
!!
!!        character(len=*),intent(in)  :: iso8601_week
!!        integer,intent(out)          :: dat(8)     ! output date array
!!        integer,intent(out),optional :: ierr
!!
!!##DESCRIPTION
!!   Given an ISO-8601 week return a "DAT" array defining a date and time,
!!   The ISO-8601 is supplied as three integer values defining the ISO
!!   year, week of year and weekday.
!!
!!##OPTIONS
!!    iso_year      ISO-8601 year number for the given date
!!    iso_week      ISO-8601 week number for the given date.
!!                  Valid values are from 1 to 53.
!!    iso_weekday   ISO-8601 weekday number for the given date.
!!                  Valid values are from 1 to 7, where 1 is Monday.
!!
!!    iso8601_week  ISO-8601 Week string for the data in the form
!!                  "yyyy-Www-D", "yyyyWwwD", "yyyy-Www", and "yyyyWww"
!!                  where yyyy is the year, ww is the iso_week, and D is
!!                  the weekday.
!!
!!##RETURNS
!!    dat          "DAT" array (an integer array of the same format as
!!                 the array returned by the intrinsic DATE_AND_TIME(3f))
!!                 describing the date to be used
!!
!!                     dat=[ year,month,day,timezone,hour,&
!!                      & minutes,seconds,milliseconds]
!!
!!    ierr         optional error code result. If non-zero an error occurred.
!!                 If an error occurs and IERR is not present the program
!!                 terminates.
!!##NOTES
!!
!!   If D is omitted 1 is returned although this does not appear in the
!!   iso-8601 standard at the current time.
!!
!!   The returned dat array is currently always assumed to have the local
!!   timezone. This might be changed to always assume ZULU time.
!!
!!##EXAMPLE
!!
!!
!!  Sample program:
!!
!!     program demo_w2d
!!     use M_time, only : w2d, fmtdate
!!     implicit none
!!       write(*,'(a)')&
!!       & 'Given Monday 29 December 2008 is written "2009-W01-1"'
!!       call printit(2009,1,1)
!!       write(*,'(a)')&
!!       & 'Given Sunday 3 January 2010 is written "2009-W53-7"'
!!       call printit(2009,53,7)
!!       write(*,'(a)')&
!!       & 'Given the Gregorian date Sun 31 December 2006 &
!!       &is written 2006-W52-7'
!!       call printit(2006,52,7)
!!       write(*,'(a)')&
!!       & 'Given 27 September 2008 is 2008-W39-6'
!!       call printit(2008,39,6)
!!
!!       string : block
!!          character(len=*),parameter :: array(4)=[character(len=80) ::  &
!!          & '2008-W39-6', '2008W396', '2008-W39', '2008W39' ]
!!          integer  :: dat(8)
!!          integer  :: i
!!          do i=1,size(array)
!!             write(*,'(a)')&
!!             & 'Given string '//array(i)
!!             call w2d(array(i),dat)
!!             write(*,'(a,i0)')'RESULT:          '
!!             write(*,'(a,*(i0:,","))')'   DAT array        ',dat
!!             write(*,'(a,/,67("="))')'    '//fmtdate(dat,'long')
!!          enddo
!!       endblock string
!!     contains
!!     subroutine printit(iso_year,iso_week,iso_weekday)
!!     ! ISO-8601 Week: 2016-W29-1
!!     integer  :: iso_year, iso_week, iso_weekday
!!     ! input date array
!!     integer  :: dat(8)
!!      call w2d(iso_year,iso_week,iso_weekday,dat)
!!      write(*,'(a,i0)')'GIVEN:           '
!!      write(*,'(a,i0)')'ISO-8601 year    ',iso_year
!!      write(*,'(a,i0)')'ISO-8601 week    ',iso_week
!!      write(*,'(a,i0)')'ISO-8601 weekday ',iso_weekday
!!      write(*,'(a,i0)')'RESULT:          '
!!      write(*,'(a,*(i0:,","))')'   DAT array        ',dat
!!      write(*,'(a,/,67("="))')'    '//fmtdate(dat,'long')
!!     end subroutine printit
!!    end program demo_w2d
!!
!!  Results:
!!
!!     Given Monday 29 December 2008 is written "2009-W01-1"
!!     GIVEN:
!!     ISO-8601 year    2009
!!     ISO-8601 week    1
!!     ISO-8601 weekday 1
!!     RESULT:
!!        DAT array        2008,12,29,-240,0,0,0,0
!!         Monday, December 29th, 2008 12:00:00 AM UTC-04:00
!!     =========================================================
!!     Given Sunday 3 January 2010 is written "2009-W53-7"
!!     GIVEN:
!!     ISO-8601 year    2009
!!     ISO-8601 week    53
!!     ISO-8601 weekday 7
!!     RESULT:
!!        DAT array        2010,1,3,-240,0,0,0,0
!!         Sunday, January 3rd, 2010 12:00:00 AM UTC-04:00
!!     =========================================================
!!     Given the Gregorian date Sun 31 December 2006 is written 2006-W52-7
!!     GIVEN:
!!     ISO-8601 year    2006
!!     ISO-8601 week    52
!!     ISO-8601 weekday 7
!!     RESULT:
!!        DAT array        2006,12,31,-240,0,0,0,0
!!         Sunday, December 31st, 2006 12:00:00 AM UTC-04:00
!!     =========================================================
!!     Given 27 September 2008 is 2008-W39-6
!!     GIVEN:
!!     ISO-8601 year    2008
!!     ISO-8601 week    39
!!     ISO-8601 weekday 6
!!     RESULT:
!!        DAT array        2008,9,27,-240,0,0,0,0
!!         Saturday, September 27th, 2008 12:00:00 AM UTC-04:00
!!     =========================================================
!!
!!##DEFINITION
!!   The ISO-8601 date and time standard was issued by the International
!!   Organization for Standardization (ISO). It is used (mainly) in
!!   government and business for fiscal years, as well as in timekeeping.
!!   The system specifies a week year atop the Gregorian calendar by
!!   defining a notation for ordinal weeks of the year.
!!
!!   An ISO week-numbering year (also called ISO year informally) has
!!   52 or 53 full weeks. That is 364 or 371 days instead of the usual
!!   365 or 366 days. The extra week is referred to here as a leap week,
!!   although ISO-8601 does not use this term. Weeks start with Monday.
!!   The first week of a year is the week that contains the first Thursday
!!   of the year (and, hence, always contains 4 January). ISO week year
!!   numbering therefore slightly deviates from the Gregorian for some
!!   days close to January 1st.
!!
!!##METHOD
!!     Calculating a date given the year, week number and weekday
!!
!!     This method requires that one know the weekday of 4 January of the
!!     year in question. Add 3 to the number of this weekday, giving a
!!     correction to be used for dates within this year.
!!
!!     Method: Multiply the week number by 7, then add the weekday. From
!!     this sum subtract the correction for the year. The result is the
!!     ordinal date, which can be converted into a calendar date. If the
!!     ordinal date thus obtained is zero or negative, the date belongs to
!!     the previous calendar year; if greater than the number of days in
!!     the year, to the following year.
!!
!!     Example: year 2008, week 39, Saturday (day 6)
!!     Correction for 2008: 5 + 3 = 8
!!     (39 x 7) + 6 = 279
!!     279 - 8 = 271
!!     Ordinal day 271 of a leap year is day 271 - 244 = 27 September
!!     Result: 27 September 2008
!!
!!##ISO_NAME
!!   Week date representations are in the format YYYY-Www ,YYYYWww,
!!   YYYY-Www-D or YYYYWwwD
!!
!!     o [YYYY] indicates the ISO week-numbering year which is slightly
!!       different from the traditional Gregorian calendar year.
!!     o [Www] is the week number prefixed by the letter W, from W01
!!       through W53.
!!     o [D] is the weekday number, from 1 through 7, beginning with Monday
!!       and ending with Sunday.
!!
!!   For example, the Gregorian date 31 December 2006 corresponds to the
!!   Sunday of the 52nd week of 2006, and is written
!!
!!     2006-W52-7 (extended form)
!!     or
!!     2006W527 (compact form).
!!
!!##REFERENCE
!!    From Wikipedia, the free encyclopedia 2016-08-08
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine w2d_numeric(iso_year,iso_week,iso_weekday,dat)

! ident_19="@(#) M_time w2d_numeric(3f) convert iso-8601 Week-numbering year date yyyy-Www-d to DAT date-time array"

integer,intent(in)  :: iso_year, iso_week, iso_weekday
integer,intent(out) :: dat(8)     ! output date array
integer             :: jan4weekday
integer             :: correction
integer             :: ordinal
integer             :: ierr
integer             :: temp_dat(8)
   temp_dat=[iso_year,1,4,0,12,0,0,0]
   call dow( temp_dat, jan4weekday, ierr=ierr) ! get day of week for January 4th where Sun=1
   correction=jan4weekday+3                      ! calculate correction
   ordinal=iso_week*7+iso_weekday-correction     ! calculate ordinal day
   dat=o2d(ordinal,iso_year)                     ! convert ordinal to DAT (routine works with negative values or days past year end)
end subroutine w2d_numeric
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine w2d_string(iso8601_week,dat,ierr)

! ident_20="@(#) or form yyyy-Www-d to DAT date-time array"

character(len=*),intent(in)   :: iso8601_week
integer                       :: iso_year, iso_week, iso_weekday
integer,intent(out)           :: dat(8)     ! output date array
integer,intent(out),optional  :: ierr
integer                       :: ierr_
integer                       :: returncode
character(len=:), allocatable :: array(:)
character(len=:), allocatable :: stopmessage

! some additional verification with verify() would be in order that of form yyyyWwwd or yyyy-Www-d

   CALL split(iso8601_week, array, delimiters=' wW-')
   ierr_=1                     ! initialize return to indicate error
   stopmessage="<ERROR>*w2d_string*: string not of format yyyy-Www-dd:"//iso8601_week
   dat=-99999

   if(size(array)==2)then       ! assume compact form of yyyyWwwdd where ww is from 01 to 53 and rearrange to three strings
      if(len_trim(array(2)) > 2)then
         array=[character(len=len(array)) :: array(1),array(2)(1:2),array(2)(3:)]
      elseif(len_trim(array(2)) == 2) then
         array=[character(len=len(array)) :: array(1),array(2),'1']
      endif
   endif

   if(size(array)==3)then  ! assume yyyy-Www-d
      ierr_=0

      iso_year=nint(s2v(array(1),returncode))
      ierr_=ierr_+abs(returncode)

      iso_week=nint(s2v(array(2),returncode))
      ierr_=ierr_+abs(returncode)
      if(iso_week < 1 .or. iso_week > 53 ) then
         stopmessage="<ERROR>*w2d_string*: week out of bounds {1-53} :"//iso8601_week
         ierr_=ierr_+abs(returncode)
      endif

      iso_weekday=nint(s2v(array(3),returncode))
      ierr_=ierr_+abs(returncode)
      if(iso_weekday < 1 .or. iso_weekday > 7) then
         stopmessage="<ERROR>*w2d_string*: day of week out of bounds {1-7} :"//iso8601_week
         ierr_=ierr_+1
      endif

   endif
   if(ierr_ == 0)then
      call w2d_numeric(iso_year,iso_week,iso_weekday,dat)
   endif

   if(present(ierr))then
      ierr=ierr_
   elseif(ierr_ /= 0)then
      write(stderr,'(a)') stopmessage
      stop 4
   endif

end subroutine w2d_string
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    box_month(3f) - [M_time:DATE_PRINTING] create specified month in a
!!    character array
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine box_month(dat,calen)
!!
!!     integer,intent(in) :: dat(8)
!!     character(len=21)  :: calen(8)
!!
!!##DESCRIPTION
!!   box_month(3f) uses a year and month from a date array to populate
!!   a small character array with a calendar representing the month.
!!
!!##OPTIONS
!!    dat  "DAT" array (an integer array of the same format as
!!          the array returned by the intrinsic DATE_AND_TIME(3f))
!!          describing the date to be used to specify what calendar
!!          month to produce.
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!##RETURNS
!!    calen  returned character array holding a display of the
!!           specified month
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_box_month
!!     use M_time, only : box_month
!!     implicit none
!!     integer           :: dat(8)
!!     character(len=21) :: calendar(8)
!!        call date_and_time(values=dat)
!!        call box_month(dat,calendar)
!!        write(*,'(a)')calendar
!!     end program demo_box_month
!!
!!    results:
!!
!!      >     July 2016
!!      >Mo Tu We Th Fr Sa Su
!!      >             1  2  3
!!      > 4  5  6  7  8  9 10
!!      >11 12 13 14 15 16 17
!!      >18 19 20 21 22 23 24
!!      >25 26 27 28 29 30 31
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
subroutine box_month(dat,calen)

! ident_21="@(#) M_time box_month(3f) generate month specified by DAT date-time array in character array"

integer,parameter    :: wklen=3*7
!-----------------------------------------------------------------------------------------------------------------------------------
! uses year and month from date array DAT to populate a small character array with a calendar representing the month
integer,intent(in)   :: dat(8)
character(len=wklen) :: calen(8)
!-----------------------------------------------------------------------------------------------------------------------------------
real(kind=realtime)  :: julian
integer              :: weekday
integer              :: dat_1st(8)
integer              :: dat_nextday(8)
integer              :: location,ierr,i
!-----------------------------------------------------------------------------------------------------------------------------------
   calen(:)='                    '                                 ! initialize output array to spaces
   dat_1st=[dat(1),dat(2),1,dat(4),0,0,0,0]                        ! create date array for first day in month specified
   call dow(dat_1st, weekday, ierr=ierr)                           ! return the day of the week for first of month
!-----------------------------------------------------------------------------------------------------------------------------------
   calen(1)=adjustc(v2mo(dat(2))//' '//v2s(dat(1)),len(calen(1)))  ! build first line with month and year centered
   calen(2)='Mo Tu We Th Fr Sa Su'                                 ! build second line with days of week
!-----------------------------------------------------------------------------------------------------------------------------------
   location=1+((weekday-1)*3)                                      ! if data were one row where would 3-character day value start?
   call date_to_julian(dat_1st,julian,ierr)                        ! get Julian Date for 1st day of month
   MNTH: do i=1,31                                                 ! put dates into rest of array starting at third line
      write(calen(location/wklen+3)(mod(location,wklen):),'(i2)')i
      if(i>=28)then                                              ! is tomorrow in another month?
         call julian_to_date(julian+i,dat_nextday,ierr)
         if(dat_nextday(2)/=dat(2))then
            exit MNTH
         endif
      endif
      location=location+3
   enddo MNTH
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine box_month
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2j(3f) - [M_time:JULIAN] given DAT date-time array returns Julian Date
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function d2j(dat) result(julian)
!!
!!     integer,intent(in)  :: dat(8)
!!     real(kind=realtime) :: julian
!!
!!##DESCRIPTION
!!   Given DAT date-time array returns Julian Date
!!
!!##OPTIONS
!!    dat       Integer array holding a "DAT" array, similar in structure
!!              to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!              If not present, use current time.
!!##RETURNS
!!    julian    The Julian Date. Julian dates (abbreviated JD)
!!              are simply a continuous count of days and fractions since
!!              noon Universal Time on January 1, 4713 BC (on the Julian
!!              calendar).
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2j
!!     use M_time, only : d2j
!!     implicit none
!!     integer :: dat(8)
!!        call date_and_time(values=dat)
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        write(*,*)'Julian Date is ',d2j(dat)
!!     end program demo_d2j
!!
!!    results:
!!
!!     Today is:2016:7:19:-240:2:11:50:885
!!     Julian Date is    2457588.7582278359
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function d2j(dat) result(julian)

! ident_22="@(#) M_time d2j(3f) Given DAT date-time array returns Julian Date"

integer,intent(in),optional :: dat(8)
real(kind=realtime)         :: julian
integer                     :: ierr
integer                     :: dat_local(8)

   if(present(dat))then                      ! if dat array is present use value contained in it
      call date_to_julian(dat,julian,ierr)
   else                                      ! if dat array is not present create one containing current time
      dat_local=getnow()
      call date_to_julian(dat_local,julian,ierr)
   endif

end function d2j
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    j2d(3f) - [M_time:JULIAN] given a JD (Julian Date) returns a
!!    date-time array DAT.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function j2d(julian) result(dat)
!!
!!     real(kind=realtime),intent(in),optional :: julian
!!     integer                                 :: dat(8)
!!
!!##DESCRIPTION
!!   Converts a Julian Date to a DAT date-time array.
!!
!!##OPTIONS
!!    julian  A Julian Date (JD) is the number of days since
!!            noon (not midnight) on January 1st, 4713 BC.
!!            If not present, use current time.
!!
!!##RETURNS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_j2d
!!     use M_time, only : j2d, d2j, fmtdate, realtime
!!     implicit none
!!     integer,parameter   :: dp=kind(0.0d0)
!!     real(kind=realtime) :: today
!!     integer             :: dat(8)
!!        call date_and_time(values=dat) ! get the date using intrinsic
!!        today=d2j(dat)                  ! convert today to Julian Date
!!        write(*,*)'Today=',fmtdate(j2d(today))
!!        ! math is easy with Julian Days and Julian Dates
!!        write(*,*)'Yesterday=',fmtdate(j2d(today-1.0_dp))
!!        write(*,*)'Tomorrow=',fmtdate(j2d(today+1.0_dp))
!!     end program demo_j2d
!!
!!    results:
!!
!!     Today=Tuesday, July 19th, 2016 08:48:20 AM
!!     Yesterday=Monday, July 18th, 2016 08:48:20 AM
!!     Tomorrow=Wednesday, July 20th, 2016 08:48:20 AM
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function j2d(julian) result(dat)

! ident_23="@(#) M_time j2d(3f) Given Julian Date returns DAT date-time array"

real(kind=realtime),intent(in)   :: julian
integer                          :: dat(8)
integer                          :: ierr
   call julian_to_date(julian,dat,ierr)
end function j2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2u(3f) - [M_time:UNIX_EPOCH] given DAT date-time array returns Unix
!!    Epoch Time (UET starts at 0000 on 1 Jan. 1970, UTC)
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function d2u(dat) result(unixtime)
!!
!!       integer,intent(in),optional :: dat(8)
!!       real(kind=realtime)         :: unixtime
!!
!!##DESCRIPTION
!!   Converts a DAT date-time array to a Unix Epoch Time value. Typically
!!   mathematical operations such as sums, sorting and comparison are
!!   performed with simple UET numeric values, and then they are converted
!!   back.
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!          If not present the current time is used
!!
!!##RETURNS
!!    unixtime  The "Unix Epoch" time, or the number of seconds since 00:00:00 on
!!              January 1st, 1970, UTC.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2u
!!     use M_time, only : d2u
!!     implicit none
!!     integer           :: dat(8)
!!        call date_and_time(values=dat)
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        write(*,*)'Unix Epoch time is ',d2u(dat)
!!     end program demo_d2u
!!
!!    results:
!!
!!     Today is:2016:7:19:-240:2:0:48:561
!!     Unix Epoch time is    1468908048.5610321
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function d2u(dat) result(unixtime)

! ident_24="@(#) M_time d2u(3f) Given DAT date-time array returns Unix Epoch time"

real(kind=realtime)           :: unixtime
integer,intent(in),optional   :: dat(8)
   integer                    :: datlocal(8)
   integer                    :: ierr
   if(present(dat))then
      datlocal=dat
   else
      datlocal=getnow() ! current time is placed in array
   endif
   call date_to_unix(datlocal,unixtime,ierr)
end function d2u
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    u2d(3f) - [M_time:UNIX_EPOCH] given Unix Epoch Time returns DAT
!!    date-time array
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function u2d(unixtime) result(dat)
!!
!!     class(*),intent(in),optional      :: unixtime
!!     ! integer
!!     ! real
!!     ! real(kind=realtime)
!!
!!     integer                           :: dat(8)
!!
!!##DESCRIPTION
!!   Given Unix Epoch Time returns DAT date-time array
!!
!!##OPTIONS
!!    unixtime  The "Unix Epoch" time, or the number of seconds since
!!              00:00:00 on January 1st, 1970, UTC. If not present, use
!!              current time.
!!
!!##RETURNS
!!    dat       Integer array holding a "DAT" array, similar in structure
!!              to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_u2d
!!     use M_time, only : u2d, d2u, fmtdate, realtime
!!     implicit none
!!     integer,parameter :: dp=kind(0.0d0)
!!     real(kind=realtime) :: today
!!     integer :: dat(8)
!!        ! get the date using intrinsic
!!        call date_and_time(values=dat)
!!        ! convert today to Julian Date
!!        today=d2u(dat)
!!        write(*,*)'Today=',fmtdate(u2d(today))
!!        ! subtract day
!!        write(*,*)'Yesterday=',fmtdate(u2d(today-86400.0_dp))
!!        ! add day
!!        write(*,*)'Tomorrow=',fmtdate(u2d(today+86400.0_dp))
!!     end program demo_u2d
!!
!!    results:
!!
!!     Today=Tuesday, July 19th, 2016 11:10:08 AM
!!     Yesterday=Monday, July 18th, 2016 11:10:08 AM
!!     Tomorrow=Wednesday, July 20th, 2016 11:10:08 AM
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function u2d(unixtime) result(dat)

! ident_25="@(#) M_time u2d(3f) Given Unix Epoch Time returns DAT date-time array"

class(*),intent(in),optional   :: unixtime
integer                        :: dat(8)
real(kind=realtime)            :: local_unixtime
integer                        :: ierr

   if(present(unixtime))then
      select type(unixtime)
      type is (integer);             local_unixtime=unixtime
      type is (integer(kind=int64)); local_unixtime=unixtime
      type is (real);                local_unixtime=unixtime
      type is (real(kind=realtime)); local_unixtime=unixtime
      end select
      call unix_to_date(local_unixtime,dat,ierr)
   else
      dat=getnow() ! current time is placed in array
   endif

end function u2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    date_to_modified_julian(3f) - [M_time:MODIFIED_JULIAN] converts DAT
!!    date-time array to Modified Julian Date
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine date_to_modified_julian(dat,modified_juliandate,ierr)
!!
!!     integer,intent(in)              :: dat(8)
!!     real(kind=realtime),intent(out) :: modified_juliandate
!!     integer,intent(out)             :: ierr
!!
!!##DESCRIPTION
!!    Converts a DAT date-time array to a Modified Julian Date type. Simply
!!
!!    Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5
!!
!!    Modified Julian Date (MJD) measures days (and fractional days) since
!!    the start of 17 Nov 1858 CE in Universal Time (UTC).
!!
!!    MJD starts at midnight (00:00:00) so truncating the fractional
!!    component of MJD always gives the same Civil Calendard day whatever
!!    the time of day (unlike JD).
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!           dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!##RETURNS
!!    modified_juliandate  A Modified Julian Date (MJD) measures days
!!                         (and fractional days) since the start of 17 Nov
!!                         1858 CE in Universal Time (UTC).
!!
!!    ierr        Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!     program demo_date_to_modified_julian
!!     use M_time, only : date_to_modified_julian
!!     use M_time, only : date_to_julian, realtime
!!     implicit none
!!     integer                    :: dat(8)
!!     real(kind=realtime)        :: modified_juliandate
!!     real(kind=realtime)        :: juliandate
!!     integer                    :: ierr
!!     character(len=*),parameter :: g='(*(g0,1x))'
!!        !
!!        ! generate DAT array
!!        call date_and_time(values=dat)
!!        !
!!        ! show DAT array
!!        write(*,'("Today is:",*(i0:,":"))')dat
!!        !
!!        ! convert DAT to Julian Date
!!        call date_to_julian(dat,juliandate,ierr)
!!        write(*,g) 'Expecting:', juliandate - 2400000.5_realtime
!!        !
!!        ! convert DAT to Modified Julian Date
!!        call date_to_modified_julian(dat,modified_juliandate,ierr)
!!        write(*,g)'Modified Julian Date is ', modified_juliandate
!!
!!     end program demo_date_to_modified_julian
!!
!!   Results:
!!
!!     > Today is:2025:1:26:-300:1:5:31:721
!!     > Expecting: 60701.253839362878
!!     > Modified Julian Date is  60701.253839362878
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
subroutine date_to_modified_julian(dat,modified_julian,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
! * There is no year zero
! * Modified Julian Date must be non-negative
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_26="@(#) M_time date_to_modified_julian(3f) Converts proleptic Gregorian DAT date-time array to Modified Julian Date"

integer,intent(in)              :: dat(8)          ! array like returned by DATE_AND_TIME(3f)
real(kind=realtime),intent(out) :: modified_julian ! Modified Julian Date (non-negative)
integer,intent(out)             :: ierr            ! Error return: 0 =successful,-1=invalid year,-2=invalid month,-3=invalid day
                                                   ! -4=invalid date (29th Feb, non leap-year)
integer                    :: year, month, day, utc, hour, minute
real(kind=realtime)        :: second
real(kind=realtime)        :: julian

   year   = dat(1)                            ! Year
   month  = dat(2)                            ! Month
   day    = dat(3)                            ! Day
   utc    = dat(4)*60                         ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                            ! Hour
   minute = dat(6)                            ! Minute
   second = dat(7)-utc+dat(8)/1000.0_dp       ! Second   ; with correction for time zone and milliseconds

   modified_julian = real(-HUGE(99999),kind=real64) ! the date if an error occurs and IERR is < 0

   if(year==0 .or. year < -4713) then
      ierr=-1
      return
   endif
   ierr=0
   call date_to_julian(dat,julian,ierr)
   if(ierr.eq.0)then
      modified_julian=julian-2400000.5_realtime
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine date_to_modified_julian
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    modified_julian_to_date(3f) - [M_time:MODIFIED_JULIAN] converts a
!!    MJD(Modified Julian Date) to a DAT date-time array.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine modified_julian_to_date(modified_julian,dat,ierr)
!!
!!     real(kind=realtime),intent(in) :: modified_julian
!!     integer,intent(out)            :: dat(8)
!!     integer,intent(out)            :: ierr
!!
!!##DESCRIPTION
!! Converts a Modified Julian Date(MJD) value to a DAT date-time
!! array.
!!
!! Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5
!!
!! Modified Julian Date (MJD) measures days (and fractional days) since
!! the start of 17 Nov 1858 CE in Universal Time (UTC). Julian Date (JD)
!! measures days (and fractional days) since noon on 1 January, 4713 BCE
!! in Universal Time (UTC).
!!
!! MJD starts at midnight (00:00:00) so truncating the fractional component
!! of MJD always gives the same Civil Calendar day whatever the time of day
!! (unlike JD).
!!
!!##OPTIONS
!!    modified_julian  A Modified Julian Date (MJD) measures days
!!                     (and fractional days) since the start of 17 Nov
!!                     1858 CE in Universal Time (UTC).
!!
!!##RETURNS
!!     dat     Integer array holding a "DAT" array, similar in structure
!!             to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!    ierr      Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!     Sample program:
!!
!!      program demo_modified_julian_to_date
!!      use M_time, only : modified_julian_to_date, fmtdate, realtime
!!      implicit none
!!      integer,parameter   :: dp=kind(0.0d0)
!!      real(kind=realtime) :: modified_juliandate, tomorrow, yesterday
!!      integer             :: dat(8)
!!      integer             :: ierr
!!         ! set sample Modified Julian Date
!!         modified_juliandate=60700.503682349771_dp
!!         ! create DAT array for this date
!!         call modified_julian_to_date(modified_juliandate,dat,ierr)
!!         write(*,*)'Sample Date=',fmtdate(dat)
!!         !
!!         ! go back one day
!!         yesterday= modified_juliandate-1.0
!!         call modified_julian_to_date(yesterday,dat,ierr)
!!         write(*,*)'Day Before =',fmtdate(dat)
!!         !
!!         ! go forward one day
!!         tomorrow= modified_juliandate+1
!!         call modified_julian_to_date(tomorrow,dat,ierr)
!!         write(*,*)'Day After  =',fmtdate(dat)
!!         !
!!      end program demo_modified_julian_to_date
!!
!!     Results:
!!
!!      >  Sample Date=Saturday, January 25th, 2025 7:05:18 AM UTC-05:00
!!      >  Day Before =Friday, January 24th, 2025 7:05:18 AM UTC-05:00
!!      >  Day After  =Sunday, January 26th, 2025 7:05:18 AM UTC-05:00
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
subroutine modified_julian_to_date(modified_julian,dat,ierr)

! ident_27="@(#) M_time modified_julian_to_date(3f) Converts Modified Julian Date to DAT date-time array"

real(kind=realtime),intent(in) :: modified_julian
integer,intent(out)            :: dat(8)
integer,intent(out)            :: ierr              ! 0 for successful execution, otherwise 1
real(kind=realtime)            :: julian

   julian=modified_julian + 2400000.5_realtime
   call julian_to_date(julian,dat,ierr)

end subroutine modified_julian_to_date
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2m(3f) - [M_time:MODIFIED_JULIAN] given DAT date-time array returns
!!    Modified Julian Date
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function d2m(dat) result(julian)
!!
!!     integer,intent(in)  :: dat(8)
!!     real(kind=realtime) :: modified_julian
!!
!!##DESCRIPTION
!!   Given DAT date-time array returns Modified Julian Date
!!
!!##OPTIONS
!!    dat       Integer array holding a "DAT" array, similar in structure
!!              to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!              If not present, use current time.
!!##RETURNS
!!    modified_juliandate  A Modified Julian Date (MJD) measures days
!!                         (and fractional days) since the start of 17 Nov
!!                         1858 CE in Universal Time (UTC).
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2m
!!     use M_time, only : d2m, realtime
!!     implicit none
!!     integer :: dat(8)
!!        call date_and_time(values=dat)
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        write(*,*)'Modified Julian Date is ',d2m(dat)
!!     end program demo_d2m
!!
!!    Results:
!!
!!     >  Today is:2025:1:26:-300:1:7:49:295
!!     >  Modified Julian Date is    60701.255431655329
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
function d2m(dat) result(modified_julian)

! ident_28="@(#) M_time d2m(3f) Given DAT date-time array returns Julian Date"

integer,intent(in),optional :: dat(8)
real(kind=realtime)         :: modified_julian
integer                     :: ierr
integer                     :: dat_local(8)

   if(present(dat))then                      ! if dat array is present use value contained in it
      call date_to_modified_julian(dat,modified_julian,ierr)
   else                                      ! if dat array is not present create one containing current time
      dat_local=getnow()
      call date_to_modified_julian(dat_local,modified_julian,ierr)
   endif

end function d2m
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    m2d(3f) - [M_time:MODIFIED_JULIAN] given a MJD (Modified Julian Date)
!!    returns a date-time array DAT.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function m2d(modified_julian) result(dat)
!!
!!     real(kind=realtime),intent(in),optional :: modified_julian
!!     integer                                 :: dat(8)
!!
!!##DESCRIPTION
!!   Converts a Modified Julian Date to a DAT date-time array.
!!
!!##OPTIONS
!!    modified_juliandate  A Modified Julian Date (MJD) measures days
!!                         (and fractional days) since the start of 17 Nov
!!                         1858 CE in Universal Time (UTC).
!!                         If not present, use current time.
!!
!!##RETURNS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_m2d
!!     use M_time, only : m2d, d2m, fmtdate, realtime
!!     implicit none
!!     integer,parameter   :: dp=kind(0.0d0)
!!     real(kind=realtime) :: today
!!     integer             :: dat(8)
!!        call date_and_time(values=dat) ! get the date using intrinsic
!!        today=d2m(dat)                  ! convert today to Julian Date
!!        write(*,*)'Today=',fmtdate(m2d(today))
!!        ! math is easy with Julian Days and Julian Dates
!!        write(*,*)'Yesterday=',fmtdate(m2d(today-1.0_dp))
!!        write(*,*)'Tomorrow=',fmtdate(m2d(today+1.0_dp))
!!     end program demo_m2d
!!
!!    Results:
!!
!!     >  Today=Sunday, January 26th, 2025 1:08:25 AM UTC-05:00
!!     >  Yesterday=Saturday, January 25th, 2025 1:08:25 AM UTC-05:00
!!     >  Tomorrow=Monday, January 27th, 2025 1:08:25 AM UTC-05:00
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
function m2d(modified_julian) result(dat)

! ident_29="@(#) M_time m2d(3f) Given Modified Julian Date returns DAT date-time array"

real(kind=realtime),intent(in) :: modified_julian
integer                        :: dat(8)
integer                        :: ierr
   call modified_julian_to_date(modified_julian,dat,ierr)
end function m2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    date_to_bas(3f) - [M_time:BAS] converts DAT
!!    date-time array to Baseday and Seconds
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine date_to_bas(dat,bas,ierr)
!!
!!     integer,intent(in)        :: dat(8)
!!     type(BAStime),intent(out) :: bas
!!     integer,intent(out)       :: ierr
!!
!!##DESCRIPTION
!!    Converts a DAT date-time array to a Baseday and Seconds type.
!!
!!    In this module the BAS date and time is stored internally as a structure
!!    named BAStime, containing the number of days since the beginning of the
!!    MJD Epoch and a double representing the seconds offset from the start
!!    of this day.
!!
!!    type BAStime
!!       integer :: base_day     ! number of days since the MJD Epoch date
!!       real(kind=real64) :: secs ! seconds from start of base_day
!!    end type BAStime
!!
!!    Modified Julian Date (MJD) measures days (and fractional days) since
!!    the start of 17 Nov 1858 CE in Universal Time (UTC). Put another way
!!
!!        Modified Julian Date (MJD) = Julian Date (JD) - 2400000.5
!!
!!    This allows for storing a date at a higher precision that the other
!!    formats used by the library, although sometimes that lower precision
!!    is limited primarily by the definition (ie. the milliseconds in a DAT
!!    could be smaller units).
!!
!!    BAS (and MJD) starts at midnight (00:00:00) so truncating the
!!    fractional component of BAS always gives the same Civil Calendar day
!!    whatever the time of day (unlike JD).
!!
!!    The seconds offset may take any double-precision value, so that any
!!    date/time may be expressed in terms of an offset from the same MJD
!!    day. The seconds field thus may exceed a single day, and may also be
!!    negative. Note that in floating-point math larger numbers will have
!!    a wider spacing between representable values, possibly decreasing
!!    the precision of results.
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!           dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!##RETURNS
!!    bas         A Baseday and Seconds variable representing the date
!!                and time found in the DAT array
!!    ierr        Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!   Sample Program:
!!
!!     program demo_date_to_bas
!!     use M_time, only : date_to_bas, realtime, BAStime
!!     use M_time, only : date_to_julian
!!     implicit none
!!     integer                    :: dat(8)
!!     type(BAStime)              :: bas
!!     real(kind=realtime)        :: juliandate
!!     integer                    :: ierr
!!     character(len=*),parameter :: g='(*(g0,1x))'
!!        !
!!        write(*,g)'date_to_bas:'
!!        ! generate DAT array
!!        call date_and_time(values=dat)
!!        !
!!        ! show DAT array
!!        write(*,'("Today is:",*(i0:,":"))')dat
!!        !
!!        ! convert DAT to Julian
!!        call date_to_julian(dat,juliandate,ierr)
!!        ! show as Modified Julian Date
!!        write(*,g) 'Expecting Modified Julian Date:', &
!!        & juliandate - 2400000.5_realtime
!!        !
!!        ! convert DAT to BAS
!!        call date_to_bas(dat,bas,ierr)
!!        write(*,g)'Baseday and Seconds is ', bas
!!        write(*,g)'converted to Modified Julian Date:', &
!!        & bas%base_day +  bas%secs/86400.0d0
!!
!!     end program demo_date_to_bas
!!
!!    Results:
!!
!!     > date_to_bas:
!!     > Today is:2025:1:26:-300:1:9:0:914
!!     > Expecting Modified Julian Date: 60701.256260578521
!!     > Baseday and Seconds is  60701 22140.913984179497
!!     > converted to Modified Julian Date: 60701.256260578521
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
subroutine date_to_bas(dat,bas,ierr)
!-----------------------------------------------------------------------------------------------------------------------------------
! * There is no year zero
! * Modified Julian Date must be non-negative
!-----------------------------------------------------------------------------------------------------------------------------------

! ident_30="@(#) M_time date_to_bas(3f) Converts proleptic Gregorian DAT date-time array to Baseday and Seconds"

integer,intent(in)         :: dat(8)        ! array like returned by DATE_AND_TIME(3f)
type(BAStime),intent(out)  :: bas           ! Baseday and Seconds (non-negative)
integer,intent(out)        :: ierr          ! Error return: 0 =successful execution,-1=invalid year,-2=invalid month,-3=invalid day
                                            ! -4=invalid date (29th Feb, non leap-year)
integer                    :: year, month, day, utc, hour, minute
real(kind=realtime)        :: second
real(kind=realtime)        :: julian

   year   = dat(1)                          ! Year
   month  = dat(2)                          ! Month
   day    = dat(3)                          ! Day
   utc    = dat(4)*60                       ! Delta from UTC, convert from minutes to seconds
   hour   = dat(5)                          ! Hour
   minute = dat(6)                          ! Minute
   second = dat(7)-utc+dat(8)/1000.0_dp     ! Second   ; with correction for time zone and milliseconds

   bas = BAStime(-HUGE(99999),real(-HUGE(99999),kind=real64)) ! the date if an error occurs and IERR is < 0

   if(year==0 .or. year < -4713) then
      ierr=-1
      return
   endif
   ierr=0
   call date_to_julian(dat,julian,ierr)
   if(ierr.eq.0)then
      bas%base_day=int(julian-2400000.5_realtime)
      ! convert remaining fraction of a day to seconds
      bas%secs=mod(julian-2400000.5_realtime,1.0_realtime)*86400
   elseif(julian < 0.0_dp) then  ! Julian Day must be non-negative
      ierr=1
   else
      ierr=0
   endif
!-----------------------------------------------------------------------------------------------------------------------------------
end subroutine date_to_bas
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    bas_to_date(3f) - [M_time:BAS] converts a
!!    BAS(Baseday and Seconds) to a DAT date-time array.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine bas_to_date(bas,dat,ierr)
!!
!!     type(BAStime),intent(in) :: bas
!!     integer,intent(out)      :: dat(8)
!!     integer,intent(out)      :: ierr
!!
!!##DESCRIPTION
!! Converts a Baseday and Seconds(BAS) value to a DAT date-time
!! array.
!!
!! In this module the MJD date and time is stored internally as a structure
!! named BAStime, containing the number of days since the beginning of the
!! MJD Epoch and a double representing the seconds offset from the start
!! of this day.
!!
!!     type BAStime
!!      integer :: base_day ! number of days since the MJD Epoch date
!!      real(kind=real64) :: secs ! seconds from start of base_day
!!     end type BAStime
!!
!! A Modified Julian Date (MJD) measures days (and fractional days) since
!! the start of 17 Nov 1858 CE in Universal Time (UTC).
!!
!! A Julian Date (JD) measures days (and fractional days) since noon on 1
!! January, 4713 BCE in Universal Time (UTC).
!!
!! That is,
!!
!!     Julian Date (MJD) = Julian Date (JD) - 2400000.5
!!
!! Using a structure allows for storing a date at a higher precision
!! that other formats used by the library, although sometimes that lower
!! precision is limited primarily by the definition (ie. the milliseconds
!! in a DAT could be smaller units).
!!
!! MJD starts at midnight (00:00:00) so truncating the fractional component
!! of MJD always gives the same Civil Calendar day whatever the time of day
!! (unlike JD).
!!
!! The seconds offset may take any double-precision value, so that any
!! date/time may be expressed in terms of an offset from the same MJD
!! day. The seconds field thus may exceed a single day, and may also be
!! negative.
!!
!!##OPTIONS
!!    bas  A Baseday and Seconds (BAS) measures days
!!         since the start of 17 Nov 1858 CE in Universal Time (UTC) and
!!         contains an offset value in seconds from that base date.
!!
!!##RETURNS
!!     dat     Integer array holding a "DAT" array, similar in structure
!!             to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!               & minutes,seconds,milliseconds]
!!
!!    ierr      Error code. If 0 no error occurred.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!      program demo_bas_to_date
!!      use M_time, only : bas_to_date, fmtdate, realtime, BAStime
!!      implicit none
!!      integer,parameter          :: dp=kind(0.0d0)
!!      type(BAStime)              :: bas, tomorrow, yesterday
!!      integer                    :: dat(8)
!!      integer                    :: ierr
!!      character(len=*),parameter :: g='(*(g0,1x))'
!!         write(*,g)'bas_to_date:'
!!         ! set sample Baseday and Seconds date
!!         bas=BAStime( 60700, 0.213682349771_dp)
!!         ! create DAT array for this date
!!         call bas_to_date(bas,dat,ierr)
!!         write(*,g)'Sample Date=',fmtdate(dat)
!!         !
!!         write(*,g)'add and subtract days from base_day:'
!!         ! go back one day
!!         yesterday= BAStime(bas%base_day-1,bas%secs)
!!         call bas_to_date(yesterday,dat,ierr)
!!         write(*,g)'Day Before =',fmtdate(dat)
!!         !
!!         ! go forward one day
!!         tomorrow= BAStime(bas%base_day+1,bas%secs)
!!         call bas_to_date(tomorrow,dat,ierr)
!!         write(*,g)'Day After  =',fmtdate(dat)
!!
!!         write(*,g)'add and subtract seconds from BAS:'
!!         ! go back one day
!!         yesterday=bas-86400
!!         call bas_to_date(yesterday,dat,ierr)
!!         write(*,g)'Day Before =',fmtdate(dat)
!!         !
!!         ! go forward one day
!!         yesterday=bas+86400
!!         call bas_to_date(tomorrow,dat,ierr)
!!         write(*,g)'Day After  =',fmtdate(dat)
!!         !
!!      end program demo_bas_to_date
!!
!!    Results:
!!
!!     > bas_to_date:
!!     > Sample Date= Friday, January 24th, 2025 7:00:00 PM UTC-05:00
!!     > add and subtract days from base_day:
!!     > Day Before = Thursday, January 23rd, 2025 7:00:00 PM UTC-05:00
!!     > Day After  = Saturday, January 25th, 2025 7:00:00 PM UTC-05:00
!!     > add and subtract seconds from BAS:
!!     > Day Before = Thursday, January 23rd, 2025 7:00:00 PM UTC-05:00
!!     > Day After  = Saturday, January 25th, 2025 7:00:00 PM UTC-05:00
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
subroutine bas_to_date(bas,dat,ierr)

! ident_31="@(#) M_time bas_to_date(3f) Converts Baseday and Seconds to DAT date-time array"

type(BAStime),intent(in) :: bas               ! Baseday and Seconds
integer,intent(out)      :: dat(8)
integer,intent(out)      :: ierr              ! 0 for successful execution, otherwise 1
real(kind=realtime)      :: julian

   julian=bas%base_day+bas%secs/86400.0_realtime + 2400000.5_realtime
   call julian_to_date(julian,dat,ierr)

end subroutine bas_to_date
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    d2b(3f) - [M_time:BAS] given DAT date-time array returns Baseday
!!    and Seconds type
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function d2b(dat) result(bas)
!!
!!     integer,intent(in)  :: dat(8)
!!     type(BAStime) :: bas
!!
!!##DESCRIPTION
!!   Given DAT date-time array returns Baseday and Seconds type
!!
!!##OPTIONS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!              dat=[ year,month,day,timezone,hour,&
!!              & minutes,seconds,milliseconds]
!!
!!          If not present, use current time.
!!##RETURNS
!!    bas  A Baseday and seconds(MJD) is composed of whole days
!!         since the start of 17 Nov 1858 CE in Universal Time (UTC)
!!         and an offset in seconds from the base day.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_d2b
!!     use M_time, only : d2b, BAStime, d2j, d2m
!!     implicit none
!!     integer :: dat(8)
!!     type(BAStime) :: bas
!!     !                            Modified Julian Dates
!!     !
!!     !   To use this table, add the day-of-month to the tabulated entry.
!!     !   For example, 30 Jan 2000 = MJD 51573.
!!     ! __________________________________________________________________
!!     !  2000  2001  2002  2003  2004  2005  2006  2007  2008  2009
!!     integer,parameter :: array(1:12,2000:2009)=reshape([ &
!!      51543,51909,52274,52639,53004,53370,53735,54100,54465,54831, & ! Jan
!!      51574,51940,52305,52670,53035,53401,53766,54131,54496,54862, & ! Feb
!!      51603,51968,52333,52698,53064,53429,53794,54159,54525,54890, & ! Mar
!!      51634,51999,52364,52729,53095,53460,53825,54190,54556,54921, & ! Apr
!!      51664,52029,52394,52759,53125,53490,53855,54220,54586,54951, & ! May
!!      51695,52060,52425,52790,53156,53521,53886,54251,54617,54982, & ! Jun
!!      51725,52090,52455,52820,53186,53551,53916,54281,54647,55012, & ! Jul
!!      51756,52121,52486,52851,53217,53582,53947,54312,54678,55043, & ! Aug
!!      51787,52152,52517,52882,53248,53613,53978,54343,54709,55074, & ! Sep
!!      51817,52182,52547,52912,53278,53643,54008,54373,54739,55104, & ! Oct
!!      51848,52213,52578,52943,53309,53674,54039,54404,54770,55135, & ! Nov
!!      51878,52243,52608,52973,53339,53704,54069,54434,54800,55165],& ! Dec
!!      shape=shape(array),order=[2,1])
!!      integer :: i,j
!!        call date_and_time(values=dat)
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        bas=d2b(dat)
!!        write(*,*)'Baseday and Seconds is',bas
!!        write(*,*)'Baseday is', bas%base_day ! whole days since the MJD Epoch date
!!        write(*,*)'Seconds is', bas%secs     ! offset in seconds from start of BASE_DAY
!!        ! print any date that does not match regression test values
!!        do i=2000,2009
!!         do j=1,12
!!          !dat=[ year,month,day,timezone,hour,minutes,seconds,milliseconds]
!!          dat=[i,j,1,0,0,0,0,0]   ! first day of month
!!          bas=d2b(dat)
!!          if(array(j,i)+1.ne.bas%base_day)then
!!             write(*,*)i,j,array(j,i)+1,d2b(dat),d2m(dat),d2j(dat)-2400000.5
!!          endif
!!         enddo
!!        enddo
!!     end program demo_d2b
!! ```
!! Results:
!! ```text
!!  >  Today is:2025:3:28:-240:12:8:0:42
!!  >  Baseday and Seconds is       60762   58080.042001605034
!!  >  Baseday is       60762
!!  >  Seconds is   58080.042001605034
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
function d2b(dat) result(bas)

! ident_32="@(#) M_time d2b(3f) Given DAT date-time array returns Basedate and Seconds"

integer,intent(in),optional :: dat(8)
type(BAStime)               :: bas
integer                     :: ierr
integer                     :: dat_local(8)

   if(present(dat))then                      ! if dat array is present use value contained in it
      call date_to_bas(dat,bas,ierr)
   else                                      ! if dat array is not present create one containing current time
      dat_local=getnow()
      call date_to_bas(dat_local,bas,ierr)
   endif

end function d2b
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    b2d(3f) - [M_time:BAS] given a BAS (Baseday and Seconds)
!!    returns a date-time array DAT.
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function b2d(bas) result(dat)
!!
!!     type(BAStime),intent(in),optional :: bas
!!     integer                           :: dat(8)
!!
!!##DESCRIPTION
!!   Converts a Baseday and Seconds (BAS) to a DAT date-time array.
!!
!!##OPTIONS
!!    bas  A Baseday and seconds(MJD) is composed of whole days
!!         since the start of 17 Nov 1858 CE in Universal Time (UTC)
!!         and an offset in seconds from the base day. If not present,
!!         use current time.
!!
!!##RETURNS
!!    dat   Integer array holding a "DAT" array, similar in structure
!!          to the array returned by the intrinsic DATE_AND_TIME(3f):
!!
!!                 dat=[ year,month,day,timezone,hour,&
!!                  & minutes,seconds,milliseconds]
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_b2d
!!     use M_time, only : b2d, d2b, fmtdate, realtime, BAStime
!!     !BAStime includes operator(+), operator(-)
!!     implicit none
!!     integer,parameter :: dp=kind(0.0d0)
!!     type(BAStime)     :: today
!!     type(BAStime)     :: aday
!!     type(BAStime)     :: newday, yesterday, tomorrow
!!     integer           :: dat(8)
!!     character(len=*),parameter :: g='(*(g0,1x))'
!!
!!        write(*,g)'b2d:'
!!        call date_and_time(values=dat) ! get the date using intrinsic
!!        today=d2b(dat)                 ! convert DAT to BAS
!!        aday=BAStime(1,0.0_dp)         ! a value of one day
!!        write(*,g)'Today=',fmtdate(b2d(today))
!!
!!        write(*,g)'BAStime +- BAStime'
!!        write(*,g)'Yesterday=',fmtdate(b2d(today+BAStime(-1,0.0_dp)))
!!        write(*,g)'Tomorrow= ',fmtdate(b2d(today+BAStime(+1,0.0_dp)))
!!
!!        write(*,g)'Yesterday=',fmtdate(b2d(today+BAStime(0,-86400.0_dp)))
!!        write(*,g)'Tomorrow= ',fmtdate(b2d(today+BAStime(0,+86400.0_dp)))
!!
!!        write(*,g)'Yesterday=',fmtdate(b2d(today-aday))
!!        write(*,g)'Tomorrow= ',fmtdate(b2d(today+aday))
!!
!!        yesterday=today-aday
!!        write(*,g)'Yesterday=',fmtdate(b2d(yesterday))
!!        tomorrow=today+aday
!!        write(*,g)'Tomorrow=',fmtdate(b2d(tomorrow))
!!
!!        write(*,g)'BAStime +- value_in_seconds'
!!        write(*,g)'Yesterday=',fmtdate(b2d(today-86400))
!!        write(*,g)'Tomorrow= ',fmtdate(b2d(today+86400))
!!
!!        write(*,g)'BAStime comparisons'
!!        newday=today+(aday/2)
!!        write(*,g)'today=',today%format()
!!        write(*,g)'newday=',newday%format()
!!        call pr(today,newday)
!!        call pr(newday,today)
!!        call pr(today,today)
!!
!!        write(*,g)'BAStime compound expressions'
!!        write(*,g) (today+86400/2).eq.newday,fmtdate(b2d(newday))
!!     contains
!!        subroutine pr(left,right)
!!        type(BAStime),intent(in) :: left, right
!!        write(*,g) 'eq',left.eq.right, &
!!                   'gt',left.gt.right, &
!!                   'lt',left.lt.right, &
!!                   'ge',left.ge.right, &
!!                   'le',left.le.right, &
!!                   'ne',left.ne.right
!!        end subroutine pr
!!     end program demo_b2d
!!
!!    Results:
!!
!!     > b2d:
!!     > Today= Monday, January 27th, 2025 7:52:40 AM UTC-05:00
!!     > BAStime +- BAStime
!!     > Yesterday= Sunday, January 26th, 2025 7:52:40 AM UTC-05:00
!!     > Tomorrow=  Tuesday, January 28th, 2025 7:52:40 AM UTC-05:00
!!     > Yesterday= Sunday, January 26th, 2025 7:52:40 AM UTC-05:00
!!     > Tomorrow=  Tuesday, January 28th, 2025 7:52:40 AM UTC-05:00
!!     > Yesterday= Sunday, January 26th, 2025 7:52:40 AM UTC-05:00
!!     > Tomorrow=  Tuesday, January 28th, 2025 7:52:40 AM UTC-05:00
!!     > Yesterday= Sunday, January 26th, 2025 7:52:40 AM UTC-05:00
!!     > Tomorrow= Tuesday, January 28th, 2025 7:52:40 AM UTC-05:00
!!     > BAStime +- value_in_seconds
!!     > Yesterday= Sunday, January 26th, 2025 7:52:40 AM UTC-05:00
!!     > Tomorrow=  Tuesday, January 28th, 2025 7:52:40 AM UTC-05:00
!!     > BAStime comparisons
!!     > today= Monday, January 27th, 2025 7:52:40 AM UTC-05:00
!!     > newday= Monday, January 27th, 2025 7:52:40 PM UTC-05:00
!!     > eq F gt F lt T ge F le T ne T
!!     > eq F gt T lt F ge T le F ne T
!!     > eq T gt F lt F ge T le T ne F
!!     > BAStime compound expressions
!!     > T Monday, January 27th, 2025 7:52:40 PM UTC-05:00
!!
!!##AUTHOR
!!    John S. Urban, 2025
!!
!!##LICENSE
!!    MIT
function b2d(bas) result(dat)

! ident_33="@(#) M_time b2d(3f) Given Baseday and Seconds (BAS) returns DAT date-time array"

type(BAStime),intent(in) :: bas
integer                  :: dat(8)
integer                  :: ierr
   call bas_to_date(bas,dat,ierr)
end function b2d
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
! FUNCTIONS FOR DEFINING OVERLOADED OPERATORS

! ident_34="@(#) M_time eq(3f) compare or change derived type BAStime objects (eq lt gt le ge ne + -)"

! These functions are privately used to define the methods that TYPE(BAStime) will support
!===================================================================================================================================
impure function bas_minus(self,valuein) result (answer)

! ident_35="@(#) M_time bas_minus(3f) subtract derived type BAStime object and BAStime or number"

class(BAStime),intent(in)  :: self
class(*),intent(in)        :: valuein
type(BAStime)              :: answer
   answer=delta_MJD(self,valuein,-1)
end function bas_minus
!===================================================================================================================================
impure function bas_plus(self,valuein) result (answer)

! ident_36="@(#) M_time bas_plus(3f) add derived type BAStime object and BAStime or number"

class(BAStime),intent(in)  :: self
class(*),intent(in)        :: valuein
type(BAStime)              :: answer
   answer=delta_MJD(self,valuein,+1)
end function bas_plus
!===================================================================================================================================
impure function bas_multiply(self,valuein) result (answer)

! ident_37="@(#) M_time bas_multiply(3f) multiply derived type BAStime object and BAStime or number"

class(BAStime),intent(in)  :: self
class(*),intent(in)        :: valuein
type(BAStime)              :: mjd_in
type(BAStime)              :: answer
real(kind=dp)              :: secs1,secs2
! not sure what multiply should mean, but this could reduce accuracy

   mjd_in=anyscalar_to_mjd(valuein)
   ! assuming mjd_in is small
   secs1=86400*self%base_day+self%secs
   secs2=86400*mjd_in%base_day+mjd_in%secs
   answer=BAStime(0,secs1*secs2)
   answer=bas_reduce(answer)

end function bas_multiply
!===================================================================================================================================
impure function bas_divide(self,valuein) result (answer)

! ident_38="@(#) M_time bas_divide(3f) divide derived type BAStime object and BAStime or number"

class(BAStime),intent(in)  :: self
class(*),intent(in)        :: valuein
type(BAStime)              :: mjd_in
type(BAStime)              :: answer
real(kind=dp)              :: secs1,secs2
! not sure what divide should mean, but this could reduce accuracy

   mjd_in=anyscalar_to_mjd(valuein)
   ! assuming mjd_in is small
   secs1=86400*self%base_day+self%secs
   secs2=86400*mjd_in%base_day+mjd_in%secs
   answer=BAStime(0,secs1/secs2)
   answer=bas_reduce(answer)

end function bas_divide
!===================================================================================================================================
impure elemental function delta_MJD(self,valuein,op) result (answer)

! ident_39="@(#) M_time delta_MJD(3f) add derived type BAStime object and BAStime value"

class(BAStime),intent(in)  :: self
class(*),intent(in)        :: valuein
integer,intent(in)         :: op
type(BAStime)              :: mjdin
type(BAStime)              :: answer
real(kind=dp)              :: secs
integer                    :: idays
integer                    :: idays_in_secs

   mjdin=anyscalar_to_mjd(valuein)
   idays = self%base_day+op*mjdin%base_day
   secs = self%secs+op*mjdin%secs
   if(abs(secs).ge.86400)then
      idays_in_secs=int(secs/86400.0_dp)
      secs=secs-idays_in_secs*86400.0_dp
      idays=idays+idays_in_secs
   endif
   answer=BAStime(idays,secs)

end function delta_MJD
!===================================================================================================================================
function bas_format(self,fmt) result (string)

! ident_40="@(#) M_time bas_format(3f) convert derived type BAStime to formatted string"

class(BAStime),intent(in)             :: self
character(len=*),intent(in),optional  :: fmt
character(len=:),allocatable          :: string
   string=fmtdate(b2d(self),fmt)
end function bas_format
!===================================================================================================================================
logical function bas_eq(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   bas_eq= a%base_day == b%base_day .and. a%secs == b%secs
end function bas_eq

logical function bas_lt(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   if (a%base_day == b%base_day)then
      bas_lt = a%secs < b%secs
   else
      bas_lt = a%base_day < b%base_day
   endif
end function bas_lt

logical function bas_gt(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   if (a%base_day == b%base_day)then
      bas_gt = a%secs > b%secs
   else
      bas_gt = a%base_day > b%base_day
   endif
end function bas_gt

logical function bas_le(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   if (a%base_day == b%base_day)then
      bas_le = a%secs <= b%secs
   else
      bas_le = a%base_day <= b%base_day
   endif
end function bas_le

logical function bas_ge(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   if (a%base_day == b%base_day)then
      bas_ge = a%secs >= b%secs
   else
      bas_ge = a%base_day >= b%base_day
   endif
end function bas_ge

logical function bas_ne(self,other)
class(BAStime),intent(in)   :: self
type(BAStime),intent(in)    :: other
type(BAStime)               :: a, b
   a=bas_reduce(self)
   b=bas_reduce(other)
   if (a%base_day == b%base_day)then
      bas_ne = a%secs /= b%secs
   else
      bas_ne = a%base_day /= b%base_day
   endif
end function bas_ne
!===================================================================================================================================
function bas_reduce(self)
class(BAStime),intent(in) :: self
type(BAStime)             :: bas_reduce

! ident_41="@(#) M_time bas_reduce(3f) reduce seconds to less than one day"

   if(abs(self%secs).ge.86400)then
      bas_reduce%base_day=self%base_day+int(self%secs/86400)
      bas_reduce%secs=mod(self%secs,86400.0_real64)
   else
      bas_reduce=self
   endif
end function bas_reduce
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
impure elemental function anyscalar_to_mjd(valuein) result(mjd_out)

! ident_42="@(#) M_time anyscalar_to_mjd(3f) convert integer or real parameter of almost any intrinsc kind to BAStime"

class(*),intent(in)       :: valuein
type(BAStime)             :: mjd_out
real(kind=real64)         :: rval
   select type(valuein)
   type is (BAStime);              mjd_out=valuein
   type is (integer(kind=int8));   mjd_out=BAStime(0,real(valuein,kind=real64))
   type is (integer(kind=int16));  mjd_out=BAStime(0,real(valuein,kind=real64))
   type is (integer(kind=int32));  mjd_out=BAStime(0,real(valuein,kind=real64))
   type is (integer(kind=int64));  mjd_out=BAStime(0,real(valuein,kind=real64))
   type is (real(kind=real32));    mjd_out=BAStime(0,real(valuein,kind=real64))
   type is (real(kind=real64));    mjd_out=BAStime(0,valuein)
   type is (logical);              mjd_out=BAStime(0,merge(0.0d0,1.0d0,valuein))
   type is (character(len=*));     read(valuein,*) rval
                                   mjd_out=BAStime(0,rval)
   class default
     stop '*M_time::anyscalar_to_double: unknown type'
   end select
end function anyscalar_to_mjd
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function get_timezone() result(tz)
integer :: tz
integer :: timezone(8)
   timezone=getnow()
   tz=timezone(4)
   if(tz>0)then  ! gfortran bug on new-years
      write(stderr,gen)'<ERROR>*get_timezone*: TZ=',tz
      tz=mod(tz,1440)-1440
   endif
end function get_timezone
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    sec2days(3f) - [M_time:DURATION] convert seconds to string of form
!!    dd-hh:mm:ss
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    function sec2days(seconds,crop) result(dhms)
!!
!!     real(kind=realtime),intent(in) :: seconds
!!       or
!!     integer,intent(in)             :: seconds
!!       or
!!     real,intent(in)                :: seconds
!!       or
!!     character(len=*)               :: seconds
!!
!!     logical,intent(in),optional    :: crop
!!     character(len=:),allocatable   :: dhms
!!
!!##DESCRIPTION
!!   Given a number of seconds convert it to a string of the form
!!
!!       dd-hh:mm:ss
!!
!!   where dd is days, hh hours, mm minutes and ss seconds.
!!
!!##OPTIONS
!!    seconds    number of seconds to convert to string of form dd-hh:mm:ss. May
!!               be of type INTEGER, REAL, REAL(KIND=REALTIME), or CHARACTER.
!!
!!               CHARACTER strings may be of the form
!!               [NNd][NNh][NNm][NNs][NNw]. Case,spaces and underscores are
!!               ignored. Allowed aliases for d,h,m, and s units are
!!
!!                   d -  days,day
!!                   m -  minutes,minute,min
!!                   h -  hours,hour,hrs,hr
!!                   s -  seconds,second,sec
!!
!!               The numeric values may represent floating point numbers.
!!
!!    crop       if .true., remove leading zero day values or day and hour values.
!!               Optional, defaults to .false. .
!!##RETURNS
!!    dmhs       the returned string of form [d:h:]m:s
!!
!!##EXAMPLE
!!
!!    Sample Program:
!!
!!     program demo_sec2days
!!     use M_time, only : sec2days
!!     implicit none
!!     integer,parameter :: dp=kind(0.0d0)
!!        write(*,*)sec2days(129860)
!!        write(*,*)sec2days(80000.0_dp)
!!        write(*,*)sec2days(80000.0,crop=.true.)
!!        write(*,*)sec2days('1 day 2.0hr 100 min 300.0seconds')
!!     end program demo_sec2days
!!
!!    results:
!!
!!     1-12:04:20
!!     0-22:13:20
!!     22:13:20
!!     1-03:45:00
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function sec2days(seconds,crop) result(dhms)
use, intrinsic :: iso_fortran_env, only : int64

! ident_43="@(#) M_time sec2days(3f) converts seconds or string of form IId JJh KKm LLs to string showing days of form D-HH MM SS"

! on this platform, (select_int_kind(i),i=1,100) returns
! 1:2=1 ,3:4=2 ,5:9=4 ,10:18= 8 ,19:38=16 ,39:=-1
!integer,parameter              :: k(38)=[(selected_int_kind(i),i=1,38)]
integer                        :: i
class(*),intent(in)            :: seconds
logical,intent(in),optional    :: crop
character(len=:),allocatable   :: dhms
real(kind=realtime), parameter :: units_hl(4)=[ 86400.0_dp, 3600.0_dp, 60.0_dp, 1.0_dp ]
character(len=40)              :: scratch
integer(kind=int64)            :: days, hours, minutes, secsleft
integer,parameter              :: one_day=86400
integer,parameter              :: one_hour=3600
integer,parameter              :: one_minute=60
logical                        :: crop_local
integer                        :: iprint
logical                        :: negative
integer                        :: ilast
character(len=:),allocatable   :: strlocal
character(len=:),allocatable   :: array(:)
doubleprecision                :: dtime

   !  Convert input value to nearest integer
   !  Notice that the value SECONDS can be any of several types ( INTEGER,REAL,REAL(KIND=REALTIME))
   select type(seconds)
   type is (integer);               secsleft=seconds
   type is (real);                  secsleft=nint(seconds)
   type is (real(kind=realtime));   secsleft=nint(seconds)
   type is (character(len=*))

      ! note _ is removed from input strings to allow use of _ every three digits in a number as sometimes seen in Java, perl, ...
      strlocal=compact(lower(transliterate(seconds," _,",'')),'')//'                '   ! add whitespace to make room for spaces

      call substitute(strlocal,'days','d')                      ! from long names to short names substitute common aliases for units
      call substitute(strlocal,'day','d')
      call substitute(strlocal,'hours','h')
      call substitute(strlocal,'hour','h')
      call substitute(strlocal,'hrs','h')
      call substitute(strlocal,'hr','h')
      call substitute(strlocal,'minutes','m')
      call substitute(strlocal,'minute','m')
      call substitute(strlocal,'min','m')
      call substitute(strlocal,'''','m')
      call substitute(strlocal,'seconds','s')
      call substitute(strlocal,'second','s')
      call substitute(strlocal,'secs','s')
      call substitute(strlocal,'sec','s')
      call substitute(strlocal,'"','s')
      call substitute(strlocal,'weeks','w')
      call substitute(strlocal,'week','w')
      call substitute(strlocal,'wks','w')
      call substitute(strlocal,'wk','w')
      !do i=2,len_trim(strlocal)
      ! maybe filter out other characters obviously not part of values?
      ! if a letter not in smhdw remove but leave numeric values alone. Allow sign and e?
      ! or parse
      !enddo
      call substitute(strlocal,'s','s ')          ! assuming only one suffix character and not too many to exceed length of strlocal
      call substitute(strlocal,'m','m ')
      call substitute(strlocal,'h','h ')
      call substitute(strlocal,'d','d ')
      call substitute(strlocal,'w','w ')

      dtime=0.0_dp
      call split(strlocal,array,' ')

      do i=1,size(array)
         ilast=len_trim(array(i))
         select case(array(i)(ilast:ilast))
         case('w'); dtime=dtime+s2v(array(i)(:ilast-1))*units_hl(1)*7
         case('d'); dtime=dtime+s2v(array(i)(:ilast-1))*units_hl(1)
         case('h'); dtime=dtime+s2v(array(i)(:ilast-1))*units_hl(2)
         case('m'); dtime=dtime+s2v(array(i)(:ilast-1))*units_hl(3)
         case('s'); dtime=dtime+s2v(array(i)(:ilast-1))*units_hl(4)
         case default
            dtime=dtime+s2v(array(i))
         end select
      enddo
      secsleft=int(dtime,kind=int64)
   end select

   if(present(crop))then    ! whether to trim cases where(days=0) and (hours=0 when days=0) from output or always show dd-hh:mm:ss
      crop_local=crop
   else
      crop_local=.false.
   endif

   if(secsleft<0)then
      secsleft=-secsleft
      negative=.true.
   else
      negative=.false.
   endif

   iprint=4

   days=secsleft/one_day                  ! get whole number of days
   if(days==0) iprint=3
   secsleft=secsleft-days*one_day         ! calculate remainder

   hours=secsleft/one_hour                ! get whole number of hours
   if(days==0.and.hours==0) iprint=2
   secsleft=secsleft-hours*one_hour

   minutes=secsleft/one_minute            ! get whole number of minutes
   secsleft=secsleft-minutes*one_minute

   if(.not.crop_local)then
      iprint=4
   endif

   select case(iprint)                    ! select format if cropping is on and leading zero values are present
   case(2)
      write(scratch,'(i2.2,":",i2.2)')minutes,secsleft
   case(3)
      write(scratch,'(i2.2,":",i2.2,":",i2.2)')hours,minutes,secsleft
   case default
      write(scratch,'(i0,"-",i2.2,":",i2.2,":",i2.2)')days,hours,minutes,secsleft
   end select

   if(negative)then
      dhms='-'//trim(scratch)
   else
      dhms=trim(scratch)
   endif

end function sec2days
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    days2sec(3f) - [M_time:DURATION] convert string of form
!!    [[-]dd-]hh:mm:ss.nn or dNNhNNmNNsNN to seconds
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    elemental impure function days2sec(str) result(time)
!!
!!     character(len=*),intent(in) :: str
!!     real(kind=realtime)         :: time
!!
!!##DESCRIPTION
!!   Given a string representing a duration of the form
!!   [-][[[dd-]hh:]mm:]ss or [NNd][NNh][NNm[]NNs][NNw]
!!   return a value representing seconds.
!!
!!   If "dd-" is present, units for the numbers are assumed to
!!   proceed from day to hour to minute to second. But if no
!!   day is present, the units are assumed to proceed from second
!!   to minutes to hour from left to right. That is ...
!!
!!         [-]dd-hh:mm:ss
!!         [-]dd-hh:mm
!!         [-]dd-hh
!!
!!         hh:mm:ss
!!         mm:ss
!!         ss
!!
!!         Where dd is days, hh hours, mm minutes and ss seconds.
!!
!!   A decimal fraction is supported on the seconds (Actually,
!!   any of the numeric values may represent positive floating
!!   point numbers). Spaces are ignored.
!!
!!   Simple numeric values may also be used with unit suffixes; where
!!   s,m,h, or d represents seconds, minutes, hours or days and w
!!   represents a week. Allowed aliases for w,d,h,m, and s units are
!!
!!        [NNd][NNh][NNm][NNs][NNw]
!!
!!          d   -  days,day
!!          h   -  hours,hour,hr,hrs
!!          m,' -  minutes,minute,min,mins
!!          s," -  seconds,second,sec,secs
!!          w   -  week, weeks, wk, wks
!!
!!   The numeric values may represent floating point numbers.
!!
!!   Spaces, commas and case are ignored.
!!
!!##OPTIONS
!!       str   string of the general form dd-hh:mm:ss.nn
!!             or [NNd][NNh][NNm][NNs][NNw]
!!##RETURNS
!!       time  the number of seconds represented by the input string
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_days2sec
!!     use M_time, only : days2sec
!!     implicit none
!!        write(*,*)days2sec('1-12:04:20')
!!        write(*,*)'one second ',days2sec('1')
!!        write(*,*)'one minute ',days2sec('1:00')
!!        write(*,*)'one hour ',days2sec('1:00:00')
!!        write(*,*)'one day ',days2sec('1-00:00:00')
!!        write(*,*)nint(days2sec(' 1-12:04:20              ')) == 129860
!!        write(*,*)nint(days2sec(' 1.5 days                ')) == 129600
!!        write(*,*)nint(days2sec(' 1.5 days 4hrs 30minutes ')) == 145800
!!        write(*,*)nint(days2sec(' 1.5d                    ')) == 129600
!!        write(*,*)nint(days2sec(' 1d2h3m4s                ')) == 93784
!!        ! duplicates
!!        write(*,*)nint(days2sec(' 1d1d1d                  ')) == 259200
!!        ! negative values
!!        write(*,*)nint(days2sec(' 4d-12h                  ')) == 302400
!!     end program demo_days2sec
!!
!!    Results:
!!
!!     > 129860.00000000000
!!     > one second    1.0000000000000000
!!     > one minute    60.000000000000000
!!     > one hour    3600.0000000000000
!!     > one day    86400.000000000000
!!     > T
!!     > T
!!     > T
!!     > T
!!     > T
!!     > T
!!     > T
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
elemental impure function days2sec(str) result(time)

! ident_44="@(#) M_time days2sec(3f) convert string [[-]dd-]hh mm ss.nn to seconds or string IId JJh KKm LLs to seconds"

character(len=*),intent(in)    :: str
real(kind=realtime)            :: time
! Supported input syntax:
!    [-]dd-hh:mm:ss
!          hh:mm:ss
!          mm:ss
!          ss
!
character(len=:),allocatable   :: strlocal
character(len=:),allocatable   :: array(:)
real(kind=realtime), parameter :: units_lh(4)=[ 1.0_dp, 60.0_dp, 3600.0_dp, 86400.0_dp ]
real(kind=realtime), parameter :: units_hl(4)=[ 86400.0_dp, 3600.0_dp, 60.0_dp, 1.0_dp ]
integer                        :: i, icount, iwords, ilast
logical                        :: negative

   time=0.0_dp
   strlocal=compact(str,'')                             ! remove whitespace
   time=0.0_dp
   strlocal=transliterate(strlocal,"_,",'')             ! remove underscores and commas sometimes used in numbers
   strlocal=lower(strlocal)//repeat(' ',len(strlocal))  ! change to lowercase and add whitespace to make room for spaces

   if(len(strlocal)==0)then
      time=0.0_dp
   elseif(scan(strlocal,'wdshm"''')/=0)then             ! unit code values not DD-HH:MM:SS either plain number or unit numbers
      call substitute(strlocal,'days','d')              ! from long names to short names substitute common aliases for units
      call substitute(strlocal,'day','d')
      call substitute(strlocal,'hours','h')
      call substitute(strlocal,'hour','h')
      call substitute(strlocal,'hrs','h')
      call substitute(strlocal,'hr','h')
      call substitute(strlocal,'minutes','m')
      call substitute(strlocal,'minute','m')
      call substitute(strlocal,'mins','m')
      call substitute(strlocal,'min','m')
      call substitute(strlocal,'''','m')
      call substitute(strlocal,'seconds','s')
      call substitute(strlocal,'second','s')
      call substitute(strlocal,'secs','s')
      call substitute(strlocal,'sec','s')
      call substitute(strlocal,'"','s')
      call substitute(strlocal,'weeks','w')
      call substitute(strlocal,'week','w')
      call substitute(strlocal,'wks','w')
      call substitute(strlocal,'wk','w')

      call substitute(strlocal,'s','s ')          ! assuming only one suffix character and not too many to exceed length of strlocal
      call substitute(strlocal,'m','m ')
      call substitute(strlocal,'h','h ')
      call substitute(strlocal,'d','d ')
      call substitute(strlocal,'w','w ')
      call split(strlocal,array,' ')
      iwords=size(array)
      icount=0
      do i=iwords,1,-1
         icount=icount+1
         ilast=len_trim(array(i))
         select case(array(i)(ilast:ilast))
         case('w'); time=time+s2v(array(i)(:ilast-1))*units_hl(1)*7
         case('d'); time=time+s2v(array(i)(:ilast-1))*units_hl(1)
         case('h'); time=time+s2v(array(i)(:ilast-1))*units_hl(2)
         case('m'); time=time+s2v(array(i)(:ilast-1))*units_hl(3)
         case('s'); time=time+s2v(array(i)(:ilast-1))*units_hl(4)
         case default
            time=time+s2v(array(i))
         end select
      enddo
   else

      if(strlocal(1:1)=='-')then          ! allow negative prefix as first character but remove it and change sign of value at end
         negative=.true.
         strlocal(1:1)=' '
      else
         negative=.false.
      endif

      call split(trim(strlocal),array,' -:')
      iwords=size(array)

      if(iwords>4)then
         write(stderr,gen)'<ERROR>*days2sec*: too many values in',trim(strlocal)
         iwords=4
      endif

      if(index(strlocal,'-')>0)then                ! found a dash, assume has days and form DD-HH:MM:SS, DD-, DD-HH, DD-HH:MM
         do i=1,iwords
            time=time+s2v(array(i))*units_hl(i)
         enddo
      else                                            ! no dash, assume no days, either HH:MM:SS or MM:SS, SS
         icount=0
         do i=iwords,1,-1
            icount=icount+1
            ilast=len_trim(array(i))
            time=time+s2v(array(i))*units_lh(icount)
         enddo
      endif

      if(negative)time=-time

   endif

end function days2sec
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!! locale(3f) - [M_time:DATE_PRINTING] allow for selecting languages to represent
!!              month and weekday names
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!    subroutine locale(name,month_names,weekday_names, &
!!    & month_names_abbr,weekday_names_abbr,IERR)
!!
!!     character(len=*),intent(in)          :: name
!!     character(len=*),intent(in),optional :: month_names(12)
!!     character(len=*),intent(in),optional :: month_names_abbr(12)
!!     character(len=*),intent(in),optional :: weekday_names(7)
!!     character(len=*),intent(in),optional :: weekday_names_abbr(7)
!!     integer,intent(out)                  :: ierr
!!
!!##DESCRIPTION
!!   given a pre-defined locale name or strings to substitute for month names
!!   and weekday names provide some basic support for non-POSIX labels in
!!   date representation.
!!
!!   The parameters are default character types and so may be limited to the
!!   basic ASCII character set, but are typically limited to the extended
!!   ASCII set.
!!
!!   This is only a basic attempt to support internationalization and
!!   currently just supports basic substitution of the default POSIX names
!!   with the alternate strings. As support for UTF-8 grows among Fortran
!!   compilers something more robust will hopefully emerge to provide full
!!   internationalization of the date representations.
!!
!!##OPTIONS
!!   name   predefined name or reserved name "user"
!!
!!   month_names        12 month names
!!   weekday_names       7 weekday names
!!   month_names_abbr   12 month name abbreviations
!!   weekday_names_abbr  7 weekday name abbreviations
!!
!!   ierr               if non-zero an error occurred
!!
!! The NAME parameter may be a pre-defined name or the special name "user".
!! The current pre-defined names are
!!
!!    'bokmal','catalan','czech','dansk'/'danish','deutsch'/'german','dutch',
!!    'eesti'/'estonian','english','finnish','french','galego'/'galician',
!!    'hrvatski'/'croation','hungarian','icelandic','italian','korean',
!!    'lithuanian','norwegian','nynorsk','polish','portuguese','romanian',
!!    'slovak','slovene'/'slovenian','spanish','swedish','turkish'
!!
!! These non-ISO-8859 character sets are defined in terms of ISO-8859 but will
!! not work on most platforms
!!
!!    'greek', 'russian','thai', 'hebrew','japanese'
!!
!! The remaining reserved names take special actions
!!
!!    o POSIX            load POSIX names
!!    o LANGUAGE         use value of environment variable LANGUAGE
!!    o user             placeholder indicating to expect at least one of the
!!                       optional values to be set
!!    o reset,ISO-8601   reset back to initial defaults
!!
!!    o show    print user-defined values to stdout
!!    o chars   dump characters from chars([(i,i=0,255)])
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_locale
!!     use M_time, only : locale, now
!!     implicit none
!!        call locale('POSIX')
!!        write(*,*)now()
!!        call locale('french')
!!        write(*,*)now()
!!        call mine()
!!        write(*,*)now()
!!     contains
!!     subroutine mine()
!!     character(len=*),parameter :: months(12)=[ character(len=9) :: &
!!     &'JANUARY','FEBRUARY','MARCH    ','APRIL  ','MAY     ','JUNE    ', &
!!     &'JULY   ','AUGUST  ','SEPTEMBER','OCTOBER','NOVEMBER','DECEMBER']
!!     character(len=*),parameter :: weekdays(7)=[character(len=9) :: &
!!     &'MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY','SUNDAY']
!!     character(len=3),parameter :: short_months(12)=months(:)(1:3)
!!     character(len=3),parameter :: short_weekdays(7)=weekdays(:)(1:3)
!!     integer :: ierr
!!       call locale('user',months,short_months,weekdays,short_weekdays,ierr)
!!     end subroutine mine
!!     end program demo_locale
!!
!!    Results:
!!
!!     Sunday, September 29th, 2024 7:55:00 PM UTC-04:00
!!     dimanche, septembre 29th, 2024 7:55:00 PM UTC-04:00
!!     JUL, SEPTEMBER 29th, 2024 7:55:00 PM UTC-04:00
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
subroutine locale(name,month_names,weekday_names,month_names_abbr,weekday_names_abbr,IERR)
character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: month_names(12)
character(len=*),intent(in),optional :: month_names_abbr(12)
character(len=*),intent(in),optional :: weekday_names(7)
character(len=*),intent(in),optional :: weekday_names_abbr(7)
integer,intent(out),optional         :: ierr
integer                              :: i
character(len=:),allocatable         :: name_
   name_=lower(name)
   if(name_.eq.'language')then
      name_=lower(get_env('LANGUAGE',''))
   endif
   select case(name_)
   case('posix','english','en_us');      call  locale_POSIX()
   case('deutsch','german','de_de');     call  locale_deutsch()
   case('slovak');               call  locale_slovak()
   case('czech');                call  locale_czech()
   case('spanish');              call  locale_spanish()
   case('slovene','slovenian');  call  locale_slovene()
   case('dansk','danish');       call  locale_dansk()
   case('galego','galician');    call  locale_galego()
   case('eesti','estonian');     call  locale_eesti()
   case('hrvatski','croation');  call  locale_hrvatski()
   case('dutch');                call  locale_dutch()
   case('finnish');              call  locale_finnish()
   case('icelandic');            call  locale_icelandic()
   case('hungarian');            call  locale_hungarian()
   case('swedish');              call  locale_swedish()
   case('korean');               call  locale_korean()
   case('nynorsk');              call  locale_nynorsk()
   case('turkish');              call  locale_turkish()
   case('romanian');             call  locale_romanian()
   case('portuguese');           call  locale_portuguese()
   case('polish');               call  locale_polish()
   case('lithuanian');           call  locale_lithuanian()
   case('catalan');              call  locale_catalan()
   case('italian');              call  locale_italian()
   case('french','fr_fr');               call  locale_french()
   case('bokmal');               call  locale_bokmal()
   case('norwegian');            call  locale_norwegian()

   case('greek');                call  locale_greek()
   case('russian');              call  locale_russian()
   case('thai');                 call  locale_thai()
   case('hebrew');               call  locale_hebrew()
   case('japanese');             call  locale_japanese()

   case('iso-8601')
      M_time_month_names=G_month_names
      M_time_month_names_abbr=G_month_names_abbr
      M_time_weekday_names=G_weekday_names
      M_time_weekday_names_abbr=G_weekday_names_abbr
   case('reset')
      if(allocated( M_time_month_names))        deallocate(M_time_month_names)
      if(allocated( M_time_month_names_abbr))   deallocate(M_time_month_names_abbr)
      if(allocated( M_time_weekday_names))      deallocate(M_time_weekday_names)
      if(allocated( M_time_weekday_names_abbr)) deallocate(M_time_weekday_names_abbr)
   case('user','')
   case('chars')
      do i=0,255
         write(stdout,gen)i,char(i)
      enddo
   case('show')
      call printit('Month Names',               M_time_month_names )
      call printit('Month Names abbreviated',   M_time_month_names_abbr )
      call printit('Weekday Names',             M_time_weekday_names )
      call printit('Weekday Names abbreviated', M_time_weekday_names_abbr )
   end select

   if(present( month_names        )) M_time_month_names        = month_names
   if(present( month_names_abbr   )) M_time_month_names_abbr   = month_names_abbr
   if(present( weekday_names      )) M_time_weekday_names      = weekday_names
   if(present( weekday_names_abbr )) M_time_weekday_names_abbr = weekday_names_abbr

   if(present(ierr))  then
      ierr=0
   endif
contains

subroutine printit(header,strs)
character(len=*),parameter              :: fmt="(*('""',g0,'""':,','))"
character(len=*),intent(in)             :: header
character(len=:),allocatable,intent(in) :: strs(:)
integer                                 :: i
   if(allocated(strs))then
      write(stdout,fmt)header,(trim(strs(i)),i=1,size(strs))
   else
      select case(header)
      case('Month Names')
         if(allocated(M_time_month_names))then
            write(stdout,fmt) header,(trim(M_time_month_names(i)),i=1,size(M_time_month_names))
         else
            write(stdout,fmt) header,(trim(G_month_names(i)),i=1,size(G_month_names)),"POSIX"
         endif
      case('Month Names abbreviated')
         if(allocated(M_time_month_names_abbr))then
            write(stdout,fmt) header,(trim(M_time_month_names_abbr(i)),i=1,size(M_time_month_names_abbr))
         else
            write(stdout,fmt) header,(trim(G_month_names_abbr(i)),i=1,size(G_month_names_abbr)),"POSIX"
         endif
      case('Weekday Names')
         if(allocated(M_time_weekday_names))then
            write(stdout,fmt) header,(trim(M_time_weekday_names(i)),i=1,size(M_time_weekday_names))
         else
            write(stdout,fmt) header,(trim(G_weekday_names(i)),i=1,size(G_weekday_names)),"POSIX"
         endif
      case('Weekday Names abbreviated')
         if(allocated(M_time_weekday_names_abbr))then
            write(stdout,fmt) header,(trim(M_time_weekday_names_abbr(i)),i=1,size(M_time_weekday_names_abbr))
         else
            write(stdout,fmt) header,(trim(G_weekday_names_abbr(i)),i=1,size(G_weekday_names_abbr)),"POSIX"
         endif
      end select
   endif
end subroutine printit

end subroutine locale
!!----------------------------------------------------------------------------------------------------------------------------------
!include "locale.ffinc"
subroutine locale_deutsch()
! LANG=deutsch
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "Mo","Di","Mi","Do","Fr","Sa","So"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag","Sonntag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "Jan","Feb","Mrz","Apr","Mai","Jun", &
& "Jul","Aug","Sep","Okt","Nov","Dez" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "Januar","Februar","Mrz","April","Mai","Juni", &
& "Juli","August","September","Oktober","November","Dezember" ]
 ! ASCII weekdays
months(3)(2:2)=char(228)
 ! ASCII weekdays_abbr
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_deutsch

subroutine locale_slovak()
! LANG=slovak
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "po","ut","st","t","pi","so","ne"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "pondelok","utorok","streda","tvrtok","piatok","sobota","nedea"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","mj","jn", &
& "jl","aug","sep","okt","nov","dec" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "janur","februr","marec","aprl","mj","jn", &
& "jl","august","september","oktber","november","december" ]
weekdays(4)(1:1)=char(185)
weekdays(7)(5:5)=char(181)
months(1)(5:5)=char(225)
months(2)(6:6)=char(225)
months(4)(4:4)=char(237)
months(5)(2:2)=char(225)
months(6)(2:2)=char(250)
months(7)(2:2)=char(250)
months(10)(4:4)=char(243)
weekdays_abbr(4)(1:1)=char(185)
months_abbr(5)(2:2)=char(225)
months_abbr(6)(2:2)=char(250)
months_abbr(7)(2:2)=char(250)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_slovak

subroutine locale_czech()
! LANG=czech
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "po","t","st","t","p","so","ne"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "pondl","ter","steda","tvrtek","ptek","sobota","nedle"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "led","no","be","dub","kv","vn", &
& "vc","srp","z","j","lis","pro" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "leden","nor","bezen","duben","kvten","erven", &
& "ervenec","srpen","z","jen","listopad","prosinec" ]
weekdays(1)(5:5)=char(236)
weekdays(1)(7:7)=char(237)
weekdays(2)(1:1)=char(250)
weekdays(2)(5:5)=char(253)
weekdays(3)(3:3)=char(248)
weekdays(4)(1:1)=char(232)
weekdays(5)(2:2)=char(225)
weekdays(7)(4:4)=char(236)
months(2)(1:1)=char(250)
months(3)(2:2)=char(248)
months(5)(3:3)=char(236)
months(6)(1:1)=char(232)
months(7)(1:1)=char(232)
months(9)(2:2)=char(225)
months(9)(3:3)=char(248)
months(9)(4:4)=char(237)
months(10)(1:1)=char(248)
months(10)(2:2)=char(237)
weekdays_abbr(2)(1:1)=char(250)
weekdays_abbr(4)(1:1)=char(232)
weekdays_abbr(5)(2:2)=char(225)
months_abbr(2)(1:1)=char(250)
months_abbr(3)(2:2)=char(248)
months_abbr(5)(3:3)=char(236)
months_abbr(6)(1:1)=char(232)
months_abbr(7)(1:1)=char(232)
months_abbr(9)(2:2)=char(225)
months_abbr(9)(3:3)=char(248)
months_abbr(10)(1:1)=char(248)
months_abbr(10)(2:2)=char(237)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_czech

subroutine locale_catalan()
! LANG=catalan
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "dl.","dt.","dc.","dj.","dv.","ds.","dg."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "dilluns","dimarts","dimecres","dijous","divendres","dissabte","diumenge"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "gen.","febr.","mar","abr.","maig","juny", &
& "jul.","ag.","set.","oct.","nov.","des." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "gener","febrer","mar","abril","maig","juny", &
& "juliol","agost","setembre","octubre","novembre","desembre" ]
 ! ASCII weekdays
months(3)(4:4)=char(231)
 ! ASCII weekdays_abbr
months_abbr(3)(4:4)=char(231)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_catalan

subroutine locale_spanish()
! LANG=spanish
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "lu.","ma.","mi.","ju.","vi.","s.","do."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "lunes","martes","mircoles","jueves","viernes","sbado","domingo"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "ene.","feb.","mar.","abr.","may.","jun.", &
& "jul.","ago.","sep.","oct.","nov.","dic." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "enero","febrero","marzo","abril","mayo","junio", &
& "julio","agosto","septiembre","octubre","noviembre","diciembre" ]
weekdays(3)(3:3)=char(233)
weekdays(6)(2:2)=char(225)
 ! ASCII months
weekdays_abbr(6)(2:2)=char(225)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_spanish

subroutine locale_russian()
! LANG=russian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
weekdays(1)(1:1)=char(223)
weekdays(1)(2:2)=char(222)
weekdays(1)(3:3)=char(221)
weekdays(1)(4:4)=char(213)
weekdays(1)(5:5)=char(212)
weekdays(1)(6:6)=char(213)
weekdays(1)(7:7)=char(219)
weekdays(1)(8:8)=char(236)
weekdays(1)(9:9)=char(221)
weekdays(1)(10:10)=char(216)
weekdays(1)(11:11)=char(218)
weekdays(2)(1:1)=char(210)
weekdays(2)(2:2)=char(226)
weekdays(2)(3:3)=char(222)
weekdays(2)(4:4)=char(224)
weekdays(2)(5:5)=char(221)
weekdays(2)(6:6)=char(216)
weekdays(2)(7:7)=char(218)
weekdays(3)(1:1)=char(225)
weekdays(3)(2:2)=char(224)
weekdays(3)(3:3)=char(213)
weekdays(3)(4:4)=char(212)
weekdays(3)(5:5)=char(208)
weekdays(4)(1:1)=char(231)
weekdays(4)(2:2)=char(213)
weekdays(4)(3:3)=char(226)
weekdays(4)(4:4)=char(210)
weekdays(4)(5:5)=char(213)
weekdays(4)(6:6)=char(224)
weekdays(4)(7:7)=char(211)
weekdays(5)(1:1)=char(223)
weekdays(5)(2:2)=char(239)
weekdays(5)(3:3)=char(226)
weekdays(5)(4:4)=char(221)
weekdays(5)(5:5)=char(216)
weekdays(5)(6:6)=char(230)
weekdays(5)(7:7)=char(208)
weekdays(6)(1:1)=char(225)
weekdays(6)(2:2)=char(227)
weekdays(6)(3:3)=char(209)
weekdays(6)(4:4)=char(209)
weekdays(6)(5:5)=char(222)
weekdays(6)(6:6)=char(226)
weekdays(6)(7:7)=char(208)
weekdays(7)(1:1)=char(210)
weekdays(7)(2:2)=char(222)
weekdays(7)(3:3)=char(225)
weekdays(7)(4:4)=char(218)
weekdays(7)(5:5)=char(224)
weekdays(7)(6:6)=char(213)
weekdays(7)(7:7)=char(225)
weekdays(7)(8:8)=char(213)
weekdays(7)(9:9)=char(221)
weekdays(7)(10:10)=char(236)
weekdays(7)(11:11)=char(213)
months(1)(1:1)=char(207)
months(1)(2:2)=char(221)
months(1)(3:3)=char(210)
months(1)(4:4)=char(208)
months(1)(5:5)=char(224)
months(1)(6:6)=char(236)
months(2)(1:1)=char(196)
months(2)(2:2)=char(213)
months(2)(3:3)=char(210)
months(2)(4:4)=char(224)
months(2)(5:5)=char(208)
months(2)(6:6)=char(219)
months(2)(7:7)=char(236)
months(3)(1:1)=char(188)
months(3)(2:2)=char(208)
months(3)(3:3)=char(224)
months(3)(4:4)=char(226)
months(4)(1:1)=char(176)
months(4)(2:2)=char(223)
months(4)(3:3)=char(224)
months(4)(4:4)=char(213)
months(4)(5:5)=char(219)
months(4)(6:6)=char(236)
months(5)(1:1)=char(188)
months(5)(2:2)=char(208)
months(5)(3:3)=char(217)
months(6)(1:1)=char(184)
months(6)(2:2)=char(238)
months(6)(3:3)=char(221)
months(6)(4:4)=char(236)
months(7)(1:1)=char(184)
months(7)(2:2)=char(238)
months(7)(3:3)=char(219)
months(7)(4:4)=char(236)
months(8)(1:1)=char(176)
months(8)(2:2)=char(210)
months(8)(3:3)=char(211)
months(8)(4:4)=char(227)
months(8)(5:5)=char(225)
months(8)(6:6)=char(226)
months(9)(1:1)=char(193)
months(9)(2:2)=char(213)
months(9)(3:3)=char(221)
months(9)(4:4)=char(226)
months(9)(5:5)=char(239)
months(9)(6:6)=char(209)
months(9)(7:7)=char(224)
months(9)(8:8)=char(236)
months(10)(1:1)=char(190)
months(10)(2:2)=char(218)
months(10)(3:3)=char(226)
months(10)(4:4)=char(239)
months(10)(5:5)=char(209)
months(10)(6:6)=char(224)
months(10)(7:7)=char(236)
months(11)(1:1)=char(189)
months(11)(2:2)=char(222)
months(11)(3:3)=char(239)
months(11)(4:4)=char(209)
months(11)(5:5)=char(224)
months(11)(6:6)=char(236)
months(12)(1:1)=char(180)
months(12)(2:2)=char(213)
months(12)(3:3)=char(218)
months(12)(4:4)=char(208)
months(12)(5:5)=char(209)
months(12)(6:6)=char(224)
months(12)(7:7)=char(236)
weekdays_abbr(1)(1:1)=char(191)
weekdays_abbr(1)(2:2)=char(221)
weekdays_abbr(2)(1:1)=char(178)
weekdays_abbr(2)(2:2)=char(226)
weekdays_abbr(3)(1:1)=char(193)
weekdays_abbr(3)(2:2)=char(224)
weekdays_abbr(4)(1:1)=char(199)
weekdays_abbr(4)(2:2)=char(226)
weekdays_abbr(5)(1:1)=char(191)
weekdays_abbr(5)(2:2)=char(226)
weekdays_abbr(6)(1:1)=char(193)
weekdays_abbr(6)(2:2)=char(209)
weekdays_abbr(7)(1:1)=char(178)
weekdays_abbr(7)(2:2)=char(225)
months_abbr(1)(1:1)=char(239)
months_abbr(1)(2:2)=char(221)
months_abbr(1)(3:3)=char(210)
months_abbr(2)(1:1)=char(228)
months_abbr(2)(2:2)=char(213)
months_abbr(2)(3:3)=char(210)
months_abbr(3)(1:1)=char(220)
months_abbr(3)(2:2)=char(208)
months_abbr(3)(3:3)=char(224)
months_abbr(4)(1:1)=char(208)
months_abbr(4)(2:2)=char(223)
months_abbr(4)(3:3)=char(224)
months_abbr(5)(1:1)=char(220)
months_abbr(5)(2:2)=char(208)
months_abbr(5)(3:3)=char(217)
months_abbr(6)(1:1)=char(216)
months_abbr(6)(2:2)=char(238)
months_abbr(6)(3:3)=char(221)
months_abbr(7)(1:1)=char(216)
months_abbr(7)(2:2)=char(238)
months_abbr(7)(3:3)=char(219)
months_abbr(8)(1:1)=char(208)
months_abbr(8)(2:2)=char(210)
months_abbr(8)(3:3)=char(211)
months_abbr(9)(1:1)=char(225)
months_abbr(9)(2:2)=char(213)
months_abbr(9)(3:3)=char(221)
months_abbr(10)(1:1)=char(222)
months_abbr(10)(2:2)=char(218)
months_abbr(10)(3:3)=char(226)
months_abbr(11)(1:1)=char(221)
months_abbr(11)(2:2)=char(222)
months_abbr(11)(3:3)=char(239)
months_abbr(12)(1:1)=char(212)
months_abbr(12)(2:2)=char(213)
months_abbr(12)(3:3)=char(218)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_russian

subroutine locale_norwegian()
! LANG=norwegian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "man.","tir.","ons.","tor.","fre.","lr.","sn."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mandag","tirsdag","onsdag","torsdag","fredag","lrdag","sndag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","mai","jun", &
& "jul","aug","sep","okt","nov","des" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januar","februar","mars","april","mai","juni", &
& "juli","august","september","oktober","november","desember" ]
weekdays(6)(2:2)=char(248)
weekdays(7)(2:2)=char(248)
 ! ASCII months
weekdays_abbr(6)(2:2)=char(248)
weekdays_abbr(7)(2:2)=char(248)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_norwegian

subroutine locale_bokmal()
! LANG=bokmal
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "man.","tir.","ons.","tor.","fre.","lr.","sn."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mandag","tirsdag","onsdag","torsdag","fredag","lrdag","sndag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","mai","jun", &
& "jul","aug","sep","okt","nov","des" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januar","februar","mars","april","mai","juni", &
& "juli","august","september","oktober","november","desember" ]

weekdays(6)(2:2)=char(248)
weekdays(7)(2:2)=char(248)
 ! ASCII months
weekdays_abbr(6)(2:2)=char(248)
weekdays_abbr(7)(2:2)=char(248)
 ! ASCII months_abbr

   call locale("user",months,weekdays,months_abbr,weekdays_abbr)

end subroutine locale_bokmal

subroutine locale_dansk()
! LANG=dansk
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "ma","ti","on","to","fr","l","s"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mandag","tirsdag","onsdag","torsdag","fredag","lrdag","sndag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","maj","jun", &
& "jul","aug","sep","okt","nov","dec" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januar","februar","marts","april","maj","juni", &
& "juli","august","september","oktober","november","december" ]
weekdays(6)(2:2)=char(248)
weekdays(7)(2:2)=char(248)
 ! ASCII months
weekdays_abbr(6)(2:2)=char(248)
weekdays_abbr(7)(2:2)=char(248)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_dansk

subroutine locale_nynorsk()
! LANG=nynorsk
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "mn","tys","ons","tor","fre","lau","sn"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mndag","tysdag","onsdag","torsdag","fredag","laurdag","sndag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","mai","jun", &
& "jul","aug","sep","okt","nov","des" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januar","februar","mars","april","mai","juni", &
& "juli","august","september","oktober","november","desember" ]
weekdays(1)(2:2)=char(229)
weekdays(7)(2:2)=char(248)
 ! ASCII months
weekdays_abbr(1)(2:2)=char(229)
weekdays_abbr(7)(2:2)=char(248)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_nynorsk

subroutine locale_swedish()
! LANG=swedish
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "mn","tis","ons","tor","fre","lr","sn"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mndag","tisdag","onsdag","torsdag","fredag","lrdag","sndag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mar","apr","maj","jun", &
& "jul","aug","sep","okt","nov","dec" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januari","februari","mars","april","maj","juni", &
& "juli","augusti","september","oktober","november","december" ]
weekdays(1)(2:2)=char(229)
weekdays(6)(2:2)=char(246)
weekdays(7)(2:2)=char(246)
 ! ASCII months
weekdays_abbr(1)(2:2)=char(229)
weekdays_abbr(6)(2:2)=char(246)
weekdays_abbr(7)(2:2)=char(246)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_swedish

subroutine locale_dutch()
! LANG=dutch
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "ma","di","wo","do","vr","za","zo"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag","zondag"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","feb","mrt","apr","mei","jun", &
& "jul","aug","sep","okt","nov","dec" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januari","februari","maart","april","mei","juni", &
& "juli","augustus","september","oktober","november","december" ]
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_dutch

subroutine locale_finnish()
! LANG=finnish
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "ma","ti","ke","to","pe","la","su"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "maanantai","tiistai","keskiviikko","torstai","perjantai","lauantai","sunnuntai"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "tammi","helmi","maalis","huhti","touko","kes", &
& "hein","elo","syys","loka","marras","joulu" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "tammikuu","helmikuu","maaliskuu","huhtikuu","toukokuu","keskuu", &
& "heinkuu","elokuu","syyskuu","lokakuu","marraskuu","joulukuu" ]
 ! ASCII weekdays
months(6)(4:4)=char(228)
months(7)(5:5)=char(228)
 ! ASCII weekdays_abbr
months_abbr(6)(4:4)=char(228)
months_abbr(7)(5:5)=char(228)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_finnish

subroutine locale_french()
! LANG=french
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "lun.","mar.","mer.","jeu.","ven.","sam.","dim."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "lundi","mardi","mercredi","jeudi","vendredi","samedi","dimanche"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "janv.","fvr.","mars","avr.","mai","juin", &
& "juil.","aot","sept.","oct.","nov.","dc." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "janvier","fvrier","mars","avril","mai","juin", &
& "juillet","aot","septembre","octobre","novembre","dcembre" ]
 ! ASCII weekdays
months(2)(2:2)=char(233)
months(8)(3:3)=char(251)
months(12)(2:2)=char(233)
 ! ASCII weekdays_abbr
months_abbr(2)(2:2)=char(233)
months_abbr(8)(3:3)=char(251)
months_abbr(12)(2:2)=char(233)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_french

subroutine locale_galego()
! LANG=galego
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "Luns","Mar.","Mr.","Xov.","Ven.","Sb.","Dom."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "luns","martes","mrcores","xoves","venres","sbado","domingo"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "Xan.","Feb.","Mar.","Abr.","Maio","Xuo", &
& "Xul.","Ago.","Set.","Out.","Nov.","Dec." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "Xaneiro","Febreiro","Marzo","Abril","Maio","Xuo", &
& "Xullo","Agosto","Setembro","Outubro","Novembro","Decembro" ]
weekdays(3)(2:2)=char(233)
weekdays(6)(2:2)=char(225)
months(6)(3:3)=char(241)
weekdays_abbr(3)(2:2)=char(233)
weekdays_abbr(6)(2:2)=char(225)
months_abbr(6)(3:3)=char(241)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_galego

subroutine locale_greek()
! LANG=greek
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
weekdays(1)(1:1)=char(196)
weekdays(1)(2:2)=char(229)
weekdays(1)(3:3)=char(245)
weekdays(1)(4:4)=char(244)
weekdays(1)(5:5)=char(221)
weekdays(1)(6:6)=char(241)
weekdays(1)(7:7)=char(225)
weekdays(2)(1:1)=char(212)
weekdays(2)(2:2)=char(241)
weekdays(2)(3:3)=char(223)
weekdays(2)(4:4)=char(244)
weekdays(2)(5:5)=char(231)
weekdays(3)(1:1)=char(212)
weekdays(3)(2:2)=char(229)
weekdays(3)(3:3)=char(244)
weekdays(3)(4:4)=char(220)
weekdays(3)(5:5)=char(241)
weekdays(3)(6:6)=char(244)
weekdays(3)(7:7)=char(231)
weekdays(4)(1:1)=char(208)
weekdays(4)(2:2)=char(221)
weekdays(4)(3:3)=char(236)
weekdays(4)(4:4)=char(240)
weekdays(4)(5:5)=char(244)
weekdays(4)(6:6)=char(231)
weekdays(5)(1:1)=char(208)
weekdays(5)(2:2)=char(225)
weekdays(5)(3:3)=char(241)
weekdays(5)(4:4)=char(225)
weekdays(5)(5:5)=char(243)
weekdays(5)(6:6)=char(234)
weekdays(5)(7:7)=char(229)
weekdays(5)(8:8)=char(245)
weekdays(5)(9:9)=char(222)
weekdays(6)(1:1)=char(211)
weekdays(6)(2:2)=char(220)
weekdays(6)(3:3)=char(226)
weekdays(6)(4:4)=char(226)
weekdays(6)(5:5)=char(225)
weekdays(6)(6:6)=char(244)
weekdays(6)(7:7)=char(239)
weekdays(7)(1:1)=char(202)
weekdays(7)(2:2)=char(245)
weekdays(7)(3:3)=char(241)
weekdays(7)(4:4)=char(233)
weekdays(7)(5:5)=char(225)
weekdays(7)(6:6)=char(234)
weekdays(7)(7:7)=char(222)
months(1)(1:1)=char(201)
months(1)(2:2)=char(225)
months(1)(3:3)=char(237)
months(1)(4:4)=char(239)
months(1)(5:5)=char(245)
months(1)(6:6)=char(220)
months(1)(7:7)=char(241)
months(1)(8:8)=char(233)
months(1)(9:9)=char(239)
months(1)(10:10)=char(242)
months(2)(1:1)=char(214)
months(2)(2:2)=char(229)
months(2)(3:3)=char(226)
months(2)(4:4)=char(241)
months(2)(5:5)=char(239)
months(2)(6:6)=char(245)
months(2)(7:7)=char(220)
months(2)(8:8)=char(241)
months(2)(9:9)=char(233)
months(2)(10:10)=char(239)
months(2)(11:11)=char(242)
months(3)(1:1)=char(204)
months(3)(2:2)=char(220)
months(3)(3:3)=char(241)
months(3)(4:4)=char(244)
months(3)(5:5)=char(233)
months(3)(6:6)=char(239)
months(3)(7:7)=char(242)
months(4)(1:1)=char(193)
months(4)(2:2)=char(240)
months(4)(3:3)=char(241)
months(4)(4:4)=char(223)
months(4)(5:5)=char(235)
months(4)(6:6)=char(233)
months(4)(7:7)=char(239)
months(4)(8:8)=char(242)
months(5)(1:1)=char(204)
months(5)(2:2)=char(220)
months(5)(3:3)=char(233)
months(5)(4:4)=char(239)
months(5)(5:5)=char(242)
months(6)(1:1)=char(201)
months(6)(2:2)=char(239)
months(6)(3:3)=char(253)
months(6)(4:4)=char(237)
months(6)(5:5)=char(233)
months(6)(6:6)=char(239)
months(6)(7:7)=char(242)
months(7)(1:1)=char(201)
months(7)(2:2)=char(239)
months(7)(3:3)=char(253)
months(7)(4:4)=char(235)
months(7)(5:5)=char(233)
months(7)(6:6)=char(239)
months(7)(7:7)=char(242)
months(8)(1:1)=char(193)
months(8)(2:2)=char(253)
months(8)(3:3)=char(227)
months(8)(4:4)=char(239)
months(8)(5:5)=char(245)
months(8)(6:6)=char(243)
months(8)(7:7)=char(244)
months(8)(8:8)=char(239)
months(8)(9:9)=char(242)
months(9)(1:1)=char(211)
months(9)(2:2)=char(229)
months(9)(3:3)=char(240)
months(9)(4:4)=char(244)
months(9)(5:5)=char(221)
months(9)(6:6)=char(236)
months(9)(7:7)=char(226)
months(9)(8:8)=char(241)
months(9)(9:9)=char(233)
months(9)(10:10)=char(239)
months(9)(11:11)=char(242)
months(10)(1:1)=char(207)
months(10)(2:2)=char(234)
months(10)(3:3)=char(244)
months(10)(4:4)=char(254)
months(10)(5:5)=char(226)
months(10)(6:6)=char(241)
months(10)(7:7)=char(233)
months(10)(8:8)=char(239)
months(10)(9:9)=char(242)
months(11)(1:1)=char(205)
months(11)(2:2)=char(239)
months(11)(3:3)=char(221)
months(11)(4:4)=char(236)
months(11)(5:5)=char(226)
months(11)(6:6)=char(241)
months(11)(7:7)=char(233)
months(11)(8:8)=char(239)
months(11)(9:9)=char(242)
months(12)(1:1)=char(196)
months(12)(2:2)=char(229)
months(12)(3:3)=char(234)
months(12)(4:4)=char(221)
months(12)(5:5)=char(236)
months(12)(6:6)=char(226)
months(12)(7:7)=char(241)
months(12)(8:8)=char(233)
months(12)(9:9)=char(239)
months(12)(10:10)=char(242)
weekdays_abbr(1)(1:1)=char(196)
weekdays_abbr(1)(2:2)=char(229)
weekdays_abbr(1)(3:3)=char(245)
weekdays_abbr(2)(1:1)=char(212)
weekdays_abbr(2)(2:2)=char(241)
weekdays_abbr(2)(3:3)=char(233)
weekdays_abbr(3)(1:1)=char(212)
weekdays_abbr(3)(2:2)=char(229)
weekdays_abbr(3)(3:3)=char(244)
weekdays_abbr(4)(1:1)=char(208)
weekdays_abbr(4)(2:2)=char(229)
weekdays_abbr(4)(3:3)=char(236)
weekdays_abbr(5)(1:1)=char(208)
weekdays_abbr(5)(2:2)=char(225)
weekdays_abbr(5)(3:3)=char(241)
weekdays_abbr(6)(1:1)=char(211)
weekdays_abbr(6)(2:2)=char(225)
weekdays_abbr(6)(3:3)=char(226)
weekdays_abbr(7)(1:1)=char(202)
weekdays_abbr(7)(2:2)=char(245)
weekdays_abbr(7)(3:3)=char(241)
months_abbr(1)(1:1)=char(201)
months_abbr(1)(2:2)=char(225)
months_abbr(1)(3:3)=char(237)
months_abbr(2)(1:1)=char(214)
months_abbr(2)(2:2)=char(229)
months_abbr(2)(3:3)=char(226)
months_abbr(3)(1:1)=char(204)
months_abbr(3)(2:2)=char(225)
months_abbr(3)(3:3)=char(241)
months_abbr(4)(1:1)=char(193)
months_abbr(4)(2:2)=char(240)
months_abbr(4)(3:3)=char(241)
months_abbr(5)(1:1)=char(204)
months_abbr(5)(2:2)=char(225)
months_abbr(5)(3:3)=char(250)
months_abbr(6)(1:1)=char(201)
months_abbr(6)(2:2)=char(239)
months_abbr(6)(3:3)=char(245)
months_abbr(6)(4:4)=char(237)
months_abbr(7)(1:1)=char(201)
months_abbr(7)(2:2)=char(239)
months_abbr(7)(3:3)=char(245)
months_abbr(7)(4:4)=char(235)
months_abbr(8)(1:1)=char(193)
months_abbr(8)(2:2)=char(245)
months_abbr(8)(3:3)=char(227)
months_abbr(9)(1:1)=char(211)
months_abbr(9)(2:2)=char(229)
months_abbr(9)(3:3)=char(240)
months_abbr(10)(1:1)=char(207)
months_abbr(10)(2:2)=char(234)
months_abbr(10)(3:3)=char(244)
months_abbr(11)(1:1)=char(205)
months_abbr(11)(2:2)=char(239)
months_abbr(11)(3:3)=char(229)
months_abbr(12)(1:1)=char(196)
months_abbr(12)(2:2)=char(229)
months_abbr(12)(3:3)=char(234)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_greek

subroutine locale_hebrew()
! LANG=hebrew
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
weekdays(1)(1:1)=char(233)
weekdays(1)(2:2)=char(229)
weekdays(1)(3:3)=char(237)
weekdays(1)(4:4)=char(160)
weekdays(1)(5:5)=char(249)
weekdays(1)(6:6)=char(240)
weekdays(1)(7:7)=char(233)
weekdays(2)(1:1)=char(233)
weekdays(2)(2:2)=char(229)
weekdays(2)(3:3)=char(237)
weekdays(2)(4:4)=char(160)
weekdays(2)(5:5)=char(249)
weekdays(2)(6:6)=char(236)
weekdays(2)(7:7)=char(233)
weekdays(2)(8:8)=char(249)
weekdays(2)(9:9)=char(233)
weekdays(3)(1:1)=char(233)
weekdays(3)(2:2)=char(229)
weekdays(3)(3:3)=char(237)
weekdays(3)(4:4)=char(160)
weekdays(3)(5:5)=char(248)
weekdays(3)(6:6)=char(225)
weekdays(3)(7:7)=char(233)
weekdays(3)(8:8)=char(242)
weekdays(3)(9:9)=char(233)
weekdays(4)(1:1)=char(233)
weekdays(4)(2:2)=char(229)
weekdays(4)(3:3)=char(237)
weekdays(4)(4:4)=char(160)
weekdays(4)(5:5)=char(231)
weekdays(4)(6:6)=char(238)
weekdays(4)(7:7)=char(233)
weekdays(4)(8:8)=char(249)
weekdays(4)(9:9)=char(233)
weekdays(5)(1:1)=char(233)
weekdays(5)(2:2)=char(229)
weekdays(5)(3:3)=char(237)
weekdays(5)(4:4)=char(160)
weekdays(5)(5:5)=char(249)
weekdays(5)(6:6)=char(233)
weekdays(5)(7:7)=char(249)
weekdays(5)(8:8)=char(233)
weekdays(6)(1:1)=char(249)
weekdays(6)(2:2)=char(225)
weekdays(6)(3:3)=char(250)
weekdays(7)(1:1)=char(233)
weekdays(7)(2:2)=char(229)
weekdays(7)(3:3)=char(237)
weekdays(7)(4:4)=char(160)
weekdays(7)(5:5)=char(248)
weekdays(7)(6:6)=char(224)
weekdays(7)(7:7)=char(249)
weekdays(7)(8:8)=char(229)
weekdays(7)(9:9)=char(239)
months(1)(1:1)=char(233)
months(1)(2:2)=char(240)
months(1)(3:3)=char(229)
months(1)(4:4)=char(224)
months(1)(5:5)=char(248)
months(2)(1:1)=char(244)
months(2)(2:2)=char(225)
months(2)(3:3)=char(248)
months(2)(4:4)=char(229)
months(2)(5:5)=char(224)
months(2)(6:6)=char(248)
months(3)(1:1)=char(238)
months(3)(2:2)=char(248)
months(3)(3:3)=char(245)
months(4)(1:1)=char(224)
months(4)(2:2)=char(244)
months(4)(3:3)=char(248)
months(4)(4:4)=char(233)
months(4)(5:5)=char(236)
months(5)(1:1)=char(238)
months(5)(2:2)=char(224)
months(5)(3:3)=char(233)
months(6)(1:1)=char(233)
months(6)(2:2)=char(229)
months(6)(3:3)=char(240)
months(6)(4:4)=char(233)
months(7)(1:1)=char(233)
months(7)(2:2)=char(229)
months(7)(3:3)=char(236)
months(7)(4:4)=char(233)
months(8)(1:1)=char(224)
months(8)(2:2)=char(229)
months(8)(3:3)=char(226)
months(8)(4:4)=char(229)
months(8)(5:5)=char(241)
months(8)(6:6)=char(232)
months(9)(1:1)=char(241)
months(9)(2:2)=char(244)
months(9)(3:3)=char(232)
months(9)(4:4)=char(238)
months(9)(5:5)=char(225)
months(9)(6:6)=char(248)
months(10)(1:1)=char(224)
months(10)(2:2)=char(229)
months(10)(3:3)=char(247)
months(10)(4:4)=char(232)
months(10)(5:5)=char(229)
months(10)(6:6)=char(225)
months(10)(7:7)=char(248)
months(11)(1:1)=char(240)
months(11)(2:2)=char(229)
months(11)(3:3)=char(225)
months(11)(4:4)=char(238)
months(11)(5:5)=char(225)
months(11)(6:6)=char(248)
months(12)(1:1)=char(227)
months(12)(2:2)=char(246)
months(12)(3:3)=char(238)
months(12)(4:4)=char(225)
months(12)(5:5)=char(248)
weekdays_abbr(1)(1:1)=char(233)
weekdays_abbr(1)(2:2)=char(229)
weekdays_abbr(1)(3:3)=char(237)
weekdays_abbr(1)(4:4)=char(160)
weekdays_abbr(1)(5:5)=char(225)
weekdays_abbr(2)(1:1)=char(233)
weekdays_abbr(2)(2:2)=char(229)
weekdays_abbr(2)(3:3)=char(237)
weekdays_abbr(2)(4:4)=char(160)
weekdays_abbr(2)(5:5)=char(226)
weekdays_abbr(3)(1:1)=char(233)
weekdays_abbr(3)(2:2)=char(229)
weekdays_abbr(3)(3:3)=char(237)
weekdays_abbr(3)(4:4)=char(160)
weekdays_abbr(3)(5:5)=char(227)
weekdays_abbr(4)(1:1)=char(233)
weekdays_abbr(4)(2:2)=char(229)
weekdays_abbr(4)(3:3)=char(237)
weekdays_abbr(4)(4:4)=char(160)
weekdays_abbr(4)(5:5)=char(228)
weekdays_abbr(5)(1:1)=char(233)
weekdays_abbr(5)(2:2)=char(229)
weekdays_abbr(5)(3:3)=char(237)
weekdays_abbr(5)(4:4)=char(160)
weekdays_abbr(5)(5:5)=char(229)
weekdays_abbr(6)(1:1)=char(249)
weekdays_abbr(6)(2:2)=char(225)
weekdays_abbr(6)(3:3)=char(250)
weekdays_abbr(7)(1:1)=char(233)
weekdays_abbr(7)(2:2)=char(229)
weekdays_abbr(7)(3:3)=char(237)
weekdays_abbr(7)(4:4)=char(160)
weekdays_abbr(7)(5:5)=char(224)
months_abbr(1)(1:1)=char(233)
months_abbr(1)(2:2)=char(240)
months_abbr(1)(3:3)=char(229)
months_abbr(2)(1:1)=char(244)
months_abbr(2)(2:2)=char(225)
months_abbr(2)(3:3)=char(248)
months_abbr(3)(1:1)=char(238)
months_abbr(3)(2:2)=char(248)
months_abbr(3)(3:3)=char(245)
months_abbr(4)(1:1)=char(224)
months_abbr(4)(2:2)=char(244)
months_abbr(4)(3:3)=char(248)
months_abbr(5)(1:1)=char(238)
months_abbr(5)(2:2)=char(224)
months_abbr(5)(3:3)=char(233)
months_abbr(6)(1:1)=char(233)
months_abbr(6)(2:2)=char(229)
months_abbr(6)(3:3)=char(240)
months_abbr(7)(1:1)=char(233)
months_abbr(7)(2:2)=char(229)
months_abbr(7)(3:3)=char(236)
months_abbr(8)(1:1)=char(224)
months_abbr(8)(2:2)=char(229)
months_abbr(8)(3:3)=char(226)
months_abbr(9)(1:1)=char(241)
months_abbr(9)(2:2)=char(244)
months_abbr(9)(3:3)=char(232)
months_abbr(10)(1:1)=char(224)
months_abbr(10)(2:2)=char(229)
months_abbr(10)(3:3)=char(247)
months_abbr(11)(1:1)=char(240)
months_abbr(11)(2:2)=char(229)
months_abbr(11)(3:3)=char(225)
months_abbr(12)(1:1)=char(227)
months_abbr(12)(2:2)=char(246)
months_abbr(12)(3:3)=char(238)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_hebrew

subroutine locale_hrvatski()
! LANG=hrvatski
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "pon","uto","sri","et","pet","sub","ned"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "ponedjeljak","utorak","srijeda","etvrtak","petak","subota","nedjelja"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "sij","vlj","ou","tra","svi","lip", &
& "srp","kol","ruj","lis","stu","pro" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "sijeanj","veljaa","oujak","travanj","svibanj","lipanj", &
& "srpanj","kolovoz","rujan","listopad","studeni","prosinac" ]
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
weekdays(4)(1:1)=char(232)
months(1)(5:5)=char(232)
months(2)(6:6)=char(232)
months(3)(2:2)=char(190)
weekdays_abbr(4)(1:1)=char(232)
months_abbr(3)(2:2)=char(190)

end subroutine locale_hrvatski

subroutine locale_hungarian()
! LANG=hungarian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "H","K","Sze","Cs","P","Szo","V"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "htf","kedd","szerda","cstrtk","pntek","szombat","vasrnap"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan.","febr.","mrc.","pr.","mj.","jn.", &
& "jl.","aug.","szept.","okt.","nov.","dec." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "janur","februr","mrcius","prilis","mjus","jnius", &
& "jlius","augusztus","szeptember","oktber","november","december" ]
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
weekdays(1)(2:2)=char(233)
weekdays(1)(5:5)=char(245)
weekdays(4)(3:3)=char(252)
weekdays(4)(5:5)=char(246)
weekdays(4)(8:8)=char(246)
weekdays(5)(2:2)=char(233)
weekdays(7)(4:4)=char(225)
months(1)(5:5)=char(225)
months(2)(6:6)=char(225)
months(3)(2:2)=char(225)
months(4)(1:1)=char(225)
months(5)(2:2)=char(225)
months(6)(2:2)=char(250)
months(7)(2:2)=char(250)
months(10)(4:4)=char(243)
 ! ASCII weekdays_abbr
months_abbr(3)(2:2)=char(225)
months_abbr(4)(1:1)=char(225)
months_abbr(5)(2:2)=char(225)
months_abbr(6)(2:2)=char(250)
months_abbr(7)(2:2)=char(250)
end subroutine locale_hungarian

subroutine locale_icelandic()
! LANG=icelandic
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "mn.","ri.","mi.","fim.","fs.","lau.","sun."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "mnudagur","rijudagur","mivikudagur","fimmtudagur","fstudagur","laugardagur","sunnudagur"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan.","feb.","mar.","apr.","ma","jn.", &
& "jl.","g.","sep.","okt.","nv.","des." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "janar","febrar","mars","aprl","ma","jn", &
& "jl","gst","september","oktber","nvember","desember" ]
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
weekdays(1)(2:2)=char(225)
weekdays(2)(1:1)=char(254)
weekdays(2)(4:4)=char(240)
weekdays(3)(3:3)=char(240)
weekdays(5)(2:2)=char(246)
months(1)(4:4)=char(250)
months(2)(5:5)=char(250)
months(4)(4:4)=char(237)
months(5)(3:3)=char(237)
months(6)(2:2)=char(250)
months(6)(4:4)=char(237)
months(7)(2:2)=char(250)
months(7)(4:4)=char(237)
months(8)(1:1)=char(225)
months(8)(3:3)=char(250)
months(10)(4:4)=char(243)
months(11)(2:2)=char(243)
weekdays_abbr(1)(2:2)=char(225)
weekdays_abbr(2)(1:1)=char(254)
weekdays_abbr(3)(3:3)=char(240)
weekdays_abbr(5)(2:2)=char(246)
months_abbr(5)(3:3)=char(237)
months_abbr(6)(2:2)=char(250)
months_abbr(7)(2:2)=char(250)
months_abbr(8)(1:1)=char(225)
months_abbr(8)(3:3)=char(250)
months_abbr(11)(2:2)=char(243)
end subroutine locale_icelandic

subroutine locale_italian()
! LANG=italian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "lun","mar","mer","gio","ven","sab","dom"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "luned","marted","mercoled","gioved","venerd","sabato","domenica"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "gen","feb","mar","apr","mag","giu", &
& "lug","ago","set","ott","nov","dic" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "gennaio","febbraio","marzo","aprile","maggio","giugno", &
& "luglio","agosto","settembre","ottobre","novembre","dicembre" ]
weekdays(1)(6:6)=char(236)
weekdays(2)(7:7)=char(236)
weekdays(3)(9:9)=char(236)
weekdays(4)(7:7)=char(236)
weekdays(5)(7:7)=char(236)
 ! ASCII months
 ! ASCII weekdays_abbr
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_italian

subroutine locale_japanese()
! LANG=japanese
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "1","2","3","4","5","6", &
& "7","8","9","10","11","12" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "1","2","3","4","5","6", &
& "7","8","9","10","11","12" ]
weekdays(1)(1:1)=char(183)
weekdays(1)(2:2)=char(238)
weekdays(1)(3:3)=char(205)
weekdays(1)(4:4)=char(203)
weekdays(1)(5:5)=char(198)
weekdays(1)(6:6)=char(252)
weekdays(2)(1:1)=char(178)
weekdays(2)(2:2)=char(208)
weekdays(2)(3:3)=char(205)
weekdays(2)(4:4)=char(203)
weekdays(2)(5:5)=char(198)
weekdays(2)(6:6)=char(252)
weekdays(3)(1:1)=char(191)
weekdays(3)(2:2)=char(229)
weekdays(3)(3:3)=char(205)
weekdays(3)(4:4)=char(203)
weekdays(3)(5:5)=char(198)
weekdays(3)(6:6)=char(252)
weekdays(4)(1:1)=char(204)
weekdays(4)(2:2)=char(218)
weekdays(4)(3:3)=char(205)
weekdays(4)(4:4)=char(203)
weekdays(4)(5:5)=char(198)
weekdays(4)(6:6)=char(252)
weekdays(5)(1:1)=char(182)
weekdays(5)(2:2)=char(226)
weekdays(5)(3:3)=char(205)
weekdays(5)(4:4)=char(203)
weekdays(5)(5:5)=char(198)
weekdays(5)(6:6)=char(252)
weekdays(6)(1:1)=char(197)
weekdays(6)(2:2)=char(218)
weekdays(6)(3:3)=char(205)
weekdays(6)(4:4)=char(203)
weekdays(6)(5:5)=char(198)
weekdays(6)(6:6)=char(252)
weekdays(7)(1:1)=char(198)
weekdays(7)(2:2)=char(252)
weekdays(7)(3:3)=char(205)
weekdays(7)(4:4)=char(203)
weekdays(7)(5:5)=char(198)
weekdays(7)(6:6)=char(252)
months(1)(2:2)=char(183)
months(1)(3:3)=char(238)
months(2)(2:2)=char(183)
months(2)(3:3)=char(238)
months(3)(2:2)=char(183)
months(3)(3:3)=char(238)
months(4)(2:2)=char(183)
months(4)(3:3)=char(238)
months(5)(2:2)=char(183)
months(5)(3:3)=char(238)
months(6)(2:2)=char(183)
months(6)(3:3)=char(238)
months(7)(2:2)=char(183)
months(7)(3:3)=char(238)
months(8)(2:2)=char(183)
months(8)(3:3)=char(238)
months(9)(2:2)=char(183)
months(9)(3:3)=char(238)
months(10)(3:3)=char(183)
months(10)(4:4)=char(238)
months(11)(3:3)=char(183)
months(11)(4:4)=char(238)
months(12)(3:3)=char(183)
months(12)(4:4)=char(238)
weekdays_abbr(1)(1:1)=char(183)
weekdays_abbr(1)(2:2)=char(238)
weekdays_abbr(2)(1:1)=char(178)
weekdays_abbr(2)(2:2)=char(208)
weekdays_abbr(3)(1:1)=char(191)
weekdays_abbr(3)(2:2)=char(229)
weekdays_abbr(4)(1:1)=char(204)
weekdays_abbr(4)(2:2)=char(218)
weekdays_abbr(5)(1:1)=char(182)
weekdays_abbr(5)(2:2)=char(226)
weekdays_abbr(6)(1:1)=char(197)
weekdays_abbr(6)(2:2)=char(218)
weekdays_abbr(7)(1:1)=char(198)
weekdays_abbr(7)(2:2)=char(252)
months_abbr(1)(2:2)=char(183)
months_abbr(1)(3:3)=char(238)
months_abbr(2)(2:2)=char(183)
months_abbr(2)(3:3)=char(238)
months_abbr(3)(2:2)=char(183)
months_abbr(3)(3:3)=char(238)
months_abbr(4)(2:2)=char(183)
months_abbr(4)(3:3)=char(238)
months_abbr(5)(2:2)=char(183)
months_abbr(5)(3:3)=char(238)
months_abbr(6)(2:2)=char(183)
months_abbr(6)(3:3)=char(238)
months_abbr(7)(2:2)=char(183)
months_abbr(7)(3:3)=char(238)
months_abbr(8)(2:2)=char(183)
months_abbr(8)(3:3)=char(238)
months_abbr(9)(2:2)=char(183)
months_abbr(9)(3:3)=char(238)
months_abbr(10)(3:3)=char(183)
months_abbr(10)(4:4)=char(238)
months_abbr(11)(3:3)=char(183)
months_abbr(11)(4:4)=char(238)
months_abbr(12)(3:3)=char(183)
months_abbr(12)(4:4)=char(238)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_japanese

subroutine locale_korean()
! LANG=korean
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "1","2","3","4","5","6", &
& "7","8","9","10","11","12" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "1","2","3","4","5","6", &
& "7","8","9","10","11","12" ]
weekdays(1)(1:1)=char(191)
weekdays(1)(2:2)=char(249)
weekdays(1)(3:3)=char(191)
weekdays(1)(4:4)=char(228)
weekdays(1)(5:5)=char(192)
weekdays(1)(6:6)=char(207)
weekdays(2)(1:1)=char(200)
weekdays(2)(2:2)=char(173)
weekdays(2)(3:3)=char(191)
weekdays(2)(4:4)=char(228)
weekdays(2)(5:5)=char(192)
weekdays(2)(6:6)=char(207)
weekdays(3)(1:1)=char(188)
weekdays(3)(2:2)=char(246)
weekdays(3)(3:3)=char(191)
weekdays(3)(4:4)=char(228)
weekdays(3)(5:5)=char(192)
weekdays(3)(6:6)=char(207)
weekdays(4)(1:1)=char(184)
weekdays(4)(2:2)=char(241)
weekdays(4)(3:3)=char(191)
weekdays(4)(4:4)=char(228)
weekdays(4)(5:5)=char(192)
weekdays(4)(6:6)=char(207)
weekdays(5)(1:1)=char(177)
weekdays(5)(2:2)=char(221)
weekdays(5)(3:3)=char(191)
weekdays(5)(4:4)=char(228)
weekdays(5)(5:5)=char(192)
weekdays(5)(6:6)=char(207)
weekdays(6)(1:1)=char(197)
weekdays(6)(2:2)=char(228)
weekdays(6)(3:3)=char(191)
weekdays(6)(4:4)=char(228)
weekdays(6)(5:5)=char(192)
weekdays(6)(6:6)=char(207)
weekdays(7)(1:1)=char(192)
weekdays(7)(2:2)=char(207)
weekdays(7)(3:3)=char(191)
weekdays(7)(4:4)=char(228)
weekdays(7)(5:5)=char(192)
weekdays(7)(6:6)=char(207)
months(1)(2:2)=char(191)
months(1)(3:3)=char(249)
months(2)(2:2)=char(191)
months(2)(3:3)=char(249)
months(3)(2:2)=char(191)
months(3)(3:3)=char(249)
months(4)(2:2)=char(191)
months(4)(3:3)=char(249)
months(5)(2:2)=char(191)
months(5)(3:3)=char(249)
months(6)(2:2)=char(191)
months(6)(3:3)=char(249)
months(7)(2:2)=char(191)
months(7)(3:3)=char(249)
months(8)(2:2)=char(191)
months(8)(3:3)=char(249)
months(9)(2:2)=char(191)
months(9)(3:3)=char(249)
months(10)(3:3)=char(191)
months(10)(4:4)=char(249)
months(11)(3:3)=char(191)
months(11)(4:4)=char(249)
months(12)(3:3)=char(191)
months(12)(4:4)=char(249)
weekdays_abbr(1)(1:1)=char(191)
weekdays_abbr(1)(2:2)=char(249)
weekdays_abbr(2)(1:1)=char(200)
weekdays_abbr(2)(2:2)=char(173)
weekdays_abbr(3)(1:1)=char(188)
weekdays_abbr(3)(2:2)=char(246)
weekdays_abbr(4)(1:1)=char(184)
weekdays_abbr(4)(2:2)=char(241)
weekdays_abbr(5)(1:1)=char(177)
weekdays_abbr(5)(2:2)=char(221)
weekdays_abbr(6)(1:1)=char(197)
weekdays_abbr(6)(2:2)=char(228)
weekdays_abbr(7)(1:1)=char(192)
weekdays_abbr(7)(2:2)=char(207)
months_abbr(1)(2:2)=char(191)
months_abbr(1)(3:3)=char(249)
months_abbr(2)(2:2)=char(191)
months_abbr(2)(3:3)=char(249)
months_abbr(3)(2:2)=char(191)
months_abbr(3)(3:3)=char(249)
months_abbr(4)(2:2)=char(191)
months_abbr(4)(3:3)=char(249)
months_abbr(5)(2:2)=char(191)
months_abbr(5)(3:3)=char(249)
months_abbr(6)(2:2)=char(191)
months_abbr(6)(3:3)=char(249)
months_abbr(7)(2:2)=char(191)
months_abbr(7)(3:3)=char(249)
months_abbr(8)(2:2)=char(191)
months_abbr(8)(3:3)=char(249)
months_abbr(9)(2:2)=char(191)
months_abbr(9)(3:3)=char(249)
months_abbr(10)(3:3)=char(191)
months_abbr(10)(4:4)=char(249)
months_abbr(11)(3:3)=char(191)
months_abbr(11)(4:4)=char(249)
months_abbr(12)(3:3)=char(191)
months_abbr(12)(4:4)=char(249)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_korean

subroutine locale_lithuanian()
! LANG=lithuanian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "pr","an","tr","kt","pn","t","sk"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "pirmadienis","antradienis","treiadienis","ketvirtadienis","penktadienis","etadienis","sekmadienis"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "saus.","vas.","kov.","bal.","geg.","bir.", &
& "liep.","rugp.","rugs.","spal.","lapkr.","gruod." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "sausis","vasaris","kovas","balandis","gegu","birelis", &
& "liepa","rugpjtis","rugsjis","spalis","lapkritis","gruodis" ]
weekdays(3)(4:4)=char(232)
weekdays(6)(1:1)=char(240)
weekdays(6)(3:3)=char(240)
months(5)(5:5)=char(254)
months(5)(6:6)=char(235)
months(6)(4:4)=char(254)
months(8)(6:6)=char(251)
months(9)(5:5)=char(235)
weekdays_abbr(6)(1:1)=char(240)
months_abbr(6)(4:4)=char(254)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_lithuanian

subroutine locale_polish()
! LANG=polish
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "pon.","wt.","r.","czw.","pt.","sob.","niedz."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "poniedziaek","wtorek","roda","czwartek","pitek","sobota","niedziela"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "sty","lut","mar","kwi","maj","cze", &
& "lip","sie","wrz","pa","lis","gru" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "stycze","luty","marzec","kwiecie","maj","czerwiec", &
& "lipiec","sierpie","wrzesie","padziernik","listopad","grudzie" ]
weekdays(1)(10:10)=char(179)
weekdays(3)(1:1)=char(182)
weekdays(5)(3:3)=char(177)
months(1)(7:7)=char(241)
months(4)(8:8)=char(241)
months(8)(8:8)=char(241)
months(9)(8:8)=char(241)
months(10)(3:3)=char(188)
months(12)(8:8)=char(241)
weekdays_abbr(3)(1:1)=char(182)
months_abbr(10)(3:3)=char(188)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_polish

subroutine locale_portuguese()
! LANG=portuguese
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "seg","ter","qua","qui","sex","sb","dom"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "segunda-feira","tera-feira","quarta-feira","quinta-feira","sexta-feira","sbado","domingo"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan","fev","mar","abr","mai","jun", &
& "jul","ago","set","out","nov","dez" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "janeiro","fevereiro","maro","abril","maio","junho", &
& "julho","agosto","setembro","outubro","novembro","dezembro" ]
weekdays(2)(4:4)=char(231)
weekdays(6)(2:2)=char(225)
months(3)(4:4)=char(231)
weekdays_abbr(6)(2:2)=char(225)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_portuguese

subroutine locale_romanian()
! LANG=romanian
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "lun.","mar.","mie.","joi","vin.","sm.","dum."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "luni","mari","miercuri","joi","vineri","smbt","duminic"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "ian.","feb.","mar.","apr.","mai","iun.", &
& "iul.","aug.","sept.","oct.","nov.","dec." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "ianuarie","februarie","martie","aprilie","mai","iunie", &
& "iulie","august","septembrie","octombrie","noiembrie","decembrie" ]
weekdays(6)(2:2)=char(226)
weekdays(6)(5:5)=char(227)
weekdays(6)(7:7)=char(227)
weekdays(7)(8:8)=char(227)
 ! ASCII months
weekdays_abbr(6)(2:2)=char(226)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_romanian

subroutine locale_slovene()
! LANG=slovene
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "pon.","tor.","sre.","et.","pet.","sob.","ned."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "ponedeljek","torek","sreda","etrtek","petek","sobota","nedelja"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jan.","feb.","mar.","apr.","maj","jun.", &
& "jul.","avg.","sep.","okt.","nov.","dec." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "januar","februar","marec","april","maj","junij", &
& "julij","avgust","september","oktober","november","december" ]
weekdays(4)(1:1)=char(232)
 ! ASCII months
weekdays_abbr(4)(1:1)=char(232)
 ! ASCII months_abbr
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_slovene

subroutine locale_thai()
! LANG=thai
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& ".",".",".",".",".",".","."]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "","","","","","",""]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "..","..","..","..","..","..", &
& "..","..","..","..","..",".." ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "","","","","","", &
& "","","","","","" ]
weekdays(1)(1:1)=char(168)
weekdays(1)(2:2)=char(209)
weekdays(1)(3:3)=char(185)
weekdays(1)(4:4)=char(183)
weekdays(1)(5:5)=char(195)
weekdays(1)(6:6)=char(236)
weekdays(2)(1:1)=char(205)
weekdays(2)(2:2)=char(209)
weekdays(2)(3:3)=char(167)
weekdays(2)(4:4)=char(164)
weekdays(2)(5:5)=char(210)
weekdays(2)(6:6)=char(195)
weekdays(3)(1:1)=char(190)
weekdays(3)(2:2)=char(216)
weekdays(3)(3:3)=char(184)
weekdays(4)(1:1)=char(190)
weekdays(4)(2:2)=char(196)
weekdays(4)(3:3)=char(203)
weekdays(4)(4:4)=char(209)
weekdays(4)(5:5)=char(202)
weekdays(4)(6:6)=char(186)
weekdays(4)(7:7)=char(180)
weekdays(4)(8:8)=char(213)
weekdays(5)(1:1)=char(200)
weekdays(5)(2:2)=char(216)
weekdays(5)(3:3)=char(161)
weekdays(5)(4:4)=char(195)
weekdays(5)(5:5)=char(236)
weekdays(6)(1:1)=char(224)
weekdays(6)(2:2)=char(202)
weekdays(6)(3:3)=char(210)
weekdays(6)(4:4)=char(195)
weekdays(6)(5:5)=char(236)
weekdays(7)(1:1)=char(205)
weekdays(7)(2:2)=char(210)
weekdays(7)(3:3)=char(183)
weekdays(7)(4:4)=char(212)
weekdays(7)(5:5)=char(181)
weekdays(7)(6:6)=char(194)
weekdays(7)(7:7)=char(236)
months(1)(1:1)=char(193)
months(1)(2:2)=char(161)
months(1)(3:3)=char(195)
months(1)(4:4)=char(210)
months(1)(5:5)=char(164)
months(1)(6:6)=char(193)
months(2)(1:1)=char(161)
months(2)(2:2)=char(216)
months(2)(3:3)=char(193)
months(2)(4:4)=char(192)
months(2)(5:5)=char(210)
months(2)(6:6)=char(190)
months(2)(7:7)=char(209)
months(2)(8:8)=char(185)
months(2)(9:9)=char(184)
months(2)(10:10)=char(236)
months(3)(1:1)=char(193)
months(3)(2:2)=char(213)
months(3)(3:3)=char(185)
months(3)(4:4)=char(210)
months(3)(5:5)=char(164)
months(3)(6:6)=char(193)
months(4)(1:1)=char(224)
months(4)(2:2)=char(193)
months(4)(3:3)=char(201)
months(4)(4:4)=char(210)
months(4)(5:5)=char(194)
months(4)(6:6)=char(185)
months(5)(1:1)=char(190)
months(5)(2:2)=char(196)
months(5)(3:3)=char(201)
months(5)(4:4)=char(192)
months(5)(5:5)=char(210)
months(5)(6:6)=char(164)
months(5)(7:7)=char(193)
months(6)(1:1)=char(193)
months(6)(2:2)=char(212)
months(6)(3:3)=char(182)
months(6)(4:4)=char(216)
months(6)(5:5)=char(185)
months(6)(6:6)=char(210)
months(6)(7:7)=char(194)
months(6)(8:8)=char(185)
months(7)(1:1)=char(161)
months(7)(2:2)=char(195)
months(7)(3:3)=char(161)
months(7)(4:4)=char(174)
months(7)(5:5)=char(210)
months(7)(6:6)=char(164)
months(7)(7:7)=char(193)
months(8)(1:1)=char(202)
months(8)(2:2)=char(212)
months(8)(3:3)=char(167)
months(8)(4:4)=char(203)
months(8)(5:5)=char(210)
months(8)(6:6)=char(164)
months(8)(7:7)=char(193)
months(9)(1:1)=char(161)
months(9)(2:2)=char(209)
months(9)(3:3)=char(185)
months(9)(4:4)=char(194)
months(9)(5:5)=char(210)
months(9)(6:6)=char(194)
months(9)(7:7)=char(185)
months(10)(1:1)=char(181)
months(10)(2:2)=char(216)
months(10)(3:3)=char(197)
months(10)(4:4)=char(210)
months(10)(5:5)=char(164)
months(10)(6:6)=char(193)
months(11)(1:1)=char(190)
months(11)(2:2)=char(196)
months(11)(3:3)=char(200)
months(11)(4:4)=char(168)
months(11)(5:5)=char(212)
months(11)(6:6)=char(161)
months(11)(7:7)=char(210)
months(11)(8:8)=char(194)
months(11)(9:9)=char(185)
months(12)(1:1)=char(184)
months(12)(2:2)=char(209)
months(12)(3:3)=char(185)
months(12)(4:4)=char(199)
months(12)(5:5)=char(210)
months(12)(6:6)=char(164)
months(12)(7:7)=char(193)
weekdays_abbr(1)(1:1)=char(168)
weekdays_abbr(2)(1:1)=char(205)
weekdays_abbr(3)(1:1)=char(190)
weekdays_abbr(4)(1:1)=char(190)
weekdays_abbr(4)(2:2)=char(196)
weekdays_abbr(5)(1:1)=char(200)
weekdays_abbr(6)(1:1)=char(202)
weekdays_abbr(7)(1:1)=char(205)
weekdays_abbr(7)(2:2)=char(210)
months_abbr(1)(1:1)=char(193)
months_abbr(1)(3:3)=char(164)
months_abbr(2)(1:1)=char(161)
months_abbr(2)(3:3)=char(190)
months_abbr(3)(1:1)=char(193)
months_abbr(3)(2:2)=char(213)
months_abbr(3)(4:4)=char(164)
months_abbr(4)(1:1)=char(224)
months_abbr(4)(2:2)=char(193)
months_abbr(4)(4:4)=char(194)
months_abbr(5)(1:1)=char(190)
months_abbr(5)(3:3)=char(164)
months_abbr(6)(1:1)=char(193)
months_abbr(6)(2:2)=char(212)
months_abbr(6)(4:4)=char(194)
months_abbr(7)(1:1)=char(161)
months_abbr(7)(3:3)=char(164)
months_abbr(8)(1:1)=char(202)
months_abbr(8)(3:3)=char(164)
months_abbr(9)(1:1)=char(161)
months_abbr(9)(3:3)=char(194)
months_abbr(10)(1:1)=char(181)
months_abbr(10)(3:3)=char(164)
months_abbr(11)(1:1)=char(190)
months_abbr(11)(3:3)=char(194)
months_abbr(12)(1:1)=char(184)
months_abbr(12)(3:3)=char(164)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_thai

subroutine locale_turkish()
! LANG=turkish
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "Pzt","Sal","ar","Per","Cum","Cmt","Paz"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "Pazartesi","Sal","aramba","Perembe","Cuma","Cumartesi","Pazar"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "Oca","ub","Mar","Nis","May","Haz", &
& "Tem","Au","Eyl","Eki","Kas","Ara" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "Ocak","ubat","Mart","Nisan","Mays","Haziran", &
& "Temmuz","Austos","Eyll","Ekim","Kasm","Aralk" ]
weekdays(2)(4:4)=char(253)
weekdays(3)(1:1)=char(199)
weekdays(3)(4:4)=char(254)
weekdays(4)(4:4)=char(254)
months(2)(1:1)=char(222)
months(5)(4:4)=char(253)
months(8)(2:2)=char(240)
months(9)(4:4)=char(252)
months(11)(4:4)=char(253)
months(12)(5:5)=char(253)
weekdays_abbr(3)(1:1)=char(199)
months_abbr(2)(1:1)=char(222)
months_abbr(8)(2:2)=char(240)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_turkish

subroutine locale_POSIX()
! LANG=POSIX
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "Mon","Tue","Wed","Thu","Fri","Sat","Sun"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "Monday","Tuesday","Wednesday","Thursday","Friday","Saturday","Sunday"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "Jan","Feb","Mar","Apr","May","Jun", &
& "Jul","Aug","Sep","Oct","Nov","Dec" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "January","February","March","April","May","June", &
& "July","August","September","October","November","December" ]
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_POSIX

subroutine locale_eesti()
! LANG=eesti
! AM= PM=
character(len=20),save :: weekdays_abbr(7)=[character(len=20) :: &
& "E","T","K","N","R","L","P"]
character(len=20),save :: weekdays(7)=[character(len=20) :: &
& "esmaspev","teisipev","kolmapev","neljapev","reede","laupev","phapev"]
character(len=20),save :: months_abbr(12)=[character(len=20) :: &
& "jaan","veebr","mrts","apr","mai","juuni", &
& "juuli","aug","sept","okt","nov","dets" ]
character(len=20),save :: months(12)=[character(len=20) :: &
& "jaanuar","veebruar","mrts","aprill","mai","juuni", &
& "juuli","august","september","oktoober","november","detsember" ]
weekdays(1)(7:7)=char(228)
weekdays(2)(7:7)=char(228)
weekdays(3)(7:7)=char(228)
weekdays(4)(7:7)=char(228)
weekdays(6)(5:5)=char(228)
weekdays(7)(2:2)=char(252)
weekdays(7)(6:6)=char(228)
months(3)(2:2)=char(228)
 ! ASCII weekdays_abbr
months_abbr(3)(2:2)=char(228)
   call locale("user",months,weekdays,months_abbr,weekdays_abbr)
end subroutine locale_eesti
function get_env(name,default) result(value)
! a function that makes calling get_environment_variable(3) simple
implicit none
character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: default
character(len=:),allocatable         :: value
integer                              :: howbig
integer                              :: stat
integer                              :: length
   length=0
   value=''
   if(name.ne.'')then
      call get_environment_variable( name, &
      & length=howbig,status=stat,trim_name=.true.)
      select case (stat)
      case (1)
         !print *, name, " is not defined in the environment. Strange..."
         value=''
      case (2)
         !print *, "This processor does not support environment variables. Boooh!"
         value=''
      case default
         ! make string of sufficient size to hold value
         if(allocated(value))deallocate(value)
         allocate(character(len=max(howbig,1)) :: value)
         ! get value
         call get_environment_variable( &
         & name,value,status=stat,trim_name=.true.)
         if(stat.ne.0)value=''
      end select
   endif
   if(value.eq.''.and.present(default))value=default
end function get_env
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     phase_of_moon(3f) - [M_time:ASTROLOGICAL] return name for phase of
!!     moon for given date
!!     (LICENSE:MIT)
!!##SYNOPSIS
!!
!!   function phase_of_moon(dat)
!!
!!    integer,intent(in)            :: dat(8)
!!    character(len=:),allocatable  :: phase_of_moon
!!
!!##DESCRIPTION
!!   Phases Of The Moon
!!
!!   This procedure is used to support the %p field descriptor for the
!!   fmtdate(3f) routine.
!!
!!   The moon circles the earth every 29.530588853 days on average, so pick a
!!   starting point and count. A new moon occurred at Julian date 2451550.1
!!   (January 6, 2000, 18:14 UTC). Then it is easy to count the number of
!!   days since the last new moon. This is an approximate calculation.
!!
!!   There are eight generally recognized phases of the moon in common use
!!
!!    o new or dark
!!    o waxing crescent
!!    o first quarter
!!    o waxing gibbous
!!    o full
!!    o waning gibbous
!!    o last quarter
!!    o waning crescent
!!
!!   To calculate the phase of the moon simply divide the days since the
!!   last new moon by eight and select the appropriate phase.
!!
!!   Note that technically the four states (new, first quarter, full, third
!!   quarter) are events not phases. That is to say, the moon is technically
!!   only new for an instant.
!!
!!##EXAMPLES
!!
!!  Sample:
!!
!!   program demo_phase_of_moon
!!   use M_time, only : now
!!   use M_time, only : phase_of_moon
!!   use M_time, only : moon_fullness
!!   implicit none
!!   integer :: dat(8)
!!    ! generate DAT array
!!    call date_and_time(values=dat)
!!    ! show DAT array
!!    write(*,'(" Today is:",*(i0:,":"))')dat
!!    ! the %p and %P fields are supported by fmtdate(3f)
!!    write(*,*)&
!!    & now('The phase of the moon is %p, with a fullness of %P')
!!    write(*,'(1x,*(a))',advance='no')&
!!    & 'The phase of the moon is ',trim( phase_of_moon(dat)),','
!!    write(*,'(1x,a,i0,a)')'with a fullness of ',moon_fullness(dat),'%'
!!   end program demo_phase_of_moon
!!
!!  Sample output:
!!
!!     Today is:2018:11:3:-240:20:18:44:245
!!     The phase of the moon is Waning crescent, with a fullness of -30%
!!     The phase of the moon is Waning crescent, with a fullness of -30%
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function phase_of_moon(dat)

! ident_45="@(#) M_time phase_of_moon(3f) return name for phase of moon for given date"

integer,intent(in)            :: dat(8)
character(len=:),allocatable  :: phase_of_moon

real(kind=realtime),parameter :: syndonic_month=29.530588853_realtime ! average period of a lunar cycle, or days per lunation
integer,parameter             :: reference(*)= [2000,1,6,0,18,14,0,0] ! new moon of January 2000 was January 6, 18:14 UTC.
character(len=15),parameter   :: phase_names(*)=[ "New            ", "Waxing crescent", &
                                                  "First quarter  ", "Waxing gibbous ", &
                                                  "Full           ", "Waning gibbous ", &
                                                  "Last quarter   ", "Waning crescent"  ]
real(kind=realtime),parameter :: phase_length=syndonic_month/8_realtime  ! days per phase
integer                       :: phase
real(kind=realtime)           :: days

days= d2j(dat)-d2j(reference)                               ! days between reference date and input date
days = mod(days + phase_length/2.0_dp, syndonic_month)        ! modulo calculation of which phase rounding up
if(days<0)days=days+syndonic_month                         ! correct for days before reference date
phase = int( days * ( size(phase_names) / syndonic_month ))+1 ! index into phase names
phase_of_moon=trim(phase_names(phase))

end function phase_of_moon
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!     moon_fullness(3f) - [M_time:ASTROLOGICAL] return percentage of moon phase
!!     from new to full
!!     (LICENSE:MIT)
!!##SYNOPSIS
!!
!!   function moon_fullness(dat)
!!
!!    integer,intent(in) :: dat(8)
!!    integer            :: moon_fullness
!!
!!##DESCRIPTION
!!
!!   This procedure is used to support the %P field descriptor for the
!!   fmtdate(3f) routine.
!!
!!   The moon circles the earth every 29.530588853 days on average, so pick
!!   a starting point and count. A new moon occurred at January 6, 2000,
!!   18:14 UTC. Then it is easy to count the number of days since the last
!!   new moon. This is an approximate calculation.
!!
!!##OPTIONS
!!
!!    dat    DAT Date array describing input date
!!
!!##RESULTS
!!
!!    moon_fullness  0 is a new or dark moon, 100 is a full moon, + for waxing
!!                   and - for waning.
!!
!!##EXAMPLES
!!
!!    Sample:
!!
!!     program demo_moon_fullness
!!     use M_time, only : now
!!     use M_time, only : phase_of_moon
!!     use M_time, only : moon_fullness
!!     implicit none
!!     integer :: dat(8)
!!        ! generate DAT array
!!        call date_and_time(values=dat)
!!        ! show DAT array
!!        write(*,'(" Today is:",*(i0:,":"))')dat
!!        ! the %p and %P fields are supported by fmtdate(3f)
!!        write(*,*)&
!!        &now('The phase of the moon is %p, with a fullness of %P')
!!        write(*,'(1x,*(a))',advance='no')&
!!        &'The phase of the moon is ',trim( phase_of_moon(dat)),','
!!        write(*,'(1x,a,i0,a)')&
!!        &'with a fullness of ', moon_fullness(dat),'%'
!!     end program demo_moon_fullness
!!
!!    Sample output:
!!
!!      Today is:2018:11:3:-240:20:18:44:245
!!      The phase of the moon is Waning crescent, with a fullness of -30%
!!      The phase of the moon is Waning crescent, with a fullness of -30%
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
function moon_fullness(dat)

! ident_46="@(#) M_time moon_fullness(3f) return percentage of moon phase from new to full"

integer,intent(in)            :: dat(8)
integer                       :: moon_fullness

real(kind=realtime),parameter :: syndonic_month=29.530588853_realtime  ! average period of a lunar cycle, or days per lunation
integer,parameter             :: reference(*)= [2000,1,6,0,18,14,0,0]  ! new moon of January 2000 was January 6, 18:14 UTC.
real(kind=realtime)           :: days_into_cycle

days_into_cycle = mod(d2j(dat)-d2j(reference) , syndonic_month)        ! number of days into lunar cycle
if(days_into_cycle<0)days_into_cycle=days_into_cycle+syndonic_month    ! correct for input date being before reference date

if(days_into_cycle<=syndonic_month/2.0_realtime)then                   ! if waxing from new to full report as 0% to 100%
   moon_fullness=int((days_into_cycle/syndonic_month)*200.0_realtime+0.5_realtime)
else                                                                   ! if waning from full to new report as -99% to -1%
   moon_fullness=-(200-int((days_into_cycle/syndonic_month)*200.0_realtime))
endif

end function moon_fullness
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    easter(3f) - [M_time:ASTROLOGICAL] calculate date for Easter given a year
!!    (LICENSE:MIT)
!!
!!##SYNOPSIS
!!
!!   subroutine easter(year,dat)
!!
!!     integer, intent(in)  :: year
!!     integer, intent(out) :: dat
!!
!!##DESCRIPTION
!!   The Date of Easter (Sunday)
!!
!!   The algorithm is due to J.-M. Oudin (1940) and is reprinted
!!   in the Explanatory Supplement to the Astronomical Almanac,
!!   ed. P. K. Seidelmann (1992). See Chapter 12, "Calendars", by
!!   L. E. Doggett.
!!
!!   The following are dates of Easter from 1980 to 2024:
!!
!!        1980  April  6        1995  April 16        2010  April  4
!!        1981  April 19        1996  April  7        2011  April 24
!!        1982  April 11        1997  March 30        2012  April  8
!!        1983  April  3        1998  April 12        2013  March 31
!!        1984  April 22        1999  April  4        2014  April 20
!!        1985  April  7        2000  April 23        2015  April  5
!!        1986  March 30        2001  April 15        2016  March 27
!!        1987  April 19        2002  March 31        2017  April 16
!!        1988  April  3        2003  April 20        2018  April  1
!!        1989  March 26        2004  April 11        2019  April 21
!!        1990  April 15        2005  March 27        2020  April 12
!!        1991  March 31        2006  April 16        2021  April  4
!!        1992  April 19        2007  April  8        2022  April 17
!!        1993  April 11        2008  March 23        2023  April  9
!!        1994  April  3        2009  April 12        2024  March 31
!!
!!   N.B. The date of Easter for the Eastern Orthodox Church may be different.
!!
!!##OPTIONS
!!      year    Year for which to calculate day that Easter falls on
!!##RESULTS
!!      dat     Date array for noon on Easter for the specified year
!!
!!##EXAMPLE
!!
!!
!!    Sample program:
!!
!!     program demo_easter
!!     use M_time, only : easter, fmtdate
!!     implicit none
!!     integer :: year
!!     integer :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond
!!       call date_and_time(values=dat)  ! get current year
!!       year=dat(1)
!!       call easter(year, dat)
!!       write(*,*)fmtdate(dat,&
!!       "Easter day: the %d day of %L in the year of our Lord %Y")
!!     end program demo_easter
!!
!!    Sample output:
!!
!!     Easter day: the 16th day of April in the year of our Lord 2017
!>
!!
!!   U.S. Naval Observatory Astronomical Applications Department
!!
!!   This code assembled by Alan Miller
!!   Reference web site:
!!   http://aa.usno.navy.mil/faq/docs/easter.html
!!   Latest revision 8 April 2002
SUBROUTINE Easter(year, dat)

! ident_47="@(#) M_time easter(3f) calculate date for Easter given a year"

integer,intent(in)  :: year
integer,intent(out) :: dat(8) ! year,month,day,tz,hour,minute,second,millisecond
integer             :: day, month
integer             :: c, i, j, k, l, n

   c = year / 100
   n = year - 19 * ( year / 19 )
   k = ( c - 17 ) / 25
   i = c - c / 4 - ( c - k ) / 3 + 19 * n + 15
   i = i - 30 * ( i / 30 )
   i = i - (i / 28) * (1 - (i / 28) * (29 / (i + 1 )) * ( (21 - n) / 11) )
   j = year + year / 4 + i + 2 - c + c / 4
   j = j - 7 * ( j / 7 )
   l = i - j
   month = 3 + ( l + 40 ) / 44
   day = l + 28 - 31 * ( month / 4 )

   ! fill out a date_and_time array
   dat=getnow() ! get current year
   dat=[year,month,day,dat(4),12,0,0,0]

end subroutine Easter
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!
!   XXXX
!  X    X
! X
! X
! X
! X
! X
!  X    X
!   XXXX
!
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    system_sleep(3f) - [M_time:C_INTERFACE] call C sleep(3c) or usleep(3c)
!!    procedure
!!    (LICENSE:MIT)
!!##SYNOPSIS
!!
!!    subroutine system_sleep(wait_seconds)
!!
!!       integer,intent(in)  :: wait_seconds
!!          or
!!       real,intent(in)  :: wait_seconds
!!
!!##DESCRIPTION
!!   The system_sleep(3f) routine uses the intrinsic ISO_C_BINDING
!!   interface to call the C sleep(3c) procedure or usleep(3c)
!!   routine.
!!
!!##OPTIONS
!!    wait_seconds  integer,real or doubleprecision number of seconds for
!!                  process to sleep.
!!
!!##EXAMPLE
!!
!!    Sample program:
!!
!!     program demo_system_sleep
!!     use M_time, only : system_sleep, now
!!     implicit none
!!     integer :: i
!!        !
!!        write(*,'(a)')"Time before integer call is: ",now()
!!        call system_sleep(4)
!!        write(*,'(a)')"Time after integer call is: ",now()
!!        !
!!        write(*,'(a)')"Time before real call is: ",now()
!!        call system_sleep(4.0)
!!        write(*,'(a)')"Time after real call is: ",now()
!!        !
!!        write(*,'(a)')"Time before loop is: ",now()
!!        do i=1,1000
!!           call system_sleep(4.0/1000.0)
!!        enddo
!!        write(*,'(a)')"Time after loop is: ",now()
!!        !
!!     end program demo_system_sleep
!!
!!  results
!!
!!      Time before integer call is:
!!      Sunday, July 17th, 2016 2:29:45 AM UTC-0240
!!      Time after integer call is:
!!      Sunday, July 17th, 2016 2:29:49 AM UTC-0240
!!      Time before real call is:
!!      Sunday, July 17th, 2016 2:29:49 AM UTC-0240
!!      Time after real call is:
!!      Sunday, July 17th, 2016 2:29:53 AM UTC-0240
!!      Time before loop is:
!!      Sunday, July 17th, 2016 2:29:53 AM UTC-0240
!!      Time after loop is:
!!      Sunday, July 17th, 2016 2:30:09 AM UTC-0240
!!
!!##AUTHOR
!!    John S. Urban, 2015
!!
!!##LICENSE
!!    MIT
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine system_sleep(seconds)
use,intrinsic       :: iso_c_binding, only: c_int

! ident_48="@(#) M_time system_sleep(3f) call sleep(3c) or usleep(3c)"

class(*),intent(in) :: seconds
integer(kind=c_int) :: cint
   select type(seconds)
   type is (integer);             cint=seconds                    ; call call_sleep(cint)
   type is (real);                cint=nint(seconds*1000000.0_dp) ; call call_usleep(cint)
   type is (real(kind=realtime)); cint=nint(seconds*1000000.0_dp) ; call call_usleep(cint)
   end select
end SUBROUTINE system_sleep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine call_sleep(wait_seconds)
use,intrinsic                   :: iso_c_binding, only: c_int

! ident_49="@(#) M_time call_sleep(3fp) call sleep(3c)"

integer(kind=c_int),intent(in)  :: wait_seconds
integer(kind=c_int)             :: how_long
interface
   function c_sleep(seconds) bind (C,name="sleep")
      import
      integer(c_int)       :: c_sleep ! should be unsigned int (not available in Fortran). OK until highest bit gets set.
      integer(c_int), intent(in), VALUE :: seconds
   end function c_sleep
end interface
   if(wait_seconds>0)then
      how_long=c_sleep(wait_seconds)
   endif
end subroutine call_sleep
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
subroutine call_usleep(milliseconds)

! ident_50="@(#) M_time call_usleep(3fp) call usleep(3c)"

use,intrinsic                   :: iso_c_binding, only: c_int
integer(kind=c_int),intent(in)  :: milliseconds
integer(kind=c_int)             :: status
interface
   function c_usleep(mseconds) bind (C,name="usleep")
      import
      integer(c_int)       :: c_usleep ! should be unsigned int (not available in Fortran). OK until highest bit gets set.
      integer(c_int), intent(in), VALUE :: mseconds
   end function c_usleep
end interface
   if(milliseconds>0)then
      status=c_usleep(milliseconds)
   endif
end subroutine call_usleep
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
function getnow() result(dat)

! ident_51="@(#) M_time getnow(3f) get DAT for current time or value of SOURCE_DATE_EPOCH"

integer :: dat(8)
   call date_and_time(values=dat)
   ! VALUES : An array of at least eight elements. If there is no data
   ! available for a value it is set to -HUGE(VALUES). Otherwise, it contains:
   !      VALUES(1) : The year, including the century.
   !      VALUES(2) : The month of the year
   !      VALUES(3) : The day of the month
   !      VALUES(4) : Time difference in minutes between the reported time and UTC time.
   !      VALUES(5) : The hour of the day, in the range 0 to 23.
   !      VALUES(6) : The minutes of the hour, in the range 0 to 59
   !      VALUES(7) : The seconds of the minute, in the range 0 to 60
   !      VALUES(8) : The milliseconds of the second, in the range 0 to 999.
   if(any(dat == -huge(0)))then
      write(stderr,"('<ERROR>*getnow*: date_and_time(3f) contains unsupported values')")
      stop 3
   endif
end function getnow
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_time
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_framework/src/M_framework__approx.F90
#ifdef __NVCOMPILER
#undef HAS_REAL128
#else
#define HAS_REAL128
#endif
module M_framework__approx
use, intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64 !  1           2           4           8
use, intrinsic :: iso_fortran_env,  only : real32, real64, real128   !  4           8          10
use, intrinsic :: iso_fortran_env,  only : ERROR_UNIT,OUTPUT_UNIT    ! access computing environment
implicit none
private
! COMPARING AND ROUNDING FLOATING POINT VALUES
public  :: almost          ! function compares two numbers only up to a specified number of digits
public  :: accdig          ! compare two real numbers only up to a specified number of digits
public  :: in_margin       ! check if two reals are approximately equal using a relative margin
public  :: round_to_power  ! round val to specified number of digits after the decimal point
public  :: round           ! round val to specified number of significant digits
public  :: significant     ! round val to specified number of significant digits
public  :: compare_float
public  :: change_default_ulp
public  :: operator (.equalto.)
public  :: operator (.greaterthan.)
public  :: operator (.lessthan.)
!===========================
! deprecated
public  :: sp_accdig       ! compare two real numbers only up to a specified number of digits
public  :: dp_accdig       ! compare two double numbers or other kinds only up to a specified number of digits
interface dp_accdig        ! for backward compatibility, accdig(3f) preferred
   module procedure accdig
end interface dp_accdig
!===========================

interface significant
   module procedure significant_real32
   module procedure significant_real64
end interface significant

private :: anyscalar_to_realbig_
private :: anyscalar_to_double_

interface compare_float
   module procedure compare_float_real32
   module procedure compare_float_real64
#ifdef HAS_REAL128
   module procedure compare_float_real128
#endif
end interface compare_float

interface operator (.equalto.)
   module procedure is_equal_to_real32
   module procedure is_equal_to_real64
#ifdef HAS_REAL128
   module procedure is_equal_to_real128
#endif
end interface operator (.equalto.)

interface operator (.greaterthan.)
   module procedure is_greater_than_real32
   module procedure is_greater_than_real64
#ifdef HAS_REAL128
   module procedure is_greater_than_real128
#endif
end interface operator (.greaterthan.)

interface operator (.lessthan.)
   module procedure is_less_than_real32
   module procedure is_less_than_real64
#ifdef HAS_REAL128
   module procedure is_less_than_real128
#endif
end interface operator (.lessthan.)

real(kind=real64),save,private :: default_ulp=1.0_real64

contains
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    almost(3f) - [M_framework__approx] return true or false if two numbers
!!    agree up to specified number of digits
!!    (LICENSE:PD)
!!##SYNOPSIS
!!
!!    elemental impure function almost(x,y,digits,verbose)
!!
!!     class(*),intent(in)         :: x,y
!!     class(*),intent(in)         :: rdigits
!!     logical,intent(in),optional :: verbose
!!     logical                     :: almost
!!
!!##DESCRIPTION
!!    Returns true or false depending on whether the two numbers given agree
!!    to within the specified number of digits as calculated by ACCDIG(3f).
!!##OPTIONS
!!    x,y      expected and calculated values to be compared. May be of
!!             type REAL, INTEGER, or DOUBLEPRECISION.
!!    rdigits  number of digits of precision to compare. May be INTEGER or
!!             REAL.
!!    verbose  optional value that specifies to print the results of the
!!             comparison when set to .TRUE..
!!##RETURNS
!!    almost   TRUE if the input values compare up to the specified number
!!             of values
!!##EXAMPLES
!!
!!   sample:
!!
!!    program demo_almost
!!    use M_framework__approx, only : almost
!!    implicit none
!!    real    :: x, y
!!    logical :: z
!!    integer :: i
!!    x=1.2345678
!!    y=1.2300000
!!    do i=1,8
!!       z=almost(x,y,i,verbose=.true.)
!!       write(*,*)i,z
!!    enddo
!!    end program demo_almost
!!
!!   Results:
!!
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 1.00000000
!!     >            1 T
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 2.00000000
!!     >            2 T
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 3.00000000
!!     >            3 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 4.00000000
!!     >            4 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 5.00000000
!!     >            5 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 6.00000000
!!     >            6 F
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 7.00000000
!!     >            7 F
!!     > *sp_accdig* significant digit request too high= 8.00000000
!!     > *almost* for values 1.23456776 1.23000002 agreement of 2.43020344 ...
!!     > digits out of requested 8.00000000
!!     >            8 F
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
elemental impure function almost(x,y,digits,verbose)
use M_framework__journal,  only : journal

! ident_1="@(#) M_framework__approx almost(3f) function compares two real numbers up to specified number of digits by calling ACCDIG(3f)"

class(*),intent(in)         :: x,y
class(*),intent(in)         :: digits
logical,intent(in),optional :: verbose
logical                     :: almost

logical                     :: verbose_local
real                        :: acurcy
real                        :: digits_local
integer                     :: ind

   if(present(verbose))then
      verbose_local=verbose
   else
      verbose_local=.false.
   endif

   digits_local=anyscalar_to_realbig_(digits)
   acurcy=0.0
   select type(x)
   type is(real)
      select type(y)
      type is(real)
         call accdig(x,y,digits_local,acurcy,ind)
         if(verbose_local)then
            call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
         endif
      class default
         call accdig(x,y,digits_local,acurcy,ind)
         if(verbose_local)then
            call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
         endif
      end select
   class default
      call accdig(x,y,digits,acurcy,ind)
      if(verbose_local)then
         call journal('sc','*almost*','for values',x,y,'agreement of',acurcy,'digits out of requested',digits_local)
      endif
   end select

   if(ind == 0)then
      almost=.true.
   else
      almost=.false.
   endif

end function almost
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!    sp_accdig(3f) - [M_framework__approx] compare two real numbers of
!!    default kind only up to a specified number of digits
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       subroutine sp_accdig(x,y,digio,acurcy,ind)
!!
!!        real,intent(in)     :: X
!!        real,intent(in)     :: Y
!!        real,intent(in)     :: DIGI0
!!        real,intent(out)    :: acurcy
!!        integer,intent(out) :: ind
!!
!!##DESCRIPTION
!!    This procedure is used to check how closely two numbers agree.
!!
!!       call sp_accdig(X,Y,DIGI0,ACURCY,IND)
!!
!!    The values X and Y are the numbers to compare, and DIGI0 is the
!!    threshold number of digits to consider significant in returning IND.
!!
!!    If X and Y are considered equal within DIGI0 relative tolerance,
!!
!!        IND    = 0, if tolerance is     satisfied.
!!               = 1, if tolerance is not satisfied.
!!
!!    The result ACURCY gives a measure of the number of leading digits in X
!!    which are the same as the number of leading digits in Y.
!!
!!            ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0
!!            ACURCY=-log10(X-Y)       if X != Y and Y = 0
!!            ACURCY=8                 if X=Y
!!
!!            ACURCY is never less than -8 or greater than 8
!!
!!    TOLERANCE ...
!!         X and Y are considered equal within DIGI0 relative tolerance,
!!         if ACURCY is greater than DIGI0.
!!
!!    For example, Take some numbers and compare them to 1.2345678 ...
!!
!!        > ================================================
!!        > A number     |    ACURCY       |   ACURCY
!!        >              |    1.2345678=Y  |   1.2345678=X
!!        > ================================================
!!        >  1.234680    |    3.7900571    |   3.7901275
!!        >  1.2345378   |    4.6144510    |   4.6144404
!!        >  2.2234568   |    0.096367393  |   0.35188114
!!        >  1.2345678   |    8.0000000    |   8.0000000
!!        >  1.2345679   |    7.0732967    |   7.0731968
!!        > -1.2345678   |   -0.30103000   |  -0.30103000
!!        > 76.234567    |   -1.7835463    |   0.0070906729
!!        >  2.4691356   |    0.0          |   0.3010300
!!        >  0.0         |    0.0          |  -0.91514942.
!!
!!    Due to the typical limits of the log function, the number of
!!    significant digits in the result is best considered to be three.
!!
!!    Notice that 1.2345678=Y produces different values than 1.2345678=X
!!
!!    A negative result indicates the two values being compared either do
!!    not agree in the first digit or they differ with respect to sign. An
!!    example of two numbers which do not agree in their leading digit (and
!!    actually differ in order of magnitude) is given above by X=76.234567
!!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of
!!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678;
!!    here the accuracy reported is -0.30103000.
!!
!!##EXAMPLES
!!
!!
!!   Example program:
!!
!!    program demo_sp_accdig ! fortran 90 example
!!    use M_framework__approx, only : sp_accdig
!!    implicit none
!!    integer :: digi
!!    integer :: i10, i20, i30
!!    integer :: ind, ind1, ind2
!!    real    :: acurcy, acurcy1, acurcy2
!!    real    :: a, b
!!    real    :: vals(9)
!!    data vals/ &
!!      &1.234680,   1.2345378,  2.2234568, 1.2345678, &
!!      &1.2345679, -1.2345678, 76.234567,  2.4691356, &
!!      &0.0/
!!       write(*,*)'========================='
!!       do i10=0,16
!!          a=1.0
!!          b=a+1.0/(10.0**i10)
!!          call sp_accdig(a,b,8.0,acurcy,ind)
!!          write(*,*)i10,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       digi=16
!!       do i20=0,digi
!!          a=1.0
!!          b=a+1.0/(10.0**i20)
!!          call sp_accdig(a,b,real(digi),acurcy,ind)
!!          write(*,*)i20,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       do i30=1,9
!!          call sp_accdig(1.2345678,vals(i30),8.0,acurcy1,ind1)
!!          call sp_accdig(vals(i30),1.2345678,8.0,acurcy2,ind2)
!!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2
!!       enddo
!!    end program demo_sp_accdig
!!
!!##REFERENCES
!!
!!   based on ...
!!
!!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. accdig V 7.00  2/14/90. **
!!       David Hogben,
!!       Statistical Engineering Division,
!!       Center for Computing and Applied Mathematics,
!!       A337 Administration Building,
!!       National Institute of Standards and Technology,
!!       Gaithersburg, MD 20899
!!                      TELEPHONE 301-975-2845
!!           ORIGINAL VERSION -  October, 1969.
!!            CURRENT VERSION - February, 1990.
!!            JSU     VERSION - February, 1991.
!!
!!##DEPENDENCIES
!!    o M_framework__journal(),log10(), abs(1)
!!
!!##AUTHOR
!!    David Hogben, John S. Urban
!!
!!##LICENSE
!!    Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE sp_accdig(X,Y,digi0,ACURCY,IND)
use M_framework__journal, only : journal
implicit none

! ident_2="@(#) M_framework__approx sp_accdig(3f) compare two real numbers only up to a specified number of digits"

!     INPUT ...
real,intent(in) :: x           ! First  of two real numbers to be compared.
real,intent(in) :: y           ! Second of two real numbers to be compared.
real,intent(in) :: digi0       ! Number of digits to be satisfied in relative tolerance.
!     OUTPUT ...
real,intent(out)    :: acurcy  ! = -LOG10(ABS((X-Y)/Y)))
integer,intent(out) :: ind     ! = 0, If tolerance is     satisfied.
! = 1, If tolerance is not satisfied.

real     :: diff
real     :: digi
integer,parameter  :: ireal_significant_digits = int(log10(2.**digits(0.0))) ! maximum number of significant digits in a real number.

   digi=digi0
   if(digi <= 0)then
      call journal('sc','*sp_accdig* bad number of significant digits=',digi)
      digi=ireal_significant_digits
   elseif(digi  >  ireal_significant_digits)then
      call journal('sc','*sp_accdig* significant digit request too high=',digi)
      digi=min(digi,real(ireal_significant_digits))
   endif

   diff = x - y
   if(diff  ==  0.0) then
      acurcy = ireal_significant_digits
   elseif(y  ==  0.0) then
      acurcy = -log10(abs(x))
   else
      acurcy = -log10(abs(diff)) + log10(abs(y))
   endif

   if(acurcy  <  digi ) then
      ind = 1
   else
      ind = 0
   endif

END SUBROUTINE sp_accdig
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!      accdig(3f) - [M_framework__approx] compare two numbers only up to
!!      a specified number of digits
!!      (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!       elemental impure subroutine accdig(x,y,digio,acurcy,ind)
!!
!!        class(*),intent(in)  :: X
!!        class(*),intent(in)  :: Y
!!        class(*),intent(in)  :: DIGI0
!!        real,intent(out)     :: acurcy
!!        integer,intent(out)  :: ind
!!
!!##DESCRIPTION
!!
!!    This procedure is used to check how closely two numbers agree.
!!
!!       call accdig(X,Y,DIGI0,ACURCY,IND)
!!
!!    The values X and Y are the numbers to compare, and DIGI0 is the
!!    threshold number of digits to consider significant in returning IND.
!!
!!    If X and Y are considered equal within DIGI0 relative tolerance,
!!
!!        IND    = 0, if tolerance is     satisfied.
!!               = 1, if tolerance is not satisfied.
!!
!!    The result ACURCY gives a measure of the number of leading digits in X
!!    which are the same as the number of leading digits in Y.
!!
!!         ACURCY=-log10((X-Y)/Y)   if X != Y and Y != 0
!!         ACURCY=-log10(X-Y)       if X != Y and Y = 0
!!         ACURCY=8                 if X=Y
!!
!!         ACURCY is never less than -8 or greater than 8 for 32-bit REAL values
!!
!!    TOLERANCE ...
!!         X and Y are considered equal within DIGI0 relative tolerance,
!!         if ACURCY is greater than DIGI0.
!!
!!    For example, Take some numbers and compare them  to 1.2345678 ...
!!
!!       >  ================================================
!!       >  A number     |    ACURCY       |   ACURCY
!!       >               |    1.2345678=Y  |   1.2345678=X
!!       >  ================================================
!!       >   1.234680    |    3.7900571    |   3.7901275
!!       >   1.2345378   |    4.6144510    |   4.6144404
!!       >   2.2234568   |    0.096367393  |   0.35188114
!!       >   1.2345678   |    8.0000000    |   8.0000000
!!       >   1.2345679   |    7.0732967    |   7.0731968
!!       >  -1.2345678   |   -0.30103000   |  -0.30103000
!!       >  76.234567    |   -1.7835463    |   0.0070906729
!!       >   2.4691356   |    0.0          |   0.3010300
!!       >   0.0         |    0.0          |  -0.91514942.
!!
!!    Due to the typical limits of the log function, the number of
!!    significant digits in the result is best considered to be three.
!!
!!    Notice that 1.2345678=Y produces different values than 1.2345678=X
!!
!!    A negative result indicates the two values being compared either do
!!    not agree in the first digit or they differ with respect to sign. An
!!    example of two numbers which do not agree in their leading digit (and
!!    actually differ in order of magnitude) is given above by X=76.234567
!!    and Y=1.2345678; the accuracy reported is -1.7835463. An example of
!!    two numbers which do not agree in sign in X=-1.2345678 and Y=1.2345678;
!!    here the accuracy reported is -0.30103000.
!!
!!##EXAMPLES
!!
!!
!!   Example program:
!!
!!    program demo_accdig ! fortran 90 example
!!    use M_framework__approx, only : accdig
!!    implicit none
!!    integer         :: digi
!!    doubleprecision :: a, b
!!    integer         :: i10, i20, i30
!!    integer         :: ind, ind1, ind2
!!    real            :: acurcy, acurcy1, acurcy2
!!    doubleprecision :: vals(9)
!!    data vals/ &
!!      &1.234680d0,   1.2345378d0,  2.2234568d0, 1.2345678d0, &
!!      &1.2345679d0, -1.2345678d0, 76.234567d0,  2.4691356d0, &
!!      &0.0d0/
!!       write(*,*)'========================='
!!       do i10=0,16
!!          a=1.0d0
!!          b=a+1.0d0/(10.0d0**i10)
!!          call accdig(a,b,8.0,acurcy,ind)
!!          write(*,*)i10,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       digi=16
!!       do i20=0,digi
!!          a=1.0d0
!!          b=a+1.0d0/(10.0d0**i20)
!!          call accdig(a,b,dble(digi),acurcy,ind)
!!          write(*,*)i20,a,b,acurcy,ind
!!       enddo
!!       write(*,*)'========================='
!!       do i30=1,9
!!          call accdig(1.2345678d0,vals(i30),8.0,acurcy1,ind1)
!!          call accdig(vals(i30),1.2345678d0,8.0,acurcy2,ind2)
!!          write(*,*)i30,vals(i30),acurcy1,acurcy2,ind1,ind2
!!       enddo
!!    end program demo_accdig
!!
!!##NOTES
!!##REFERENCES
!!
!!   based on ...
!!
!!    NBS OMNITAB 1980 VERSION 6.01  1/ 1/81. dp_accdig V 7.00  2/14/90. **
!!       David Hogben,
!!       Statistical Engineering Division,
!!       Center for Computing and Applied Mathematics,
!!       A337 Administration Building,
!!       National Institute of Standards and Technology,
!!       Gaithersburg, MD 20899
!!                      TELEPHONE 301-975-2845
!!           ORIGINAL VERSION -  October, 1969.
!!            CURRENT VERSION - February, 1990.
!!            JSU     VERSION - February, 1991.
!!
!!##DEPENDENCIES
!!         o M_framework__journal(), log10(), abs(1)
!!
!!##AUTHORS
!!      David Hogben, John S. Urban
!!
!!##LICENSE
!!      Public Domain
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
elemental impure SUBROUTINE accdig(x,y,digi0,ACURCY,IND)
#ifdef HAS_REAL128
use,intrinsic :: iso_fortran_env, only : wp=>real128
#else
use,intrinsic :: iso_fortran_env, only : wp=>real64
#endif
use M_framework__journal,  only : journal
implicit none

! ident_3="@(#) M_framework__approx accdig(3f) compare two values only up to a specified number of digits"

!  INPUT ...
class(*),intent(in)  :: x           ! FIRST  OF TWO NUMBERS TO BE COMPARED.
class(*),intent(in)  :: y           ! SECOND OF TWO NUMBERS TO BE COMPARED.
class(*),intent(in)  :: digi0       ! NUMBER OF DIGITS TO BE SATISFIED IN RELATIVE TOLERANCE.
real(kind=wp)        :: x_local
real(kind=wp)        :: y_local
!  OUTPUT ...
real,intent(out)     :: acurcy      ! = -LOG10(ABS((x_local-y_local)/y_local)))
integer,intent(out)  :: ind         ! = 0, IF TOLERANCE IS     SATISFIED.
                                    ! = 1, IF TOLERANCE IS NOT SATISFIED.
real(kind=wp)        :: diff
real(kind=wp)        :: digi
                        ! Maximum number of significant digits in a number of biggest real kind.
integer,parameter    :: idble_significant_digits = int(log10(2.0_wp**digits(0.0_wp)))

   x_local=anyscalar_to_realbig_(x)
   y_local=anyscalar_to_realbig_(y)
   digi=anyscalar_to_realbig_(digi0)

   if(digi <= 0)then
      call journal('sc','*accdig* bad number of significant digits=',real(digi,kind=wp))
      digi=idble_significant_digits
   elseif(digi  >  idble_significant_digits)then
      call journal('sc','*accdig* significant digit request too high=',real(digi,kind=wp))
      digi=min(digi,real(idble_significant_digits,kind=wp))
   endif
   diff = x_local - y_local
   if(diff  ==  0.0_wp) then
      acurcy = idble_significant_digits
   elseif(y_local  ==  0.0_wp) then
      acurcy = -log10(abs(x_local))
   else
      acurcy = -log10(abs(diff)) + log10(abs(y_local))
   endif
   if(acurcy  <  digi ) then
      ind = 1
   else
      ind = 0
   endif
end subroutine accdig
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
!>
!!##NAME
!!   in_margin(3f) - [M_framework__approx] check if two reals are
!!   approximately equal using a relative margin
!!
!!##SYNOPSIS
!!
!!     elemental pure function in_margin( expected_value, measured_value,
!!     allowed_margin )
!!
!!      real, intent(in)    :: expected_value
!!      real, intent(in)    :: measured_value
!!      real, intent(in)    :: allowed_margin
!!      class(*),intent(in) :: invalue
!!
!!##DESCRIPTION
!!   Compare two values to see if they are relatively equal using the
!!   specified allowed margin. That is, see if VALUE_MEASURED is in
!!   the range VALUE_EXPECTED +- ALLOWED_ERROR where the allowed error
!!   varies with the magnitude of the values, such that the allowed error
!!   is margin * average magnitude of measured and expected).
!!
!!   So the allowed error is smaller when the magnitudes are smaller.
!!
!!##OPTIONS
!!   expected_value   First value
!!   measured_value   Second value
!!   allowed_margin   Allowed relative margin
!!
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_in_margin
!!    use :: M_framework__approx, only : in_margin
!!    implicit none
!!    write(*,*) in_margin(4.00000,3.99999,0.000000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.00000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.0000001)
!!    write(*,*) in_margin(4.00000,3.99999,0.000001)
!!
!!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
!!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.000001)
!!    write(*,*) in_margin([4.0,40.0,400.0,4000.0,40000.0], &
!!            & [3.9,39.9,399.9,3999.9,39999.9] ,0.00001)
!!
!!    write(*,*) in_margin(4.00000,3.99999,0.00001)
!!    write(*,*) in_margin(4.00000,3.99999,0.0001)
!!    write(*,*) in_margin(4.00000,3.99999,0.001)
!!    write(*,*) in_margin(4.00000,3.99999,0.01)
!!
!!    end program demo_in_margin
!!
!!   Results:
!!
!!        > F
!!        > F
!!        > F
!!        > F
!!        > F F F F F
!!        > F F F F T
!!        > T
!!        > T
!!        > T
!!        > T
!===================================================================================================================================
elemental impure function in_margin(expected_value, measured_value, allowed_margin)
implicit none

! ident_4="@(#) M_framework__approx in_margin(3f) check if two reals are approximately equal using a relative margin"

class(*),intent(in) :: expected_value, measured_value, allowed_margin
logical             :: in_margin

   doubleprecision     :: expected, measured, margin

   expected=anyscalar_to_double_(expected_value)
   measured=anyscalar_to_double_(measured_value)
   margin=anyscalar_to_double_(allowed_margin)

   if ( abs(expected-measured) > 0.50d0 * margin * (abs(expected)+abs(measured)) ) then
      in_margin=.false.  ! values not comparable
   else
      in_margin=.true.   ! values comparable
   endif

end function in_margin
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function round_to_power(val,n)

! ident_5="@(#) M_framework__approx round_to_power(3f) round val to specified given decimal (power) position"

real,intent(in) :: val
integer,intent(in) :: n
real :: round_to_power
   round_to_power = anint(val*10.0**n)/10.0**n
end function round_to_power
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
function round(val,idigits0)
implicit none

! ident_6="@(#) M_framework__approx round(3f) round val to specified number of significant digits"

integer,parameter          :: dp=kind(0.0d0)
real(kind=dp),intent(in)   :: val
integer,intent(in)         :: idigits0
   integer                 :: idigits,ipow
   real(kind=dp)           :: aval,rnormal
   real(kind=dp)           :: round
!  this does not work very well because of round-off errors.
!  Make a better one, probably have to use machine-dependent bit shifting
   ! make sure a reasonable number of digits has been requested
   idigits=max(1,idigits0)
   aval=abs(val)
!  select a power that will normalize the number
!  (put it in the range 1 > abs(val) <= 0)
   if(aval >= 1)then
      ipow=int(log10(aval)+1)
   else
      ipow=int(log10(aval))
   endif
   rnormal=val/(10.0d0**ipow)
   if(rnormal == 1)then
      ipow=ipow+1
   endif
   !normalize, multiply by 10*idigits to an integer, and so on
   round=real(anint(val*10.d0**(idigits-ipow)))*10.d0**(ipow-idigits)
end function round
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!   significant(3f) - [M_framework__approx] round val to specified number
!!   of significant digits
!!
!!##SYNOPSIS
!!
!!     pure elemental function significant(val,digits,round)
!!
!!      real,intent(in)                      :: val
!!      integer,intent(in)                   :: digits
!!      character(len=*),intent(in),optional :: round
!!      real                                 :: significant
!!
!!##DESCRIPTION
!!
!! Round real value to specified number of significant digits
!!
!!##OPTIONS
!!
!! val     value to round
!! digits  number of significant digits to produce
!! round   Use the round edit descriptor
!!
!!           RU  UP : the value resulting from conversion shall be the
!!                    smallest representable value that is greater than or
!!                    equal to the original value
!!           RD  DOWN : the value resulting from conversion shall be the
!!                    largest representable value that is less than or
!!                    equal to the original value
!!           RZ  ZERO : the value resulting from conversion shall be the value
!!                    closest to the original value and no greater in
!!                    magnitude than the original value.
!!           RN  NEAREST : modeis NEAREST,thevalueresulting from conversion
!!                        shall be the closer of the two nearest
!!                        representable values if one is closer than the
!!                        other. If the two nearest representable values
!!                        are equidistant from the original value, it is
!!                        processor dependent which one of them is chosen.
!!           RC  COMPATIBLE : the value resulting from conversion shall be
!!                          the closer of the two nearest representable
!!                          values or the value away from zero if halfway
!!                          between them.
!!           RP  PROCESSOR_DEFINED : rounding during conversion shall be
!!                                   a processor-dependent default mode,
!!                                   which may correspond to one of the
!!                                   other modes.
!!
!!##EXAMPLES
!!
!!  Sample program
!!
!!    program demo_significant
!!    use M_framework__approx, only : significant
!!    implicit none
!!    integer :: i
!!    real :: r, v
!!    character(len=*),parameter :: g='(*(g0.7,1x))'
!!
!!       write(*,g)significant([8765.43210,0.1234567890],5)
!!
!!       write(*,*)'default:',1.23456789012345
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9])
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RU'),'RU'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RD'),'RD'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RZ'),'RZ'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RN'),'RN'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RC'),'RC'
!!       write(*,g)significant(1.23456789012345,[1,2,3,4,5,6,7,8,9],'RP'),'RP'
!!    end program demo_significant
!!
!!   Results:
!!
!!       > 8765.400 .1234600
!!       >  default:   1.234568
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568
!!       > 2.000000 1.300000 1.240000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RU
!!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
!!       > 1.234567 1.234568 1.234568 RD
!!       > 1.000000 1.200000 1.230000 1.234000 1.234500 1.234560 ...
!!       > 1.234567 1.234568 1.234568 RZ
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RN
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RC
!!       > 1.000000 1.200000 1.230000 1.235000 1.234600 1.234570 ...
!!       > 1.234568 1.234568 1.234568 RP
pure elemental function significant_real32(val,digits,round) result(significant)

! ident_7="@(#) M_framework__approx significant_real32(3f) round val to specified number of significant digits"

integer,parameter :: wp=real32
real(kind=wp),intent(in)             :: val
integer,intent(in)                   :: digits
character(len=*),intent(in),optional :: round
real(kind=wp)                        :: significant
character(len=80)                    :: line,fmt
   if(present(round))then
      write(fmt,'("(",a,",e0.",i0,")")')trim(round),digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   else
      write(fmt,'("(e0.",i0,")")')digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   endif
   write(line,fmt)val                  ! write with specified number of significant diguts
   read(line,'(e80.30)')significant    ! read back into a value
end function significant_real32
!-----------------------------------------------------------------------------------------------------------------------------------
pure elemental function significant_real64(val,digits,round) result(significant)

! ident_8="@(#) M_framework__approx significant_real64(3f) round val to specified number of significant digits"

integer,parameter :: wp=real64
real(kind=wp),intent(in)             :: val
integer,intent(in)                   :: digits
character(len=*),intent(in),optional :: round
real(kind=wp)                        :: significant
character(len=80)                    :: line,fmt
   if(present(round))then
      write(fmt,'("(",a,",d0.",i0,")")')trim(round),digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   else
      write(fmt,'("(d0.",i0,")")')digits ! build e0.N format to write specified number of digits as 0.NNNNN+EE
   endif
   write(line,fmt)val                  ! write with specified number of significant diguts
   read(line,'(d80.30)')significant    ! read back into a value
end function significant_real64
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function anyscalar_to_realbig_(valuein) result(d_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
#ifdef HAS_REAL128
use,intrinsic :: iso_fortran_env, only : wp=>real128
#else
use,intrinsic :: iso_fortran_env, only : wp=>real64
#endif
implicit none

! ident_9="@(#) M_framework__approx anyscalar_to_realbig_(3f) convert integer or real parameter of any kind to real128 or biggest available"

class(*),intent(in)          :: valuein
real(kind=wp)           :: d_out
character(len=3)             :: readable
   select type(valuein)
   type is (integer(kind=int8));   d_out=real(valuein,kind=wp)
   type is (integer(kind=int16));  d_out=real(valuein,kind=wp)
   type is (integer(kind=int32));  d_out=real(valuein,kind=wp)
   type is (integer(kind=int64));  d_out=real(valuein,kind=wp)
   type is (real(kind=real32));    d_out=real(valuein,kind=wp)
   type is (real(kind=real64));    d_out=real(valuein,kind=wp)
#ifdef HAS_REAL128
   Type is (real(kind=real128));   d_out=valuein
#endif
   type is (logical);              d_out=merge(0.0_wp,1.0_wp,valuein)
   type is (character(len=*));     read(valuein,*) d_out
   class default
    !!d_out=huge(0.0_wp)
    readable='NaN'
    read(readable,*)d_out
    !!stop '*M_framework__approx::anyscalar_to_realbig_: unknown type'
   end select
end function anyscalar_to_realbig_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
pure elemental function anyscalar_to_double_(valuein) result(d_out)
use, intrinsic :: iso_fortran_env, only : error_unit !! ,input_unit,output_unit
implicit none

! ident_10="@(#) M_framework__approx anyscalar_to_double_(3f) convert integer or real parameter of any kind to doubleprecision"

class(*),intent(in)       :: valuein
doubleprecision           :: d_out
doubleprecision,parameter :: big=huge(0.0d0)
   select type(valuein)
   type is (integer(kind=int8));   d_out=dble(valuein)
   type is (integer(kind=int16));  d_out=dble(valuein)
   type is (integer(kind=int32));  d_out=dble(valuein)
   type is (integer(kind=int64));  d_out=dble(valuein)
   type is (real(kind=real32));    d_out=dble(valuein)
   type is (real(kind=real64));    d_out=dble(valuein)
#ifdef HAS_REAL128
   Type is (real(kind=real128))
#endif
      !!if(valuein > big)then
      !!   write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein
      !!endif
      d_out=dble(valuein)
   type is (logical);              d_out=merge(0.0d0,1.0d0,valuein)
   type is (character(len=*));      read(valuein,*) d_out
   !type is (real(kind=real128))
   !   if(valuein > big)then
   !      write(error_unit,*)'*anyscalar_to_double_* value too large ',valuein
   !   endif
   !   d_out=dble(valuein)
   class default
     d_out=0.0d0
     !!stop '*M_framework__approx::anyscalar_to_double_: unknown type'
   end select
end function anyscalar_to_double_
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    compare_float(3f) - [M_framework__approx] compare floating point
!!    values with adjustable tolerance.
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!     result = compare_float( x, y,ulp = SCALING_VALUE)
!!
!!      elemental function (x,y,ulp)
!!      real(kind=KIND),intent(in) :: x,y
!!      real|integer,intent(in),optional :: ulp
!!
!!     Additional convenience operators:
!!
!!        X.equalto.Y
!!        X.lessthan.Y
!!        X.greaterthan.Y
!!
!!     Developer procedure (Do not use in production):
!!
!!       change_default_ulp(ulp)
!!
!!##DESCRIPTION
!!    compare_float(3f) is a function for comparing floating point numbers
!!    within an automatically adjusted tolerance.
!!
!!    The test performed is
!!
!!        abs( x - y ) < ( ulp * spacing( max(abs(x),abs(y)) ) )
!!
!!    where ULP is a user-selected scaling factor that defaults to 1. The
!!    default is intentionally low so that default behavior is close to
!!    that of the default operators. Setting it to zero(0.0) essentially
!!    causes no values to compare equal.
!!
!!    If the result is .TRUE., the numbers are considered equal. Both single
!!    and double precision scalar and array values can be compared, as the
!!    function is elemental.
!!
!!    By definition of an elemental function the returned data entity is the
!!    same shape as the input array size or scalar if all values are scalar.
!!
!!    It can be useful to empirically test your code for numeric
!!    sensitivities by changing the value of the ULP scaling factor and
!!    noting any result changes.
!!
!!    As a convenience relational operators .EqualTo., .GreaterThan.,
!!    and .LessThan. are provided. Note the comparisons return .TRUE>
!!    if the difference between the two values is .lt., .ge., and .le. .
!!    The algorithm for each operator is shown in the following OPERATORS
!!    section.
!!
!!    The default ULP value is 1.0. A procedure is available to change the
!!    default but it should only be used for examining code behavior during
!!    development, as it changes the default for calls from all procedures
!!    (even those in other modules or procedures).
!!
!!       call default_ulp(ulp=VALUE)
!!
!!##DETAILS
!!
!!    It is generally acknowledged that real numbers should not be compared
!!    directly but within some tolerance. However, the magnitude of an
!!    appropriate tolerance value will vary depending on the magnitudes
!!    of the numbers being compared and the precision of the computing
!!    environment.
!!
!!    The Fortran standard does not specify functions or operators
!!    specifically for comparing float values, but leaves some latitude
!!    in how the compilers address floating point comparisons. It does
!!    specify functions that return platform-specific values useful in
!!    applying different methods to the problem such as
!!
!!     + epsilon(3f)       - Epsilon function
!!     + nearest(3f)       - Nearest representable number
!!     + spacing(3f)       - Smallest distance between two numbers of a given type
!!     + rrspacing(3f)     - Reciprocal of the relative spacing of a numeric type
!!
!!    and in some cases
!!
!!     + scale(3f)         - Scale a real value by a whole power of the radix
!!     + digits(3f)        - Significant digits in the numeric model
!!     + exponent(3f)      - Exponent of floating-point number
!!     + fraction(3f)      - Fractional part of the model representation
!!     + huge(3f)          - Largest number of a type and kind
!!     + maxexponent(3f)   - Maximum exponent of a real kind
!!     + minexponent(3f)   - Minimum exponent of a real kind
!!     + precision(3f)     - Decimal precision of a real kind
!!     + radix(3f)         - Base of a numeric model
!!     + range(3f)         - Decimal exponent range of a numeric kind
!!     + set_exponent(3f)  - real value with specified exponent
!!     + tiny(3f)          - Smallest positive number of a real kind
!!
!!    Books have been written on the behavior of floating point math.
!!
!!    As is used here, a commonly used simple floating point
!!    comparison algorithm is
!!
!!        if(abs(x < y) < (ulp * spacing(max(abs(x),abs(y))))) then
!!          :
!!        endif
!!
!!    where the intrinsic function SPACING(3f) determines the distance
!!    between the argument X and the nearest adjacent representable number
!!    of the same type and ULP is an optional user-supplied scaling factor.
!!
!!##OPTIONS
!!
!!    x,y   Two congruent floating point values to compare.
!!
!!    ulp   The ULP ("unit in the last place") scaling value allows for
!!          users to control the scaling of the value returned by SPACING(3f)
!!          in order to relax or tighten what is considered "equal". That
!!          is, the ULP value can be used to scale the comparison based
!!          on knowledge of the "numerical quality" of the values being used
!!          in the comparison.
!!
!!          The value should be positive. The absolute value of the value is
!!          taken if it is negative.
!!
!!          The default ULP scaling value is 1.0.
!!
!!          The value may be of type integer or real.
!!
!!          A 0.5 ULP maximum error is the best you could hope for, since
!!          this corresponds to always rounding to the nearest representable
!!          floating point number.
!!
!!##RESULT
!!
!!    The return value is a logical value indicating whether the inputs
!!    are equal to within the requested precision.
!!
!!##OPERATORS
!!
!! Additional operators based on compare_float(3f) are included:
!!
!! X.equalto.Y  If the result is .TRUE., the numbers are considered equal.
!!              The test performed is
!!
!!                abs( x - y ) < spacing( max(abs(x),abs(y)) )
!!
!! X.greaterthan.Y  If the result is .TRUE., x is considered greater than y.
!!                  The result is a logical value indicating whether the
!!                  operand x is greater than y by more than the spacing
!!                  between representable floating point numbers.
!!
!!                  The test performed is
!!
!!                   ( x - y ) >= SPACING( MAX(ABS(x),ABS(y)) )
!!
!! X.lessthan.Y  Test if one operand is less than another.
!!               The result is a logical value indicating whether
!!               the operand x is less than y by more than the
!!               spacing between representable floating point
!!               numbers.
!!
!!               The test performed is
!!
!!                  ( y - x ) >= SPACING( MAX(ABS(x),ABS(y)) )
!!
!!               If the result is .TRUE., x is considered less than y.
!!
!!##EXAMPLES
!!
!!  Sample programs:
!!
!!    program demo_compare_float
!!    use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64
!!    use,intrinsic :: iso_fortran_env, only : real32, real64, real128
!!    use,intrinsic :: iso_fortran_env, only : error_unit,output_unit
!!    use M_framework__approx,          only : compare_float
!!    use M_framework__approx,          only : &
!!    & operator(.equalto.), operator(.greaterthan.), operator(.lessthan.)
!!    implicit none
!!    integer,parameter       :: wp=int32
!!    integer                 :: i
!!    character(len=80),save  :: line='10*0.1'
!!    real(kind=wp)           :: a(10), x, y, ulp
!!       write(*,*)'is 10*0.1 == 1.0?'
!!       ! sum up 0.1 ten times hopefully in a manner compiler does not
!!       ! optimize it and in the process make it equal
!!       a=0.1_wp
!!       read(line,*)a
!!       x=sum(a)
!!       y=1.0_wp
!!       write(*, *)merge('    EQUAL ','NOT EQUAL!',x .eq. y)
!!       write(*,'(*(g0,1x,z0,1x))')x,x,y,y ! show decimal and hexadecimal value
!!       write(*, *)'regular',x .eq. y, x .gt. y, x .lt. y ! standard operators
!!       ! For the default ULP=1.0, the relational operators can be used
!!       write(*, *)'compare',x .equalto. y, x .greaterthan. y, x .lessthan. y
!!       do i=0,10
!!          ulp=real(i,kind=wp)/2.0
!!          write(*,*) i, compare_float( x, y, ulp=ulp ) ,'ULP=',ulp
!!       enddo
!!    end program demo_compare_float
!!
!!  Results:
!!
!!     >  is 10*0.1 == 1.0?
!!     >  NOT EQUAL!
!!     > 1.00000012 3F800001 1.00000000 3F800000
!!     >  regular F T F
!!     >  compare F T F
!!     >            0 F ULP=   0.00000000
!!     >            1 F ULP=  0.500000000
!!     >            2 F ULP=   1.00000000
!!     >            3 T ULP=   1.50000000
!!     >            4 T ULP=   2.00000000
!!     >            5 T ULP=   2.50000000
!!     >            6 T ULP=   3.00000000
!!     >            7 T ULP=   3.50000000
!!     >            8 T ULP=   4.00000000
!!     >            9 T ULP=   4.50000000
!!     >           10 T ULP=   5.00000000
subroutine change_default_ulp(ulp)
! developer routine for changing default ulp
class(*),intent(in) :: ulp
   default_ulp = abs(anyscalar_to_double_(ulp))
end subroutine change_default_ulp
elemental function compare_float_real32( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real32
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = default_ulp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real32
elemental function is_less_than_real32( x, y ) result ( less_than )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real32
elemental function is_greater_than_real32( x, y ) result ( greater_than )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real32
elemental function is_equal_to_real32( x, y ) result( equal_to )
integer,parameter         ::  wp=real32
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real32

elemental function compare_float_real64( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real64
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = default_ulp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real64
elemental function is_less_than_real64( x, y ) result ( less_than )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real64
elemental function is_greater_than_real64( x, y ) result ( greater_than )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real64
elemental function is_equal_to_real64( x, y ) result( equal_to )
integer,parameter         ::  wp=real64
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real64

#ifdef HAS_REAL128
elemental function compare_float_real128( x, y, ulp ) result( compare )
integer,parameter            ::  wp=real128
real(kind=wp),intent(in)     ::  x
real(kind=wp),intent(in)     ::  y
class(*),optional,intent(in) ::  ulp
logical                      ::  compare
real(kind=wp)                ::  rel
   if ( present( ulp ) ) then
     rel = abs(anyscalar_to_double_(ulp))
   else
     rel = default_ulp
   endif
   compare = abs( x - y ) < ( rel * spacing( max(abs(x),abs(y)) ) )
end function compare_float_real128
elemental function is_less_than_real128( x, y ) result ( less_than )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical :: less_than
    if ( (y - x) >= spacing( max( abs(x), abs(y) ) ) ) then
      less_than = .true.
    else
      less_than = .false.
    endif
  end function is_less_than_real128
elemental function is_greater_than_real128( x, y ) result ( greater_than )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical                   ::  greater_than
   if ( (x - y) >= spacing( max( abs(x), abs(y) ) ) ) then
     greater_than = .true.
   else
     greater_than = .false.
   endif
end function is_greater_than_real128
elemental function is_equal_to_real128( x, y ) result( equal_to )
integer,parameter         ::  wp=real128
real(kind=wp),intent(in)  ::  x, y
logical                   ::  equal_to
    equal_to = abs( x - y ) < spacing( max(abs(x),abs(y)) )
end function is_equal_to_real128
#endif
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework__approx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================

!>>>>> build/dependencies/M_msg/src/M_help.f90
module M_help
use,intrinsic :: iso_fortran_env, only : stderr=>error_unit, stdin=>input_unit, stdout=>output_unit
use M_journal, only : journal
implicit none
private
public help_command
contains
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!>
!!##NAME
!!    help_command(3f) - [M_help] uses a specially formatted text array to
!!    provide a HELP interface
!!    (LICENSE:PD)
!!
!!##SYNOPSIS
!!
!!    Syntax:
!!
!!      function help_command(text_array,topic,position)
!!
!!##DESCRIPTION
!!    This routine, when given a CHARACTER array displays the text
!!    interactively. The special topics "manual","topics", and "search"
!!    are reserved. "manual" causes the entire array to be displayed.
!!    "topics" displays all lines not beginning with a space or three or
!!    more equal signs, and "search" must be followed by a string to search
!!    for in the manual.
!!
!!    A line beginning with a non-blank character in column one is a topic
!!
!!    A topic with the preceding line beginning with "===" is a special
!!    topic that will be displayed up to the next line beginning with "==="
!!
!!    The special topic "manual" displays the entire help text
!!
!!    The help text is paged based on the values in the position() array. The
!!    first value is the current line count on the current page, and the
!!    second value is how many lines should be displayed as a page before
!!    a paging prompt is produced. POSITION(2) is typically set to 23.
!!    POSITION(1) can be set to zero, especially if the calling page is
!!    not tracking paging itself.
!!
!!    Entering a "q" at the prompt exits the help text. To see other options
!!    enter an "h" at the prompt.
!!
!!       h
!!       #----------------------------------------------------# PAGING
!!       | f b        forward or backward one page            |
!!       | u d        redraw up or down one-half page         |
!!       | r          refresh page                            |
!!       | e y | j k  refresh page moving up or down one line |
!!       #----------------------------------------------------# JUMPING
!!       | g          go to top of manual                     |
!!       | NNN        go to line number NNN. Use a sign (+-)  |
!!       |            for a relative move.                    |
!!       | .          toggle line numbering                   |
!!       #----------------------------------------------------# SEARCHING
!!       | /STRING    advance to next line containing string  |
!!       | ?STRING    search for string above current line    |
!!       | n N        find next occurrence up or down in file |
!!       | \STRING    show all lines with specified string.   |
!!       | t          displays topic lines.                   |
!!       #----------------------------------------------------#
!!       | w FILENAME write entire user guide to local file   |
!!       | h          display this help                       |
!!       | q          quit                                    |
!!       #----------------------------------------------------#
!!       A blank repeats last positioning command. Anything else is ignored.
!!       Line count is 25 out of 54 . Page size is 23 (see "lines")
!!       help:
!!
!!
!!    A normal topic is displayed until another topic line (line beginning
!!    with a non-blank) is encountered
!!
!!    The help text must begin with a line starting with "==="
!!
!!    If a line is preceded by an "===" line it is considered a section
!!    instead of a topic, and all lines between that line and the next line
!!    beginning with "===" are displayed.
!!##OPTIONS
!!    help_text  The block of text to treat as the input document
!!
!!    topic      What topic or section to search for (case sensitive). A blank
!!               is equivalent to "SUMMARY". There are several reserved names.
!!               "manual" means the entire help text, and "topics" shows only
!!               lines not beginning with a blank, and "search" does a
!!               case-insensitive search for a string.
!!
!!    position   A small array with two values. The second value is the size
!!               of the page to be used between pauses. The first one indicates
!!               how many lines on the current page have been displayed.
!!##EXAMPLES
!!
!!   Sample program:
!!
!!    program demo_help_command
!!    use M_help, only : help_command
!!    character(len=:),allocatable :: help_text(:)
!!    integer                      :: position(2)
!!    position=[0,23]
!!    help_text=[character(len=80) :: &
!!    '==============================================',&
!!    '   A sample help text file.                   ',&
!!    '   Note the first line MUST start with "==="  ',&
!!    '==============================================',&
!!    'SUMMARY                                       ',&
!!    '  This is usually a crib sheet                ',&
!!    '==============================================',&
!!    'SECTION1                                      ',&
!!    'topic1                                        ',&
!!    '   A description of topic 1                   ',&
!!    '                                              ',&
!!    '   and any general text you want              ',&
!!    '                                              ',&
!!    'topic2  A description of topic 2              ',&
!!    'topic3                                        ',&
!!    '   A description of topic 3                   ',&
!!    '   more  description of topic 3               ',&
!!    '   and more description of topic 3 a          ',&
!!    '   and more description of topic 3 b          ',&
!!    '   and more description of topic 3 c          ',&
!!    '   and more description of topic 3 d          ',&
!!    '   and more description of topic 3 e          ',&
!!    '   and more description of topic 3 f          ',&
!!    '   and more description of topic 3 g          ',&
!!    '   and more description of topic 3 h          ',&
!!    '   and more description of topic 3 i          ',&
!!    '   and more description of topic 3 j          ',&
!!    '   and more description of topic 3 k          ',&
!!    '   and more description of topic 3 l          ',&
!!    '   and more description of topic 3 m          ',&
!!    '   and more description of topic 3 n          ',&
!!    '   and more description of topic 3 o          ',&
!!    '   and more description of topic 3 p          ',&
!!    '   and more description of topic 3 q          ',&
!!    '   and more description of topic 3 r          ',&
!!    '   and more description of topic 3 s          ',&
!!    '   and more description of topic 3 t          ',&
!!    '   and more description of topic 3 u          ',&
!!    '   and more description of topic 3 v          ',&
!!    '   and more description of topic 3 w          ',&
!!    '   and more description of topic 3 x          ',&
!!    '   and more description of topic 3 y          ',&
!!    '   and more description of topic 3 z          ',&
!!    '==============================================',&
!!    'SECTION2                                      ',&
!!    'topic4  A description of topic 4              ',&
!!    '   this is the last part of SECTION1          ',&
!!    'topic5                                        ',&
!!    '  This is all about the fifth topic and is    ',&
!!    '  just displayed as-is. The text cannot start ',&
!!    '  in column one or it will be seen as the     ',&
!!    '  beginning of a topic.                       ',&
!!    '==============================================',&
!!    '                                              ' ]
!!
!!    write(*,*)'>>>>>'
!!    call help_command(help_text,'',position)
!!    write(*,*)'>>>>>topic1'
!!    call help_command(help_text,'topic1',position)
!!    write(*,*)'>>>>>topics'
!!    call help_command(help_text,'topics',position)
!!    write(*,*)'>>>>>manual'
!!    call help_command(help_text,'manual',position)
!!    end program demo_help_command
subroutine help_command(help_text,topic_name,position)

! ident_1="@(#) M_help help_command(3f) interactively display help text"

character(len=*),intent(in)            :: help_text(:)
character(len=*),intent(in)            :: topic_name
integer                                :: position(2)
integer                                :: end_of_first_word
integer                                :: start_of_topic
integer                                :: ios
character(len=:),allocatable           :: topic, old_topic, string
logical                                :: block_topic
integer                                :: i, j, k, jj, ii
logical                                :: numbered
character(len=len(help_text))          :: last_response
integer                                :: toomany
integer,parameter                      :: max_toomany=2000
integer                                :: howbig
integer                                :: old_position

   howbig=size(help_text)
   toomany=1
   last_response='f'
   numbered=.false.
   topic=trim(topic_name)
   old_topic=''
   old_position=0
   if(index(topic,'search ') == 1)then
      topic='search'
   endif
   INFINITE: do

      if (topic == ' ') then                                           ! if no topic
         call journal('Type "help" followed by a case-sensitive topic name ...')
         topic='SUMMARY'
      endif
      select case(topic)
      case('manual')                                  ! show all the help text
         i=0
         do
            i=i+1
            if(i > howbig)exit
            if(help_text(i)(1:3) == '===')then
               if(numbered)then
                  call journal('sc',i,' ')
               else
                  call journal(' ')
               endif
            else
               if(numbered)then
                  call journal('sc',i,help_text(i))
               else
                  call journal('sc',help_text(i))
               endif
            endif
            if(want_to_stop())exit INFINITE
            if(old_topic /= '')cycle INFINITE
            if(i >= howbig) then
               do j=1,max_toomany
                  call journal('sc','[end-of-file] (line',i,')')
                  position(1)=position(2)+1
                  if(want_to_stop())exit INFINITE
                  if(old_topic /= '')cycle INFINITE
                  if(i < howbig)exit
               enddo
               if(i >= howbig)exit
            endif
         enddo
         exit INFINITE
      case('topics')                         ! go through all the text showing lines not starting with a a space or equal
         i=1                                 ! display topic starting at start_of_topic
         do
            i=i+1
            if(i > howbig) exit
            if(help_text(i)(1:1) == '   ')cycle
            if(help_text(i)(1:3) == '===')cycle
            jj=merge(0,3,help_text(i-1)(1:3) == '===')
            if(numbered)then
               call journal('sc',i,'>',repeat(' ',jj)//help_text(i))
            else
               call journal('sc','>',repeat(' ',jj)//help_text(i))
            endif
            if(want_to_stop())then
               if(old_topic /= '')then
                  topic=old_topic
                  old_topic=''
                  i=old_position
                  call pageback(1)
                  i=max(1,i)
                  position(1)=position(2)+1
                  cycle INFINITE
               endif
               exit INFINITE
            endif
         enddo
         if(old_topic /= '')then
            topic=old_topic
            old_topic=''
            i=old_position
            call pageback(1)
            i=max(1,i)
            position(1)=position(2)+1
            cycle INFINITE
         endif
         exit INFINITE
      case('search')                         ! go through all the text showing lines matching string
         position(1) = 0
         string=topic_name//'        '
         string=trim(lower(adjustl(string(8:))))
         i=0
         do
            i=i+1
            if(i > howbig)exit
            if(help_text(i)(1:1) /= ' '.and.help_text(i)(1:3) /= '===')then
               old_topic=help_text(i)//' '
               ii=index(old_topic,' ')
               old_topic=old_topic(:ii)
            endif
            if(index(lower(help_text(i)),string) /= 0)then
               if(numbered)then
                  call journal('sc',i,help_text(i))
               else
                  call journal('sc',old_topic,'>',help_text(i))
               endif
               if(want_to_stop())exit INFINITE
               if(i >= howbig) then
                  do j=1,max_toomany
                     call journal('sc','[end-of-file] (line',i,')')
                     position(1)=position(2)+1
                     if(want_to_stop())exit INFINITE
                     if(i < howbig)exit
                  enddo
                  if(i >= howbig)exit
               endif
            endif
         enddo
         exit INFINITE
      case default ! find the line that starts with the topic
         start_of_topic=0
         ! find the line to start with by finding a line that starts with the given topic ( ASSUMING FIRST LINE is ===)
         FINDIT: do j=1,len(help_text)
            do i=2, howbig                                          ! get first word of lines not starting with a blank
               if(help_text(i)(1:1) /= ' ')then                              ! only topic lines start in column one so skip these
                  end_of_first_word=index(help_text(i),' ')-1
                  if(end_of_first_word == 0)end_of_first_word=len(help_text) ! if line is filled and does not have a blank
                  end_of_first_word=end_of_first_word-j+1
                  if(end_of_first_word <= 0)cycle
                  !x!write(*,*)'['//topic(:end_of_first_word)//']['//help_text(i)(:end_of_first_word)//']'
                  if(topic == help_text(i)(:end_of_first_word))then      ! find a line that matches topic
                     exit FINDIT
                  endif
               endif
            enddo
         enddo FINDIT
         start_of_topic=i

         if(i == 0)then
            call journal('<ERROR> internal error. First line of text must start with "==="')
            !!help_text=[character(len=len(help_text)) :: repeat("=",80),help_text]
            start_of_topic=start_of_topic+1
         endif

         if(help_text(i-1)(1:3) == '===')then  ! if the line above the start started with "===" it is a block comment
            block_topic=.true.
         else
            block_topic=.false.
         endif

         if(start_of_topic > howbig.or.start_of_topic == 0)then
            call journal('sc','SORRY, No help on ',topic)
         else
            position(1) = 0
            if(numbered)then
               call journal('sc',i,help_text(start_of_topic))                       ! show the start line
            else
               call journal('sc',help_text(start_of_topic))                       ! show the start line
            endif

            i=start_of_topic+1                                              ! display topic starting at start_of_topic
            do
               if(help_text(i)(1:1) /= ' '.and. .not.block_topic )then       ! stop at next topic if not a block of help
                  exit
               elseif(block_topic .and. help_text(i)(1:3) == '===')then
                  exit
               endif
               if(numbered)then
                  call journal('sc',i,help_text(i))
               else
                  call journal('sc',help_text(i))
               endif
               if(want_to_stop())exit INFINITE
               if(old_topic /= '')cycle INFINITE
               toomany=toomany+1
               if(toomany >= max_toomany)exit INFINITE    ! to prevent infinite loops in batch mode
               i=max(start_of_topic-1,i)
               i=i+1
               if(i > howbig) exit
            enddo
         endif
         exit INFINITE
      end select
      if(want_to_stop())exit INFINITE
   enddo INFINITE
contains

function want_to_stop()
character(len=len(help_text))        :: response
character(len=1)                     :: letter
logical                              :: want_to_stop
integer                              :: j
integer                              :: jj
doubleprecision                      :: val
integer                              :: ierr
   position(1) = position(1) + 1
   want_to_stop=.false.
   PROMPT: do
      if(position(1)  >  position(2)) then
         call journal('+sc','help:')
         read(stdin,'(a)',iostat=ios) response         ! read letter to pause from standard input
         if(response.eq.' ')response=last_response
         response=adjustl(response)
         letter=response(1:1)
         select case(letter)
         case('f')                                        ! next page
            position(1) = 0                                ! start new page
            last_response='f'
         case('b')                                            ! back one page
            call pageback(2)
            position(1) = 0
            last_response='b'
         case('0':'9')                                        ! assumed to be a number
            call a2d(response,val,ierr)
            i=nint(val)-1
            i=max(i,1)
            i=min(i,howbig-1)
            position(1) = 0
            last_response=last_response
         case('-','+')                                        ! assumed to be a number
            call pageback(1)
            call a2d(response,val,ierr)
            i=i+nint(val)
            i=max(i,1)
            i=min(i,howbig-1)
            position(1) = 0
            last_response=last_response
         case('t')                                            ! topics
            old_topic=topic
            old_position=i
            topic='topics'
            position(1)=0
            exit PROMPT
            !do j=2,howbig
            !   if(help_text(j)(1:1) == '   ')cycle
            !   if(help_text(j)(1:3) == '===')cycle
            !   jj=merge(0,3,help_text(j-1)(1:3) == '===')
            !   if(numbered)then
            !      call journal('sc',j,'>',repeat(' ',jj)//help_text(j))
            !   else
            !      call journal('sc','>',repeat(' ',jj)//help_text(j))
            !   endif
            !enddo
            !call pageback(1)
            !i=max(1,i)
            !position(1)=position(2)+1
            !cycle PROMPT
         case('u')                                            ! back one-half page
            call pageback(1)
            i=max(1,i-position(2)/2-1)
            position(1) = 0
            last_response='u'
         case('e','k')                                        ! back one line page
            call pageback(1)
            i=max(1,i-1)
            position(1) = 0
            last_response='e'
         case('y','j')                                        ! down one line page
            call pageback(1)
            i=max(1,i+1)
            position(1) = 0
            last_response='y'
         case('w')
            WRITEFILE: block
            character(len=1000) :: errmsg
            integer :: temp_lun
               response=adjustl(response(2:))
               if(response == '')response='userguide.txt'
               open(newunit=temp_lun,file=response,status='new',iostat=ios,iomsg=errmsg) ! open help file
               if(ios == 0)then
                  write(temp_lun,'(a)',iostat=ios)( trim(help_text(k)),k=1,howbig )
                  call journal('sc','<INFO> user guide is on file',response )
                  close(unit=temp_lun,iostat=ios)
               else
                  call journal(errmsg)
               endif
            endblock WRITEFILE
            i=max(1,i-1)
            last_response=last_response
         case('d')                                            ! down one-half page
            i=min(howbig-1,i-position(2)/2-1)
            position(1) = 0
            last_response='d'
         case('r')                                            ! repaint page
            call pageback(1)
            position(1) = 0
            last_response=last_response
         case('/','n')                                        ! find string below
            j=i ! hold
            if(letter == 'n')response=last_response
            if(response(2:) == '')response=last_response
            i=i+1
            do
               if(index(lower(help_text(i)),trim(response(2:))) /= 0)then
                  i=max(1,i-1)

                  exit
               else
                  i=i+1
               endif
               if(i > howbig) exit
            enddo
            if(i > howbig)i=j
            position(1) = 0
            last_response=response
         case('\') ! find string
            response=lower(adjustl(response(2:)))
            if(response == ' ')response=last_response
            jj=len_trim(response)
            do j=1,howbig
               if(index(lower(help_text(j)),response(:jj)) /= 0)then
                  call journal('sc',j,help_text(j))
               endif
            enddo
            i=i-1
            call pageback(1)
            last_response='/'//response
         case('?','N','p')                                            ! find string above
            j=i ! hold
            if(letter == 'N'.or.letter == ' ')response=last_response
            if(response(2:) == '')response=last_response
            i=i-1
            do
               if(index(lower(help_text(i)),trim(response(2:))) /= 0)then
                  exit
               else
                  i=i-1
               endif
               if(i <= 1) then
                  i=j
                  exit
               endif
            enddo
            call pageback(1)
            position(1) = 0
            last_response=response
         case('g')                                            ! repaint page
            i=1
            position(1) = 0
            last_response=last_response
         case('.')                                            ! help
            position(1) = 0
            numbered=.not.numbered
            last_response=last_response
         case('h')                                            ! help
            call journal('sc','#----------------------------------------------------# PAGING')
            call journal('sc','| f|SPACE b  forward or backward one page            |')
            call journal('sc','| u d        redraw up or down one-half page         |')
            call journal('sc','| r          refresh page                            |')
            call journal('sc','| e y | j k  refresh page moving up or down one line |')
            call journal('sc','#----------------------------------------------------# JUMPING')
            call journal('sc','| g          go to top of manual                     |')
            call journal('sc','| NNN        go to line number NNN. Use a sign (+-)  |')
            call journal('sc','|            for a relative move.                    |')
            call journal('sc','| .          toggle line numbering                   |')
            call journal('sc','#----------------------------------------------------# SEARCHING')
            call journal('sc','| /STRING    advance to next line containing string  |')
            call journal('sc','| ?STRING    search for string above current line    |')
            call journal('sc','| n N        find next occurrence up or down in file |')
            call journal('sc','| \STRING    show all lines with specified string.   |')
            call journal('sc','| t          displays topic lines.                   |')
            call journal('sc','#----------------------------------------------------#')
            call journal('sc','| w FILENAME write entire user guide to local file   |')
            call journal('sc','| h          display this help                       |')
            call journal('sc','| q          quit                                    |')
            call journal('sc','#----------------------------------------------------#')
            call journal('sc','A blank repeats last positioning command. Anything else is ignored.')
            call journal('sc','Line count is ',i,'out of',howbig,'. Page size is',position(2),'(see "lines")')
            last_response=last_response
            cycle
         case('q')
            position(1) = -1
            want_to_stop=.true.
         case default
            call pageback(2)
            call journal('sc','unknown option -- enter "h" for assistance or "q" to quit')
         end select
      endif
      exit
   enddo PROMPT
end function want_to_stop

subroutine pageback(loops)
integer,intent(in) :: loops
integer            :: j
   do j=1,loops
      i=max(1,i-position(2)-1)
   enddo
end subroutine pageback

end subroutine help_command

subroutine a2d(chars,valu,ierr)

! ident_2="@(#) M_strings a2d(3fp) subroutine returns double value from string"

!     1989,2016 John S. Urban.
!
!  o works with any g-format input, including integer, real, and exponential.
!  o if an error occurs in the read, iostat is returned in ierr and value is set to zero. If no error occurs, ierr=0.
!  o if the string happens to be 'eod' no error message is produced so this string may be used to act as an end-of-data.
!    IERR will still be non-zero in this case.

character(len=*),intent(in)  :: chars                        ! input string
character(len=:),allocatable :: local_chars
doubleprecision,intent(out)  :: valu                         ! value read from input string
integer,intent(out)          :: ierr                         ! error flag (0 == no error)

character(len=*),parameter   :: fmt="('(bn,g',i5,'.0)')"     ! format used to build frmt
character(len=15)            :: frmt                         ! holds format built to read input string
character(len=256)           :: msg                          ! hold message from I/O errors
character(len=3),save        :: nan_string='NaN'

   ierr=0                                                    ! initialize error flag to zero
   local_chars=chars
   msg=''
   if(len(local_chars) == 0)local_chars=' '
   write(frmt,fmt)len(local_chars)                        ! build format of form '(BN,Gn.0)'
   read(local_chars,fmt=frmt,iostat=ierr,iomsg=msg)valu   ! try to read value from string
   if(ierr /= 0)then                                         ! if an error occurred ierr will be non-zero.
      read(nan_string,'(g3.3)')valu
      call journal('sc','*a2d* - cannot produce number from string [',chars,']')
      if(msg /= '')then
         call journal('sc','*a2d* - [',msg,']')
      endif
   endif
end subroutine a2d

elemental pure function lower(str,begin,end) result (string)

! ident_3="@(#) M_strings lower(3f) Changes a string to lowercase over specified range"

character(*), intent(in)     :: str
character(len(str))          :: string
integer,intent(in),optional  :: begin, end
integer                      :: i
integer                      :: ibegin, iend
integer,parameter             :: diff = iachar('A')-iachar('a')
   string = str
   ibegin=1
   iend=len_trim(str)

   if (present(begin))then
      ibegin = min(max(1,begin),iend)
   endif

   if (present(end))then
      iend= max(1,min(iend,end))
   endif

   do concurrent (i = ibegin:iend)                   ! step thru each letter in the string in specified range
      select case (str(i:i))
      case ('A':'Z')
         string(i:i) = char(iachar(str(i:i))-diff)   ! change letter to miniscule
      case default
      end select
   enddo

end function lower

end module M_help

!>>>>> build/dependencies/M_framework/src/M_framework.f90
module M_framework
use M_framework__journal
use M_framework__msg
use M_framework__verify
use M_framework__approx
use M_framework__utility
use M_framework__timing
!use M_framework__attr
implicit none(type,external)
!private
! public ...
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
!>
!!##NAME
!!    M_framework(3f) - [M_framework::INTRO] unit test framework
!!     (LICENSE:PD)
!!##SYNOPSIS
!!
!!
!! M_framework(3f) is an aggregate of Fortran modules brought together to
!! provide unit testing for Fortran; and is particularly well suited for
!! use with the Fortran Package Manager (fpm).
!!
!! The support modules are useful for creating terminal messages, comparing
!! expected values to results, writing logfiles and playback journals
!! independent of unit testing as well.
!!
!! Typically unit testing can be integrated seamlessly into the fpm(1) subcommand
!! "test" making unit testing from github/gitlab CD/CI utilities as simple as
!! "fpm test" in many cases.
!!
!!
!!  BASIC TIMING IS INCLUDED
!! As well as the expected **pass/fail/skipped unit testing** report.
!! basic **timing information** can be produced by the unit testing module
!! M_framework__verify(3f).
!!
!!  HOOKS ARE PROVIDED TO EXTERNAL LOCAL APPLICATIONS
!!
!! M_framework(3f) comes with a unique hook that allows calling your own
!! programs to integrate with local logging tools, report generators,
!! spreadsheets or other local infrastructure. The example program
!! "bookkeeper" is included that uses the hook to write example report
!! data files:
!!
!!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv),
!!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html)
!!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml)
!!
!! The hook can call any local program with an interface similar to
!! "bookkeeper". This allows modifying the program for local needs such
!! as sending e-mail alerts and so on without having to change the tests.
!!
!!   MESSAGES CAN BE COMPOSED ALMOST LIKE LIST-DIRECTED I/O
!! Messages can be composed of up to twenty scalar intrinsic variables,
!! allowing freedom in writing messages akin to that of list-directed I/O;
!! but simultaneously to a list of output units. This easily lets messages
!! go to stdout or stderr and a file of the user's choosing as well. Output
!! can even be sent to a scratch file, essentially creating a quiet mode.
!!
!!    DESIGNED FOR INTEGRATION WITH FPM(1)
!! In conjunction with fpm(1) it is easy to run the tests with the --runner
!! option, allowing for integration with other utilities as well such as
!! the GNU debugger gdb(1), valgrind(1), and other tools.
!!
!!    PROGRAMS INCLUDED TO GENERATE SKELETON TEST PROGRAM
!! Example programs are provided to create unit test skeleton programs to
!! ease usage.
!!
!!    EASILY USED WITH GITHUB CD/CI
!! Example CD/CI scripts that can be used with github are in the .github/
!! directory that assume your tests can by run by using "fpm test".
!!
!!    MOTIVATION
!! Including **unit testing** is strongly encouraged for any software package,
!! but particularly when it is to be used in programming environments the
!! package was not developed in.
!!
!! This is the typical case for public fpm(1) packages on github.
!!
!! Additionally the proposed rules for registered fpm(1) package repositories
!! include requiring package candidates themselves only have external
!! dependencies that are also registered repository packages ( of course
!! wrappers of C libraries or other existing libraries cannot easily be
!! conformed to this).
!!
!! As a result -- this project concentrates on tools for a procedural unit
!! testing framework based on nothing but standard Fortran that specifically
!! can be used as a remote fpm(1) dependency in fpm(1) packages that may
!! reside in public github repositories.
!!
!! That is, it is designed to be integrated with the fpm(1) "test" subcommand
!! as an external dependency. It is intended to have little or no other
!! dependencies and ultimately become a registered fpm(1) package to aid in
!! the development of the fpm(1) repository.
!!
!! That being said, it can be used standalone as well.
!!
!!##DESCRIPTION
!!
!! Unit testing allows you to automatically confirm changes are acceptable
!! so you can quickly and confidently make and release changes. But many of
!! the operations required for testing are useful generically. So this
!! project is broken down into small general-purpose modules and
!! one unit-testing-specific one.
!!
!! M_framework(3f) is composed of the following individual modules:
!!
!!  + **M\_framework__msg** is a small module that in particular
!!    can convert a list of variables of any of the common default types
!!    to a string.
!!
!!    It performs low-level operations that are often used by other larger
!!    modules so it is its own module to prevent circular dependencies.
!!
!!  + **M\_framework__journal__** allows for creating log and journal files
!!
!!  + **M\_framework__approx** contains routines for rounding and comparing
!!    floating-point values.
!!
!!  + **M\_framework__help** provides for creating a standard simple
!!    interactive help facility
!!
!!  + **M\_framework__verify** is at the heart of the collection and
!!    handles virtually all the unit-test-specific operations.
!!
!! The procedures can be used in a variety of ways. After using them for
!! a long time my typical usage has changed completely several times.
!!
!! As part of private software there was little problem calling the
!! procedures directly from within the modules where they resided; and even
!! auto-detecting the routines (a naming convention of "test\_suite\_$NAME"
!! was used). The routines were pre-installed on virtually all platforms
!! so using them was no more a burden than say, calling an intrinsic.
!!
!! Put autodetecting tools (at least the ones employed) are not generally
!! portable; and with public packages there is a strong incentive to
!! minimize the amount of infrastructure and external dependencies. It is
!! generally imperative to make package use as simple and generic as possible.
!!
!! So the suggested scheme is to create a small test program for each
!! procedure or closely related procedures in the fpm test/ directory.
!!
!!  + make a subroutine for each component to be tested
!!  + in each test procedure start it with a call to UNIT\_CHECK\_START(3f)
!!  + end each test procedure it with a call to UNIT\_CHECK\_END(3f)
!!  + make multiple calls to UNIT\_CHECK(3f) in-between to generate
!!    test results
!!  + call each of those test routines from the main program
!!  + end the main program with a call to UNIT\_CHECK\_STOP(3f)
!!
!! Optionally, before starting set preferred non-default modes.
!!
!! Use the 'fpm test' command to run specific tests; all tests (the default);
!! a list of tests or test names using simple globbing.
!!
!! As desired, command line options can be used to control various test
!! behaviors.
!!
!! As an example, we can create a skeleton program to test a few
!! routines. Using
!!
!!      fpm test_suite sqrt cos sin > test/test_suite.f90
!!
!! to create the skeleton program and then adding a few actual
!! calls to unit\_test\_check(3f) results in
!!
!!   Sample program:
!!
!!    program M_test_suite_M_intrinsics
!!    use,intrinsic :: iso_fortran_env, only : &
!!    & stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
!!    !
!!    use M_framework, only : unit_test_start,unit_test,unit_test_end, &
!!                     unit_test_mode, unit_test_level, unit_test_stop
!!    use M_framework, only : CHECK_PREFIX ! change column one of messages
!!    !
!!    !use M_mymodule ! load any modules you will be testing
!!    implicit none
!!    double precision,allocatable :: expected(:), answers(:), input(:)
!!    double precision,parameter :: PI=atan(1.0d0)*4
!!    !! setup
!!       !---------------------------------------------------
!!       !OPTIONAL:
!!       !  values used in prefix column for various messages
!!       !  the default is to set them all to the basename of
!!       !  the executable running tests, but they can be
!!       !  altered. For example:
!!       CHECK_PREFIX=prefix(                  &
!!        check_MSG    =  'check_msg:   ', &
!!        check        =  'check:       ', &
!!        check_START  =  'check_start: ', &
!!        check_STOP   =  'check_stop:  ', &
!!        check_END    =  'check_end:   '  &
!!       )
!!       !---------------------------------------------------
!!       !OPTIONAL:
!!       ! the options available at run-time on the command
!!       ! line can have their defaults selected. See the
!!       ! man-page for the procedure for details.
!!       call unit_check_mode(
!!         ( keep_going=.true. ,
!!         flags=[character(len=0) ::],
!!         luns=[stdout],
!!         command, &
!!         brief=.false. ,
!!         interactive=.false. ,
!!         CMDLINE='',
!!         debug=.false. ,
!!         match
!!         )
!!       !---------------------------------------------------
!!    !! test each subroutine
!!       call test_sqrt()
!!       call test_cos()
!!       call test_sin()
!!    !! teardown
!!       call unit_test_stop()
!!    contains
!!    subroutine test_sqrt()
!!    integer :: i
!!       call unit_test_start('sqrt',msg='calculate the square root')
!!       input   =[1.0d0,4.0d0,9.0d0]
!!       expected=[1.0d0,2.0d0,3.0d0]
!!       answers=[(sqrt(input(i)),i=1,size(input))]
!!       call unit_test('sqrt', all(expected.eq.answers),&
!!          & 'check table of values')
!!       call unit_test('sqrt', sqrt(25.0d0).eq.5.0d0,&
!!          & 'got',sqrt(25.0d0),'expected',5.0d0)
!!       call unit_test_end('sqrt',msg='')
!!    end subroutine test_sqrt
!!
!!    subroutine test_sin()
!!       call unit_test_start('sin',msg='calculate the sine of a value')
!!       call unit_test_end('sin',msg='')
!!    end subroutine test_sin
!!
!!    subroutine test_cos()
!!       call unit_test_start('cos',msg='calculate the cosine of a value')
!!       call unit_test_end('cos',msg='')
!!    end subroutine test_cos
!!
!!    end program M_test_suite_M_intrinsics
!!
!! The output now looks like this (note if no calls to unit\_test
!! routines are made between unit_test_start(3f) and unit_test_end(3f)
!! the procedure gets an "UNTESTED" entry to remind you to make
!! some tests ..).
!!
!!    > check:       sqrt   SUCCESS : check table of values
!!    > check:       sqrt   SUCCESS : got 5.0000000000000000 expected 5.0000000000000000
!!    > check_end:   sqrt   PASSED  : GOOD:        2 BAD:        0 DURATION:00000000012000:
!!    > check_end:   cos    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:
!!    > check_end:   sin    UNTESTED: GOOD:        0 BAD:        0 DURATION:00000000000000:
!!    > check_stop:  TALLY  PASSED  : GOOD:        2 BAD:        0 DURATION:00000000000000
!!    > STOP 0
!!
!! this is a model that works particularly well for basic numeric procedures.
!!
!! Now it is just a matter of adding more calls to unit\_test(3f). This is
!! where procedures from the other modules become useful, as they provide
!! methods for comparing float values, for example. Since Fortran has
!! many powerful masking intrinsics usually just the unit\_test(3f) procedure
!! is required. In particular, be familiar with the ALL(3f), ANY(3f),
!! and PACK(3f) procedures.
!!
!! There are options to call a system command and use the initial string as
!! options, to interactively pause after each check, and to change options
!! like which output file to write on, what error level to use, and other
!! things I will hopefully solidify and document here.
!!
!!    RECOMMENDED BASIC USAGE
!!
!! So for an fpm(1) user a recommended process is to create and/or enter the
!! test/ directory and use the "unit\_test" program. It will make a test
!! program called "unit\_test\_$NAME.f90" for each name given on the command
!! line.
!!
!! There is a case made for closely related groups of procedures to share
!! a single test file that will be made a little bit later. For that, the
!! command "test\_suite" is used instead of "unit\_test".
!!
!! For now lets assume we have or plan to have the procedures
!! "a","b", and "c" in our package, and that we want to create a test for
!! each ( and that unit\_test(1) has been installed in your path):
!!
!!     cd $TOP_OF_FPM_PACKAGE
!!     cd test
!!     unit_test a b c
!!
!! If you then run "fpm test" the skeleton should run indicating the
!! procedures are not tested. Change the routines to actually call the
!! "unit\_test" procedure and you have the beginnings of a unit test for
!! your procedures.
!!
!! The "unit\_test(3f)" procedure in its simplest form takes a string that
!! is usually the procedure name and a logical expression, along with up
!! to twenty completely optional intrinsic scalar values which will be used
!! to create an optional message.
!!
!! The example programs also contain a placeholder call to unit\_test\_mode(3f).
!!
!!    PROCEDURAL AND COMMAND LINE MODE OPTIONS
!! The dummy skeleton routines all start with a call to unix\_check\_mode(3f).
!! Its documentation describes a few default modes you can change with the
!! routine. Essentially the same options are available on the command line
!! of the test program(s) as well.
!!
!!     # options may be specified in NAMELIST input format with no
!!     # extraneous spaces on the command line
!!     fpm test -- flags=100,200,300 keep_going=T
!!     # a little more Unix-like or MSWindows-like syntax is allowed, as
!!     # these are equivalent to the original command ...
!!     fpm test -- --flags=100,200,300 --keep_going
!!     fpm test -- /flags=100,200,300 /keep_going=T
!!
!! M_framework(3f) uses a built-in command line parser instead of
!! packages like M\_CLI or M\_CLI2 to minimize the number of dependencies
!! required.
!!
!!    SUGGEST ONE TEST PER PROGRAM
!!
!! There are advantages to each procedure being tested with a separate
!! program.
!!
!! A large number of individual test programs works well with fpm(1).
!! fpm defaults to running all the tests, but can execute subgroups
!! easily because it can execute a list of tests and the names can
!! use simple globbing.
!!
!! If you autogenerate a list of procedure names to test and call the
!! sample program "unit_test" with the names of the procedures it will
!! generate new names but skip existing files; allowing for a simple form
!! of auto-generation assuming you have a way of listing all the procedure
!! names to test.
!!
!! individual procedure tests can be deleted or added or moved easily when
!! each is in its own file.
!!
!! It is easier to test with debuggers and other tools like gdb and valgrind
!! on small units.
!!
!! This is true with other tools that you can use with --runner as well.
!! See "fpm help runner" or "fpm manual \>manual.txt" for more information.
!!
!!     TESTING MANY PROCEDURES IN A SINGLE FILE
!!
!! If it is preferred, one program can test multiple procedures. The
!! main disadvantage is that the complete test suite is always run unless
!! conditional coding is added. One of the uses of the unit\_test\_flags(:)
!! array is to allow integer values to be passed at execution time that
!! can be tested to provide such conditional testing. When many tests are
!! in one file the unit_test_start(3f) procedure includes a "matched" argument
!! which can detect if a simple globbing expression that can be given on the
!! command line matches the string composed of the test name and message.
!! This allows you to optionally select specific groups of tests from a set.
!!
!!##UNIQUE FEATURES
!!
!!    CALLING AN EXTERNAL PROGRAM
!!
!! A unique feature of the M\_framework(3f) test harness is a hook to call
!! a custom program. You can ignore it is there, but it is a very powerful
!! feature if you want to do bookkeeping on the test results or enter
!! the results into a tracking tool. This allows you a way to sent alerts
!! if something fails in automated tests, to create spreadsheets with the
!! test results, to retain results in a database or SQLite3 file, or make
!! a custom tool to convert the data to something else like TAP (Test Anywhere
!! Protocol) reports.
!!
!! An example program called "bookkeeper" is included that shows how to
!! parse the information passed to the program that generates several files:
!!
!!    + bookkeeper.csv
!!    + bookkeeper.html
!!    + bookkeeper.nml
!!    + bookkeeper\_clicks.csv
!!
!! To use the defaults you simply enter
!!
!!     fpm test -- command=bookkeeper
!!
!! The CSV files can typically be read directly into a spreadsheet program.
!!
!! They can also be read using the SQLite3 tool. This is very powerful,
!! letting you use SQL to select specific data, generate reports, and
!! convert the subsequent results to HTML, CSV, flat text and other formats.
!!
!! The NAMELIST output file is essentially a record of the harness calls
!! using the standardized NAMELIST format that is almost trivial to read
!! in with a custom Fortran program. This might be considered a metafile
!! format for a test run. You can replay the data and do whatever you want
!! with it including generating alternate output file types; plotting
!! timing data and so on.
!!
!! The HTML file is handy for importing into word processors or viewing
!! via browsers. Example output files from an fpm(1) package that uses
!! M_framemaker illustrate the different types of output that can be
!! generated.
!!  + [CSV](https://urbanjost.github.io/M_framework/bookkeeper.csv).
!!    Generally. comma-separated files can be read directly into spreadsheet
!!    programs, sqlite3, and several common databases.
!!  + [CSV runtimes](https://urbanjost.github.io/M_framework/bookkeeper_clicks.csv)
!!    Another CSV file that is a record of the runtimes between a
!!    unit test start and end.
!!  + [HTML](https://urbanjost.github.io/M_framework/bookkeeper.html)
!!    An example of a formatted report that can be displayed in a browser.
!!  + [NAMELIST](https://urbanjost.github.io/M_framework/bookkeeper.nml).
!!    Essentially this is a metafile that records the unit test calls.
!!    It is very easy for a custom Fortran program to read back a NAMELIST
!!    file and generate custom outputs instead of modifying bookkeeper(1).
!!
!! The bookkeeper(1) program is an example program that is expected to
!! be customized. It provides for parsing the parameters passed to a
!! M_framemaker external program.
!!
!!     IMPORTING INTO SQLLITE3
!! Here is an example SQLite3 Tool input file that if placed in "test.sql"
!! can be run with
!!
!!      sqlite3 -batch -init test.sql bookkeeper.db .quit
!!
!! if you have sqlite3(1) installed.
!!
!!    .mode csv
!!    .import bookkeeper.csv unit_check
!!    .schema unit_check
!!    ---
!!    --- show all data to show it worked
!!    SELECT * FROM unit_check;
!!    ---
!!    --- example lists unique names
!!    SELECT name FROM unit_check GROUP BY name ORDER BY name ;
!!    ---
!!    --- tally up passed, failed, skipped in a text table
!!    .header on
!!    .mode column unit_check
!!    .width 64 9 9 9
!!    SELECT name,
!!    --- depending on SQL version a simpler IIF/IF, IFNULL, or TOTAL might be better but this works well
!!    --- and is relatively "standard" as much as something like a standard is actually adhered to in
!!    --- SQL-land.
!!    CASE  sum( passed == 'passed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'passed')  END  AS 'ok',
!!    CASE  sum( passed == 'failed'  ) WHEN NULL THEN 0 ELSE sum ( passed == 'failed')  END  AS 'not ok',
!!    CASE  sum( passed == 'skipped' ) WHEN NULL THEN 0 ELSE sum ( passed == 'skipped') END  AS 'skip'
!!    FROM unit_check
!!    --- WHERE condition
!!    GROUP BY name
!!    ORDER BY name ;
!!    ---
!!    --- If the table already exists, the sqlite3 tool uses all the rows,
!!    --- including the first row, in the CSV file as the actual data to import.
!!    --- Therefore, you should delete the first row of the CSV file with the
!!    --- header labels if adding to an existing table instead of creating
!!    DROP TABLE IF EXISTS unit_check;
!!    --- CREATE TABLE unit_check(
!!    ---   name   TEXT NOT NULL,
!!    ---   date   DATE NOT NULL,
!!    ---   passed TEXT NOT NULL,
!!    ---   msg    TEXT
!!    --- );
!!
!! The last select generates a little tally table showing for all the runs
!! in the input DataBaseFile the number of pass, fail, and skips of the test
!! names. you could tally over a particular date range, only show failures,
!! display the last test status, generating output in HTML or CSV or ...
!! See the SQLite3 Tool documentation for sqlite3(3f) for more information.
!!
!!    name                                          ok         not ok     skip
!!    --------------------------------------------  ---------  ---------  ---------
!!    accdig                                        3          0          0
!!    almost                                        24         0          0
!!    flush_trail                                   0          0          3
!!    in_margin                                     30         0          0
!!    round                                         0          0          3
!!    set_stdout_lun                                0          0          3
!!    significant                                   15         1          2
!!    unit_test                                     0          0          3
!!    unit_test_bad                                 0          0          3
!!    unit_test_end                                 0          0          3
!!    unit_test_good                                0          0          3
!!    unit_test_start                               0          0          6
!!    unit_test_stop                                0          0          3
!!    where_write_message_all                       0          0          3
!!    write_message_only                            4          2          4
!!
!!##UNIQUE FEATURES
!!
!! fpm(1), gdb(1), and M\_framework(3f) work together
!!
!! It is easy to debug an individual test in a debugger. For example to run
!! a test called "crash" with gdb(1) use
!!
!!      fpm test --target crash --runner "gdb -ex run --quiet"
!!
!! A more elaborate example passing arguments to M\_framework(3f) to change
!! default behavior to for example write output to stdout instead of stderr
!! and display compiler version and options and to run all the tests in
!! the gdb(1) debugger (you can enter "q" after each test has run; or enter
!! gdb commands at the prompt):
!!
!!     > fpm test --target '*' --verbose \
!!     > --runner 'gdb -ex "list, 0" -ex run --quiet --args' \
!!     > -- flags=9997,9998,9999 luns=6 level=3
!!
!! This is long enough that an alias or script would facilitate its use,
!! with one changing it to use one's favorite options.
!!
!!    EASILY CALLED BY STANDARDIZED CD/CI SCRIPTS
!!
!! If a CD/CI github automated test script creates a Fortran
!! environment including fpm and simply calls "fpm test" you can standardize
!! your testing and use the same CD/CI scripts for any package. The testing
!! framework is designed with just that scenario in mind.
!!
!! The .github subdirectory in M\_framework package contains examples of just
!! such files that you can copy as-is into your fpm project. Activate test
!! actions in your github repository after adding the .github directory and
!! your package will be automatically tested on several different platforms
!! by the scripts whenever a "push" to the repository occurs.
!!
!! ------------------------------------------------------------------------------------------
!!
!!##SUPPORTS FPM
!!
!! The impatient can try this, assuming git(1) and fpm(1) are installed.
!!
!! Download the github repository and build it with fpm(1)
!! and create a test fpm(1) project:
!!
!!    #!/bin/bash
!!    # first you need to install a few example programs
!!    cd /tmp
!!    git clone https://github.com/urbanjost/M_framework.git
!!    cd M_framework
!!    # install the "unit_test", "bookkeeper", and "test_suite"
!!    # example programs; assuming the default install puts
!!    # them in your path:
!!    fpm install
!!    # "fpm help install" describes how to customize where the
!!    # programs are installed.
!!    #
!!    # go to your fpm package test/ directory.
!!    # here, we will make one up
!!    fpm new /tmp/tryit  # create test project
!!    cd /tmp/tryit/test
!!    # so lets say you plan on adding procedures "a","b",and "c" to your src/tryit.f90
!!    # project code. Set up individual skeleton tests for each procedure.
!!    unit_test a b c                         # a file for each test
!!    test_suite a b c > test_suite_tryit.f90 # or a single file
!!    cd ..  # go to the top of the project
!!    # add M_framework to the developer dependencies
!!    cat >> fpm.toml <<\EOF
!!    [dev-dependencies]
!!    M_framework    = { git = "https://github.com/urbanjost/M_framework.git" }
!!    EOF
!!    #
!!    # test the package
!!    fpm test
!!    # if will say the procedures are untested. Put real calls
!!    # in to unit_test(3f) and see how the default report
!!    # changes
!!    #
!!    # so now to run the default tests is as simple as
!!    fpm test
!!    # run just one test
!!    fpm test unit_test_a
!!    # run tests using globbing; eg. all tests beginning with "unit\_"
!!    fpm test 'unit_*'
!!    # display help on the interactive command options
!!    fpm test -- --help
!!
!!    # you can pass parameters and/or change the unit_test_mode(3f)
!!    # calls to change some of the test behavior
!!
!! So once you want to use this on your own projects, you would normally
!! just add M\_framework(3f) as a developer dependency
!! in your fpm.toml project file and start making tests that call M\_framework(3f).
!!
!! The optional programs demonstrated ("unit\_test", "test\_suite") are just simple
!! stand-alone programs that make skeleton programs to run tests that you can
!! customize (and rename too to avoid confusion).
!!
!!    # some useful things to try. Check out the man-pages for all the unit_test_*(3f)
!!    # procedures.
!!    # Then look at
!!    unit_test --help
!!    fpm test -- help
!!    # run the demo bookkeeper script
!!    fpm test -- command=bookkeeper
!!    # and look at the bookkeeper*.* files in the top of the project
!!
!!##DOCUMENTATION
!!
!!   USER
!!
!!  - An [index](https://urbanjost.github.io/M_framework/man3.html) to HTML versions
!!    of the manpages
!!
!!  - single pages that uses javascript to combine all the HTML descriptions
!!    of the man-pages is at
!!     + [BOOK_M_framework__verify](https://urbanjost.github.io/M_framework/BOOK_M_framework__verify.html)
!!     + [BOOK_M_framework__approx](https://urbanjost.github.io/M_framework/BOOK_M_framework__approx.html)
!!     + [BOOK_M_framework__journal](https://urbanjost.github.io/M_framework/BOOK_M_framework__journal.html)
!!     + [BOOK_M_framework__msg](https://urbanjost.github.io/M_framework/BOOK_M_framework__msg.html)
!!
!!  - man-pages in
!!     + [manpages.zip](https://urbanjost.github.io/M_framework/manpages.zip)
!!     + [manpages.tgz](https://urbanjost.github.io/M_framework/manpages.tgz)
!!
!!    DEVELOPER
!!    + [ford-generated developers' document](https://urbanjost.github.io/M_framework/fpm-ford/index.html)
!!    + [github action status](docs/STATUS.md)
!!
!!##ADDITIONAL DIRECTORY DESCRIPTIONS
!!
!!    - src/ is where the source for the M_framework(3f) module code resides
!!    - docs/ contains HTML documentation and the manpage archives
!!    - test/ contains simple test programs
!!    - example/ has demos
!!
!!##REFERENCES
!!  + See the .github directory in [easy](https://github.com/urbanjost/easy)
!!  + for examples of CD/CI scripts that assume your package can be tested with an "fpm test" command.
!!  + examples that use M_framework in github fpm packages:
!!      * [M_strings](https://github.com/urbanjost/M_strings)
!!      * [M_process](https://github.com/urbanjost/M_process)
!!
!!    These packages used a different reincarnation of the testing harness and are in the process of
!!    being changed to use M_framework(3f) more appropriately, but still contain some useful examples.
!!
!!  + [Fortran Package Manager](https://github.com/fortran-lang/fpm)
!!  + [fpm(1) registry](https://github.com/fortran-lang/fpm-registry)
!!  + [Fortran Wiki: unit testing list](https://fortranwiki.org/fortran/show/Unit+testing+frameworks)
!!  + [ford(1)](https://politicalphysicist.github.io/ford-fortran-documentation.html) for generating documentation for your projects
!!
!!    NOTE
!! M_framework(3f) is subject to interface changes so the generally recommended
!! practice of using a specific commit when using it an an external
!! fpm(1) dependency is highly encouraged.
!!
!! Any feedback (features, performance, ease of use, ...) is appreciated,
!! particularly in the ongoing development phase.
!!
!!
!!##QUOTE
!!    Do not let your victories go to your head, nor let your failures go
!!    to your heart.
!!
!!##AUTHOR
!!    John S. Urban
!!##LICENSE
!!    Public Domain
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!===================================================================================================================================
end module M_framework

!>>>>> ././src/M_matrix.F90
!
! NAME
!    M_matrix(3f) - [M_matrix::INTRO] The Los Alamos-inspired Linear Algebra Fortran Facility (LALA)
!    LICENSE(MIT)
!
! DESCRIPTION
! The M_matrix module contains the Linear Algebra Fortran Facility (LALA)
! which allows for interacting with a Fortran program using Matlab
! or Octave-like commands. LALA is also usable as a simple one-line
! language. It is a WIP (Work In Progress) but is already useful.
!
!   * You can pass intrinsic-type data easily between your Fortran
!     program and the LALA utility.
!   * blocks of LALA commands may be passed to lala(3f) as well.
!   * external files containing lala(3f) commands may be read to create
!     data or as configuration files.
!   * LALA commands may be recorded and played back.
!   * a command-line based command history allowed for recalling and editing
!     input.
!   * a stand-alone program lets you create and test LALA files. It is
!     a flexible calculator utility all by itself.
!   * a built-in help command describes the many functions and commands
!   * a user-added Fortran routine may be called via the USER() function.
!
! All together, this allows lala(3f) to be used for self-describing
! configuration and data files, inspecting data in existing programs,
! transferring small amounts of data between programs or assisting in
! debugging and development, unit testing and macro-level timing.
!
! EXAMPLES
!   Sample program:
!
!     program demo_M_matrix
!     use M_matrix, only : lala, put_into_lala, get_from_lala, ifin_lala
!     !real,allocatable             :: r
!     !complex,allocatable          :: cvec(:)
!     integer,allocatable          :: iarr(:,:)
!     character(len=:),allocatable :: t(:)
!     integer                      :: ierr
!     integer                      :: i
!
!     ! store some data into lala(3)
!     call put_into_lala('A',[1,2,3,4,5]*10.5,ierr)
!     write(*,*)'is A defined in LALA?',ifin_lala('A')
!     call lala('A/2.0')
!
!     ! pass some commands to lala(3f)
!     call lala([character(len=80) :: &
!     &'PI=atan(1)*4               ', &
!     &"mytitle='this is my title';", &
!     &'littlearray=<              ', &
!     &'   1 2 3;                  ', &
!     &'   4 5 6;                  ', &
!     &'   7 8 9;                  ', &
!     &'>                          ', &
!     &'S=sum(A)                   ', &
!     &'I=inv(littlearray);        ', &
!     &'B=littlearray*sin(PI/3)    ', &
!     &"save('keepB',B)            ", &
!     &''])
!
!     ! read a file containing lala(3f) commands
!     call lala("exec('mycommands');")
!
!     ! interactively interact with lala(3f) interpreter
!     call lala()
!
!     ! get some data from LALA into the calling program
!     call get_from_lala('littlearray',iarr,ierr)
!     write(*,'(a)')'IN CALLING PROGRAM IARR='
!     write(*,'(1x,*(g0,1x))')(IARR(i,:),new_line('A'),i=1,size(iarr,dim=1))
!
!     call get_from_lala('mytitle',t,ierr)
!     write(*,*)'IN CALLING PROGRAM T=',t
!
!     end program demo_M_matri
module M_matrix
! https://orcid.org/0009-0000-9717-3407

use,intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT, stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT
use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64, real32, real64, real128

use M_strings,    only : value_to_string, lower, v2s, s2v, fmt
use M_framework,  only : journal
use M_help,       only : help_command
use M_history,    only : redo
use M_list,       only : insert, locate, replace, remove
use M_io,         only : lookfor, which
use M_intrinsics, only : help_intrinsics
use M_time,       only : d2u, d2j, d2m, d2b, BAStime, d2o, dow

use M_LA, only : mat_flop,   mat_inverse_hilbert,  mat_iwamax,  mat_magic,   mat_pythag,  mat_rat,    mat_round,  mat_rref
use M_LA, only : mat_rrot,   mat_rrotg,            mat_rset,    mat_rswap,   mat_urand,   mat_wasum,  mat_wcopy
use M_LA, only : mat_wdotci,           mat_wdotcr,  mat_wdotui,  mat_wdotur, mat_wmul,   mat_wnrm2,   mat_wpow
use M_LA, only : mat_wpofa,  mat_wrscal,           mat_wscal,   mat_wset,    mat_wsign,   mat_wsqrt,  mat_wswap

!use M_LA, only : mat_wdiv,   mat_wlog, mat_watan

!matx_waxpy,ml_comqr3,ml_corth,ml_htribk,ml_htridi,ml_imtql2,ml_wgeco,ml_wgedi,ml_wgefa,ml_wgesl,ml_wqrdc,ml_wqrsl,ml_wsvdc_
!
! SYNTAX DIAGRAMS (9)
!
!    A formal description of the language acceptable to LALA, as well as
!    a flow chart of the lala program, is provided by the syntax diagrams
!    or syntax graphs of wirth [6]. There are eleven non-terminal symbols
!    in the language:
!
!       LINE, STATEMENT, CLAUSE, EXPRESSION, TERM,
!       FACTOR, NUMBER, INTEGER, NAME, COMMAND, TEXT .
!
!    The diagrams define each of the non-terminal symbols using the others
!    and the terminal symbols:
!
!       LETTER -- A THROUGH Z,
!       DIGIT  -- 0 THROUGH 9,
!       CHAR   -- ( ) ; : + - * / \ = . , < >
!       QUOTE  -- '
!
!    LINE
!
!           |-----> STATEMENT >----|
!           |                      |
!           |-----> CLAUSE >-------|
!           |                      |
!    -------|-----> EXPR >---------|------>
!         | |                      | |
!         | |-----> COMMAND >------| |
!         | |                      | |
!         | |-> > >-> EXPR >-> < >-| |
!         | |                      | |
!         | |----------------------| |
!         |                          |
!         |        |-< ; <-|         |
!         |--------|       |---------|
!                  |-< , <-|
!
!    STATEMENT
!
!         |-> NAME >--------------------------------|
!         |          |                              |
!         |          |         |--> : >---|         |
!         |          |         |          |         |
!         |          |-> ( >---|-> EXPR >-|---> ) >-|
!         |                  |              |       |
!    -----|                  |-----< , <----|       |--> = >--> EXPR >--->
!         |                                         |
!         |       |--< , <---|                      |
!         |       |          |                      |
!         |-> < >---> NAME >---> > >----------------|
!
!    CLAUSE
!
!         |---> FOR   >---> NAME >---> = >---> EXPR >--------------|
!         |                                                        |
!         | |-> WHILE >-|                                          |
!         |-|           |-> EXPR >----------------------           |
!         | |-> IF    >-|          |   |   |   |   |   |           |
!    -----|                        <   <=  =   <>  >=  >           |---->
!         |                        |   |   |   |   |   |           |
!         |                        ----------------------> EXPR >--|
!         |                                                        |
!         |---> ELSE  >--------------------------------------------|
!         |                                                        |
!         |---> END   >--------------------------------------------|
!
!    EXPR
!
!           |-> + >-|
!           |       |
!    -------|-------|-------> TERM >---------->
!           |       |    |             |
!           |-> - >-|    |  |-< + <-|  |
!                        |  |       |  |
!                        |--|-< - <-|--|
!                           |       |
!                           |-< : <-|
!
!    TERM
!
!    ---------------------> FACTOR >---------------------->
!            |                                   |
!            |             |-< ^ <-|             |
!            |             |       |             |
!            |             |-< * <-|             |
!            |  |-------|  |       |  |-------|  |
!            |--|       |--|-< / <-|--|       |--|
!               |-< . <-|  |       |  |-< . <-|
!                          |-< \ <-|
!
!    FACTOR
!
!         |----------------> NUMBER >---------------|
!         |                                         |
!         |-> NAME >--------------------------------|
!         |          |                              |
!         |          |         |--> : >---|         |
!         |          |         |          |         |
!         |          |-> ( >---|-> EXPR >-|---> ) >-|
!         |                  |              |       |
!         |                  |-----< , <----|       |
!         |                                         |
!    -----|------------> ( >-----> EXPR >-----> ) >-|-|-------|----->
!         |                                         | |       | |
!         |                  |--------------|       | |-> ' >-| |
!         |                  |              |       |           |
!         |------------> < >-|---> EXPR >---|-> > >-|           |
!         |                    |          |         |           |
!         |                    |--<   <---|         |           |
!         |                    |          |         |           |
!         |                    |--< ; <---|         |           |
!         |                    |          |         |           |
!         |                    |--< , <---|         |           |
!         |                                         |           |
!         |------------> > >-----> EXPR >-----> < >-|           |
!         |                                         |           |
!         |                  | ^  |                 |           |
!         |-----> FACTOR >--->    >---> FACTOR >----|           |
!         |                  | ** |                 |           |
!         |                                                     |
!         |------------> ' >-----> TEXT >-----> ' >-------------|
!
!    NUMBER
!
!        |----------|                          |-> + >-|
!        |          |                          |       |
!    -----> INT >-----> . >---> INT >-----> E >---------> INT >---->
!                 |                   | |      |       |        |
!                 |                   | |      |-> - >-|        |
!                 |                   | |                       |
!                 |---------------------------------------------|
!
!    INT
!
!    ------------> DIGIT >----------->
!              |           |
!              |-----------|
!
!    NAME
!
!                      |--< LETTER <--|
!                      |              |
!    ------> LETTER >--|--------------|----->
!                      |              |
!                      |--< DIGIT  <--|
!
!    COMMAND
!
!                            |--> NAME >--|
!                            |            |
!    --------> NAME >--------|------------|---->
!                            |            |
!                            |--> CHAR >--|
!                            |            |
!                            |---> ' >----|
!
!    TEXT
!
!                    |-> LETTER >--|
!                    |             |
!                    |-> DIGIT >---|
!    ----------------|             |-------------->
!                |   |-> CHAR >----|   |
!                |   |             |   |
!                |   |-> ' >-> ' >-|   |
!                |                     |
!                |---------------------|
!
! Originally based on a routine called MATLAB, although heavily modified
! since. The original stated ...
!
!    MATLAB stands for MATrix LABoratory. It is a FORTRAN package
!    developed by Argonne National Laboratories for in-house use. It
!    provides comprehensive vector and tensor operations in a package
!    which may be programmed, either through a macro language or through
!    execution of script files.
!
!    Matlab is reentrant and recursive. Functions supported include (but
!    are not by any means limited to) sin, cos, tan, arc functions, upper
!    triangular, lower triangular, determinants, matrix multiplication,
!    identity, Hilbert matrices, eigenvalues and eigenvectors, matrix
!    roots and products, inversion and so on and so forth.
!
!    The file available on the bulletin board as Matlab.arc contains an
!    Amiga-ized executable copy of MATLAB and the online help file, as
!    well as this intro.
!
!    If you want the source code (over 300K) and a manual, or if your
!    bulletin board only has this message and not the package, send $5.00
!    and a 3.5" disk to:
!
!                               Jim Locker
!                               4443 N. Hyland Ave.
!                               Dayton, OH 45424
!
!    The package is public domain, but of course postage and reproduction
!    cost money. Believe me, this package is a bargain at the price.
!    Please feel free to distribute the package.
!
!    The source was taken off a VAX 11/780. It ran without modification
!    (except the file handler and some minor error handling) on an Amiga
!    1000 using ABSoft Fortran v2.2. It will run in 512K environment.
!    I have seen it on IBM mainframes and IBM PCs.
!
!    Subsequent changes per John S. Urban: see change log and git(1) histor
implicit none
!private

public lala
public get_from_lala  ! get_a_lala   ! ??? maybe a function too with a second parameter and returned value is of same type(?)
public put_into_lala  ! give_a_lala
public :: ifin_lala   ! lalain
public :: printit
!!public :: size_lala

! for other routines
public mat_flop
public mat_wasum
public mat_wdotcr
public mat_wdotci
! till get rid of type mismatches, the following are public

integer,parameter,private:: sp=kind(1.0),dp=kind(1.0d0)
character(len=*),parameter :: gen0='(*(g0))'
character(len=*),parameter :: gen1='(*(g0,1x))'
!==================================================================================================================================!
! program limits
integer,parameter        :: GG_LINELEN=1024
integer,parameter        :: GG_MAX_NUMBER_OF_NAMES=480
integer,parameter        :: GG_MAX_NAME_LENGTH=63
integer,parameter        :: GG_EOL=99999           ! make > 2256

!==================================================================================================================================!
character(len=GG_LINELEN),allocatable,save :: G_PSEUDO_FILE(:) ! allow for input to be passed from program instead of from file
logical                  :: G_PROMPT              ! companion for G_PSEUDO_FILE
logical,save             :: G_SYSTEM=.true.
logical,save             :: G_ECHO=.false.        ! echo input lines

integer                  :: G_LIN(GG_LINELEN)

integer                  :: G_LHS ! number of arguments on LHS
integer                  :: G_RHS ! number of arguments on RHS
integer                  :: G_FIN
integer                  :: G_FUN ! which function to call to process specified command
integer                  :: G_FMT ! which case in function to process a special command

integer                  :: G_LUN_READING_FROM
integer                  :: G_INPUT_LUN

integer                  :: G_PTZ
integer                  :: G_SYM
integer                  :: G_SYM_LEFT
integer                  :: G_SYN(GG_MAX_NAME_LENGTH)
!==================================================================================================================================!
integer                  :: G_CURRENT_RANDOM_SEED
integer                  :: G_FLOP_COUNTER(2)
integer                  :: G_DEBUG_LEVEL             ! select which debug messages to display. zero (0) is off
logical                  :: G_FILE_OPEN_ERROR         ! flag whether file open error occurred or not
integer                  :: G_ERR
integer                  :: G_LINECOUNT(4)            ! [1] lines displayed since count started
                                                      ! [2] line limit before warning (ie. page length+1)
                                                      ! [3] 0 or 1 for "semi" mode to be on or off
                                                      ! [4] flag from "exec" command, and ...

integer                  :: G_BUF(GG_LINELEN)
!==================================================================================================================================!
! PARSING
integer,parameter        :: G_PSIZE=32                        ! stack size for pseudo-recursion
integer                  :: G_IDS(GG_MAX_NAME_LENGTH,G_PSIZE)
integer                  :: G_PSTK(G_PSIZE)
integer                  :: G_RSTK(G_PSIZE)
integer                  :: G_PT

integer                  :: G_CHRA ! current character in line
integer                  :: G_LINE_POINTER(6) ! [1] first character to process in current line
                                              ! [2] last character to process in current line
                                              ! [3]
                                              ! [4] pointer into current character in current line being processed
                                              ! [5]
                                              ! [6]
!==================================================================================================================================!
integer,save                   :: GM_BIGMEM=-1                           ! allocated size of data storage
doubleprecision,allocatable    :: GM_REALS(:), GM_IMAGS(:)               ! set to size of GM_BIGMEM

integer                        :: G_VAR_IDS(GG_MAX_NAME_LENGTH, GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_VAR_DATALOC(GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_VAR_ROWS(GG_MAX_NUMBER_OF_NAMES)
integer                        :: G_VAR_COLS(GG_MAX_NUMBER_OF_NAMES)

type vctr
   integer :: rows
   integer :: cols
   doubleprecision,allocatable :: re(:)
   doubleprecision,allocatable :: im(:)
endtype vctr

character(len=:),allocatable   :: keywords(:)
integer,allocatable            :: locs(:)
integer,allocatable            :: rows(:)
integer,allocatable            :: cols(:)
type(vctr),allocatable         :: vals(:)

character(len=:),allocatable   :: scr_keywords(:)
integer,allocatable            :: scr_locs(:)
integer,allocatable            :: scr_rows(:)
integer,allocatable            :: scr_cols(:)

integer                     :: G_TOP_OF_SAVED, G_ARGUMENT_POINTER

!   Two large real arrays, GM_REALS and GM_IMAGS (for real and imaginary parts), are used to store all
!   the matrices. Four integer arrays (G_VAR_IDS, G_VAR_ROWS, G_VAR_COLS, G_VAR_DATALOC) are used to store the names,
!   the row and column dimensions, and the pointers into the real stacks. The following diagram illustrates this storage scheme.
!
!                    TOP        IDS       ROWS COLS LOCS              GM_REALS    GM_IMAGS
!                     --      -- -- -- --   --   --   --              --------   --------    <<== G_ARGUMENT_POINTER
!                    |  |--->|  |  |  |  | |  | |  | |  |----------->|        | |        |
!                     --      -- -- -- --   --   --   --              --------   --------
!                            |  |  |  |  | |  | |  | |  |            |        | |        |
!                             -- -- -- --   --   --   --              --------   --------
!                                  .         .    .    .                  .          .
!                                  .         .    .    .                  .          .
!                                  .         .    .    .                  .          .
!                             -- -- -- --   --   --   --              --------   --------
!                    BOT     |  |  |  |  | |  | |  | |  |            |        | |        |
!                     --      -- -- -- --   --   --   --              --------   --------
!                    |  |--->| X|  |  |  | | 2| | 1| |  |----------->|  3.14  | |  0.00  |  <<== G_TOP_OF_SAVED
!                     --      -- -- -- --   --   --   --              --------   --------
!                            | A|  |  |  | | 2| | 2| |  |---------   |  0.00  | |  1.00  |
!                             -- -- -- --   --   --   --          \   --------   --------
!                            | E| P| S|  | | 1| | 1| |  |-------   ->| 11.00  | |  0.00  |
!                             -- -- -- --   --   --   --        \     --------   --------
!                            | F| L| O| P| | 1| | 2| |  |------  \   | 21.00  | |  0.00  |
!                             -- -- -- --   --   --   --       \  \   --------   --------
!                            | E| Y| E|  | |-1| |-1| |  |---    \ |  | 12.00  | |  0.00  |
!                             -- -- -- --   --   --   --    \   | |   --------   --------
!   GG_MAX_NUMBER_OF_NAMES-> | R| A| N| D| | 1| | 1| |  |-   \  | |  | 22.00  | |  0.00  |
!                             -- -- -- --   --   --   --  \  |  \ \   --------   --------
!                                                         |  \   \ ->| 1.E-15 | |  0.00  |
!                                                         \   \   \   --------   --------
!                                                          \   \   ->|  0.00  | |  0.00  |
!                                                           \   \     --------   --------
!                                                            \   \   |  0.00  | |  0.00  |
!                                                             \   \   --------   --------
!                                                              \   ->|  1.00  | |  0.00  |
!                                                               \     --------   --------
!                                                                --->| URAND  | |  0.00  |  GM_BIGMEM
!                                                                     --------   --------
!
!   The top portion of the stack is used for temporary variables and the
!   bottom portion for saved variables. The figure shows the situation
!   after the line
!
!      A = [11,12; 21,22],  x = [3.14, sqrt(-1)]'
!
!   has been processed. The four permanent names, "eps", "flop", "rand"
!   and "eye", occupy the last four positions of the variable stacks.
!   RAND has dimensions 1 by 1, but whenever its value is requested,
!   a random number generator is used instead. "eye" has dimensions -1
!   by -1 to indicate that the actual dimensions must be determined
!   later by context. The two saved variables have dimensions 2 by 2
!   and 2 by 1 and so take up a total of 6 locations.
!
!   Subsequent statements involving A and x will result in
!   temporary copies being made in the top of the stack for use in
!   the actual calculations. Whenever the top of the stack reaches
!   the bottom, a message indicating memory has been exceeded is
!   printed, but the current variables are not affected.
!
!   This modular structure makes it possible to implement LALA
!   on a system with a limited amount of memory, as this can easily be
!   implemented with a direct-access file as well.
!==================================================================================================================================!
interface put_into_lala
   module procedure store_array_into_lala
   module procedure store_vector_into_lala
   module procedure store_scalar_into_lala
end interface put_into_lala

interface get_from_lala
   module procedure get_fixed_array_from_lala_dpcmplx
   module procedure get_fixed_array_from_lala_cmplx
   module procedure get_fixed_array_from_lala_real32
   module procedure get_fixed_array_from_lala_real64
   module procedure get_fixed_array_from_lala_real128
   module procedure get_fixed_array_from_lala_int8
   module procedure get_fixed_array_from_lala_int16
   module procedure get_fixed_array_from_lala_int32
   module procedure get_fixed_array_from_lala_int64
   module procedure get_fixed_array_from_lala_logical
   !module procedure get_fixed_array_from_lala_character !???? hmmm, does not meet current lala model

   module procedure get_fixed_vector_from_lala_dpcmplx
   module procedure get_fixed_vector_from_lala_cmplx
   module procedure get_fixed_vector_from_lala_real32
   module procedure get_fixed_vector_from_lala_real64
   module procedure get_fixed_vector_from_lala_real128
   module procedure get_fixed_vector_from_lala_int8
   module procedure get_fixed_vector_from_lala_int16
   module procedure get_fixed_vector_from_lala_int32
   module procedure get_fixed_vector_from_lala_int64
   module procedure get_fixed_vector_from_lala_logical
   module procedure get_fixed_vector_from_lala_character

   module procedure get_fixed_scalar_from_lala_character

   module procedure get_array_from_lala_dpcmplx
   module procedure get_array_from_lala_cmplx
   module procedure get_array_from_lala_real32
   module procedure get_array_from_lala_real64
   module procedure get_array_from_lala_real128
   module procedure get_array_from_lala_int8
   module procedure get_array_from_lala_int16
   module procedure get_array_from_lala_int32
   module procedure get_array_from_lala_int64
   module procedure get_array_from_lala_logical
   !module procedure get_array_from_lala_character !???? hmmm, does not meet current lala model

   module procedure get_vector_from_lala_dpcmplx
   module procedure get_vector_from_lala_cmplx
   module procedure get_vector_from_lala_real32
   module procedure get_vector_from_lala_real64
   module procedure get_vector_from_lala_real128
   module procedure get_vector_from_lala_int8
   module procedure get_vector_from_lala_int16
   module procedure get_vector_from_lala_int32
   module procedure get_vector_from_lala_int64
   module procedure get_vector_from_lala_logical
   module procedure get_vector_from_lala_character

   module procedure get_scalar_from_lala_dpcmplx
   module procedure get_scalar_from_lala_cmplx
   module procedure get_scalar_from_lala_real32
   module procedure get_scalar_from_lala_real64
   module procedure get_scalar_from_lala_real128
   module procedure get_scalar_from_lala_int8
   module procedure get_scalar_from_lala_int16
   module procedure get_scalar_from_lala_int32
   module procedure get_scalar_from_lala_int64
   module procedure get_scalar_from_lala_logical
   module procedure get_scalar_from_lala_character

end interface get_from_lala

interface lala
   module procedure lala_init
   module procedure lala_cmd
   module procedure lala_cmds
end interface lala

character(len=:),allocatable :: G_HELP_TEXT(:)
character(len=:),allocatable :: G_FORTRAN_TEXT(:)

!==================================================================================================================================!
! CHARACTER SET
integer,parameter        :: G_CHARSET_SIZE=256      ! number of characters in character set

! unused: `~!#%^&_?
! now allow all characters, using !#
! thinking ! for comments, & for continue like Fortran
! use % for shell commands?

character(len=*),parameter :: digit='0123456789'
character(len=*),parameter :: little='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter :: big='ABCDEFGHIJKLMNOPQRSTUVWXYZ'

integer,parameter :: dstar=3042

integer,parameter :: isname=0 ! -1000
integer,parameter :: isnum=1  ! -1001

integer,parameter :: blank=32 ! blank
!integer,parameter ::  =33 !  !
!integer,parameter :: doublequote=34 ! "
!integer,parameter ::  =35 ! #
!integer,parameter ::  =36 ! $
integer,parameter ::  percent=37 ! %
!integer,parameter ::  =38 ! &
integer,parameter ::  quote=39  ! '
integer,parameter ::  lparen=40 ! (
integer,parameter ::  rparen=41 ! )
integer,parameter ::  star=42   ! *
integer,parameter ::  plus=43   ! +
integer,parameter ::  comma=44  ! ,
integer,parameter ::  minus=45  ! -
integer,parameter ::  dot=46    ! .
integer,parameter ::  slash=47  ! /
integer,parameter ::  zero=48   ! 0
!integer,parameter ::  =49 ! 1
!integer,parameter ::  =50 ! 2
!integer,parameter ::  =51 ! 3
!integer,parameter ::  =52 ! 4
!integer,parameter ::  =53 ! 5
!integer,parameter ::  =54 ! 6
!integer,parameter ::  =55 ! 7
!integer,parameter ::  =56 ! 8
!integer,parameter ::  =57 ! 9
integer,parameter ::  colon=58  ! :
integer,parameter ::  semi=59   ! ;
integer,parameter ::  less=60   ! <
integer,parameter ::  equal=61  ! =
integer,parameter ::  great=62  ! >
!integer,parameter ::  =63 ! ?
!integer,parameter ::  =64 ! @
integer,parameter ::  a_up=65   ! A
!integer,parameter ::  =66 ! B
!integer,parameter ::  =67 ! C
integer,parameter :: d_up=68   ! D
integer,parameter ::  e_up=69   ! E
!integer,parameter ::  =70 ! F
!integer,parameter ::  =71 ! G
!integer,parameter ::  =72 ! H
!integer,parameter ::  =73 ! I
!integer,parameter ::  =74 ! J
!integer,parameter ::  =75 ! K
!integer,parameter ::  =76 ! L
!integer,parameter ::  =77 ! M
!integer,parameter ::  =78 ! N
!integer,parameter ::  =79 ! O
!integer,parameter ::  =80 ! P
!integer,parameter ::  =81 ! Q
!integer,parameter ::  =82 ! R
!integer,parameter ::  =83 ! S
!integer,parameter ::  =84 ! T
!integer,parameter ::  =85 ! U
!integer,parameter ::  =86 ! V
!integer,parameter ::  =87 ! W
!integer,parameter ::  =88 ! X
!integer,parameter ::  =89 ! Y
integer,parameter ::  z_up=90   ! Z
integer,parameter ::  lbracket=91 ! [
integer,parameter ::  bslash=92 ! backslash
integer,parameter ::  rbracket=93 ! ]
integer,parameter ::  caret =94 ! ^
integer,parameter ::  score=95  ! _
!integer,parameter ::  =96 ! `
integer,parameter ::  a_low=97  ! a
!integer,parameter ::  =98 ! b
!integer,parameter ::  =99 ! c
integer,parameter ::  d_low=100 ! d
integer,parameter ::  e_low=101 ! e
!integer,parameter ::  =102 ! f
!integer,parameter ::  =103 ! g
!integer,parameter ::  =104 ! h
!integer,parameter ::  =105 ! i
!integer,parameter ::  =106 ! j
!integer,parameter ::  =107 ! k
!integer,parameter ::  =108 ! l
!integer,parameter ::  =109 ! m
!integer,parameter ::  =110 ! n
!integer,parameter ::  =111 ! o
!integer,parameter ::  =112 ! p
!integer,parameter ::  =113 ! q
!integer,parameter ::  =114 ! r
!integer,parameter ::  =115 ! s
!integer,parameter ::  =116 ! t
!integer,parameter ::  =117 ! u
!integer,parameter ::  =118 ! v
!integer,parameter ::  =119 ! w
!integer,parameter ::  =120 ! x
!integer,parameter ::  =121 ! y
integer,parameter ::  z_low=122 ! z
integer,parameter ::  lbrace=123 ! {
!integer,parameter ::  =124 ! |
integer,parameter ::  rbrace=125 ! }
!integer,parameter ::  =126 ! ~

integer,parameter        :: GG_PAD(63)=blank
!==================================================================================================================================!
! allow for a user-defined subroutine.
! ??? expand this to allow for multiple routines and a user-specified name for the procedure
! ??? and a variable specifically for returning a user error
private :: usersub_placeholder

abstract interface
   subroutine usersub_interface(a,m,n,s,t)
      import dp
      integer :: m,n
      doubleprecision :: a(:)
      doubleprecision :: s,t
   end subroutine usersub_interface
end interface

public usersub_interface

procedure(usersub_interface),pointer :: usersub => usersub_placeholder
!==================================================================================================================================!
!==================================================================================================================================!

contains
!-----------------------------------------------------------------------------------------------------------------------------------
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!-----------------------------------------------------------------------------------------------------------------------------------
subroutine set_usersub(proc)
procedure(usersub_interface) :: proc
   usersub => proc
end subroutine set_usersub
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine usersub_placeholder(a,m,n,s,t)  ! sample usersub_placeholder routine
implicit none
integer                    :: m,n
doubleprecision            :: a(:)
doubleprecision            :: s,t
integer                    :: i, j, k
!  allowing for m and n to be changed complicates dimensioning a(m,n)
!  on most compilers overindexing would probably not be a problem in actuality
!  and dimensioning would not be either but not standard unless make allocatable.
!  See RESHAPE() and PACK() if passing to other routines
   write(*,*)'M=',m
   write(*,*)'N=',n
   write(*,*)'S=',s
   write(*,*)'T=',t
   k=0
   do i = 1, m
      do j = 1, n
         k=k+1
         write(*,*)i,j,a(k)
      enddo
   enddo
   k=0
   if(s.eq.0)s=1
   do i = 1, m
      do j = 1, n
         k=k+1
         a(k)=a(k)*s+t
      enddo
   enddo
end subroutine usersub_placeholder
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!
! NAME
!    LALA(3f) - [M_matrix] initialize and/or pass commands to matrix
!    laboratory interpreter
!    LICENSE(MIT)
! SYNOPSIS
!
!     subroutine lala(init,cmd)
!
!      integer,intent(in),optional :: init
!      character(len=*),intent(in),optional :: cmd
!         or
!      character(len=*),intent(in),optional :: cmd(:)
!
! DESCRIPTION
!    LALA(3f) is modeled on MATLAB(3f) (MATrix LABoratory), a FORTRAN
!    package developed by Argonne National Laboratories for in-house use.
!    It provides comprehensive vector and tensor operations in a package
!    which may be programmed, either through a macro language or through
!    execution of script files.
!
!    LALA(3f) Functions supported include (but are not by any means limited
!    to) sin, cos, tan, arcfunctions, upper triangular, lower triangular,
!    determinants, matrix multiplication, identity, Hilbert matrices,
!    eigenvalues and eigenvectors, matrix roots and products, inversion
!    and so on and so forth.
!
!    LALA() can be used
!       + as a stand-alone utility for working with lala() files and
!         for basic computations.
!       + embedded in a Fortran program, passing variables back and forth
!         between the calling program and the utility.
!       + to read configuration and data files that contain expressions
!         and conditionally selected values.
!       + for interactively inspecting data generated by the calling program.
!       + for creating unit tests that allow for further interactive examination.
!
!    The HELP command describes using the interpreter.
!
! OPTIONS
!    INIT    indicate size of scratch space to allocate and (re)initialize
!            LALA.
!
!    CMD     LALA command(s) to perform. May be CHARACTER scalar or vector
!
!    INIT and CMD cannot be combined on a single call.
!
!    The first call may be an initialization declaring the number of
!    doubleprecision complex values to allocate for the combined scratch
!    and variable storage area. This form may be repeated and reinitializes
!    the utility at each call. A size of zero will deallocate any allocated
!    storage (after which the routine cannot be called with commands until
!    reallocated by another call to lala()).
!
!    If no parameters are supplied interactive mode is entered.
!
!    If a CMD is passed and no previous initialization call was made the
!    scratch space will be allocated to 200000.
!
! EXAMPLES
!
!   Example 1:
!
!       program demo_LALA
!       use M_matrix, only : lala
!
!          write(*,'(a)')'optionally initialize scratch area size'
!          call LALA(20000)
!
!          write(*,'(a)')'do some commands'
!          call LALA([character(len=80) :: &
!          & 'semi;                         ',&
!          & 'a=magic(4),b=-a               ',&
!          & 'a+b;a;b                       ',&
!          & "display('That is all Folks!') "])
!
!          write(*,'(a)')'do a single command'
!          call LALA('who')
!
!          write(*,'(a)')'enter interactive mode'
!          call LALA()
!
!          write(*,'(a)')'ending program'
!       end program demo_LALA
!
!   Example 2:
!
!    program bigmat
!    use M_matrix, only : lala
!       ! pass strings to LALA but do not enter interactive mode
!       call lala(20000)                  ! initialize silently
!       call lala( 'a=[1 2 3 4; 5 6 7 8]')
!       call lala( [character(len=80) :: &
!        & 'semi;lines(999999)                                    ',&
!        & '// create a magic square and add 100 to all the values',&
!        & 'A=magic(4),<X,Y>=shape(A)                             ',&
!        & 'B=A+ones(X,Y)*100                                     ',&
!        & '// save all current values to a file                  ',&
!        & "save('sample.laf')                                    ",&
!        & '// clear all user values                              ',&
!        & 'clear                                                 ',&
!        & '// show variable names, load values from file         ',&
!        & '// and show again to show the variables are restored  ',&
!        & "who;load('sample.laf');who                            "])
!    end program bigmat
!
!   Example 3: Sample program with custom user function
!
!       program custom_user
!       use M_matrix
!       implicit none
!       call set_usersub(lala_user)
!       call lala()
!       contains
!       !-------------------------------------------------------------
!       subroutine lala_user(a,m,n,s,t)  ! sample user routine
!       ! Allows personal  Fortran  subroutines  to  be  linked  into
!       ! LALA. The subroutine should have the heading
!       !
!       !    subroutine name(a,m,n,s,t)
!       !    integer :: m,n
!       !    doubleprecision a(:),s,t
!       !
!       ! The LALA statement Y = USER(X,s,t) results in a call to
!       ! the subroutine with a copy of the matrix X stored in the
!       ! argument A, its column and row dimensions in M and N,
!       ! and the scalar parameters S and T stored in S and T.
!       ! If S and T are omitted, they are set to 0.0. After
!       ! the return, A is stored in Y. The dimensions M and
!       ! N may be reset within the subroutine. The statement Y =
!       ! USER(K) results in a call with M = 1, N = 1 and A(1,1) =
!       ! FLOAT(K). After the subroutine has been written, it must
!       ! be compiled and linked to the LALA object code within the
!       ! local programming environment.
!       !
!       implicit none
!       integer                    :: m,n
!       doubleprecision            :: a(:)
!       doubleprecision            :: s,t
!       integer                    :: i, j, k
!          write(*,*)'MY ROUTINE'
!          write(*,*)'M=',m
!          write(*,*)'N=',n
!          write(*,*)'S=',s
!          write(*,*)'T=',t
!          k=0
!          do i = 1, m
!             do j = 1, n
!                k=k+1
!                write(*,*)i,j,a(k)
!             enddo
!          enddo
!          k=0
!          if(s.eq.0)s=1
!          do i = 1, m
!             do j = 1, n
!                k=k+1
!                a(k)=a(k)*s+t
!             enddo
!          enddo
!       end subroutine lala_user
!       end program custom_user
!
!  Example inputs
!
!      >:avg:
!
!      >for i = 2:2:n, for j = 2:2:n, t = (a(i-1,j-1)+a(i-1,j)+a(i,j-1)+a(i,j))/4; ...
!      >a(i-1,j-1) = t; a(i,j-1) = t; a(i-1,j) = t; a(i,j) = t;
!
!      >:cdiv:
!
!      >// ======================================================
!      >// cdiv
!      >a=sqrt(random(8))
!      >ar = real(a); ai = imag(a); br = real(b); bi = imag(b);
!      >p = bi/br;
!      >t = (ai - p*ar)/(br + p*bi);
!      >cr = p*t + ar/br;
!      >ci = t;
!      >p2 = br/bi;
!      >t2 = (ai + p2*ar)/(bi + p2*br);
!      >ci2 = p2*t2 - ar/bi;
!      >cr2 = t2;
!      >s = abs(br) + abs(bi);
!      >ars = ar/s;
!      >ais = ai/s;
!      >brs = br/s;
!      >bis = bi/s;
!      >s = brs**2 + bis**2;
!      >cr3 = (ars*brs + ais*bis)/s;
!      >ci3 = (ais*brs - ars*bis)/s;
!      >[cr ci; cr2 ci2; cr3 ci3]
!      >// ======================================================
!
!      >:exp:
!
!      >t = 0*x + eye; s = 0*eye(x); n = 1;
!      >while abs(s+t-s) > 0, s = s+t, t = x*t/n, n = n + 1
!
!      >:four:
!      > n
!      > pi = 4*atan(1);
!      > i = sqrt(-1);
!      > w = exp(2*pi*i/n);
!      > F = [];
!      > for k = 1:n, for j = 1:n, F(k,j) = w**((j-1)*(k-1));
!      > F = F/sqrt(n);
!      > alpha = r*pi;
!      > rho = exp(i*alpha);
!      > S = log(rho*F)/i - alpha*eye;
!      > serr = norm(imag(S),1);
!      > S = real(S);
!      > serr = serr + norm(S-S',1)
!      > S = (S + S')/2;
!      > ferr = norm(F-exp(i*S),1)
!
!      > :gs:
!      > for k = 1:n, for j = 1:k-1, d = x(k,:)*x(j,:)'; x(k,:) = x(k,:) - d*x(j,:); ...
!      > end, s = norm(x(k,:)), x(k,:) = x(k,:)/s;
!
!      > :jacobi:
!      > [n, n] = shape(A);
!      > X = eye(n);
!      > anorm = norm(A,'fro');
!      > cnt = 1;
!      > while cnt > 0, ...
!      >   cnt = 0; ...
!      >   for p = 1:n-1, ...
!      >     for q = p+1:n, ...
!      >       if anorm + abs(a(p,q)) > anorm, ...
!      >         cnt = cnt + 1; ...
!      >         exec('jacstep'); ...
!      >       end, ...
!      >     end, ...
!      >   end, ...
!      >   display(rat(A)), ...
!      > end
!
!      > :jacstep:
!
!      > d = (a(q,q)-a(p,p))*0.5/a(p,q);
!      > t = 1/(abs(d)+sqrt(d*d+1));
!      > if d < 0, t = -t; end;
!      > c = 1/sqrt(1+t*t);  s = t*c;
!      > R = eye(n); r(p,p)=c; r(q,q)=c; r(p,q)=s; r(q,p)=-s;
!      > X = X*R;
!      > A = R'*A*R;
!
!      > :kron:
!
!      > //  C = Kronecker product of A and B
!      > [m, n] = shape(A);
!      > for i = 1:m, ...
!      >    ci = a(i,1)*B; ...
!      >    for j = 2:n, ci = [ci a(i,j)*B]; end ...
!      >    if i = 1, C = ci; else, C = [C; ci];
!
!      > :lanczos:
!
!      > [n,n] = shape(A);
!      > q1 = randu(n,1);
!      > ort
!      > alpha = []; beta = [];
!      > q = q1/norm(q1); r = A*q(:,1);
!      > for j = 1:n, exec('lanstep',0);
!
!      > :lanstep:
!
!      > alpha(j) = q(:,j)'*r;
!      > r = r - alpha(j)*q(:,j);
!      > if ort <> 0, for k = 1:j-1, r = r - r'*q(:,k)*q(:,k);
!      > beta(j) = norm(r);
!      > q(:,j+1) = r/beta(j);
!      > r = A*q(:,j+1) - beta(j)*q(:,j);
!      > if j > 1, T = diag(beta(1:j-1),1); T = diag(alpha) + T + T'; eig(T)
!
!      > :mgs:
!
!      > for k = 1:n, s = norm(x(k,:)), x(k,:) = x(k,:)/s; ...
!      >    for j = k+1:n, d = x(j,:)*x(k,:)'; x(j,:) = x(j,:) - d*x(k,:);
!
!      > :net:
!
!      > C = [
!      > 1   2   15  .   .   .
!      > 2   1   3   .   .   .
!      > 3   2   4   11  .   .
!      > 4   3   5   .   .   .
!      > 5   4   6   7   .   .
!      > 6   5   8   .   .   .
!      > 7   5   9   30  .   .
!      > 8   6   9   10  11  .
!      > 9   7   8   30  .   .
!      > 10  8   12  30  31  34
!      > 11  3   8   12  13  .
!      > 12  10  11  34  36  .
!      > 13  11  14  .   .   .
!      > 14  13  15  16  38  .
!      > 15  1   14  .   .   .
!      > 16  14  17  20  35  37
!      > 17  16  18  .   .   .
!      > 18  17  19  .   .   .
!      > 19  18  20  .   .   .
!      > 20  16  19  21  .   .
!      > 21  20  22  .   .   .
!      > 22  21  23  .   .   .
!      > 23  22  24  35  .   .
!      > 24  23  25  39  .   .
!      > 25  24  .   .   .   .
!      > 26  27  33  39  .   .
!      > 27  26  32  .   .   .
!      > 28  29  32  .   .   .
!      > 29  28  30  .   .   .
!      > 30  7   9   10  29  .
!      > 31  10  32  .   .   .
!      > 32  27  28  31  34  .
!      > 33  26  34  .   .   .
!      > 34  10  12  32  33  35
!      > 35  16  23  34  36  .
!      > 36  12  35  38  .   .
!      > 37  16  38  .   .   .
!      > 38  14  36  37  .   .
!      > 39  24  26  .   .   .
!      > ];
!      > [n, m] = shape(C);
!      > A = 0*ones(n,n);
!      > for i=1:n, for j=2:m, k=c(i,j); if k>0, a(i,k)=1;
!      > check = norm(A-A',1), if check > 0, quit
!      > [X,D] = eig(A+eye);
!      > D = diag(D);  D = D(n:-1:1)
!      > X = X(:,n:-1:1);
!      > [x(:,1)/sum(x(:,1)) x(:,2) x(:,3) x(:,19)]
!
!      > :pascal:
!
!      > //Generate next Pascal matrix
!      > [k,k] = shape(L);
!      > k = k + 1;
!      > L(k,1:k) = [L(k-1,:) 0] + [0 L(k-1,:)];
!
!      > :pdq:
!
!      > alpha = []; beta = 0; q = []; p = p(:,1)/norm(p(:,1));
!      > t = A'*p(:,1);
!      > alpha(1) = norm(t);
!      > q(:,1) = t/alpha(1);
!      > X = p(:,1)*(alpha(1)*q(:,1))'
!      > e(1) = norm(A-X,1)
!      > for j = 2:r, exec('pdqstep',ip); ...
!      >    X = X + p(:,j)*(alpha(j)*q(:,j)+beta(j)*q(:,j-1))', ...
!      >    e(j) = norm(A-X,1)
!
!      > :pdqstep:
!
!      > t = A*q(:,j-1) - alpha(j-1)*p(:,j-1);
!      >    if ort>0, for i = 1:j-1, t = t - t'*p(:,i)*p(:,i);
!      > beta(j) = norm(t);
!      > p(:,j) = t/beta(j);
!      > t = A'*p(:,j) - beta(j)*q(:,j-1);
!      >    if ort>0, for i = 1:j-1, t = t - t'*q(:,i)*q(:,i);
!      > alpha(j) = norm(t);
!      > q(:,j) = t/alpha(j);
!
!      > :pop:
!
!      > y = [ 75.995   91.972  105.711  123.203   ...
!      >      131.669  150.697  179.323  203.212]'
!      > t = [ 1900:10:1970 ]'
!      > t = (t - 1940*ones(t))/40;   [t y]
!      > n = 8;  A(:,1) = ones(t);  for j = 2:n, A(:,j) = t .* A(:,j-1);
!      > A
!      > c = A\y
!
!      > :qr:
!
!      > scale = s(m);
!      > sm = s(m)/scale; smm1 = s(m-1)/scale; emm1 = e(m-1)/scale;
!      > sl = s(l)/scale; el = e(l)/scale;
!      > b = ((smm1 + sm)*(smm1 - sm) + emm1**2)/2;
!      > c = (sm*emm1)**2;
!      > shift = sqrt(b**2+c); if b < 0, shift = -shift;
!      > shift = c/(b + shift)
!      > f = (sl + sm)*(sl-sm) - shift
!      > g = sl*el
!      > for k = l: m-1, exec('qrstep',ip)
!      > e(m-1) = f
!
!      > :qrstep:
!
!      > exec('rot');
!      > if k <> l, e(k-1) = f
!      > f = cs*s(k) + sn*e(k)
!      > e(k) = cs*e(k) - sn*s(k)
!      > g = sn*s(k+1)
!      > s(k+1) = cs*s(k+1)
!      > exec('rot');
!      > s(k) = f
!      > f = cs*e(k) + sn*s(k+1)
!      > s(k+1) = -sn*e(k) + cs*s(k+1)
!      > g = sn*e(k+1)
!      > e(k+1) = cs*e(k+1)
!
!      > :rho:
!
!      > //Conductivity example.
!      > //Parameters ---
!      >    rho       //radius of cylindrical inclusion
!      >    n         //number of terms in solution
!      >    m         //number of boundary points
!      > //initialize operation counter
!      >    flop = [0 0];
!      > //initialize variables
!      >    m1 = round(m/3);   //number of points on each straight edge
!      >    m2 = m - m1;       //number of points with Dirichlet conditions
!      >    pi = 4*atan(1);
!      > //generate points in Cartesian coordinates
!      >    //right hand edge
!      >    for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);
!      >    //top edge
!      >    for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;
!      >    //circular edge
!      >    for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); ...
!      >       x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);
!      > //convert to polar coordinates
!      >    for i = 1:m-1, th(i) = atan(y(i)/x(i));  ...
!      >       r(i) = sqrt(x(i)**2+y(i)**2);
!      >    th(m) = pi/2;  r(m) = 1;
!      > //generate matrix
!      >    //Dirichlet conditions
!      >    for i = 1:m2, for j = 1:n, k = 2*j-1; ...
!      >       a(i,j) = r(i)**k*cos(k*th(i));
!      >    //Neumann conditions
!      >    for i = m2+1:m, for j = 1:n, k = 2*j-1; ...
!      >       a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));
!      > //generate right hand side
!      >    for i = 1:m2, b(i) = 1;
!      >    for i = m2+1:m, b(i) = 0;
!      > //solve for coefficients
!      >    c = A\b
!      > //compute effective conductivity
!      >    c(2:2:n) = -c(2:2:n)
!      >    sigma = sum(c)
!      > //output total operation count
!      >    ops = flop(2)
!
!      > :rogers.exec:
!
!      > exec('d.boug');                // reads data
!      > [g,k] = shape(p);              // p is matrix of gene frequencies
!      > wv = ncen/sum(ncen);           // ncen contains population sizes
!      > pbar = wv*p;                   // weighted average of p
!      > p = p - ones(g,1)*pbar;        // deviations from mean
!      > p = sqrt(diag(wv)) * p;        // weight rows of p by sqrt of pop size
!      > h = diag(pbar); h = h*(eye-h); // diagonal contains binomial variance: p*(1-p)
!      > r = p*inv(h)*p'/k;             // normalized covariance matrix
!      > eig(r)'
!
!      > :rosser:
!
!      > A  = [
!      >   611.  196. -192.  407.   -8.  -52.  -49.   29.
!      >   196.  899.  113. -192.  -71.  -43.   -8.  -44.
!      >  -192.  113.  899.  196.   61.   49.    8.   52.
!      >   407. -192.  196.  611.    8.   44.   59.  -23.
!      >    -8.  -71.   61.    8.  411. -599.  208.  208.
!      >   -52.  -43.   49.   44. -599.  411.  208.  208.
!      >   -49.   -8.    8.   59.  208.  208.   99. -911.
!      >    29.  -44.   52.  -23.  208.  208. -911.   99.  ];
!
!      > :rot:
!
!      > // subexec rot(f,g,cs,sn)
!      >    rho = g; if abs(f) > abs(g), rho = f;
!      >    cs = 1.0; sn = 0.0; z = 1.0;
!      >    r = norm([f g]); if rho < 0, r = -r; r
!      >    if r <> 0.0, cs = f/r
!      >    if r <> 0.0, sn = g/r
!      >    if abs(f) > abs(g), z = sn;
!      >    if abs(g) >= abs(f), if cs <> 0, z = 1/cs;
!      >    f = r;
!      >    g = z;
!
!      > :rqi:
!
!      > rho = (x'*A*x)
!      > x = (A-rho*eye)\x;
!      > x = x/norm(x)
!
!      > :setup:
!
!      > diary('xxx')
!      > !tail -f xxx > /dev/tty1 &
!      > !tail -f xxx > /dev/tty2 &
!
!      > :sigma:
!
!      > RHO = .5  M = 20  N = 10   SIGMA =  1.488934271883534
!      > RHO = .5  M = 40  N = 20   SIGMA =  1.488920312974229
!      > RHO = .5  M = 60  N = 30   SIGMA =  1.488920697912116
!
!      > :strut.laf:
!
!      > // Structure problem, Forsythe, Malcolm and Moler, p. 62
!      > s =  sqrt(2)/2;
!      > A = [
!      > -s  .  .  1  s   .  .  .  .  .  .  .  .  .  .  .  .
!      > -s  . -1  . -s   .  .  .  .  .  .  .  .  .  .  .  .
!      >  . -1  .  .  .   1  .  .  .  .  .  .  .  .  .  .  .
!      >  .  .  1  .  .   .  .  .  .  .  .  .  .  .  .  .  .
!      >  .  .  . -1  .   .  .  1  .  .  .  .  .  .  .  .  .
!      >  .  .  .  .  .   . -1  .  .  .  .  .  .  .  .  .  .
!      >  .  .  .  . -s -1  .  .  s  1  .  .  .   .  .  .  .
!      >  .  .  .  .  s   .  1  .  s  .  .  .  .  .  .  .  .
!      >  .  .  .  .  .   .  . -1 -s  .  .  1  s  .  .  .  .
!      >  .  .  .  .  .   .  .  . -s  . -1  . -s  .  .  .  .
!      >  .  .  .  .  .   .  .  .  . -1  .  .  .  1  .  .  .
!      >  .  .  .  .  .   .  .  .  .  .  1  .  .  .  .  .  .
!      >  .  .  .  .  .   .  .  .  .  .  . -1  .  .  .  s  .
!      >  .  .  .  .  .   .  .  .  .  .  .  .  .  . -1 -s  .
!      >  .  .  .  .  .   .  .  .  .  .  .  . -s -1  .  .  1
!      >  .  .  .  .  .   .  .  .  .  .  .  .  s  .  1  .  .
!      >  .  .  .  .  .   .  .  .  .  .  .  .  .  .  . -s -1];
!      > b = [
!      >  .  .  . 10  .   .  . 15  .  .  .  .  .  .  . 10  .]';
!
!      > :test1:
!
!      > // -----------------------------------------------------------------
!      > // start a new log file
!      > sh rm -fv log.txt
!      > diary('log.txt')
!      > // -----------------------------------------------------------------
!      > titles=['GNP deflator'
!      >  'GNP         '
!      >  'Unemployment'
!      >  'Armed Force '
!      >  'Population  '
!      >  'Year        '
!      >  'Employment  '];
!      > data = ...
!      > [ 83.0  234.289  235.6  159.0  107.608  1947  60.323
!      >   88.5  259.426  232.5  145.6  108.632  1948  61.122
!      >   88.2  258.054  368.2  161.6  109.773  1949  60.171
!      >   89.5  284.599  335.1  165.0  110.929  1950  61.187
!      >   96.2  328.975  209.9  309.9  112.075  1951  63.221
!      >   98.1  346.999  193.2  359.4  113.270  1952  63.639
!      >   99.0  365.385  187.0  354.7  115.094  1953  64.989
!      >  100.0  363.112  357.8  335.0  116.219  1954  63.761
!      >  101.2  397.469  290.4  304.8  117.388  1955  66.019
!      >  104.6  419.180  282.2  285.7  118.734  1956  67.857
!      >  108.4  442.769  293.6  279.8  120.445  1957  68.169
!      >  110.8  444.546  468.1  263.7  121.950  1958  66.513
!      >  112.6  482.704  381.3  255.2  123.366  1959  68.655
!      >  114.2  502.601  393.1  251.4  125.368  1960  69.564
!      >  115.7  518.173  480.6  257.2  127.852  1961  69.331
!      >  116.9  554.894  400.7  282.7  130.081  1962  70.551];
!      > short
!      > X = data;
!      > [n,p] = shape(X)
!      > mu = ones(1,n)*X/n
!      > X = X - ones(n,1)*mu;  X = X/diag(sqrt(diag(X'*X)))
!      > corr = X'*X
!      > y = data(:,p); X = [ones(y) data(:,1:p-1)];
!      > long e
!      > beta = X\y
!      > expected = [ ...
!      >    -3.482258634594421D+03
!      >     1.506187227124484D-02
!      >    -3.581917929257409D-02
!      >    -2.020229803816908D-02
!      >    -1.033226867173703D-02
!      >    -5.110410565317738D-02
!      >     1.829151464612817D+00
!      > ]
!      > display('EXPE and BETA should be the same')
!
!      > :tryall:
!
!      > diary('log.txt')
!      > a=magic(8)
!      > n=3
!      > exec('avg')
!      > b=random(8,8)
!      > exec('cdiv')
!      > exec('exp')
!      > exec('four')
!      > exec('gs')
!      > exec('jacobi')
!      > // jacstep
!      > exec('kron')
!      > exec('lanczos')
!      > // lanstep
!      > exec('longley')
!      > exec('mgs')
!      > exec('net')
!      > exec('pascal')
!      > exec('pdq')
!      > // pdqstep
!      > exec('pop')
!      > exec('qr')
!      > // qrstep
!      > exec('rho')
!      > exec('rosser')
!      > // rot
!      > exec('rqi')
!      > exec('setup')
!      > exec('sigma')
!      > exec('strut.laf')
!      > exec('w5')
!      > exec('rogers.exec
!      > exec('rogers.load
!
!      > :w5:
!
!      > w5 = [
!      >         1.     1.      0.      0.      0.
!      >       -10.     1.      1.      0.      0.
!      >        40.     0.      1.      1.      0.
!      >       205.     0.      0.      1.      1.
!      >       024.     0.      0.      0.     -4.
!      >
subroutine LALA_init(init,echo)

! ident_1="@(#) M_matrix lala(3f) initialize and/or pass commands to matrix laboratory interpreter"

integer,intent(in)          :: init
logical,intent(in),optional :: echo
doubleprecision             :: s,t
integer,parameter           :: EPS(GG_MAX_NAME_LENGTH)=   [iachar(['e','p','s',' ',' ']),GG_PAD(6:)]
integer,parameter           :: FLOPS(GG_MAX_NAME_LENGTH)= [iachar(['f','l','o','p','s']),GG_PAD(6:)]
integer,parameter           :: EYE(GG_MAX_NAME_LENGTH)=   [iachar(['e','y','e',' ',' ']),GG_PAD(6:)]
integer,parameter           :: RAND(GG_MAX_NAME_LENGTH)=  [iachar(['r','a','n','d',' ']),GG_PAD(6:)]

   if(present(echo)) G_ECHO=echo

   G_PROMPT=.true.
   G_ERR=0

   if(allocated(G_PSEUDO_FILE))deallocate(G_PSEUDO_FILE)
   allocate(G_PSEUDO_FILE(0))

   G_LIN=blank
   G_VAR_IDS=blank

   GM_BIGMEM=INIT
   if(GM_BIGMEM.lt.0)GM_BIGMEM=200000
   if(allocated(GM_REALS) )deallocate(GM_REALS)
   if(allocated(GM_IMAGS) )deallocate(GM_IMAGS)
   allocate(GM_REALS(GM_BIGMEM),GM_IMAGS(GM_BIGMEM))                      ! set to size of GM_BIGMEM

   G_INPUT_LUN = STDIN                                                    ! unit number for terminal input
   call mat_files(G_INPUT_LUN,G_BUF)
   G_LUN_READING_FROM = G_INPUT_LUN                                       ! current file to read commands from
   call mat_files(STDOUT,G_BUF)

   call mat_help_text()                                                   ! initialize help text
   G_CURRENT_RANDOM_SEED = 0                                              ! random number seed
   G_LINECOUNT(2) = 23                                                    ! initial line limit for paging output

   G_TOP_OF_SAVED = GG_MAX_NUMBER_OF_NAMES-3  ! move up to allow room for the built-in values eps, flops, eye, rand

   call mat_wset(5,0.0D0,0.0d0,GM_REALS(GM_BIGMEM-4),GM_IMAGS(GM_BIGMEM-4),1)

   call update('eps',1,1,GM_BIGMEM-4)
      !=============================================================
      call mat_copyid(G_VAR_IDS(1,GG_MAX_NUMBER_OF_NAMES-3),EPS)
      G_VAR_DATALOC(GG_MAX_NUMBER_OF_NAMES-3) = GM_BIGMEM-4
      G_VAR_ROWS(GG_MAX_NUMBER_OF_NAMES-3) = 1
      G_VAR_COLS(GG_MAX_NUMBER_OF_NAMES-3) = 1
      !=============================================================

   ! interesting way to calculate the epsilon value of a machine
   s = 1.0d0
   SET_ST: do
      s = s/2.0D0
      t = 1.0d0 + s
      if (t .LE. 1.0d0) exit
   enddo SET_ST

   GM_REALS(GM_BIGMEM-4) = 2.0d0*s

   call update('flops',1,2,GM_BIGMEM-3)
      !=============================================================
      call mat_copyid(G_VAR_IDS(1,GG_MAX_NUMBER_OF_NAMES-2),flops)
      G_VAR_DATALOC(GG_MAX_NUMBER_OF_NAMES-2) = GM_BIGMEM-3
      G_VAR_ROWS(GG_MAX_NUMBER_OF_NAMES-2) = 1
      G_VAR_COLS(GG_MAX_NUMBER_OF_NAMES-2) = 2
      !=============================================================

   call update('eye',-1,-1,GM_BIGMEM-1)
      !=============================================================
      call mat_copyid(G_VAR_IDS(1,GG_MAX_NUMBER_OF_NAMES-1), eye)
      G_VAR_DATALOC(GG_MAX_NUMBER_OF_NAMES-1) = GM_BIGMEM-1
      G_VAR_ROWS(GG_MAX_NUMBER_OF_NAMES-1) = -1
      G_VAR_COLS(GG_MAX_NUMBER_OF_NAMES-1) = -1
      !=============================================================

   GM_REALS(GM_BIGMEM-1) = 1.0D0

   call update('rand',1,1,GM_BIGMEM)
      !=============================================================
      call mat_copyid(G_VAR_IDS(1,GG_MAX_NUMBER_OF_NAMES), rand)
      G_VAR_DATALOC(GG_MAX_NUMBER_OF_NAMES) = GM_BIGMEM
      G_VAR_ROWS(GG_MAX_NUMBER_OF_NAMES) = 1
      G_VAR_COLS(GG_MAX_NUMBER_OF_NAMES) = 1
      !=============================================================

   G_FMT = 1
   G_FLOP_COUNTER(1) = 0
   G_FLOP_COUNTER(2) = 0
   G_DEBUG_LEVEL = 0
   G_PTZ = 0
   G_PT = G_PTZ

   G_FORTRAN_TEXT=help_intrinsics('manual',m_help=.true.)  ! load Fortran documentation

end subroutine LALA_init
!==================================================================================================================================
subroutine LALA_cmd(input_string,echo)

! ident_2="@(#) M_matrix lala(3f) run a single command in matrix laboratory interpreter and return to calling program"

character(len=*),intent(in) :: input_string
logical,intent(in),optional :: echo

   call lala_cmds( [input_string],echo=echo)

end subroutine LALA_cmd
!==================================================================================================================================
subroutine LALA_cmds(pseudo_file,echo)

! ident_3="@(#) M_matrix lala(3f) run an array of commands in matrix laboratory interpreter and return to calling program"

character(len=*),intent(in),optional :: pseudo_file(:)
logical,intent(in),optional          :: echo

   if(present(echo)) G_ECHO=echo

   if(GM_BIGMEM.LT.0)then
      call lala_init(200000)
   else
      G_INPUT_LUN = STDIN                                                    ! unit number for terminal input
      G_LUN_READING_FROM = G_INPUT_LUN                                       ! current file to read commands from
      G_PROMPT=.true.
   endif

   if(present(pseudo_file))then
      G_PSEUDO_FILE=[character(len=GG_LINELEN) :: pseudo_file,'quit;']
      G_PROMPT=.false.
   else
      if(allocated(G_PSEUDO_FILE))deallocate(G_PSEUDO_FILE)
      allocate(G_PSEUDO_FILE(0))
   endif

   PARSE_LINE : do
      call mat_parse()
      select case(G_FUN)
      case(1) ; call mat_matfn1()
      case(2) ; call mat_matfn2()
      case(3) ; call mat_matfn3()
      case(4) ; call mat_matfn4()
      case(5) ; call mat_matfn5()
      case(6) ; call mat_matfn6()
      case(21); call mat_matfn1()
      case(99); exit PARSE_LINE
      case default
      end select
   enddo PARSE_LINE

end subroutine LALA_cmds
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_err(n)

! ident_4="@(#) M_matrix mat_err(3fp) given error number write associated error message and set G_ERR"

integer,intent(in)   :: n

integer              :: i
integer              :: k
integer              :: lb
integer              :: lt
character(len=255)   :: msg

   G_ERR = n
   select case(n)
    case(1);  msg='Improper multiple assignment'
    case(2);  msg='Improper factor'
    case(3);  msg='Expected right parenthesis'
    case(4);  msg='Undefined variable: '//ade2str(G_IDS(:,G_PT+1)) ! extract variable name into buffer
    case(5);  msg='Column lengths do not match'
    case(6);  msg='Row lengths do not match'
    case(7);  msg='Text too long'
    case(8);  msg='Incompatible for ADDITION'
    case(9);  msg='Incompatible for SUBTRACTION'
    case(10); msg='Incompatible for MULTIPLICATION'
    case(11); msg='Incompatible for RIGHT DIVISION'
    case(12); msg='Incompatible for LEFT DIVISION'
    case(13); msg='Improper assignment to PERMANENT VARIABLE'
    case(14); msg='EYE-dentity undefined by CONTEXT'
    case(15); msg='Improper assignment to submatrix'
    case(16); msg='Improper command'
    case(17)
      lb = GM_BIGMEM - G_VAR_DATALOC(G_TOP_OF_SAVED) + 1
      lt = g_err + G_VAR_DATALOC(G_TOP_OF_SAVED)
      call journal(' Too much memory required')
      write(msg,'(1X,I7,'' Variables,'',I7,'' Temporaries,'',I7,'' Available.'')') lb,lt,GM_BIGMEM
    case(18); msg='Too many names'
    case(19); msg='Matrix is singular to working precision'
    case(20); msg='Matrix must be square'
    case(21); msg='Subscript out of range'
    case(22); write(msg, '(1x,"Recursion difficulties",*(i4))') (G_RSTK(i),i=1,G_PT)
    case(23); msg='Only 1, 2 or INF norm of matrix'
    case(24); msg='No convergence'
    case(25); msg='Can not use function name as variable'
    case(26); msg='Too complicated (STACK OVERFLOW)'
    case(27); msg='Division by zero is a NO-NO'
    case(28); msg='Empty macro'
    case(29); msg='Not positive definite'
    case(30); msg='Improper exponent'
    case(31); msg='Improper string'
    case(32); msg='Singularity of LOG or ATAN'
    case(33); msg='Too many colons'
    case(34); msg='Improper FOR clause'
    case(35); msg='Improper WHILE or IF clause'
    case(36); msg='Argument out of range'
    case(37); msg='Improper MACROS'
    case(38); msg='Improper file name'
    case(39); msg='Incorrect number of arguments'
    case(40); msg='Expecting statement terminator'
    case(41); msg='Incompatible for POWER'
    case(42); msg='new shape is not the same size as input'
    case(43); msg='shapes are not conformant'
    case(44); msg='operation not defined for complex values'
    case(45); msg='incorrect rank for argument'
    case default
       call journal('sc','*mat_err* internal error: unknown error code=',n)
       return
   end select

   if(G_system.and. n.eq.4)then
      system: block
      integer                   :: istat
      integer                   :: cmdstat
      character(len=GG_LINELEN) :: mline
      call mat_buf2str(mline,G_BUF,GG_LINELEN) ! convert ADE buffer to character
      call execute_command_line(trim(mline),cmdstat=istat)   ! call system shell
      end block system
   else
      k = max(1,G_LINE_POINTER(2) - G_LINE_POINTER(1)) ! number of spaces to shift arrow by
      call journal(' '//repeat(' ',k)//'/\--ERROR:'//msg)
   endif

end subroutine mat_err
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_files(lunit,iname,status)
integer                      :: lunit             ! logical unit number
                                                  ! if LUNIT is zero, return
                                                  ! if LUNIT = standard input, return
                                                  ! if LUNIT = standard output, return
                                                  ! if LUNIT is positive, open the unit to file name INAME
                                                  ! if LUNIT is negative, close the unit number
integer                      :: iname(GG_LINELEN) ! INAME = FILE NAME, 1 character per word
                                                  ! how to know length of iname?
character(len=1024)          :: name
character(len=*),optional    :: status
character(len=20)            :: status_local
integer                      :: ios
   if(present(status))then
      status_local=status
   else
      status_local='UNKNOWN'
   endif

   G_FILE_OPEN_ERROR=.false.
   select case(lunit)
    case(0)      ! error catcher
    case(stdin)  ! if unit is standard input return
    case(stdout) ! if unit is standard output return
    case(8)      ! diary file
       call mat_buf2str(name,iname,GG_LINELEN)
       call journal('O',trim(name)) ! open up trail file
    case(:-1)
      if(lunit.eq.-8)then
         call journal('O','')                                        ! close trail file
      else                                                           ! if LUNIT is negative, close the unit
         ios=0
         flush(unit=-lunit,iostat=ios)
         if(-lunit.ne.STDIN)then
            close(unit=-lunit,iostat=ios)
         endif
      endif
    case default                                                     !  ALL OTHER FILES
      call mat_buf2str(name,iname,GG_LINELEN)
      if(lunit.ne.STDIN)then
         open(unit=lunit,file=name,status=status_local,iostat=ios)      ! open a file
         if(ios.ne.0)then                                               ! general file open failure
            call journal('OPEN failed on file '//name)
            G_FILE_OPEN_ERROR=.true.                                    ! set the flag a file error occurred
            G_LUN_READING_FROM=G_INPUT_LUN                              ! set current file to read input lines from/to G_INPUT_LUN
         else
            G_FILE_OPEN_ERROR=.false.                                   ! set the flag a file error did not occur
         endif
      endif
   end select
end subroutine mat_files
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getsym()

! ident_5="@(#) M_matrix mat_getsym(3fp) get a symbol"

doubleprecision :: syv
doubleprecision :: s

integer         :: sign
integer         :: chcnt
integer         :: ss
integer         :: i
!.......................................................................
   INFINITE : do
      if (G_CHRA .ne. blank) exit INFINITE
      call mat_getch() ! get next character
   enddo INFINITE
!.......................................................................
   G_LINE_POINTER(2) = G_LINE_POINTER(3)
   G_LINE_POINTER(3) = G_LINE_POINTER(4)
   if ( verify(achar(G_CHRA),digit) == 0) then
      call mat_getval(syv)
      if (G_CHRA .ne. dot) goto 60
      call mat_getch() ! get next character
   elseif (verify(achar(G_CHRA),digit//big//little//achar(score)//achar(percent))== 0) then ! alphameric (0-9a-zA-Z_)
      ! name
      G_SYM = isname
      G_SYN=blank
      G_SYN(1) = G_CHRA
      do i=2,GG_MAX_NAME_LENGTH
         call mat_getch() ! get next character
         ! if not alphanumeric and not special like eol
         if (verify(achar(G_CHRA),digit//big//little//achar(score)//achar(percent))== 0 ) then
            G_SYN(i) = G_CHRA
         else
            exit
         endif
      enddo

      goto 90
   else ! special character
      ss = G_SYM
      G_SYM = G_CHRA
      call mat_getch() ! get next character
      if (G_SYM .ne. dot) goto 90
      ! is dot part of number or operator
      syv = 0.0d0
      if (.not.(verify(achar(G_CHRA),digit)== 0) ) then ! not a number character
         if (G_CHRA.eq.star.or.G_CHRA.eq.slash.or.G_CHRA.eq.bslash.or.G_CHRA.eq.caret) goto 90
         if (ss.eq.star .or. ss.eq.slash .or. ss.eq.bslash .or. ss.eq.caret) goto 90
      endif
   endif

   ! number
   chcnt = G_LINE_POINTER(4)
   call mat_getval(s)
   chcnt = G_LINE_POINTER(4) - chcnt
   if (G_CHRA .eq. GG_EOL) chcnt = chcnt+1
   syv = syv + s/10.0d0**chcnt
   goto 60

60 continue

   if (.not.(G_CHRA.ne.d_low .and. G_CHRA.ne.e_low .and. G_CHRA.ne.d_up .and. G_CHRA.ne.e_up) )then
      call mat_getch() ! get next character
      sign = G_CHRA
      if (sign.eq.minus .or. sign.eq.plus) call mat_getch() ! get next character
      call mat_getval(s)
      if (sign .ne. minus) syv = syv*10.0d0**s
      if (sign .eq. minus) syv = syv/10.0d0**s
   endif
   GM_IMAGS(GM_BIGMEM) = mat_flop(syv)
   G_SYM = isnum
   goto 90

90 continue

   if (G_CHRA .eq. blank) then
      call mat_getch() ! get next character till a non-blank is found
      goto 90
   endif

end subroutine mat_getsym
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_str2buf(string,buf,lrecl)

! ident_6="@(#) M_matrix mat_str2buf(3fp) convert string to hollerith"

! g95 compiler does not support Hollerith, this is a KLUDGE to give time to think about it

character(len=*),intent(in) :: string
integer,intent(in)          :: lrecl
integer,intent(out)         :: buf(:)
integer                     :: i

   buf=iachar(' ')
   do i=1,min(lrecl,len_trim(string),size(buf))
      buf(i)=iachar(string(i:i))
   enddo

end subroutine mat_str2buf
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
function str2ade(string) result(vec)

! ident_7="@(#) M_matrix mat_str2buf(3fp) convert CHARACTER TO ADE array vector"

character(len=*),intent(in)  :: string
integer,allocatable          :: vec(:)
integer                      :: i
   allocate(vec(len(string)))
   do i=1,len(string)
      vec(i)=iachar(string(i:i))
   enddo
end function str2ade
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
function ade2str(buf) result(string)

! ident_8="@(#) M_matrix mat_str2buf(3fp) convert ADE array to CHARACTER"

character(len=:),allocatable :: string
integer,intent(in)           :: buf(:)
integer                      :: i
   string=repeat(' ',size(buf))
   do i=1,size(buf)
      if(buf(i).ge.0 .or. buf(i).lt.255)then
         string(i:i)=achar(buf(i))
      else
         call journal('sc','ADE2STR:string contains unacceptable characters, position=',i,'ADE=',buf(i))
      endif
   enddo
end function ade2str
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_buf2str(string,buf,lrecl)

! ident_9="@(#) M_matrix mat_buf2string(3fp) convert hollerith to string"

integer,intent(in)     :: lrecl
integer,intent(in)     :: buf(:)
character(len=*)       :: string
integer                :: i
integer                :: ilen
   string(:)=' '
   ilen=len(string)
   do i=1,min(lrecl,ilen,size(buf))
      string(i:i)=achar(buf(i))
   enddo
end subroutine mat_buf2str
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine ints2str(ints,string,ierr)

! ident_10="@(#) M_matrix ints2str(3f) convert lala integers to a character variable"

! temporary procedure while writing ASCII-based upgrade

integer,intent(in)                       :: ints(:)
character(len=:),allocatable,intent(out) :: string
integer,intent(out)                      :: ierr
integer                                  :: i

   ierr=0
   if(allocated(string))deallocate(string)
   allocate(character(len=size(ints)) :: string)
   string(:)=' '
   do i=1,size(ints)
      if( ints(i).lt.G_CHARSET_SIZE .and. ints(i).ge.0 )then
         string(i:i)=achar(ints(i))
      else
         call journal('sc',' function name contains unacceptable characters:',ints(i))
         ierr=ierr+1
      endif
   enddo

end subroutine ints2str
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn6()
!
! ident_11="@(#) M_matrix mat_matfn6(3f) evaluate utility functions"
!
integer :: i, j, k
integer :: ia
integer :: ib
integer :: ja
integer :: jb
integer :: location
integer :: la
integer :: lb
integer :: ld
integer :: lj
integer :: ll
integer :: ls
integer :: m
integer :: ma
integer :: mn
integer :: n
integer :: na
integer :: nn
doubleprecision   :: eps0,eps,s,sr,si,t
character(len=80) :: message

   !write(*,*)'GOT HERE A:MAT_MATFN6:G_RHS:',G_RHS,':G_ARGUMENT_POINTER:',G_ARGUMENT_POINTER
   if(G_ARGUMENT_POINTER.le.0)then
      G_RHS=0
      location = 1
      m = 1
      n = 1
      G_ARGUMENT_POINTER=1
   else
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      m = G_VAR_ROWS(G_ARGUMENT_POINTER)
      n = G_VAR_COLS(G_ARGUMENT_POINTER)
   endif
   !write(*,*)'GOT HERE B:MAT_MATFN6:M:',m,':N:',n,':G_RHS:',G_RHS,':LOCATION:',location,':G_ARGUMENT_POINTER:',G_ARGUMENT_POINTER

!  functions/G_FIN
!  magi diag sum  prod user eye  rand ones chop shape kron  tril triu zeros
!    1    2    3    4    5    6    7    8    9   10   11-13  14   15   16

   FUN6: select case(G_FIN)
!===================================================================================================================================
   case(1) ! COMMAND::MAGIC
      if(G_RHS.ne.1)then
         call mat_err(39) ! Incorrect number of arguments
         return
      endif
      N = nint(GM_REALS(location))
      select case(N)
      case(1,3:)
         call mat_magic(GM_REALS(location),N,N)
         !call mat_rset(N*N,0.0D0,GM_IMAGS(location),1) ! copy scalar to a vector, thus setting array to zero
         GM_IMAGS(location:location+n*n-1)=0.0d0 ! set imaginary component to zero
         G_VAR_ROWS(G_ARGUMENT_POINTER) = N
         G_VAR_COLS(G_ARGUMENT_POINTER) = N
      case default  ! zero or negative dimension
         call mat_err(29) ! Not positive definite
         return
      end select
!===================================================================================================================================
   case(11,12,13) !  COMMAND::KRONECKER PRODUCT
      if (G_RHS .ne. 2) then
         call mat_err(39) ! Incorrect number of arguments
         return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      MA = G_VAR_ROWS(G_ARGUMENT_POINTER)
      NA = G_VAR_COLS(G_ARGUMENT_POINTER)
      LA = location + MAX(M*N*MA*NA,M*N+MA*NA)
      LB = LA + MA*NA

      if(too_much_memory(LB + M*N - G_VAR_DATALOC(G_TOP_OF_SAVED)) )return

!     MOVE A AND B ABOVE RESULT
      call mat_wcopy(MA*NA+M*N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LA),GM_IMAGS(LA),1)
      DO JA = 1, NA
        DO J = 1, N
          LJ = LB + (J-1)*M
          DO IA = 1, MA
!           GET J-TH COLUMN OF B
            call mat_wcopy(M,GM_REALS(LJ),GM_IMAGS(LJ),1,GM_REALS(location),GM_IMAGS(location),1)
!           ADDRESS OF A(IA,JA)
            LS = LA + IA-1 + (JA-1)*MA
            DO I = 1, M
!             A(IA,JA) OP B(I,J)
              IF (G_FIN .EQ. 11) &
              call mat_wmul( GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_FIN .EQ. 12) &
              call mat_wdiv( GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_FIN .EQ. 13)  &
              call mat_wdiv( GM_REALS(location),  GM_IMAGS(location),  &
                             GM_REALS(LS), GM_IMAGS(LS), &
                             GM_REALS(location),  GM_IMAGS(location))
              IF (G_ERR .GT. 0) return
              location = location + 1
            enddo
          enddo
        enddo
      enddo
      G_VAR_ROWS(G_ARGUMENT_POINTER) = M*MA
      G_VAR_COLS(G_ARGUMENT_POINTER) = N*NA
!===================================================================================================================================
   case(9) ! COMMAND::CHOP

      eps0 = 1.0d0
      do                                                                  ! recalculate epsilon
         eps0 = eps0/2.0d0
         t = mat_flop(1.0d0 + eps0)
         if (t .le. 1.0d0) exit
      enddo
      eps0 = 2.0d0*eps0

      G_FLOP_COUNTER(2) = int(GM_REALS(location))
      if (G_SYM .ne. SEMI) then
         write(message,'(''CHOP '',I2,'' PLACES.'')') G_FLOP_COUNTER(2)
         call journal(message)
      endif

      eps = 1.0d0
      do                                                                  ! recalculate epsilon
         eps = eps/2.0d0
         t = mat_flop(1.0d0 + eps)
         if (t .le. 1.0d0) exit
      enddo
      eps = 2.0d0*eps

      t = GM_REALS(GM_BIGMEM-4)
      if (t.lt.eps .or. t.eq.eps0) GM_REALS(GM_BIGMEM-4) = eps
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
   case(3) ! COMMAND::SUM
!      sr = 0.0d0
!      si = 0.0d0
!      mn = m*n
!      do i = 1, mn
!         ls = location+i-1
!         sr = mat_flop(SR+GM_REALS(LS))
!         si = mat_flop(SI+GM_IMAGS(LS))
!      enddo
!      GM_REALS(location) = sr
!      GM_IMAGS(location) = si
!      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
!      G_VAR_COLS(G_ARGUMENT_POINTER) = 1

      sum_command : block
      real(kind=dp),allocatable :: sum_real(:), sum_imag(:)
      integer :: dim
      integer :: sz
      dim=0
      select case(G_RHS)
      case(1)
      case(2)  ! if two parameters assume second one is dimension
         dim = int(GM_REALS(location))
         if( dim.lt.0 .or. dim.gt.2 )then
            call mat_err(21) ! Subscript out of range
            return
         endif
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select
      sum_real = [0.0d0]
      sum_imag = [0.0d0]
      mn = m*n
      ! should do in a loop and call mat_flop on each number instead of sum to trim values?
      if(dim.eq.0)then
         sum_real = [ sum(gm_reals( location:location+mn-1 ) ) ]
         sum_imag = [ sum(gm_imags( location:location+mn-1 ) ) ]
         sz=1
      else
         sum_real = sum( reshape(gm_reals( location:location+mn-1 ),[m,n]), dim )
         sum_imag = sum( reshape(gm_imags( location:location+mn-1 ),[m,n]), dim )
         sz=size(sum_real)
      endif
      GM_REALS(location:location+sz-1) = sum_real
      GM_IMAGS(location:location+sz-1) = sum_imag
      G_VAR_ROWS(G_ARGUMENT_POINTER) = sz
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endblock sum_command
!===================================================================================================================================
   case(4) ! COMMAND::PROD
      SR = 1.0D0
      SI = 0.0D0
      MN = M*N
      DO I = 1, MN
         LS = location+I-1
         call mat_wmul(GM_REALS(LS),GM_IMAGS(LS),SR,SI,SR,SI)
      enddo
      GM_REALS(location) = SR
      GM_IMAGS(location) = SI
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
!===================================================================================================================================
   case(5) ! COMMAND::USER
      ! The LALA statement "A = user(X,s,t)" results in a call to the
      ! subroutine with a copy of the matrix X stored in the argument A,
      ! its column and row dimensions in M and N, and the scalar parameters
      ! s and t stored in S and T. If s and t are omitted, they are set
      ! to 0.0. After the return, A is stored in Y. The dimensions M and
      ! N may be reset within the subroutine. The statement A = user(K)"
      ! results in a call with M = 1, N = 1 and A(1,1) = "float(K)".

      ! all of the arguments are in a vector that is part of the stack.
      ! the location points to the last value and M and N are set to the
      ! the row and column size of the last argument. G_RHS is the number
      ! of arguments.
      s = 0.0d0
      t = 0.0d0
      if (G_RHS .eq. 2) then
         s = GM_REALS(location)
         ! back up the stack one argument
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)   ! the end of argument X
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)            ! the size of X(M,N)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
      elseif(G_RHS.gt.2)then
         t = GM_REALS(location)
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1       ! back up to s
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         s = GM_REALS(location)
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1       ! back up to X
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
      else  ! if not 1,2,3 should it be an error???
      endif
      ! ??? if user routine changes size of array and/or should pass vector instead of address ???
      ! ??? user routine cannot do complex values? Just REAL ???
      call usersub(GM_REALS(location:),m,n,s,t)
      !call mat_rset(m*n,0.0d0,GM_IMAGS(location),1)      ! set the imaginary values to zero
      gm_imags(location:location+m*n-1)=0.0d0 ! set imaginary component to zero
      G_VAR_COLS(G_ARGUMENT_POINTER) = n               ! store the possibly new size
      G_VAR_ROWS(G_ARGUMENT_POINTER) = m
!===================================================================================================================================
   case(10) ! COMMAND::SHAPE
      ! store the two output values onto stack
      GM_REALS(location) = M
      GM_IMAGS(location) = 0.0D0
      GM_REALS(location+1) = N
      GM_IMAGS(location+1) = 0.0D0
      if(G_LHS.eq.1)then
         ! output is a 1x2 array so store values indicating the shape of the new stack value
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 2
      else
         ! output is two scalars
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1

         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
         G_VAR_DATALOC(G_ARGUMENT_POINTER) = location+1
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endif
!===================================================================================================================================
   case(2,14,15) ! COMMAND::DIAG=2
                 ! COMMAND::TRIL=14
                 ! COMMAND::TRIU=15
      k = 0
      if (G_RHS .eq. 2) then
         k = int(GM_REALS(location))
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
      endif

      if (G_FIN .ge. 14) then ! COMMAND::TRIL, COMMAND::TRIU
            do j = 1, n
               ld = location + j - k - 1 + (j-1)*m
               select case(G_FIN)
               case(14)
                        ll = j - k - 1
                        ls = ld - ll
               case(15)
                        ll = m - j + k
                        ls = ld + 1
               end select
               if (ll .gt. 0) call mat_wset(ll, 0.0d0, 0.0d0, GM_REALS(ls), GM_IMAGS(ls), 1)
            enddo
      elseif (m .eq. 1 .or. n .eq. 1) then
         n = max(m,n)+iabs(k)

         if(too_much_memory( location+n*n - G_VAR_DATALOC(G_TOP_OF_SAVED)) )return

         G_VAR_ROWS(G_ARGUMENT_POINTER) = n
         G_VAR_COLS(G_ARGUMENT_POINTER) = n
         do jb = 1, n
            do ib = 1, n
               j = n+1-jb
               i = n+1-ib
               sr = 0.0d0
               si = 0.0d0
               if (k.ge.0) ls = location+i-1
               if (k.lt.0) ls = location+j-1
               ll = location+i-1+(j-1)*n
               if (j-i .eq. k) sr = GM_REALS(ls)
               if (j-i .eq. k) si = GM_IMAGS(ls)
               GM_REALS(LL) = sr
               GM_IMAGS(LL) = si
            enddo
         enddo
      else
         if (k.ge.0) mn=min(m,n-k)
         if (k.lt.0) mn=min(m+k,n)
         G_VAR_ROWS(G_ARGUMENT_POINTER) = max(mn,0)
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
         if (mn .le. 0) exit FUN6
         do i = 1, mn
            if (k.ge.0) ls = location+(i-1)+(i+k-1)*m
            if (k.lt.0) ls = location+(i-k-1)+(i-1)*m
            ll = location+i-1
            GM_REALS(ll) = GM_REALS(ls)
            GM_IMAGS(ll) = GM_IMAGS(ls)
         enddo
      endif
      exit FUN6
!-----------------------------------------------------------------------------------------------------------------------------------
   case(6,7,8,16) ! COMMAND::EYE
                  ! COMMAND::RAND
                  ! COMMAND::ONES
                  ! COMMAND::ZEROS
      !write(*,*)'GOT HERE A:RAND:M:',m,':N:',n,':G_RHS:',G_RHS,':LOCATION:',location
      if (.not.(m.gt.1 .or. G_RHS.eq.0)) then

         if (G_RHS .eq. 2) then
            nn = int(GM_REALS(location))
            G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
            location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
            n = G_VAR_COLS(G_ARGUMENT_POINTER)
         endif

         if (n .le. 1) then
            m = max(int(GM_REALS(location)),0)
            if (G_RHS .eq. 2) n = max(nn,0)
            if (G_RHS .ne. 2) n = m

            if(too_much_memory( location+m*n - G_VAR_DATALOC(G_TOP_OF_SAVED))) return

            G_VAR_ROWS(G_ARGUMENT_POINTER) = m
            G_VAR_COLS(G_ARGUMENT_POINTER) = n
            if (m*n .eq. 0) exit FUN6
         endif

      endif

      do j = 1, n
         do i = 1, m

           ll = location+i-1+(j-1)*m             ! location to place value

           GM_IMAGS(ll) = 0.0d0      ! all of these functions set imaginary values to zero

           select case(G_FIN)
           case( 6 ) !::EYE
              if(i.eq.j)then               ! on the diagonal
                 GM_REALS(ll) = 1.0d0
              else
                 GM_REALS(ll) = 0.0d0
              endif
           case( 7 ) !::RAND
                 GM_REALS(ll)=mat_flop(mat_urand(G_CURRENT_RANDOM_SEED))
           case( 8 ) !::ONES
              GM_REALS(ll) = 1.0d0
           case( 16) !::ZEROS
              GM_REALS(ll) = 0.0d0
           case default
              call journal('should not get here: internal error')
           end select
         enddo
      enddo
      exit FUN6
!===================================================================================================================================
   case(17) ! COMMAND::GETENV
      GETENV : block
      character(len=:),allocatable :: answers(:)
      character(len=GG_LINELEN)    :: varname
      character(len=:),allocatable :: env_value
      allocate(character(len=0)    :: answers(0) )
      ! sort out what to do with an array of input later, for now concatenating into one string
      if (m.lt.1 .or. G_RHS.eq.0)then
         call journal('sc','<ERROR>getenv:needs an argument:rows=',m,' arg_count=',G_RHS)
         G_ERR=999
         return
      endif
      if (G_RHS.gt.1)then
         call journal('sc','<ERROR>getenv:too many arguments:arg_count=',G_RHS)
         G_ERR=999
         return
      endif

      ll=location
      do j=1,m
         varname=ade2str( int(GM_REALS(ll:ll+n-1)) )
         if(.not.mat_is_name(varname))then
               call journal('sc',' function name contains unacceptable characters')
               return
         endif
         ll=ll+n
         env_value=system_getenv(varname)
         ! do not leave it undefined or any variable on LHS will not be defined so make sure at least 1
         answers=[character(len=max(len(answers),len_trim(env_value),1)) :: answers,env_value]
      enddo

      m=size(answers,dim=1)
      n=len(answers)
      if(too_much_memory( location+m*n - G_VAR_DATALOC(G_TOP_OF_SAVED)) )return
      G_VAR_ROWS(G_ARGUMENT_POINTER) = m
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      if (m*n .eq. 0) exit FUN6

      ! so starting at GM_REALS(location) convert the characters to numbers and store the M x N number of characters
      do j = 1, n
         do i = 1, m
           ll = location+i-1+(j-1)*m             ! location to place value
           GM_IMAGS(ll) = 0.0d0             ! all of these functions set imaginary values to zero
           nn=iachar(answers(m)(j:j))
           if(nn.gt.0)then
              GM_REALS(ll) = real(nn)
           else
              call journal('sc','bad character')
              GM_REALS(ll) = 0.0d0
           endif
         enddo
      enddo
      endblock GETENV
      exit FUN6
!===================================================================================================================================
   case(18) ! COMMAND::DATE_AND_TIME
      DATETIME: block
      integer          :: time_values(8)
      integer          :: indx
      integer          :: keep
      integer          :: ll
      integer          :: weekday
      character(len=9) :: day
      integer          :: ierr
      type(BAStime)    :: bas
      if(G_RHS .eq. 1)then
         call date_and_time(values=time_values)
      elseif(G_RHS .eq. 2)then ! user-supplied DAT array
         ! NOT COMPLETE
         ! NOT COMPLETE
         ! NOT COMPLETE
         ! NOT COMPLETE
         M = G_VAR_ROWS(G_ARGUMENT_POINTER)
         N = G_VAR_COLS(G_ARGUMENT_POINTER)
         if(M*N.ne.8)then
            call mat_err(39) ! Incorrect number of arguments
            return
         endif
         time_values=10
      else
         call mat_err(39) ! Incorrect number of arguments
         return
      endif

      M = G_VAR_ROWS(G_ARGUMENT_POINTER)
      N = G_VAR_COLS(G_ARGUMENT_POINTER)
      keep=0
      do i = 1, m*n
         indx = location+i-1
         keep=keep+1
         ll=location+keep-1
         GM_IMAGS(ll:ll) = 0.0d0
         select case(nint(GM_REALS(indx)))
         case(1:8)
            GM_REALS(ll:ll) = dble(time_values(nint(GM_REALS(indx))))
         case(9)
            GM_REALS(ll:ll) = d2u(time_values)
         case(10)
            GM_REALS(ll:ll) = d2j(time_values)
         case(11)
            GM_REALS(ll:ll) = d2m(time_values)
         case(12)
            bas = d2b(time_values)
            GM_REALS(ll:ll) = bas%base_day ! whole days since the MJD Epoch date
            GM_IMAGS(ll:ll) = bas%secs     ! offset in seconds from start of BASE_DAY
         case(13)
            GM_REALS(ll:ll) = d2o(time_values)
         case(14)
            call dow(time_values, weekday, day, ierr)
            GM_REALS(ll:ll) = weekday
         case default
            keep=keep-1
         end select
      enddo
      if(keep==0)then
         keep=8
         GM_REALS(location:location+8-1) = dble(time_values)
         GM_IMAGS(location:location+8-1) = 0.0D0
      endif
      ! store the two output values onto stack
      ! output is a 1x8 array so store values indicating the size of the new stack value
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = keep
      endblock DATETIME
!===================================================================================================================================
   case(19) ! COMMAND::ALL
   all : block
   integer           :: all_are_zero
   integer           :: indx
   integer,parameter :: T=1, F=0
      if(G_RHS .NE. 1) then
         call mat_err(39) ! Incorrect number of arguments
         return
      endif
      all_are_zero=T
      M = G_VAR_ROWS(G_ARGUMENT_POINTER)
      N = G_VAR_COLS(G_ARGUMENT_POINTER)
      do i = 1, m*n
         indx = location+i-1
         if ( (GM_REALS(indx).eq.F).and.(GM_IMAGS(indx).eq.F) )then
            all_are_zero=F
            exit
         endif
      enddo
      GM_REALS(location) = all_are_zero
      GM_IMAGS(location) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
   endblock all
!===================================================================================================================================
   case(20) ! COMMAND::ANY
      any : block ! are any elements true
      integer           :: are_any_true
      integer           :: indx
      integer,parameter :: T=1, F=0
         if(G_RHS .NE. 1) then
            call mat_err(39) ! Incorrect number of arguments
            return
         endif
         are_any_true=F
         M = G_VAR_ROWS(G_ARGUMENT_POINTER)
         N = G_VAR_COLS(G_ARGUMENT_POINTER)
         do i = 1, m*n
            indx = location+i-1
            if ( (GM_REALS(indx).eq.F).and.(GM_IMAGS(indx).eq.F) ) cycle
            are_any_true=T
            exit
         enddo
         GM_REALS(location) = are_any_true
         GM_IMAGS(location) = 0.0d0
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endblock any
!===================================================================================================================================
   case(21,22,23) ! COMMAND::fmtc
                  ! COMMAND::fmti
                  ! COMMAND::fmtr
      fmts : block ! are any elements true
      integer                      :: indx
      character(len=GG_LINELEN)    :: passedfmt
      character(len=:),allocatable :: out
      integer                      :: istore
         !call mat_buf2str(passedfmt,G_BUF,GG_LINELEN) ! entire command
         !write(*,*)'GOT HERE A:',trim(passedfmt)
         select case(G_RHS)
         case(1)
            passedfmt=''
            M = G_VAR_ROWS(G_ARGUMENT_POINTER)
            N = G_VAR_COLS(G_ARGUMENT_POINTER)
         case(2)
            passedfmt=ade2str( int(GM_REALS(location:location+m*n-1)) )
            G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
            location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
            M = G_VAR_ROWS(G_ARGUMENT_POINTER)
            N = G_VAR_COLS(G_ARGUMENT_POINTER)
         case default
            call mat_err(39) ! Incorrect number of arguments
            return
         end select
         out=''
         do i = 1, m*n
            indx = location+i-1
            select case(G_FIN)
            case(21);
                    if(passedfmt.eq.''.and.m*n>1)passedfmt= '("(",1pg0,",",1pg0,")")'
                    out=out//fmt(cmplx(GM_REALS(indx),GM_IMAGS(indx),kind=dp),passedfmt)
            case(22);
                    if(passedfmt.eq.''.and.m*n>1)passedfmt='(i0,1x)'
                    out=out//fmt(nint(GM_REALS(indx),kind=int64),passedfmt)
            case(23);
                    if(passedfmt.eq.''.and.m*n>1)passedfmt='(1pg0,1x)'
                    out=out//fmt(GM_REALS(indx),passedfmt)
            end select
         enddo

         istore=len(out)
         GM_REALS(location:location+istore-1) = str2ade(out)
         GM_IMAGS(location:location+istore-1) = 0.0d0
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = istore
      endblock fmts
!===================================================================================================================================
   case(24) ! COMMAND::MAXVAL
      select case(G_RHS)
      case(1)
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select
      mn = m*n
      sr = maxval(GM_REALS(location:location+mn-1))
      si = 0.0d0
      GM_REALS(location) = sr
      GM_IMAGS(location) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
!===================================================================================================================================
   case(25) ! COMMAND::MINVAL

      select case(G_RHS)
      case(1)
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select

      mn = m*n
      sr = minval(GM_REALS(location:location+mn-1))
      si = 0.0d0
      GM_REALS(location) = sr
      GM_IMAGS(location) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
!===================================================================================================================================
   case(26,27) ! COMMAND::RANDU
               ! COMMAND::RANDN
      !write(*,*)'GOT HERE A:RANDU:M:',m,':N:',n,':G_RHS:',G_RHS,':LOCATION:',location
      rands: block
      integer :: rows
      integer :: cols

      ! check arguments

      if(m*n.ne.1)then    ! argument should be a scalar
         call mat_err(45) ! incorrect rank for argument
         return
      endif

      select case(G_RHS)
      case(1)
         rows = int(GM_REALS(location))
         cols = rows
      case(2)
         cols = int(GM_REALS(location))
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         m= G_VAR_ROWS(G_ARGUMENT_POINTER)
         n= G_VAR_COLS(G_ARGUMENT_POINTER)
         if(m*n.ne.1)then    ! argument should be a scalar
            call mat_err(45) ! incorrect rank for argument
            return
         endif
         rows = int(GM_REALS(location))
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select
      if(rows.lt.1 .or. cols.lt.1)then
         call mat_err(36) ! Argument out of range
         return
      endif

      if(too_much_memory( location+rows*cols - G_VAR_DATALOC(G_TOP_OF_SAVED))) return

      ! create random values

      do j = 1, cols
         do i = 1, rows
           ll = location+i-1+(j-1)*rows  ! location to place value
           select case(G_FIN)
           case( 26)
              GM_REALS(ll)=mat_flop(mat_urand(G_CURRENT_RANDOM_SEED))
           case( 27)
              do
                 sr = 2.0d0*mat_urand(G_CURRENT_RANDOM_SEED)-1.0d0
                 si = 2.0d0*mat_urand(G_CURRENT_RANDOM_SEED)-1.0d0
                 t = sr*sr + si*si
                 if (t .le. 1.0d0) exit
              enddo
              GM_REALS(ll) = mat_flop(sr*dsqrt((-(2.0d0*dlog(t)))/t))
           end select
           GM_IMAGS(ll) = 0.0d0          ! all of these functions set imaginary values to zero
         enddo
      enddo

      G_VAR_ROWS(G_ARGUMENT_POINTER) = rows
      G_VAR_COLS(G_ARGUMENT_POINTER) = cols

      endblock rands
!===================================================================================================================================
   case(28) ! COMMAND::RANDSEED
      !write(*,*)'GOT HERE A:RANDSEED:M:',m,':N:',n,':G_RHS:',G_RHS,':LOCATION:',location
      select case(G_RHS)
      case(0)
      case(1)
         if(m*n.ne.1)then
            call mat_err(45) ! incorrect rank for argument
            return
         endif
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select

      if(too_much_memory( location+m*n - G_VAR_DATALOC(G_TOP_OF_SAVED))) return

      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1

      if(G_RHS.eq.0)then
         GM_REALS(location) = G_CURRENT_RANDOM_SEED
      else
         G_CURRENT_RANDOM_SEED = GM_REALS(location)
         GM_REALS(location) = G_CURRENT_RANDOM_SEED
      endif
      GM_IMAGS(location) = 0.0d0
!===================================================================================================================================
!===================================================================================================================================
   case(29) ! COMMAND::SORT
      ! ignores imaginary component, change to sort rows and columns so could sort text, for example
      sort_command : block
      integer :: dim
      integer :: sz
      dim=0
      select case(G_RHS)
      case(1)
      case(2)  ! if two parameters assume second one is dimension
         dim = int(GM_REALS(location))
         if( dim.lt.0 .or. dim.gt.2 )then
            call mat_err(21) ! Subscript out of range
            return
         endif
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)
      case default
         call mat_err(39) ! Incorrect number of arguments
         return
      end select
      ! should do in a loop and call mat_flop on each number instead of sort to trim values?
      mn = m*n
      GM_REALS(location:location+mn-1) = qsort(gm_reals( location:location+mn-1 ) )
      GM_IMAGS(location:location+mn-1) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = mn
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endblock sort_command
!==================================================================================================================================!
   end select FUN6
!==================================================================================================================================!
end subroutine mat_matfn6
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_funs(id)

! ident_12="@(#) M_matrix ml_funcs(3fp) scan function list and set G_FUN and G_FIN"

integer,intent(in)                :: id(GG_MAX_NAME_LENGTH)
integer                           :: selector
character(len=GG_MAX_NAME_LENGTH) :: name
integer                           :: i

  name=' '
   do i=1,size(id)
      if(id(i).le.0)exit
      if(id(i).le.G_CHARSET_SIZE)then
         name(i:i)=achar(id(i))
      else
         call journal('sc',' function name contains unacceptable characters:',name,'... ADE=',id(i),'position=',i)
         G_FIN = 0
         return
      endif
   enddo
   !
   !  find value for given function name to determine what to call for each name.
   !     o first digit indicates which routine to call (SUBROUTINE MAT_MATFN[1-6])
   !     o remaining digits indicate nth number in computed goto in called routine
   select case(name)
   case('eps');             selector=000
   case('flop');            selector=000

   case('inv');             selector=101
   case('det');             selector=102
   case('rcond');           selector=103
   case('lu');              selector=104
   case('invh','inverse_hilbert','invhilb');  selector=105
   case('chol');            selector=106
   case('rref');            selector=107

   case('sin');             selector=201
   case('cos');             selector=202
   case('atan');            selector=203
   case('exp');             selector=204
   case('sqrt');            selector=205
   case('log');             selector=206
   case('eig');             selector=211
   case('schur');           selector=212
   case('hess');            selector=213
   case('poly');            selector=214
   case('roots');           selector=215
   case('abs');             selector=221  !  calling  codes  corresponding  to  the  function  names
   case('round','nint');    selector=222
   case('real');            selector=223
   case('imag','aimag');    selector=224
   case('conjg');           selector=225

   case('svd');             selector=301
   case('pinv');            selector=302
   case('cond');            selector=303
   case('norm');            selector=304
   case('rank');            selector=305
   case('pow','power');     selector=306
   case('reshape');         selector=307
   case('lt');              selector=308
   case('le');              selector=309
   case('eq');              selector=310
   case('ge');              selector=311
   case('gt');              selector=312
   case('ne');              selector=313
   case('pack');            selector=314

   case('qr');              selector=401
   case('orth');            selector=402

   case('exec','include','source','script');  selector=501
   case('save');            selector=502
   case('load');            selector=503
   case('print');           selector=504
   case('diary');           selector=505
   case('disp','display','echo');  selector=506
   case('base');            selector=507
   case('lines');           selector=508
   case('char');            selector=509
   case('plot');            selector=510
   case('rat');             selector=511
   case('debug');           selector=512
   case('show');            selector=513
   case('delete');          selector=514

   case('magic');           selector=601
   case('diag');            selector=602
    case('sum');             selector=603
   case('prod','product');  selector=604
   case('user');            selector=605
   case('eye');             selector=606
   case('rand','random');   selector=607
   case('ones');            selector=608
   case('chop');            selector=609
   case('shape');           selector=610
   case('kron');            selector=611
   case('tril');            selector=614
   case('triu');            selector=615
   case('zeros');           selector=616
   case('getenv');          selector=617
   case('date_and_time');   selector=618
   case('all');             selector=619
   case('any');             selector=620
   case('fmtc');            selector=621
   case('fmti');            selector=622
   case('fmtr');            selector=623
    case('maxval');          selector=624
    case('minval');          selector=625
   case('randu','rand%uniform');  selector=626
   case('randn','rand%normal');   selector=627
   case('randseed');        selector=628
   case('sort');            selector=629

   case default !  function name was not found
      G_FIN = 0
      return
   end select

!  found name so get G_FIN and G_FUN value from corresponding code

   G_FIN = mod(selector,100) ! which case to select in called procedure
   G_FUN = selector/100      ! which routine to call (SUBROUTINE MAT_MATFN[1-6])

   if (G_RHS.eq.0 .and. selector.eq.606) G_FIN = 0
   if (G_RHS.eq.0 .and. selector.eq.607) G_FIN = 0
   !write(*,*)'GOT HERE A:MAT_FUNS:NAME:',name,':G_FIN:',G_FIN,':G_RHS:',G_RHS
end subroutine mat_funs
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_copyid(x,y)

! ident_13="@(#) M_matrix mat_copyid(3fp) copy a name to allow an easy way to store a name"

integer,intent(out) :: x(GG_MAX_NAME_LENGTH)
integer,intent(in)  :: y(GG_MAX_NAME_LENGTH)
integer             :: i
      do i = 1, GG_MAX_NAME_LENGTH
         x(i) = y(i)
      enddo
end subroutine mat_copyid
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getval(s)

! ident_14="@(#) M_matrix mat_getval(3fp) form numerical value from string of "integer" characters"

doubleprecision,intent(out) :: s
      s = 0.0d0
      INFINITE: do
         select case(G_CHRA)
         case(iachar('0')); s = 10.0d0*s + 0.0d0
         case(iachar('1')); s = 10.0d0*s + 1.0d0
         case(iachar('2')); s = 10.0d0*s + 2.0d0
         case(iachar('3')); s = 10.0d0*s + 3.0d0
         case(iachar('4')); s = 10.0d0*s + 4.0d0
         case(iachar('5')); s = 10.0d0*s + 5.0d0
         case(iachar('6')); s = 10.0d0*s + 6.0d0
         case(iachar('7')); s = 10.0d0*s + 7.0d0
         case(iachar('8')); s = 10.0d0*s + 8.0d0
         case(iachar('9')); s = 10.0d0*s + 9.0d0
         case default
            exit INFINITE
         end select
         call mat_getch() ! get next character
      enddo INFINITE
end subroutine mat_getval
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getch()

! ident_15="@(#) M_matrix mat_getch(3f) get next character from input line into G_CHRA"

   G_CHRA = G_LIN(G_LINE_POINTER(4))
   if (G_CHRA .ne. GG_EOL) G_LINE_POINTER(4) = G_LINE_POINTER(4) + 1

end subroutine mat_getch
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_base(x,base,eps,s,n)

! ident_16="@(#) M_matrix mat_base(3fp) store representation of x in s(1 n) using specified base"

doubleprecision            :: x
doubleprecision,intent(in) :: base
doubleprecision,intent(in) :: eps
doubleprecision            :: s(*)
integer                    :: n

doubleprecision :: t

integer      :: l
integer      :: j
integer      :: k
integer      :: m

   l = 1
   if (x .ge. 0.0d0)then
      s(l) = plus
   else
      s(l) = minus
   endif
   s(l+1) = zero
   s(l+2) = dot
   x = dabs(x)
   if (x .ne. 0.0d0) then
      k = dlog(x)/dlog(base)
   else
      k = 0
   endif
   if (x .gt. 1.0d0) k = k + 1
   x = x/base**k
   if (base*x .ge. base) k = k + 1
   if (base*x .ge. base) x = x/base
   if (eps .ne. 0.0d0)then
      m = (-1)*dlog(eps)/dlog(base) + 4
   else
      m = 54
   endif
   do l = 4, m
      x = base*x
      j = int(x)
      s(l) = dble(j)
      x = x - s(l)
      s(l)=s(l)+48
   enddo
   s(m+1) = comma
   if (k .ge. 0) s(m+2) = plus
   if (k .lt. 0) s(m+2) = minus
   t = dabs(dble(k))
   n = m + 3
   if (t .ge. base) n = n + int(dlog(t)/dlog(base))
   l = n
   INFINITE: do
      j = int(dmod(t,base))
      s(l) = dble(j+48)
      l = l - 1
      t = t/base
      if (l .lt. m+3) exit
   enddo INFINITE
end subroutine mat_base
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_print(ID,K)

! ident_17="@(#) M_matrix mat_print(3fp) primary output routine"

integer           :: id(GG_MAX_NAME_LENGTH)
integer           :: k

character(len=81) :: message
character(len=80) :: form
character(len=1)  :: ls_char

doubleprecision   :: s
doubleprecision   :: tr
doubleprecision   :: ti
doubleprecision   :: pr(12)
doubleprecision   :: pi(12)
integer           :: sig(12)
integer           :: typ
integer           :: f
integer           :: location,m,n,mn
integer           :: ks
integer           :: i
integer           :: ios
integer           :: istep
integer           :: j
integer           :: j1
integer           :: j2
integer           :: j3
integer           :: jinc
integer           :: jm
integer           :: ls
integer,save      :: fno(11)= [11,12,21,22,23,24,31,32,33,34,-1]
integer,save      :: fnl(11)= [12, 6, 8, 4, 6, 3, 4, 2, 3, 1, 1]
integer           :: itype

! FORMAT NUMBERS AND LENGTHS
! G_FMT   1       2       3       4       5
!       SHORT   LONG   SHORT E  LONG E    Z
! TYP   1       2       3
!    INTEGER  REAL   COMPLEX
!.......................................................................
   if (G_LINECOUNT(1) .lt. 0) goto 99
!.......................................................................
   location = G_VAR_DATALOC(k)
   m = G_VAR_ROWS(k)
   n = G_VAR_COLS(k)
   mn = m*n
   typ = 1
   s = 0.0d0
   itype=-9999
   do i = 1, mn
      ls = location+i-1
      tr = GM_REALS(ls)
      ti = GM_IMAGS(ls)
      s = dmax1(s,dabs(tr),dabs(ti))
      if (mat_round(tr) .ne. tr) typ = max(2,typ)
      if (ti .ne. 0.0d0) typ = 3
   enddo
   if (s .ne. 0.0d0) s = dlog10(s)
   ks = int(s)
   if (-2 .le. ks .and. ks .le. 1) ks = 0
   if (ks .eq. 2 .and. G_FMT .eq. 1 .and. typ .eq. 2) ks = 0

   f=0                          ! initialize to bad value
   if (typ .eq. 1 )then         ! if output type is integer
      if( ks .le. 2 )then
         f = 1
      else
         f = 2
      endif
   endif
   if (typ .eq. 1 .and. ks .gt. 9) typ = 2  !change type from integer to real

   if (typ .eq. 2) f = G_FMT + 2   ! if type is real
   if (typ .eq. 3) f = G_FMT + 6   ! if type is complex
   if(f.eq.0)then
      call journal('*mat_print* internal error - bad type')
      goto 99
   endif

   if (mn.eq.1 .and. ks.ne.0 .and. G_FMT.lt.3 .and. typ.ne.1) f = f+2

   if (G_FMT .eq. 5) f = 11

   jinc = fnl(f)
   f = fno(f)

   s = 1.0d0
   if (f.eq.21 .or. f.eq.22 .or. f.eq.31 .or. f.eq.32) s = 10.0D0**ks
   ls = ((n-1)/jinc+1)*m + 2
!.......................................................................
   IF (G_LINECOUNT(1) + LS .gt. G_LINECOUNT(2)) then
      G_LINECOUNT(1) = 0

      if(G_PROMPT)then
         WRITE(message, "(' AT LEAST ',I5,' MORE LINES.','  ENTER BLANK LINE TO CONTINUE OUTPUT.')") LS
         call journal(message)

         READ(G_INPUT_LUN,'(a1)',END=19) LS_CHAR  ! read response to pause from standard input
         IF (LS_CHAR .EQ. ' ') goto 20      ! if blank or a return display the values
         G_LINECOUNT(1) = -1
         goto 99
      else
         LS_CHAR = ' '
         goto 20
      endif
   19 continue
      call mat_files(-G_INPUT_LUN,G_BUF)
   endif
   20 continue
!.......................................................................
   call journal(' ')
   call mat_print_id(ID,-1)
   G_LINECOUNT(1) = G_LINECOUNT(1)+2
   if (s .ne. 1.0d0)then
      write(message,'(''  '',1PD9.1," *")') s
      call journal(message)
   endif
   do j1 = 1, n, jinc
      j2 = min(n, j1+jinc-1)
      if (n .gt. jinc)then
         write(message,'(''     COLUMNS'',I6,'' THRU'',I6)') j1,j2
         call journal(message)
      endif
      do i = 1, m
         jm = j2-j1+1
         do j = 1, jm
            ls = location+i-1+(j+j1-2)*m
            pr(j) = GM_REALS(ls)/s
            pi(j) = dabs(GM_IMAGS(ls)/s)
            sig(j) = plus
            if (GM_IMAGS(ls) .lt. 0.0d0) sig(j) = minus
         enddo

         select case(F)
         case(11)
            form='(1X,12F6.0)'          ! integer
            istep=12
            itype= 777
         case(12)
            form='(1X,6F12.0)'          ! integer
            istep=6
            itype= 777
         case(21)
            form='(1X,F9.4,7F10.4)'     ! 8 numbers
            istep=8
            itype= 999
         case(22)
            form='(1X,F19.15,3F20.15)'  ! 4 numbers
            istep=4
            itype= 999
         case(23)
            form='(1X,1P6D13.4)'        ! 6 numbers
            istep=6
            itype= 999
         case(24)
            form='(1X,1P3D24.15)'       ! 3 numbers
            istep=3
            itype= 999
         case(31)
            form='(1X,4(F9.4,1X,A1,F7.4,''i''))'                       ! 4x3
            istep=12
            itype= 888
         case(32)
            form='(1X,F19.15,A1,F18.15,''i'',F20.15,A1,F18.15,''i'')'  ! 6
            istep=6
            itype= 888
         case(33)
            form='(1X,3(1PD13.4,1X,A1,1PD10.4,''i''))'                 ! 9
            istep=9
            itype= 888
         case(34)
            form='(1X,1PD24.15,1X,A1,1PD21.15,''i'')'                  ! 3
            istep=3
            itype= 888
         case(-1)
            call mat_formz(GM_REALS(ls),GM_IMAGS(ls))
            istep=-1
            itype=-1
         case default
            call journal('*internal error*')
            goto 99
         end select

         ! print data based on type
         if(itype.gt.0)then
            do j3=1,jm,istep
               select case(itype)
               case(777); write(message,form)(pr(j),j=j3,min(j3+istep-1,jm))
               case(999); write(message,form)(pr(j),j=j3,min(j3+istep,jm))
               case(888); write(message,form)(pr(j),sig(j),pi(j),j=j3,min(j3+istep-1,jm))
               end select
               call journal(message)
            enddo
         endif

         G_LINECOUNT(1) = G_LINECOUNT(1)+1
      enddo
   enddo

99 continue
   flush(unit=STDOUT,iostat=ios)

end subroutine mat_print
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_formz(x,y)

! ident_18="@(#) M_matrix mat_formz system dependent routine to print with z format"

doubleprecision,intent(in) :: x,y

character(len=36)          :: mline

   if (y .ne. 0.0d0) then
      write(mline,'(2z18)') x,y
   else
      write(mline,'(z18)') x
   endif

   call journal(mline)

end subroutine mat_formz
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_prompt(pause)

! ident_19="@(#) M_matrix mat_prompt(3f) issue interactive prompt with optional pause"

integer,intent(in) :: pause
character(len=1)   :: dummy

   if(.not.G_PROMPT)return ! in batch mode
   ! write prompt using format that stays on current line
   if(G_INPUT_LUN.eq.STDIN)then
     WRITE(STDOUT,'(''<>'')',advance='no')   ! write prompt to interactive input
     if (pause .eq. 1) read(G_INPUT_LUN,'(a1)') dummy
   endif

end subroutine mat_prompt
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stack1(op)

! ident_20="@(#) M_matrix mat_stack1(3f) Unary Operations"

integer           :: op
integer           :: i
integer           :: j
integer           :: location
integer           :: ll
integer           :: ls
integer           :: m
integer           :: mn
integer           :: n

   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)
   mn = m*n
   if (mn .eq. 0) then
   elseif (op .ne. quote) then                                 ! unary minus
      call mat_wrscal(MN,-1.0D0,GM_REALS(location),GM_IMAGS(location),1)
   else                                                        ! transpose
      ll = location + mn

      if(too_much_memory( ll+mn - G_VAR_DATALOC(G_TOP_OF_SAVED)) )return

      call mat_wcopy(MN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(ll),GM_IMAGS(ll),1)
      M = G_VAR_COLS(G_ARGUMENT_POINTER)
      N = G_VAR_ROWS(G_ARGUMENT_POINTER)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = m
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      do i = 1, m
         do j = 1, n
            ls = location+mn+(j-1)+(i-1)*n
            ll = location+(i-1)+(j-1)*m
            GM_REALS(ll) = GM_REALS(ls)
            GM_IMAGS(ll) = -GM_IMAGS(ls)
         enddo
      enddo
   endif
end subroutine mat_stack1
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_print_id(id,argcnt)

! ident_21="@(#) M_matrix mat_print_id(3fp) print table of variable id names (up to) eight per line"

!     ID     Is array of GG_MAX_NAME_LENGTH character IDs to print
!     ARGCNT is number of IDs to print
!            If = -1, print one ID with an "  =" suffix
!
integer            :: id(GG_MAX_NAME_LENGTH,*)
integer            :: argcnt
integer            :: id_counter                               !
integer            :: i, j, k
integer            :: line_position                            ! pointer into output line being built
integer            :: linebuf(8*GG_MAX_NAME_LENGTH+2*8+1)      ! scratch buffer for building up line
character(len=(8*GG_MAX_NAME_LENGTH+2*8+1)) :: mline           ! scratch space for building line to print

   id_counter = 1                                         ! which ID to start the line with
   INFINITE : do
      linebuf(1)=blank                                    ! put a space at beginning of line
      line_position = 2
      do j = id_counter,min(id_counter+7,iabs(argcnt))    ! copy up to eight names into buffer
         do i = 1, GG_MAX_NAME_LENGTH                     ! copy one name into buffer
            k = id(i,j)                                   ! this is the kth letter of the set
            linebuf(line_position) = k
            if(linebuf(line_position).ne.blank)line_position = line_position+1   ! increment pointer into output
         enddo
         linebuf(line_position+0)=blank         ! put two spaces between names
         linebuf(line_position+1)=blank
         line_position=line_position+2
      enddo
      if (argcnt .eq. -1) then                            ! special flag to print one word and  =
         linebuf(line_position) = equal                   ! put value for equal sign into buffer
      else
         line_position=line_position-3                    ! was prepared for another ID with two blanks
      endif

      call mat_buf2str(mline,linebuf,line_position)       ! write LINEBUF(1:line_position) line to a character variable
      call journal(mline)                                 ! print the line to stdout

      id_counter = id_counter+8                           ! prepare to get up to eight more IDs
      if (id_counter .gt. iabs(argcnt)) exit INFINITE     ! if not done do another line
   enddo INFINITE
end subroutine mat_print_id
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stack_put(id)

! ident_22="@(#) M_matrix mat_stack_put(3fp) put variables into storage"

integer  :: id(GG_MAX_NAME_LENGTH)
integer  :: i, j, k
integer  :: ib
integer  :: km1
integer  :: location
integer  :: l1,l2, li,lj,lk, ll,ls,lt
integer  :: m, m1,m2, mk
integer  :: mn, mn1, mn2, mnk
integer  :: mt
integer  :: n, nk, nt

   if (G_ARGUMENT_POINTER .le. 0) then
      call mat_err(1)  ! Improper multiple assignment
      return
   endif

   call mat_funs(id)
   if (G_FIN .ne. 0) then
      call mat_err(25) ! Can not use function name as variable
      return
   endif

   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)
   if (m .gt. 0) then
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   elseif(m.lt.0) then
      call mat_err(14) ! EYE-dentity undefined by CONTEXT
      return
   elseif (m .eq. 0 .and. n .ne. 0) then
      goto 99
   else  ! what about m zero and n not zero???
   endif

   mn = m*n
   lk = 0
   mk = 1
   nk = 0
   lt = 0
   mt = 0
   nt = 0

   ! unconditionally add name to end of list
   call mat_copyid(G_VAR_IDS(1,G_TOP_OF_SAVED-1),id)

   ! did variable already exist (knowing name is there at least once)
   do k=GG_MAX_NUMBER_OF_NAMES,1,-1
      if (mat_eqid(G_VAR_IDS(1:,k),id)) exit
   enddo

   if (k .ne. G_TOP_OF_SAVED-1) then        ! variable exists
      lk = G_VAR_DATALOC(k)
      mk = G_VAR_ROWS(k)
      nk = G_VAR_COLS(k)
      mnk = mk*nk
      if (G_RHS .gt. 2) then
         call mat_err(15)                   ! Improper assignment to submatrix
         return
      elseif (G_RHS .ne. 0) then
         mt = mk
         nt = nk
         lt = location + mn
         if(too_much_memory( lt + mnk - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )then
            return
         endif
         call mat_wcopy(mnk,GM_REALS(lk),GM_IMAGS(lk),1,GM_REALS(lt),GM_IMAGS(lt),1)
      endif

      ! does it fit
      if (G_RHS.eq.0 .and. mn.eq.mnk) then    ! size of existing array did not change
         goto 40
      endif

      if (k .ge. GG_MAX_NUMBER_OF_NAMES-3) then
         call mat_err(13) ! Improper assignment to PERMANENT VARIABLE
         return
      endif

      if (k .ne. G_TOP_OF_SAVED) then
         ! shift storage
         ls = G_VAR_DATALOC(G_TOP_OF_SAVED)
         ll = ls + mnk
         call mat_wcopy(lk-ls,GM_REALS(ls),GM_IMAGS(ls),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
         km1 = k-1
         do ib = G_TOP_OF_SAVED, km1
            i = G_TOP_OF_SAVED+km1-ib
            call mat_copyid(G_VAR_IDS(1,i+1),G_VAR_IDS(1,i))
            G_VAR_ROWS(i+1) = G_VAR_ROWS(i)
            G_VAR_COLS(i+1) = G_VAR_COLS(i)
            G_VAR_DATALOC(i+1) = G_VAR_DATALOC(i)+mnk
         enddo
      endif

      ! destroy old variable
      G_TOP_OF_SAVED = G_TOP_OF_SAVED+1
   endif
!
   ! create new variable
   if (mn .eq. 0) then
      goto 99
   endif

   if (G_TOP_OF_SAVED-2 .le. G_ARGUMENT_POINTER) then
      call mat_err(18) ! Too many names
      return
   endif

   k = G_TOP_OF_SAVED-1
   call mat_copyid(G_VAR_IDS(1,k), id)

   if (G_RHS .eq. 1) then
      !  vect(arg)
      if (G_VAR_ROWS(G_ARGUMENT_POINTER-1) .lt. 0) then
         goto 59
      endif
      mn1 = 1
      mn2 = 1
      l1 = 0
      l2 = 0
      if (n.ne.1 .or. nk.ne.1) then
         if (m.ne.1 .or. mk.ne.1) then
            call mat_err(15) ! Improper assignment to submatrix
            return
         endif
         l2 = G_VAR_DATALOC(G_ARGUMENT_POINTER-1)
         m2 = G_VAR_ROWS(G_ARGUMENT_POINTER-1)
         mn2 = m2*G_VAR_COLS(G_ARGUMENT_POINTER-1)
         m1 = -1
         goto 60
      endif
      l1 = G_VAR_DATALOC(G_ARGUMENT_POINTER-1)
      m1 = G_VAR_ROWS(G_ARGUMENT_POINTER-1)
      mn1 = m1*G_VAR_COLS(G_ARGUMENT_POINTER-1)
      m2 = -1
      goto 60
   elseif (G_RHS .eq. 2)then
      ! matrix(arg,arg)
      if (G_VAR_ROWS(G_ARGUMENT_POINTER-1).lt.0 .and. G_VAR_ROWS(G_ARGUMENT_POINTER-2).lt.0) then
         goto 59
      endif
      l2 = G_VAR_DATALOC(G_ARGUMENT_POINTER-1)
      m2 = G_VAR_ROWS(G_ARGUMENT_POINTER-1)
      mn2 = m2*G_VAR_COLS(G_ARGUMENT_POINTER-1)
      if (m2 .lt. 0) mn2 = n
      l1 = G_VAR_DATALOC(G_ARGUMENT_POINTER-2)
      m1 = G_VAR_ROWS(G_ARGUMENT_POINTER-2)
      mn1 = m1*G_VAR_COLS(G_ARGUMENT_POINTER-2)
      if (m1 .lt. 0) mn1 = m
      goto 60
   endif
!
!  STORE
40 continue
   if (k .lt. GG_MAX_NUMBER_OF_NAMES) G_VAR_DATALOC(k) = G_VAR_DATALOC(k+1) - mn
   G_VAR_ROWS(k) = m
   G_VAR_COLS(k) = n

   lk = G_VAR_DATALOC(k)
   call mat_wcopy(mn,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(lk),GM_IMAGS(lk),-1)
   goto 90
!===================================================================================================================================
59 continue
   if (mn .ne. mnk) then
      call mat_err(15) ! Improper assignment to submatrix
      return
   endif

   lk = G_VAR_DATALOC(k)
   call mat_wcopy(mn,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(lk),GM_IMAGS(lk),-1)
   goto 90
!===================================================================================================================================
60 continue
   if (mn1.ne.m .or. mn2.ne.n) then
      call mat_err(15) ! Improper assignment to submatrix
      return
   endif
   ll = 1
   if (m1 .ge. 0) then
      do i = 1, mn1
         ls = l1+i-1
         mk = max(mk,int(GM_REALS(ls)))
         ll = min(ll,int(GM_REALS(ls)))
      enddo
   endif

   mk = max(mk,m)
   if (m2 .ge. 0) then
      do i = 1, mn2
         ls = l2+i-1
         nk = max(nk,int(GM_REALS(ls)))
         ll = min(ll,int(GM_REALS(ls)))
      enddo
   endif
   nk = max(nk,n)
   if (ll .lt. 1) then
      call mat_err(21) ! Subscript out of range
      return
   endif
   mnk = mk*nk
   lk = G_VAR_DATALOC(k+1) - mnk

   if(too_much_memory( lt + mt*nt - lk) )return

   G_VAR_DATALOC(k) = lk
   G_VAR_ROWS(k) = mk
   G_VAR_COLS(k) = nk
   call mat_wset(mnk,0.0d0,0.0d0,GM_REALS(lk),GM_IMAGS(lk),1)
   if (nt .ge. 1) then
      do j = 1, nt
         ls = lt+(j-1)*mt
         ll = lk+(j-1)*mk
         call mat_wcopy(mt,GM_REALS(ls),GM_IMAGS(ls),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
      enddo
   endif

   do j = 1, n
      do i = 1, m
         li = l1+i-1
         if (m1 .gt. 0) li = l1 + int(GM_REALS(li)) - 1
         lj = l2+j-1
         if (m2 .gt. 0) lj = l2 + int(GM_REALS(lj)) - 1
         ll = lk+li-l1+(lj-l2)*mk
         ls = location+i-1+(j-1)*m
         GM_REALS(ll) = GM_REALS(ls)
         GM_IMAGS(ll) = GM_IMAGS(ls)
      enddo
   enddo
   goto 90
!===================================================================================================================================
! print if desired and pop stack
90 continue
   if (G_SYM.ne.semi .and. G_LINECOUNT(3).eq.0) call mat_print(id,k) ! if not a semi-colon and "semi" mode print
   if (G_SYM.eq.semi .and. G_LINECOUNT(3).eq.1) call mat_print(id,k) ! if a semi-colon and "semi" mode off print
   if (k .eq. G_TOP_OF_SAVED-1) G_TOP_OF_SAVED = G_TOP_OF_SAVED-1

99 continue
   if (m .eq. 0) then
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
   else
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1 - G_RHS
   endif
end subroutine MAT_STACK_PUT
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!
! THE PARSER-INTERPRETER (10)
!
!    The structure of the parser-interpreter is similar to that of Wirth's
!    compiler [6] for his simple language, PL/0 , except that LALA is
!    programmed in Fortran, which does not have explicit recursion. The
!    interrelation of the primary subroutines is shown in the following
!    diagram.
!
!          MAIN
!            |
!          LALA     |--CLAUSE
!            |       |    |
!          PARSE-----|--EXPR----TERM----FACTOR
!                    |    |       |       |
!                    |    |-------|-------|
!                    |    |       |       |
!                    |  STACK1  STACK2  STACKG
!                    |
!                    |--STACKP--PRINT
!                    |
!                    |--COMAND
!                    |
!                    |
!                    |          |--CGECO
!                    |          |
!                    |          |--CGEFA
!                    |          |
!                    |--MATFN1--|--CGESL
!                    |          |
!                    |          |--CGEDI
!                    |          |
!                    |          |--CPOFA
!                    |
!                    |
!                    |          |--IMTQL2
!                    |          |
!                    |          |--HTRIDI
!                    |          |
!                    |--MATFN2--|--HTRIBK
!                    |          |
!                    |          |--CORTH
!                    |          |
!                    |          |--COMQR3
!                    |
!                    |
!                    |--MATFN3-----CSVDC
!                    |
!                    |
!                    |          |--CQRDC
!                    |--MATFN4--|
!                    |          |--CQRSL
!                    |
!                    |
!                    |          |--FILES
!                    |--MATFN5--|
!                               |--SAVLOD
!
!    Subroutine MAT_PARSE controls the interpretation of each statement. It
!    calls subroutines that process the various syntactic quantities such
!    as command, expression, term and factor. A fairly simple program
!    stack mechanism allows these subroutines to recursively "call"
!    each other along the lines allowed by the syntax diagrams. The four
!    STACK subroutines manage the variable memory and perform elementary
!    operations, such as matrix addition and transposition.
!
!    The subroutines MATFN1 though MATFN6 are called whenever "serious"
!    matrix computations are required. They are interface routines which
!    call the various LINPACK and EISPACK subroutines. MATFN5 primarily
!    handles the file access tasks
SUBROUTINE mat_parse()
integer            :: id(GG_MAX_NAME_LENGTH)
integer            :: excnt
integer            :: pts
integer,parameter  :: ans(GG_MAX_NAME_LENGTH)  = [iachar(['a','n','s',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: ennd(GG_MAX_NAME_LENGTH) = [iachar(['e','n','d',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: else(GG_MAX_NAME_LENGTH) = [iachar(['e','l','s','e',' ',' ',' ']),GG_PAD(8:)]
integer            :: p
integer            :: r
integer            :: i5
integer            :: ierr
integer            :: j
integer            :: k
integer            :: location
integer            :: ls
integer            :: n
character(len=:),allocatable :: symbol
!
   01 continue
      r = 0
      if (G_ERR .gt. 0) G_PTZ = 0
      if (G_ERR.le.0 .and. G_PT.gt.G_PTZ) r = G_RSTK(G_PT)

      if (r.eq.15) goto 93
      if (r.eq.16 .or. r.eq.17) goto 94
      G_SYM = GG_EOL
      G_ARGUMENT_POINTER = 0
      if (G_LUN_READING_FROM .ne. G_INPUT_LUN) call mat_files(-G_LUN_READING_FROM,G_BUF)
      G_LUN_READING_FROM = G_INPUT_LUN
      G_LINECOUNT(3) = 0
      G_LINECOUNT(4) = 2
      G_LINE_POINTER(1) = 1
   10 continue  ! get a new line if the current line has ended
      if (G_SYM.eq.GG_EOL.and.mod(G_LINECOUNT(4)/2,2).eq.1) call mat_prompt(G_LINECOUNT(4)/4)
      if (G_SYM .eq. GG_EOL) call mat_getlin()
      G_ERR = 0
      G_PT = G_PTZ

   15 continue   ! (continue) processing current line
      excnt = 0
      G_LHS = 1
      call mat_copyid(id,ans) ! copy ans to id
      call mat_getsym()

      if (G_SYM .eq. colon) then
         call mat_getsym()
      endif

      if (G_SYM.eq.SEMI .or. G_SYM.eq.COMMA .or. G_SYM.eq.GG_EOL) goto 80

      if (G_SYM .eq. isname) then
         ! lhs begins with name
         call ints2str(G_SYN,symbol,ierr)              ! convert ID to a character variable
         call mat_comand(symbol)
         IF (G_ERR .GT. 0) goto 01
         IF (G_FUN .EQ. 99) goto 95
         IF (G_FIN .EQ. -15) goto 80
         IF (G_FIN .LT. 0) goto 91
         IF (G_FIN .GT. 0) goto 70
         ! if name is a function, must be rhs
         G_RHS = 0
         call mat_funs(G_SYN)
         IF (G_FIN .NE. 0)then
            goto 50
         endif
         ! peek one character ahead
         IF (G_CHRA.EQ.SEMI .OR. G_CHRA.EQ.COMMA .OR. G_CHRA.EQ.GG_EOL) call mat_copyid(ID,G_SYN)
         IF (G_CHRA .EQ. EQUAL) then
            ! lhs is simple variable
            call mat_copyid(ID,G_SYN)
            call mat_getsym()
            call mat_getsym()
            goto 50
         endif
         IF (G_CHRA .EQ. LPAREN .or. G_CHRA .EQ. LBRACE) then
            ! lhs is name(...)
            G_LINE_POINTER(5) = G_LINE_POINTER(4)
            call mat_copyid(ID,G_SYN)
            call mat_getsym()
            goto 32
         endif
         goto 50
      endif
      if (G_SYM .eq. less .or. G_SYM .eq. lbracket) goto 40
      if (G_SYM .eq. great .or. G_SYM .eq. rbracket) goto 45
      goto 50
!.......................................................................
!     lhs is name(...)
   32 continue
      call mat_getsym()
      excnt = excnt+1
      G_PT = G_PT+1
      call mat_copyid(G_IDS(1,G_PT), id)
      G_PSTK(G_PT) = excnt
      G_RSTK(G_PT) = 1
!     *call* expr
      goto 92
!.......................................................................
   35 continue
      call mat_copyid(id,G_IDS(1,G_PT))
      excnt = G_PSTK(G_PT)
      G_PT = G_PT-1
      if (G_SYM .eq. comma) goto 32
      if ((G_SYM .ne. rparen) .and. (G_SYM.ne.rbrace)) then
         call mat_err(3)
         goto 01
         return  ! ???? cannot unconditionally goto and return
      endif
      if ((G_SYM .eq. rparen) .or. (G_SYM.eq.rbrace)) call mat_getsym()
      if (G_SYM .eq. equal) goto 50
!     lhs is really rhs, forget scan just done
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - excnt
      G_LINE_POINTER(4) = G_LINE_POINTER(5)
      G_CHRA = lparen
      G_SYM = isname
      call mat_copyid(G_SYN,id)
      call mat_copyid(id,ans)
      excnt = 0
      goto 50
!.......................................................................
!     multiple lhs
   40 continue
      G_LINE_POINTER(5) = G_LINE_POINTER(4)
      pts = G_PT
      call mat_getsym()
   41 continue
      if (G_SYM .ne. isname)then
         goto 43
      endif
      call mat_copyid(id,G_SYN)
      call mat_getsym()
      if (G_SYM .eq. great.or. G_SYM.eq.rbracket)then
         call mat_getsym()
         if (G_SYM .eq. equal) goto 50
         goto 43
      endif
      if (G_SYM .eq. comma) call mat_getsym()
      G_PT = G_PT+1
      G_LHS = G_LHS+1
      G_PSTK(G_PT) = 0
      call mat_copyid(G_IDS(1,G_PT),id)
      goto 41
!.......................................................................
   43 continue
      G_LINE_POINTER(4) = G_LINE_POINTER(5)
      G_PT = pts
      G_LHS = 1
      G_SYM = less
      G_CHRA = G_LIN(G_LINE_POINTER(4)-1)
      call mat_copyid(id,ans)
      goto 50
!.......................................................................
!     macros string
   45 continue
      call mat_getsym()
      if ((G_SYM.eq.less .or. G_SYM.eq.lbracket) .and. G_CHRA.eq.GG_EOL) then
         call mat_err(28) ! Empty macro
         goto 01
      endif
      G_PT = G_PT+1
      G_RSTK(G_PT) = 20
!     *call* expr
      goto 92
!.......................................................................
   46 continue
      G_PT = G_PT-1
      if ((G_SYM.ne.less .and. G_SYM.ne.lbracket) .and. G_SYM.ne.GG_EOL) then
         call mat_err(37) ! Improper MACROS
         goto 01
      endif
      if (G_SYM .eq. less .or. G_SYM.eq. lbracket) call mat_getsym()
      k = G_LINE_POINTER(6)
      G_LIN(k+1) = G_LINE_POINTER(1)
      G_LIN(k+2) = G_LINE_POINTER(2)
      G_LIN(k+3) = G_LINE_POINTER(6)
      G_LINE_POINTER(1) = k + 4
!     transfer stack to input line
      k = G_LINE_POINTER(1)
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      n = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      do j = 1, n
         ls = location + j-1
         G_LIN(k) = int(GM_REALS(ls))
         if (G_LIN(k).lt.0 .or. G_LIN(k).ge.G_CHARSET_SIZE) then
            call mat_err(37) ! improper MACROS
            return
         endif
         if (k.lt.1024) k = k+1
         if (k.eq.1024) then
            call journal('sc',' input buffer limit is',k,'characters')
          endif
      enddo
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
      G_LIN(K) = GG_EOL; G_LIN(K+1:)=blank
      G_LINE_POINTER(6) = k
      G_LINE_POINTER(4) = G_LINE_POINTER(1)
      G_LINE_POINTER(3) = 0
      G_LINE_POINTER(2) = 0
      G_LINECOUNT(1) = 0
      G_CHRA = blank
      G_PT = G_PT+1
      G_PSTK(G_PT) = G_LINE_POINTER(1)
      G_RSTK(G_PT) = 21
!     *call* parse
      goto 15
!.......................................................................
   49 continue
      G_PT = G_PT-1
      k = G_LINE_POINTER(1) - 4
      G_LINE_POINTER(1) = G_LIN(K+1)
      G_LINE_POINTER(4) = G_LIN(K+2)
      G_LINE_POINTER(6) = G_LIN(K+3)
      G_CHRA = BLANK
      call mat_getsym()
      goto 80
!.......................................................................
!     lhs finished, start rhs
   50 continue
      if (G_SYM .eq. equal) call mat_getsym()
      G_PT = G_PT+1
      call mat_copyid(G_IDS(1,G_PT),id)
      G_PSTK(G_PT) = excnt
      G_RSTK(G_PT) = 2
!     *call* expr
      goto 92
!.......................................................................
!     store results
   60 continue
      G_RHS = G_PSTK(G_PT)
      call MAT_STACK_PUT(G_IDS(1,G_PT))
      if (G_ERR .gt. 0) goto 01
      G_PT = G_PT-1
      G_LHS = G_LHS-1
      if (G_LHS .gt. 0) goto 60
      goto 70
!.......................................................................
!     update and possibly print operation counts
   70 continue
      k = G_FLOP_COUNTER(1)
      if (K .ne. 0) GM_REALS(GM_BIGMEM-3) = dble(k)
      GM_REALS(GM_BIGMEM-2) = GM_REALS(GM_BIGMEM-2) + dble(K)
      G_FLOP_COUNTER(1) = 0
      if (.not.(G_CHRA.eq.comma .or. (G_SYM.eq.comma .and. G_CHRA.eq.GG_EOL)))goto 80
      call mat_getsym()
      i5 = 10**5

      if (k .eq. 0) then
         call journal('   no flops')
      elseif (k .EQ. 1) then
         call journal('    1 flop')
      else
         call journal('sc','',k,' flops')
      endif
      goto 80
!.......................................................................
!     finish statement
   80 continue
      G_FIN = 0
      p = 0
      r = 0
      if (G_PT .gt. 0) p = G_PSTK(G_PT)
      if (G_PT .gt. 0) r = G_RSTK(G_PT)
      if (G_SYM.eq.comma .or. G_SYM.eq.semi) goto 15
      if (r.eq.21 .and. p.eq.G_LINE_POINTER(1)) goto 49
      if (G_PT .gt. G_PTZ) goto 91
      goto 10
!.......................................................................
!     simulate recursion
!.......................................................................
   91 continue
      call mat_clause()
      if (G_ERR .gt. 0) goto 01
      if (G_PT .le. G_PTZ) goto 15
      r = G_RSTK(G_PT)
      select case(R)
      case(3:5);   goto 92
      case(13:14); goto 15
      case(21);    goto 49
      case default
         write(*,*)'INTERNAL ERROR 91'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
!.......................................................................
   92 CONTINUE
      call mat_expr()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(r)
      case(1);     goto 35
      case(2)
         if (G_SYM.eq.semi .or. G_SYM.eq.comma .or. G_SYM.eq.GG_EOL) goto 60
         if (G_SYM.eq.isname .and. mat_eqid(G_SYN,else)) goto 60
         if (G_SYM.eq.isname .and. mat_eqid(G_SYN,ennd)) goto 60
         call mat_err(40) ! 'Expecting statement terminator'
         if (G_ERR .gt. 0) goto 01
         goto 60
      case(3:5);   goto 91
      case(6:7);   goto 93
      case(10:11); goto 94
      case(18:19); goto 94
      case(20);    goto 46
      case default
         write(*,*)'Internal error 92'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
!.......................................................................
   93 continue
      call mat_term()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(R)
      case(6:7);   goto 92
      case(8:9);   goto 94
      case(15);    goto 95
      case default
         write(*,*)'INTERNAL ERROR 93'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
!.......................................................................
   94 continue
      call mat_factor()
      if (G_ERR .gt. 0) goto 01
      r = G_RSTK(G_PT)
      select case(R)
      case(8:9);   goto 93
      case(10:11); goto 92
      case(12);    goto 94
      case(16:17); goto 95
      case(18:19); goto 92
      case default
         write(*,*)'INTERNAL ERROR 94'
         call mat_err(22) ! recursion difficulties
         goto 01
      end select
!.......................................................................
!     call mat_matfns by returning to LALA
   95 continue
      if(G_ARGUMENT_POINTER.lt.1)then
         !call journal('sc','*mat_parse* stack emptied',G_ARGUMENT_POINTER)
      else
         if (G_FIN.gt.0 .and. G_VAR_ROWS(G_ARGUMENT_POINTER).lt.0) call mat_err(14)
      endif
      if (G_ERR .gt. 0) goto 01
      return
!.......................................................................
end subroutine mat_parse
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_comand(id)

character(len=*),intent(in)  :: id
integer                      :: chr
integer                      :: i, k
integer                      :: l

! a list of names this procedure matches to use for some preliminary tests
character(len=10),parameter :: cmd(*)=[ character(len=10) :: &
 & 'clear', 'else',  'end',      'exit',   'for',  &
 & 'help',  'if',    'long',     'quit',   'semi', &
 & 'short', 'what',  'while',    'who',    'sh',   &
 & 'lala',  'shell', 'continue', 'return', 'fhelp'   &
 & ]

FINISHED: block
   G_FUN = 0

   do k = size(cmd),0,-1
     if(k.eq.0)then                          ! did not match anything
        G_FIN = 0
        return
     elseif (id.eq.cmd(k))then               ! found match to command

        select case(G_CHRA)                  ! check next character
        case(comma,semi,GG_EOL)              ! next character is end of a command so good to go
           exit
        ! alphanumeric or a HELP command so good to go
        case(iachar('0'):iachar('9'),iachar('a'):iachar('z'),iachar('A'):iachar('Z'),score,percent)
           exit
        end select

        if (id.eq.'help')then                ! special case where anything after the help could be a topic
           exit
        elseif(id.eq.'fhelp')then
           exit
        else
           call mat_err(16)                  ! improper command
           return
        endif

     endif
   enddo

   G_FIN = 1                                 ! found a match and next character passed tests
!===================================================================================================================================
   COMAND : select case(id)
!===================================================================================================================================
   case('clear')
   ! alphameric character
      if(verify(achar(G_CHRA),big//little//digit)==0)then ! is alphanumeric so good to go by name
         call mat_getsym()
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
         G_VAR_COLS(G_ARGUMENT_POINTER) = 0
         G_RHS = 0
         call mat_stack_put(G_SYN)
         if (G_ERR .gt. 0) return
         G_FIN = 1
      else
         G_TOP_OF_SAVED = GG_MAX_NUMBER_OF_NAMES-3
      endif
!===================================================================================================================================
   case('for')
      G_FIN = -11
      exit FINISHED
   case('while')
      G_FIN = -12
      exit FINISHED
   case('if')
      G_FIN = -13
      exit FINISHED
   case('else')
      G_FIN = -14
      exit FINISHED
   case('end')
      G_FIN = -15
      exit FINISHED
!===================================================================================================================================
   case('exit')
      IF (G_PT .GT. G_PTZ)then
         G_FIN = -16
         exit COMAND
      endif
      K = int(GM_REALS(GM_BIGMEM-2))
      call journal('sc',' total flops ',k)

      select case( int(mat_urand(G_CURRENT_RANDOM_SEED)*9) )    ! for serendipity's sake randomly pick a sign-off
      case(1); call journal(' adios')
      case(2); call journal(' adieu')
      case(3); call journal(' arrivederci')
      case(4); call journal(' au revior')
      case(5); call journal(' so long')
      case(6); call journal(' sayonara')
      case(7); call journal(' auf wiedersehen')
      case default
         call journal(' cheerio')
      end select

      G_FUN = 99
!===================================================================================================================================
   case('quit','return')
      K = G_LINE_POINTER(1) - 7
      IF (K .LE. 0)then
         G_FUN = 99
         exit COMAND
      endif
      call mat_files(-G_LUN_READING_FROM,G_BUF)
      G_LINE_POINTER(1) = G_LIN(K+1)
      G_LINE_POINTER(4) = G_LIN(K+2)
      G_LINE_POINTER(6) = G_LIN(K+3)
      G_PTZ = G_LIN(K+4)
      G_LUN_READING_FROM = G_LIN(K+5)
      G_LINECOUNT(4) = G_LIN(K+6)
      G_CHRA = BLANK
      G_SYM = COMMA
      exit FINISHED
!===================================================================================================================================
   case('continue')
      G_FUN = 99
      exit FINISHED
!===================================================================================================================================
   case('lala')
      call journal('QUIT SINGING AND GET BACK TO WORK.')
!===================================================================================================================================
   case('shell')
      call journal(' Your place or mine?')
!===================================================================================================================================
   case('short','long')
      if(k.eq.11)then
         G_FMT = 1
      else
         G_FMT = 2
      endif
      if (G_CHRA.eq.e_low .or. G_CHRA.eq.d_low .or. G_CHRA.eq.e_up .or. chr.eq.d_up ) G_FMT = G_FMT+2
      if (G_CHRA .eq. z_low) G_FMT = 5
      if (G_CHRA.eq.e_low .or. G_CHRA.eq.d_low .or. G_CHRA.eq.z_low) call mat_getsym()
      if (G_CHRA.eq.e_UP .or. G_CHRA.eq.d_up .or. G_CHRA.eq.z_up ) call mat_getsym()
!===================================================================================================================================
   case('semi')
      G_LINECOUNT(3) = 1 - G_LINECOUNT(3)  ! toggle "semi" mode
!===================================================================================================================================
   case('who')
      call journal(' Your current variables are...')
      call mat_print_id(G_VAR_IDS(1,G_TOP_OF_SAVED),GG_MAX_NUMBER_OF_NAMES-G_TOP_OF_SAVED+1)
      !x!do i=1,size(keywords)
      !x!   write(*,*)keywords(i),rows(i),cols(i),locs(i)
      !x!enddo
      l = GM_BIGMEM-G_VAR_DATALOC(G_TOP_OF_SAVED)+1
      call journal('sc','using',l,'out of',GM_BIGMEM,'elements')
!===================================================================================================================================
   case('what')
!===================================================================================================================================
   case('sh')
      call sh_command()
!===================================================================================================================================
   case('help','fhelp')
      HELP_ : block
      character(len=GG_LINELEN) :: topic_name
      integer                   :: position(2)
         G_BUF=blank
         if (G_CHRA .eq. GG_EOL) then                                      ! if no topic
            topic_name= ' '
         else
            call mat_getsym()                                              ! get next symbol or name
            if (G_SYM .eq. isname)then                                     ! use next word on line as topic
                 G_BUF(:GG_MAX_NAME_LENGTH) = G_SYN
            else                                                           ! use next non-blank character as topic
               if (G_SYM .eq. 0) G_SYM = dot
               G_BUF(1)  = G_SYM
               G_BUF(2:) = blank
            endif
            call mat_buf2str(topic_name,G_BUF,len(topic_name))             ! convert ADE array to string
         endif
         if(topic_name.eq.'search')then
            topic_name=ade2str(pack(G_LIN,G_LIN.gt.0.and.G_LIN.lt.255))
            i=index(topic_name,'search')                                   ! assuming help command on line by itself to some extent
            if(i.ne.0)topic_name=topic_name(i:)
         endif
         position=merge(G_LINECOUNT(:2),[0,huge(0)],G_PROMPT)              ! page length
         if(id.eq.'help')then
            call help_command(G_HELP_TEXT,trim(topic_name),position)
         else
            call help_command(G_FORTRAN_TEXT,trim(topic_name),position)    ! page length
         endif
      endblock HELP_
!===================================================================================================================================
   case default ! did not find a match
      G_FIN = 0
      return
!===================================================================================================================================
   end select COMAND
!===================================================================================================================================
   call mat_getsym()
endblock FINISHED
end subroutine mat_comand
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine sh_command()

! ident_23="@(#) M_matrix sh_command(3f) start system shell interactively"

character(len=GG_LINELEN) :: line
integer                   :: istat

   call get_environment_variable('SHELL',line)               ! get command to execute
   IF (G_CHRA .eq. GG_EOL )then                               ! if next character on stack is end-of-line call interactive shell
      call execute_command_line(line,cmdstat=istat)          ! call shell interactively
   else                                                      ! there were characters after SH on the line
      call execute_command_line(line,cmdstat=istat)          ! call shell interactively
   endif

end subroutine sh_command
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_plot(lplot,x,y,n,p,k)

! ident_24="@(#) M_matrix mat_plot(3fp) Plot X vs. Y on LPLOT. If K is nonzero then P(1) ... P(K) are extra parameters"

integer           :: lplot
integer           :: n
doubleprecision   :: x(n)
doubleprecision   :: y(n)
doubleprecision   :: p(*)
integer           :: k

integer           :: lets(k)
character(len=k)  :: string
doubleprecision   :: xmin,ymin,xmax,ymax,dy,dx,y1,y0
character(len=79) :: pbuf                             ! work space for ascii plot
integer,parameter :: h=20,w=79                        ! h = height, w = width
integer           :: tlun
integer           :: ios
integer           :: ch
integer           :: i
integer           :: j
integer           :: jmax
integer           :: l
integer           :: istat

!!      if (k .gt. 0) write(lplot,01) (p(i), i=1,k)
!!   01 FORMAT('Extra parameters',*(f5.1,/))

   xmin = x(1)
   xmax = x(1)
   ymin = y(1)
   ymax = y(1)

   do i = 1, n
      xmin = dmin1(xmin,x(i))
      xmax = dmax1(xmax,x(i))
      ymin = dmin1(ymin,y(i))
      ymax = dmax1(ymax,y(i))
   enddo

   dx = xmax - xmin
   if (dx .eq. 0.0d0) dx = 1.0d0
   dy = ymax - ymin
   write(lplot,'(80x)')
   do l = 1, h
      pbuf(:)=' '  ! blank out the line
      y1 = ymin + (h-l+1)*dy/h
      y0 = ymin + (h-l)*dy/h
      jmax = 1
      do i = 1, n
         if (y(i) .gt. y1) cycle
         if (l.ne.h .and. y(i).le.y0) cycle
         j = 1 + (w-1)*(x(i) - xmin)/dx
         pbuf(j:j) = '*'
         jmax = max(jmax,j)
      enddo
      write(lplot,'(1x,a)') pbuf(1:jmax)
   enddo

   ! set up the data file
   open(newunit=tlun,file='xy.dat')
   do i=1,n
      write(tlun,*)x(i),y(i)
   enddo
   flush(tlun)

   string=' '
   lets=0
   do i=1,k
      ch=p(i)
      if ((ch.ge.0) .and. (ch.lt.G_CHARSET_SIZE)) then
         lets(i) = ch
      endif
   enddo
   call mat_buf2str(string,lets,k)

   ! call the external program xy(1) converting the parameters to a string of options
   call journal('sc','xy xy.dat ',trim(string))
   if(which('xy')/='')then
      call execute_command_line('xy xy.dat '//trim(string),cmdstat=istat)
   endif
   close(unit=tlun,status='delete',iostat=ios)

end subroutine mat_plot
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn1()

! ident_25="@(#) M_matrix mat_matfn1(3fp) evaluate functions involving gaussian elimination"

doubleprecision   :: dtr(2)
doubleprecision   :: dti(2)
doubleprecision   :: sr(1)
doubleprecision   :: si(1)
doubleprecision   :: rcond
doubleprecision   :: t
doubleprecision   :: t0
doubleprecision   :: t1
doubleprecision   :: eps
character(len=80) :: mline
integer           :: i
integer           :: info
integer           :: j
integer           :: k
integer           :: ka
integer           :: kb
integer           :: location
integer           :: l2
integer           :: l3
integer           :: li
integer           :: lj
integer           :: lk
integer           :: ll
integer           :: ls
integer           :: lu
integer           :: m
integer           :: m2
integer           :: n
integer           :: n2
integer           :: nn
!
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   M = G_VAR_ROWS(G_ARGUMENT_POINTER)
   N = G_VAR_COLS(G_ARGUMENT_POINTER)
!===================================================================================================================================
   select case(G_FIN)
!===================================================================================================================================
    case(-1) ! MATRIX RIGHT DIVISION, A/A2
      l2 = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      m2 = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
      n2 = G_VAR_COLS(G_ARGUMENT_POINTER+1)
      if (m2 .ne. n2) then
         call mat_err(20)
         return
      endif
      if (m*n .ne. 1) then
         if (n .ne. n2) then
            call mat_err(11)
            return
         endif
         l3 = l2 + m2*n2

         if(too_much_memory( l3+n2 - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

         call ml_wgeco(GM_REALS(l2),GM_IMAGS(l2),m2,n2,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
         if (rcond .eq. 0.0d0) then
            call mat_err(19)
            return
         endif
         t = mat_flop(1.0d0 + rcond)
         if (t.eq.1.0d0 .and. G_FUN.ne.21)then
            call journal('WARNING:')
            call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         if (t.eq.1.0d0 .and. G_FUN.eq.21)then
            call journal('WARNING')
            call journal('EIGENVECTORS ARE BADLY CONDITIONED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         do i = 1, m
            do j = 1, n
               ls = location+i-1+(j-1)*m
               ll = l3+j-1
               GM_REALS(ll) = GM_REALS(ls)
               GM_IMAGS(ll) = -GM_IMAGS(ls)
            enddo
            call ml_wgesl(GM_REALS(l2),GM_IMAGS(l2),m2,n2,G_BUF,GM_REALS(l3),GM_IMAGS(l3),1)
            do j = 1, n
               ll = location+i-1+(j-1)*m
               ls = l3+j-1
               GM_REALS(ll) = GM_REALS(ls)
               GM_IMAGS(ll) = -GM_IMAGS(ls)
            enddo
         enddo
         if (G_FUN .ne. 21) goto 99
   !
   !     CHECK FOR IMAGINARY ROUNDOFF IN MATRIX FUNCTIONS
         sr(1) = mat_wasum(n*n,GM_REALS(location),GM_REALS(location),1)
         si(1) = mat_wasum(n*n,GM_IMAGS(location),GM_IMAGS(location),1)
         eps = GM_REALS(GM_BIGMEM-4)
         t = eps*sr(1)
         !if (si(1) .le. eps*sr(1)) call mat_rset(n*n,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
         if (si(1) .le. eps*sr(1)) gm_imags(location:location+n*n-1)=0.0d0 ! set imaginary component to zero
         goto 99
   !
      endif

      sr(1) = GM_REALS(location)
      si(1) = GM_IMAGS(location)
      n = n2
      m = n
      G_VAR_ROWS(G_ARGUMENT_POINTER) = n
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      call mat_wcopy(n*n,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
!===================================================================================================================================
    case(-2) ! MATRIX LEFT DIVISION A BACKSLASH A2
      l2 = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      m2 = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
      n2 = G_VAR_COLS(G_ARGUMENT_POINTER+1)
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      if (m2*n2 .ne. 1) then
         l3 = l2 + m2*n2

         if(too_much_memory( l3+n - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

         call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
         if (rcond .eq. 0.0d0) then
            call mat_err(19)
            return
         endif
         t = mat_flop(1.0d0 + rcond)
         if (t .eq. 1.0d0) then
            call journal('WARNING:')
            call journal('MATRIX IS CLOSE TO SINGULAR OR BADLY SCALED.')
            WRITE(mline,'(''RESULTS MAY BE INACCURATE. RCOND='',1PD13.4)') RCOND
            call journal(mline)
         endif
         if (m2 .ne. n) then
            call mat_err(12)
            return
         endif
         do j = 1, n2
            lj = l2+(j-1)*m2
            call ml_wgesl(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,GM_REALS(lj),GM_IMAGS(lj),0)
         enddo
         G_VAR_COLS(G_ARGUMENT_POINTER) = n2
         call mat_wcopy(m2*n2,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
         goto 99
      endif
      sr(1) = GM_REALS(l2)
      si(1) = GM_IMAGS(l2)
!===================================================================================================================================
   end select
!===================================================================================================================================
   select case(G_FIN)
!===================================================================================================================================
    case(1) ! COMMAND::INV
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      do j = 1, n
         do i = 1, n
            ls = location+i-1+(j-1)*n
            t0 = GM_REALS(ls)
            t1 = mat_flop(1.0d0/(dble(i+j-1)))
            if (t0 .ne. t1) goto 32
         enddo
      enddo
      call mat_inverse_hilbert(GM_REALS(location),n,n)
      !call mat_rset(n*n,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
      gm_imags(location:location+n*n-1)=0.0d0 ! set imaginary component to zero
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
      goto 99
32    continue
      l3 = location + n*n

      if(too_much_memory( l3+n - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
      if (rcond .eq. 0.0d0) then
         call mat_err(19)
         return
      endif
      t = mat_flop(1.0d0 + rcond)
      if (t .eq. 1.0d0) then
         call journal('warning:')
         call journal('matrix is close to singular or badly scaled.')
         write(mline,'(''results may be inaccurate. rcond='',1pd13.4)') rcond
         call journal(mline)
      endif
      call ml_wgedi(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,dtr,dti,GM_REALS(l3),GM_IMAGS(l3),1)
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
!===================================================================================================================================
    case (2) ! COMMAND::DET
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call ml_wgefa(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,info)
      !SUBROUTINE ML_WGEDI(ar,ai,LDA,N,ipvt,detr,deti,workr,worki,JOB)
      call ml_wgedi(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,dtr,dti,sr(1),si(1),10)
      k = int(dtr(2))
      ka = iabs(k)+2
      t = 1.0d0
      do i = 1, ka
         t = t/10.0d0
         if (t .ne. 0.0d0) goto 42
      enddo
      GM_REALS(location) = dtr(1)*10.d0**k
      GM_IMAGS(location) = dti(1)*10.d0**k
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      goto 99
42    continue
      if (dti(1) .eq. 0.0d0)then
         write(mline,43) dtr(1),k
         call journal(mline)
      else
         write(mline,44) dtr(1),dti(1),k
         call journal(mline)
      endif
      GM_REALS(location) = dtr(1)
      GM_IMAGS(location) = dti(1)
      GM_REALS(location+1) = dtr(2)
      GM_IMAGS(location+1) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 2
43    format(' det =  ',f7.4,' * 10**',i4)
44    format(' det =  ',f7.4,' + ',f7.4,' i ',' * 10**',i4)
!===================================================================================================================================
    case(3) ! COMMAND::RCOND
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      l3 = location + n*n

      if(too_much_memory( l3+n - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      call ml_wgeco(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,rcond,GM_REALS(l3),GM_IMAGS(l3))
      GM_REALS(location) = rcond
      GM_IMAGS(location) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      if (G_lhs .ne. 1)then
         location = location + 1
         call mat_wcopy(n,GM_REALS(l3),GM_IMAGS(l3),1,GM_REALS(location),GM_IMAGS(location),1)
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
         G_VAR_DATALOC(G_ARGUMENT_POINTER) = location
         G_VAR_ROWS(G_ARGUMENT_POINTER) = n
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endif
!===================================================================================================================================
    case(4) ! COMMAND::LU
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call ml_wgefa(GM_REALS(location),GM_IMAGS(location),m,n,G_BUF,info)
      if (G_lhs .ne. 2) goto 99
      nn = n*n
      if (G_ARGUMENT_POINTER+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = location + nn
      G_VAR_ROWS(G_ARGUMENT_POINTER) = n
      G_VAR_COLS(G_ARGUMENT_POINTER) = n

      if(too_much_memory( location+nn+nn - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      do kb = 1, n
         k = n+1-kb
         do i = 1, n
            ll = location+i-1+(k-1)*n
            lu = ll + nn
            if (i .le. k) GM_REALS(lu) = GM_REALS(ll)
            if (i .le. k) GM_IMAGS(lu) = GM_IMAGS(ll)
            if (i .gt. k) GM_REALS(lu) = 0.0d0
            if (i .gt. k) GM_IMAGS(lu) = 0.0d0
            if (i .lt. k) GM_REALS(ll) = 0.0d0
            if (i .lt. k) GM_IMAGS(ll) = 0.0d0
            if (i .eq. k) GM_REALS(ll) = 1.0d0
            if (i .eq. k) GM_IMAGS(ll) = 0.0d0
            if (i .gt. k) GM_REALS(ll) = -GM_REALS(ll)
            if (i .gt. k) GM_IMAGS(ll) = -GM_IMAGS(ll)
         enddo
         i = G_BUF(k)
         if (i .eq. k) cycle
         li = location+i-1+(k-1)*n
         lk = location+k-1+(k-1)*n
         call mat_wswap(n-k+1,GM_REALS(li),GM_IMAGS(li),n,GM_REALS(lk),GM_IMAGS(lk),n)
      enddo
!===================================================================================================================================
    case(5) ! COMMAND::inverse_hilbert
      n = int(GM_REALS(location))
      G_VAR_ROWS(G_ARGUMENT_POINTER) = n
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      call mat_inverse_hilbert(GM_REALS(location),n,n)
      !call mat_rset(n*n,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
      gm_imags(location:location+n*n-1)=0.0d0 ! set imaginary component to zero
      if (G_FIN .lt. 0) call mat_wscal(n*n,sr(1),si(1),GM_REALS(location),GM_IMAGS(location),1)
!===================================================================================================================================
    case(6) ! COMMAND::CHOLESKY
      if (m .ne. n) then
         call mat_err(20)
         return
      endif
      call mat_wpofa(GM_REALS(location),GM_IMAGS(location),m,n,G_err)
      if (G_err .ne. 0) then
         call mat_err(29)
         return
      endif
      do j = 1, n
         ll = location+j+(j-1)*m
         call mat_wset(m-j,0.0d0,0.0d0,GM_REALS(ll),GM_IMAGS(ll),1)
      enddo
!===================================================================================================================================
    case(7) ! COMMAND::RREF
      if (G_RHS .ge. 2)then
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         if (G_VAR_ROWS(G_ARGUMENT_POINTER) .ne. m) then
            call mat_err(5)
            return
         endif
         n = n + G_VAR_COLS(G_ARGUMENT_POINTER)
      endif
      call mat_rref(GM_REALS(location),GM_IMAGS(location),m,m,n,GM_REALS(GM_BIGMEM-4))
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
!===================================================================================================================================
   end select
!
99 continue
end subroutine mat_matfn1
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn2()
integer          :: i
integer          :: inc
integer          :: j
integer          :: job
integer          :: k
integer          :: location
integer          :: l1
integer          :: l2
integer          :: ld
integer          :: le
integer          :: lj
integer          :: ll
integer          :: ls
integer          :: lw
integer          :: m
integer          :: n
integer          :: nn
!
!     evaluate elementary functions and functions involving eigenvalues and eigenvectors
!
      doubleprecision tr(1),ti(1),sr,si,powr,powi
      logical herm,schur,vect,hess
!
!     functions/G_FIN
!     **   SIN  COS ATAN  EXP  SQRT LOG
!      0    1    2    3    4     5    6
!    EIG  SCHU HESS POLY ROOT
!     11   12   13   14   15
!    ABS  ROUN REAL IMAG CONJ
!     21   22   23   24   25
      if (G_FIN .eq. 0) then
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
         powr = GM_REALS(location)
         powi = GM_IMAGS(location)
      endif
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      m = G_VAR_ROWS(G_ARGUMENT_POINTER)
      n = G_VAR_COLS(G_ARGUMENT_POINTER)

      if (G_FIN .ge. 11 .and. G_FIN .le. 13) goto 10
      if (G_FIN .eq. 14 .and. (m.eq.1 .or. n.eq.1))then
         goto 50
      endif
      if (G_FIN .eq. 14) goto 10
      if (G_FIN .eq. 15) goto 60

      if (G_FIN .gt. 20) goto 40
      if (m .eq. 1 .or. n .eq. 1) goto 40
      ! what about fall-though?
!===================================================================================================================================
!     EIGENVALUES AND VECTORS
   10 continue
      IF (M .NE. N) then
         call mat_err(20)
         return
      endif
      SCHUR = G_FIN .EQ. 12
      HESS = G_FIN .EQ. 13
      VECT = G_LHS.EQ.2 .OR. G_FIN.LT.10
      NN = N*N
      L2 = location + NN
      LD = L2 + NN
      LE = LD + N
      LW = LE + N

      if(too_much_memory( LW+N - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      call mat_wcopy(NN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(L2),GM_IMAGS(L2),1)
!
!     CHECK IF HERMITIAN
      HERM=.FALSE.
      DO J = 1, N
         DO I = 1, J
            LS = location+I-1+(J-1)*N
            LL = location+(I-1)*N+J-1
            HERM = GM_REALS(LL).EQ.GM_REALS(LS) .AND. GM_IMAGS(LL).EQ.-GM_IMAGS(LS)
            IF (.NOT. HERM) goto 30
         enddo
      enddo
!
!     HERMITIAN EIGENVALUE PROBLEM
      call mat_wset(NN,0.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),1)
      call mat_wset(N,1.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),N+1)
      call mat_wset(N,0.0D0,0.0D0,GM_IMAGS(LD),GM_IMAGS(LE),1)
      job = 0
      IF (VECT) JOB = 1
      call ML_HTRIDI(N,N, &
      GM_REALS(L2),GM_IMAGS(L2), &
      GM_REALS(LD),GM_REALS(LE), &
      GM_REALS(LE),GM_REALS(LW))
      IF(.NOT.HESS)call ML_IMTQL2(N,N,GM_REALS(LD),GM_REALS(LE),GM_REALS(location),G_ERR,JOB)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
      IF (JOB .NE. 0) call ML_HTRIBK(N,N,GM_REALS(L2),GM_IMAGS(L2), &
                                         GM_REALS(LW),N,GM_REALS(location), &
                                         GM_IMAGS(location))
      goto 31
!
!     NON-HERMITIAN EIGENVALUE PROBLEM
   30 continue
      call ML_CORTH(N,N,1,N,GM_REALS(L2),GM_IMAGS(L2), &
                            GM_REALS(LW),GM_IMAGS(LW))
      IF (.NOT.VECT .AND. HESS) goto 31
      JOB = 0
      IF (VECT) JOB = 2
      IF (VECT .AND. SCHUR) JOB = 1
      IF (HESS) JOB = 3
      call ML_COMQR3(N,N,1,N,GM_REALS(LW),GM_IMAGS(LW), &
                             GM_REALS(L2),GM_IMAGS(L2),  &
                             GM_REALS(LD),GM_IMAGS(LD), &
                             GM_REALS(location),GM_IMAGS(location), &
                             G_ERR,JOB)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
!
!     VECTORS
   31 continue
      IF (.NOT.VECT) goto 34
      IF (G_ARGUMENT_POINTER+1 .GE. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = L2
      G_VAR_ROWS(G_ARGUMENT_POINTER) = N
      G_VAR_COLS(G_ARGUMENT_POINTER) = N
!
!     DIAGONAL OF VALUES OR CANONICAL FORMS
   34 continue
      IF (.NOT.VECT .AND. .NOT.SCHUR .AND. .NOT.HESS) goto 37
      DO J = 1, N
         LJ = L2+(J-1)*N
         IF (SCHUR .AND. (.NOT.HERM)) LJ = LJ+J
         IF (HESS .AND. (.NOT.HERM)) LJ = LJ+J+1
         LL = L2+J*N-LJ
         call mat_wset(LL,0.0D0,0.0D0,GM_REALS(LJ),GM_IMAGS(LJ),1)
      enddo
      IF (.NOT.HESS .OR. HERM) call mat_wcopy(N,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(L2),GM_IMAGS(L2),N+1)
      LL = L2+1
      IF (HESS .AND. HERM)call mat_wcopy(N-1,GM_REALS(LE+1),GM_IMAGS(LE+1),1,GM_REALS(LL),GM_IMAGS(LL),N+1)
      LL = L2+N
      IF (HESS .AND. HERM)call mat_wcopy(N-1,GM_REALS(LE+1),GM_IMAGS(LE+1),1,GM_REALS(LL),GM_IMAGS(LL),N+1)
      IF (G_FIN .LT. 10) goto 42
      IF (VECT .OR. .NOT.(SCHUR.OR.HESS)) goto 99
      call mat_wcopy(NN,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
      goto 99
!
!     VECTOR OF EIGENVALUES
   37 continue
      IF (G_FIN .EQ. 14) goto 52
      call mat_wcopy(N,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(location),GM_IMAGS(location),1)
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      goto 99
!===================================================================================================================================
!     elementary functions
!     for matrices.. x,d = eig(a), fun(a) = x*fun(d)/x
   40 continue
      inc = 1
      n = m*n
      l2 = location
      goto 44

   42 continue
      INC = N+1

   44 continue
      do j = 1, n
        ls = l2+(j-1)*inc
        sr = GM_REALS(ls)
        si = GM_IMAGS(ls)
        ti = 0.0d0
        if (G_FIN .eq. 0) then
          call mat_wlog(sr,si,sr,si)
          call mat_wmul(sr,si,powr,powi,sr,si)
          tr(1) = dexp(sr)*dcos(si)
          ti(1) = dexp(sr)*dsin(si)
        endif

        select case(G_FIN)
        case( 1)                                      ! COMMAND::sin
                 tr(1) = dsin(sr)*dcosh(si)
                 ti(1) = dcos(sr)*dsinh(si)
        case( 2)                                      ! COMMAND::cos
                 tr(1) = dcos(sr)*dcosh(si)
                 ti(1) = (-dsin(sr))*dsinh(si)
        case( 3)                                      ! COMMAND::atan
                 call mat_watan(sr,si,tr(1),ti(1))
        case( 4)                                      ! COMMAND::exp
                 tr(1) = dexp(sr)*dcos(si)
                 ti(1) = dexp(sr)*dsin(si)
        case( 5)                                      ! COMMAND::sqrt
                 call mat_wsqrt(sr,si,tr(1),ti(1))
        case( 6)                                      ! COMMAND::log
                 call mat_wlog(sr,si,tr(1),ti(1))
        case( 21)                                     ! COMMAND::abs
                 tr(1) = mat_pythag(sr,si)
        case( 22)                                     ! COMMAND::ROUND
                 tr(1) = mat_round(sr)
        case( 23)                                     ! COMMAND::REAL
                 tr(1) = sr
        case( 24)                                     ! COMMAND::IMAG
                 tr(1) = si
        case( 25)                                     ! COMMAND::CONJG
                 tr(1) = sr
                 ti(1) = -si
        end select

        if (G_ERR .gt. 0) return
        GM_REALS(ls) = mat_flop(tr(1))
        GM_IMAGS(ls) = 0.0d0
        if (ti(1) .ne. 0.0d0) GM_IMAGS(ls) = mat_flop(ti(1))
      enddo
      if (inc .eq. 1) goto 99
      do j = 1, n
        ls = l2+(j-1)*inc
        sr = GM_REALS(ls)
        si = GM_IMAGS(ls)
        ls = location+(j-1)*n
        ll = l2+(j-1)*n
        call mat_wcopy(n,GM_REALS(ls),GM_IMAGS(ls),1,GM_REALS(ll),GM_IMAGS(ll),1)
        call mat_wscal(n,sr,si,GM_REALS(ls),GM_IMAGS(ls),1)
      enddo
      ! signal matfn1 to divide by eigenvectors
      G_FUN = 21
      G_FIN = -1
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
      goto 99
!===================================================================================================================================
!     POLY
      ! form polynomial with given vector as roots
   50 continue
      N = MAX(M,N)
      LD = location+N+1
      call mat_wcopy(N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LD),GM_IMAGS(LD),1)
      goto 52
!===================================================================================================================================
!     FORM CHARACTERISTIC POLYNOMIAL
   52 continue
      call mat_wset(N+1,0.0D0,0.0D0,GM_REALS(location),GM_IMAGS(location),1)
      GM_REALS(location) = 1.0D0
      DO J = 1, N
         call matX_waxpy(J,-GM_REALS(LD),-GM_IMAGS(LD), &
                            GM_REALS(location),GM_IMAGS(location), &
                            -1,  &
                            GM_REALS(location+1),GM_IMAGS(location+1), &
                            -1)
         LD = LD+1
      enddo
      G_VAR_ROWS(G_ARGUMENT_POINTER) = N+1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      goto 99
!===================================================================================================================================
!     ROOTS
   60 continue
      LL = location+M*N
      GM_REALS(LL) = -1.0D0
      GM_IMAGS(LL) = 0.0D0
      K = -1
   61 continue
      K = K+1
      L1 = location+K
      IF (DABS(GM_REALS(L1))+DABS(GM_IMAGS(L1)) .EQ. 0.0D0) goto 61
      N = MAX(M*N - K-1, 0)
      IF (N .LE. 0) goto 65
      L2 = L1+N+1
      LW = L2+N*N

      if(too_much_memory( LW+N - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      call mat_wset(N*N+N,0.0D0,0.0D0,GM_REALS(L2),GM_IMAGS(L2),1)
      DO J = 1, N
         LL = L2+J+(J-1)*N
         GM_REALS(LL) = 1.0D0
         LS = L1+J
         LL = L2+(J-1)*N
         call mat_wdiv(-GM_REALS(LS),-GM_IMAGS(LS), &
                        GM_REALS(L1),GM_IMAGS(L1),  &
                        GM_REALS(LL),GM_IMAGS(LL))
         IF (G_ERR .GT. 0) return
      enddo
      call ML_COMQR3(N,N,1,N,GM_REALS(LW),GM_IMAGS(LW), &
                             GM_REALS(L2),GM_IMAGS(L2), &
                             GM_REALS(location),GM_IMAGS(location), &
                             TR,TI,G_ERR,0)
      IF (G_ERR .GT. 0) then
         call mat_err(24)
         return
      endif
   65 continue
      G_VAR_ROWS(G_ARGUMENT_POINTER) = N
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      goto 99
!===================================================================================================================================
   99 continue
end subroutine mat_matfn2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn3()

! ident_26="@(#) M_matrix mat_matfn3(3fp) evaluate functions involving singular value decomposition"

integer         :: i
integer         :: j
integer         :: jb
integer         :: job
integer         :: k
integer         :: location
integer         :: l1
integer         :: l2
integer         :: ld
integer         :: li
integer         :: lj
integer         :: ll
integer         :: ls
integer         :: lu
integer         :: lv
integer         :: m
integer         :: mn
integer         :: n
logical         :: fro,inf
doubleprecision :: p,s,t(1,1),tol,eps
!
   if (G_FIN.eq.1 .and. G_RHS.eq.2) G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)
   mn = m*n
   !      SVD PINV COND NORM RANK POW RESHAPE
   !        1    2    3    4    5   6       7
   FUN3: select case(G_FIN)
!===================================================================================================================================
    case(3) ! COMMAND::COND
      ld = location + m*n
      l1 = ld + min(m+1,n)
      l2 = l1 + n

      if(too_much_memory( l2+min(m,n) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      call ml_wsvdc(GM_REALS(location),GM_IMAGS(location),   &
                  & m,m,n,                               &
                  & GM_REALS(ld),GM_IMAGS(ld), &
                  & GM_REALS(l1),GM_IMAGS(l1), &
                  & t,t,1,t,t,1,                         &
                  & GM_REALS(l2),GM_IMAGS(l2), &
                  & 0,G_err)
      if (G_err .ne. 0) then
         call mat_err(24)
         return
      endif
      s = GM_REALS(ld)
      ld = ld + min(m,n) - 1
      t(1,1) = GM_REALS(ld)
      if (t(1,1) .ne. 0.0d0) then
         GM_REALS(location) = mat_flop(s/t(1,1))
         GM_IMAGS(location) = 0.0d0
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      else
         call journal(' CONDITION IS INFINITE')
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      endif
!===================================================================================================================================
    case(4) ! command::norm

      p = 2.0d0
      inf = .false.

      if (G_RHS .eq. 2)then
         fro = int(GM_REALS(location)).eq.iachar('f') .and. mn.gt.1
         inf = int(GM_REALS(location)).eq.iachar('i') .and. mn.gt.1
         if (.not. fro) then
            p = GM_REALS(location)
         endif
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         m = G_VAR_ROWS(G_ARGUMENT_POINTER)
         n = G_VAR_COLS(G_ARGUMENT_POINTER)
         mn = m*n
         if (fro) then
            m = mn
            n = 1
         endif
      endif

      if (m .gt. 1 .and. n .gt. 1) then
         ! matrix norm

         if (inf)then
            s = 0.0d0
            do i = 1, m
               li = location+i-1
               t(1,1) = mat_wasum(n,GM_REALS(LI),GM_IMAGS(li),m)
               s = dmax1(s,t(1,1))
            enddo
         elseif (p .eq. 1.0d0) then
            s = 0.0d0
            do j = 1, n
               lj = location+(j-1)*m
               t(1,1) = mat_wasum(m,GM_REALS(LJ),GM_IMAGS(lj),1)
               s = dmax1(s,t(1,1))
            enddo
         elseif (p .ne. 2.0d0) then
            call mat_err(23) ! Only 1, 2 or INF norm of matrix
            return
         else
            ld = location + m*n
            l1 = ld + min(m+1,n)
            l2 = l1 + n

            if(too_much_memory( l2+min(m,n) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )then
               return
            endif

            call ml_wsvdc(GM_REALS(location),GM_IMAGS(location), &
                        & m,m,n, &
                        & GM_REALS(ld),GM_IMAGS(ld), &
                        & GM_REALS(l1),GM_IMAGS(l1), &
                        & t,t,1,t,t,1, &
                        & GM_REALS(l2),GM_IMAGS(l2), &
                        & 0,G_err)

            if (G_ERR .ne. 0)then
               call mat_err(24)
               return
            endif

            s = GM_REALS(LD)
         endif

      elseif (p .eq. 1.0d0)then
         s = mat_wasum(MN,GM_REALS(location),GM_IMAGS(location),1)
      elseif (p .eq. 2.0d0) then
         s = mat_wnrm2(MN,GM_REALS(location),GM_IMAGS(location),1)
      else
         i = mat_iwamax(mn,GM_REALS(location),GM_IMAGS(location),1) + location - 1
         s = dabs(GM_REALS(i)) + dabs(GM_IMAGS(i))

         if (.not.(inf .or. s .eq. 0.0d0))then
            t(1,1) = 0.0d0
            do i = 1, mn
               ls = location+i-1
               t(1,1) = mat_flop(t(1,1) + (mat_pythag(GM_REALS(ls),GM_IMAGS(ls))/s)**p)
            enddo
            if (p .ne. 0.0d0) then
               p = 1.0d0/p
            endif
            s = mat_flop(s*t(1,1)**p)
         endif
      endif

      GM_REALS(location) = s
      GM_IMAGS(location) = 0.0d0
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
!===================================================================================================================================
    case(1) !     COMMAND::SVD
      IF (G_LHS .EQ. 3)then
         K = M
         IF (G_RHS .EQ. 2) K = MIN(M,N)
         LU = location + M*N
         LD = LU + M*K
         LV = LD + K*N
         L1 = LV + N*N
         L2 = L1 + N

         if(too_much_memory( L2+MIN(M,N) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

         JOB = 11
         IF (G_RHS .EQ. 2) JOB = 21
         call ml_wsvdc(GM_REALS(location),GM_IMAGS(location), &
         & m,m,n, &
         & GM_REALS(ld),GM_IMAGS(ld), &
         & GM_REALS(l1),GM_IMAGS(l1), &
         & GM_REALS(lu),GM_IMAGS(lu), &
         & m, &
         & GM_REALS(lv),GM_IMAGS(lv), &
         & n, &
         & GM_REALS(l2),GM_IMAGS(l2), &
         & job,G_err)
         DO JB = 1, N
            DO I = 1, K
               J = N+1-JB
               LL = LD+I-1+(J-1)*K
               IF (I.NE.J) GM_REALS(LL) = 0.0D0
               GM_IMAGS(LL) = 0.0D0
               LS = LD+I-1
               IF (I.EQ.J) GM_REALS(LL) = GM_REALS(LS)
               LS = L1+I-1
               IF (G_ERR.NE.0 .AND. I.EQ.J-1) GM_REALS(LL) = GM_REALS(LS)
            enddo
         enddo
         IF (G_ERR .NE. 0) call mat_err(24)
         G_ERR = 0
         call mat_wcopy(M*K+K*N+N*N, &
                      & GM_REALS(LU),GM_IMAGS(LU), &
                      & 1, &
                      & GM_REALS(location),GM_IMAGS(location), &
                      & 1)
         G_VAR_ROWS(G_ARGUMENT_POINTER) = M
         G_VAR_COLS(G_ARGUMENT_POINTER) = K
         IF (G_ARGUMENT_POINTER+1 .GE. G_TOP_OF_SAVED) then
            call mat_err(18)
            return
         endif
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
         G_VAR_DATALOC(G_ARGUMENT_POINTER) = location + M*K
         G_VAR_ROWS(G_ARGUMENT_POINTER) = K
         G_VAR_COLS(G_ARGUMENT_POINTER) = N
         IF (G_ARGUMENT_POINTER+1 .GE. G_TOP_OF_SAVED) then
            call mat_err(18)
            return
         endif
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
         G_VAR_DATALOC(G_ARGUMENT_POINTER) = location + M*K + K*N
         G_VAR_ROWS(G_ARGUMENT_POINTER) = N
         G_VAR_COLS(G_ARGUMENT_POINTER) = N
      else
         LD = location + M*N
         L1 = LD + MIN(M+1,N)
         L2 = L1 + N

         if(too_much_memory( L2+MIN(M,N) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

         call ml_wsvdc(GM_REALS(location),GM_IMAGS(location),m,m,n, &
         & GM_REALS(ld),GM_IMAGS(ld),GM_REALS(l1),GM_IMAGS(l1), &
         & t,t,1,t,t,1,GM_REALS(l2),GM_IMAGS(l2),0,G_err)
         IF (G_ERR .NE. 0) then
            call mat_err(24)
            return
         endif
         K = MIN(M,N)
         call mat_wcopy(K,GM_REALS(LD),GM_IMAGS(LD),1,GM_REALS(location),GM_IMAGS(location),1)
         G_VAR_ROWS(G_ARGUMENT_POINTER) = K
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endif
!===================================================================================================================================
    case(2,5) ! COMMAND::PINV AND RANK
      TOL = -1.0D0
      IF (G_RHS .EQ. 2) then
         TOL = GM_REALS(location)
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         M = G_VAR_ROWS(G_ARGUMENT_POINTER)
         N = G_VAR_COLS(G_ARGUMENT_POINTER)
      endif
      LU = location + M*N
      LD = LU + M*M
      IF (G_FIN .EQ. 5) LD = location + M*N
      LV = LD + M*N
      L1 = LV + N*N
      IF (G_FIN .EQ. 5) L1 = LD + N
      L2 = L1 + N

      if(too_much_memory( L2+MIN(M,N) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      IF (G_FIN .EQ. 2) JOB = 11
      IF (G_FIN .EQ. 5) JOB = 0
      call ML_WSVDC(GM_REALS(location),GM_IMAGS(location),M,M,N, &
                  & GM_REALS(LD),GM_IMAGS(LD), &
                  & GM_REALS(L1),GM_IMAGS(L1), &
                  & GM_REALS(LU),GM_IMAGS(LU), &
                  & M, &
                  & GM_REALS(LV),GM_IMAGS(LV), &
                  & N, &
                  & GM_REALS(L2),GM_IMAGS(L2), &
                  & JOB,G_ERR)
      IF (G_ERR .NE. 0) then
         call mat_err(24)
         return
      endif
      EPS = GM_REALS(GM_BIGMEM-4)
      IF (TOL .LT. 0.0D0) TOL = mat_flop(dble(MAX(M,N))*EPS*GM_REALS(LD))
      MN = MIN(M,N)
      K = 0
      DO J = 1, MN
         LS = LD+J-1
         S = GM_REALS(LS)
         IF (S .LE. TOL) exit
         K = J
         LL = LV+(J-1)*N
         IF (G_FIN .EQ. 2) call mat_wrscal(N,1.0D0/S,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      if (G_FIN .ne. 5) then
         do j = 1, m
            do i = 1, n
               ll = location+i-1+(j-1)*n
               l1 = lv+i-1
               l2 = lu+j-1
               GM_REALS(ll) = mat_wdotcr(k,GM_REALS(l2),GM_IMAGS(l2),m,GM_REALS(l1),GM_IMAGS(l1),n)
               GM_IMAGS(ll) = mat_wdotci(k,GM_REALS(l2),GM_IMAGS(l2),m,GM_REALS(l1),GM_IMAGS(l1),n)
            enddo
         enddo
         G_VAR_ROWS(G_ARGUMENT_POINTER) = n
         G_VAR_COLS(G_ARGUMENT_POINTER) = m
      else
         GM_REALS(location) = dble(k)
         GM_IMAGS(location) = 0.0d0
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
         G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      endif
!===================================================================================================================================
    case(6) ! COMMAND::POW
            ! COMMAND::POWER
      pow: block
      integer :: MP, NP      ! shape of exponent
      integer :: LOCP_START  ! location of first exponent
      integer :: LOCP
      integer :: LOCIN, LOCOUT, LOCIN_START,LOCOUT_START
      IF (G_RHS .EQ. 2) then
            LOCP_START=location
            MP = G_VAR_ROWS(G_ARGUMENT_POINTER)
            NP = G_VAR_COLS(G_ARGUMENT_POINTER)
      else
            call mat_err(39) ! Incorrect number of arguments
            return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
      LOCIN_START = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      M = G_VAR_ROWS(G_ARGUMENT_POINTER)
      N = G_VAR_COLS(G_ARGUMENT_POINTER)
      LOCOUT_START = LOCIN_START + M*N + MP*NP
      if(too_much_memory( LOCOUT_START + M*N+1 - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      if(MP*NP .le. 1)then
         DO J = 1, M*N
            LOCIN =  LOCIN_START +J-1
            LOCOUT = LOCOUT_START+J-1
          call mat_wpow(GM_REALS(LOCIN),GM_IMAGS(LOCIN),GM_REALS(LOCOUT),GM_IMAGS(LOCOUT),GM_REALS(LOCP_START),GM_IMAGS(LOCP_START))
         enddo
      elseif(MP.eq.M .and. NP .eq. N)then
         DO J = 1, M*N
            LOCIN = LOCIN_START+J-1
            LOCOUT = LOCOUT_START+J-1
            LOCP=LOCP_START+J-1
            call mat_wpow(GM_REALS(LOCIN),GM_IMAGS(LOCIN),GM_REALS(LOCOUT),GM_IMAGS(LOCOUT),GM_REALS(LOCP),GM_IMAGS(LOCP))
         enddo
      else
         call mat_err(41) ! incompatible for powers
         return
      endif
      ! move output data back
      call mat_wcopy(M*N,GM_REALS(LOCOUT_START),GM_IMAGS(LOCOUT_START),1,GM_REALS(LOCIN_START),GM_IMAGS(LOCIN_START),1)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = M
      G_VAR_COLS(G_ARGUMENT_POINTER) = N
      endblock pow
!===================================================================================================================================
    case(7) ! COMMAND::RESHAPE
      reshape: block
      integer :: input_rows,input_cols      ! shape of array holding new shape for data
      integer :: loc_dimensions_start       ! location of first dimension
      integer :: new_rows, new_columns      ! new shape
      integer :: LOCIN_START,LOCOUT_START
      IF (G_RHS .EQ. 2) then                ! two arguments, input array and new shape
            input_rows = G_VAR_ROWS(G_ARGUMENT_POINTER)
            input_cols = G_VAR_COLS(G_ARGUMENT_POINTER)
            if(input_rows*input_cols.ne.2)then ! new shape should be two values
               call mat_err(39) ! Incorrect number of arguments
               return
            endif
            loc_dimensions_start=location
            new_rows=gm_reals(loc_dimensions_start)
            new_columns=gm_reals(loc_dimensions_start+1)
      else
            call mat_err(39) ! Incorrect number of arguments
            return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1  ! point to first argument instead of second
      M = G_VAR_ROWS(G_ARGUMENT_POINTER)         ! get dimensions of first argument
      N = G_VAR_COLS(G_ARGUMENT_POINTER)
      LOCIN_START = G_VAR_DATALOC(G_ARGUMENT_POINTER) ! location where data for first argument starts
      ! place to put generated data, which is past all the input. Could calculate from end of first parameter
      !LOCOUT_START = LOCIN_START + M*N + input_rows * input_cols ! normally would be at end of input
      if(new_rows*new_columns /= n*m)then
         call mat_err(42) ! new shape is not the same size as input
         return
      endif
      ! move output data back
      ! locout_start and locin_start will always be 1 so no actual need to copy it to itself
      !subroutine mat_wcopy(number_of_values,xr,xi,incx,yr,yi,incy)
      !call mat_wcopy(M*N,GM_REALS(LOCOUT_START),GM_IMAGS(LOCOUT_START),1,GM_REALS(LOCIN_START),GM_IMAGS(LOCIN_START),1)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = new_rows
      G_VAR_COLS(G_ARGUMENT_POINTER) = new_columns
      endblock reshape
!===================================================================================================================================
       case(8:13) ! COMMAND::LT
                  ! COMMAND::LE
                  ! COMMAND::EQ
                  ! COMMAND::GE
                  ! COMMAND::GT
                  ! COMMAND::NE
         equate: block
         integer                          :: right_rows,right_cols, left_rows,left_cols               ! shape of first array
         integer                          :: right_array_start,left_array_start  ! location of first array
         integer(kind=int8),allocatable   :: answer_array(:)
         logical                          :: is_complex

         IF (G_RHS .ne. 2) then
            call mat_err(39) ! Incorrect number of arguments
            return
         endif

         ! locate right_array
         right_array_start=LOCATION
         right_rows = G_VAR_ROWS(G_ARGUMENT_POINTER)
         right_cols = G_VAR_COLS(G_ARGUMENT_POINTER)

         ! locate left_array
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         left_array_start = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         left_rows = G_VAR_ROWS(G_ARGUMENT_POINTER)
         left_cols = G_VAR_COLS(G_ARGUMENT_POINTER)

         if(too_much_memory(right_array_start+right_rows*left_cols+left_rows*left_cols+1-G_VAR_DATALOC(G_TOP_OF_SAVED)))return

         is_complex=.false.
         if( any(GM_IMAGS(left_array_start:left_array_start+right_rows*right_cols-1).ne.0.0d0) )is_complex=.true.
         if( any(GM_IMAGS(right_array_start:right_array_start+right_rows*right_cols-1).ne.0.0d0) )is_complex=.true.
         if(is_complex)then ! only logical operators .eq. and .ne. can be used with complex values
            complex_values: block
            complex(kind=real64) :: right_array(right_cols*right_rows)
            complex(kind=real64) :: left_array(left_cols*left_rows)
               right_array=cmplx( GM_REALS(right_array_start:right_array_start+right_rows*right_cols-1), &
                                  GM_IMAGS(right_array_start:right_array_start+right_rows*right_cols-1), KIND=REAL64 )
               left_array=cmplx(  GM_REALS(left_array_start:left_array_start+left_rows*left_cols-1), &
                                  GM_IMAGS(left_array_start:left_array_start+left_rows*left_cols-1), KIND=REAL64 )
               if(right_rows*right_cols .eq. 1)then
                  select case(G_FIN)
                   case(10); answer_array=MERGE(1,0,left_array.eq.right_array(1))
                   case(13); answer_array=MERGE(1,0,left_array.ne.right_array(1))
                   case default
                      call mat_err(44) ! operation not defined for complex values
                      return
                  end select
               elseif((left_rows*left_cols).eq.1)then
                  select case(G_FIN)
                   case(10); answer_array=MERGE(1,0,left_array(1).eq.right_array)
                   case(13); answer_array=MERGE(1,0,left_array(1).ne.right_array)
                   case default
                      call mat_err(44) ! operation not defined for complex values
                      return
                  end select
               !elseif(right_rows.eq.left_rows .and. right_cols .eq. left_cols)then  ! same shape
               elseif(right_rows*right_cols == left_rows*left_cols)then  ! same number of elements
                  select case(G_FIN)
                   case(10); answer_array=MERGE(1,0,left_array.eq.right_array)
                   case(13); answer_array=MERGE(1,0,left_array.ne.right_array)
                   case default
                      call mat_err(44) ! operation not defined for complex values
                      return
                  end select
               else
                  call mat_err(43) !  shapes are not conformant
                  return
               endif
            endblock complex_values
         else
         associate( &
         right_array=> GM_REALS(right_array_start:right_array_start+right_rows*right_cols-1), &
         left_array=> GM_REALS(left_array_start:left_array_start+left_rows*left_cols-1) &
         )
         if(right_rows*right_cols .eq. 1)then
            select case(G_FIN)
             case(8);  answer_array=MERGE(1,0,left_array.lt.right_array(1))
             case(9);  answer_array=MERGE(1,0,left_array.le.right_array(1))
             case(10); answer_array=MERGE(1,0,left_array.eq.right_array(1))
             case(11); answer_array=MERGE(1,0,left_array.ge.right_array(1))
             case(12); answer_array=MERGE(1,0,left_array.gt.right_array(1))
             case(13); answer_array=MERGE(1,0,left_array.ne.right_array(1))
            end select
         elseif((left_rows*left_cols).eq.1)then
            select case(G_FIN)
             case(8);  answer_array=MERGE(1,0,left_array(1).lt.right_array)
             case(9);  answer_array=MERGE(1,0,left_array(1).le.right_array)
             case(10); answer_array=MERGE(1,0,left_array(1).eq.right_array)
             case(11); answer_array=MERGE(1,0,left_array(1).ge.right_array)
             case(12); answer_array=MERGE(1,0,left_array(1).gt.right_array)
             case(13); answer_array=MERGE(1,0,left_array(1).ne.right_array)
            end select
         !elseif(right_rows.eq.left_rows .and. right_cols .eq. left_cols)then
         elseif(right_rows*right_cols == left_rows*left_cols)then  ! same number of elements
            select case(G_FIN)
             case(8);  answer_array=MERGE(1,0,left_array.lt.right_array)
             case(9);  answer_array=MERGE(1,0,left_array.le.right_array)
             case(10); answer_array=MERGE(1,0,left_array.eq.right_array)
             case(11); answer_array=MERGE(1,0,left_array.ge.right_array)
             case(12); answer_array=MERGE(1,0,left_array.gt.right_array)
             case(13); answer_array=MERGE(1,0,left_array.ne.right_array)
            end select
         else
            call mat_err(43) !  shapes are not conformant
            return
         endif
         end associate
      endif
      ! move output data back
      mn=max(right_rows*right_cols,left_rows*left_cols)
      GM_REALS(left_array_start:left_array_start+mn-1)=answer_array
      GM_IMAGS(left_array_start:left_array_start+mn-1)=0.0d0
      if( (left_rows*left_cols).ne.1 )then
         G_VAR_ROWS(G_ARGUMENT_POINTER) = left_rows
         G_VAR_COLS(G_ARGUMENT_POINTER) = left_cols
      else
         G_VAR_ROWS(G_ARGUMENT_POINTER) = right_rows
         G_VAR_COLS(G_ARGUMENT_POINTER) = right_cols
      endif
      endblock equate
!===================================================================================================================================
       case(14) ! COMMAND::PACK
         pack_array: block
         integer  :: right_rows,right_cols, left_rows,left_cols   ! shape of first array
         integer  :: right_array_start,left_array_start           ! location of first array

         IF (G_RHS .ne. 2) then
            call mat_err(39) ! Incorrect number of arguments
            return
         endif

         ! locate right_array
         right_array_start=LOCATION
         right_rows = G_VAR_ROWS(G_ARGUMENT_POINTER)
         right_cols = G_VAR_COLS(G_ARGUMENT_POINTER)

         ! locate left_array
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         left_array_start = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         left_rows = G_VAR_ROWS(G_ARGUMENT_POINTER)
         left_cols = G_VAR_COLS(G_ARGUMENT_POINTER)

         if(too_much_memory(right_array_start+right_rows*left_cols+left_rows*left_cols+1-G_VAR_DATALOC(G_TOP_OF_SAVED)))return

         cmplex_values: block
         integer(kind=int8)               :: right_array(right_cols*right_rows)
         complex(kind=real64)             :: left_array(left_cols*left_rows)
         complex(kind=real64),allocatable :: answer_array(:)
            right_array=nint(GM_REALS(right_array_start:right_array_start+right_rows*right_cols-1))
            left_array=cmplx( GM_REALS(left_array_start:left_array_start+left_rows*left_cols-1), &
                              GM_IMAGS(left_array_start:left_array_start+left_rows*left_cols-1), KIND=REAL64 )
            if(right_rows.eq.left_rows .and. right_cols .eq. left_cols)then
                answer_array=pack(left_array,right_array.eq.1)
                ! move output data back
                mn=size(answer_array)
                GM_REALS(left_array_start:left_array_start+mn-1)=answer_array%re
                GM_IMAGS(left_array_start:left_array_start+mn-1)=answer_array%im
                G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
                G_VAR_COLS(G_ARGUMENT_POINTER) = size(answer_array)
            else
               call mat_err(41) ! incompatible for comparisions
               return
            endif
         endblock cmplex_values
      endblock pack_array
!===================================================================================================================================
   end select FUN3
!
end subroutine mat_matfn3
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
SUBROUTINE mat_matfn4()

! ident_27="@(#) M_matrix mat_matfn4(3fp) evaluate functions involving qr decomposition (least squares)"

integer           :: info
integer           :: j
integer           :: jb
integer           :: job
integer           :: k
integer           :: location
integer           :: l2
integer           :: l3
integer           :: l4
integer           :: le
integer           :: ll
integer           :: ls
integer           :: m
integer           :: m2
integer           :: mm
integer           :: mn
integer           :: n
integer           :: n2
character(len=81) :: message
DOUBLEPRECISION   :: T(1),TOL,EPS
!
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      M = G_VAR_ROWS(G_ARGUMENT_POINTER)
      N = G_VAR_COLS(G_ARGUMENT_POINTER)

      IF (G_FIN .EQ. -1) then
         goto 10
      elseIF (G_FIN .EQ. -2) then
         goto 20
      else
         goto 40
      endif
!
!     RECTANGULAR MATRIX RIGHT DIVISION, A/A2
   10 continue
      L2 = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      M2 = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
      N2 = G_VAR_COLS(G_ARGUMENT_POINTER+1)
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
      IF (N.GT.1 .AND. N.NE.N2) then
         call mat_err(11)
         return
      endif
      call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      LL = L2+M2*N2
      call mat_wcopy(M*N,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(LL),GM_IMAGS(LL),1)
      call mat_wcopy(M*N+M2*N2,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = location+M2*N2
      G_VAR_ROWS(G_ARGUMENT_POINTER) = M
      G_VAR_COLS(G_ARGUMENT_POINTER) = N
      call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
      M = N2
      N = M2
      goto 20
!
!     RECTANGULAR MATRIX LEFT DIVISION A BACKSLASH A2
!
   20 continue
      L2 = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      M2 = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
      N2 = G_VAR_COLS(G_ARGUMENT_POINTER+1)
      IF (M2*N2 .GT. 1) goto 21
        M2 = M
        N2 = M

        if(too_much_memory( L2+M*M - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

        call mat_wset(M*M-1,0.0D0,0.0D0,GM_REALS(L2+1),GM_IMAGS(L2+1),1)
        call mat_wcopy(M,GM_REALS(L2),GM_IMAGS(L2),0,GM_REALS(L2),GM_IMAGS(L2),M+1)
   21 continue
      IF (M2 .NE. M) then
         call mat_err(12)
         return
      endif
      L3 = L2 + MAX(M,N)*N2
      L4 = L3 + N

      if(too_much_memory( L4 + N - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      IF (M .GT. N) goto 23
      DO JB = 1, N2
        J = N+1-JB
        LS = L2 + (J-1)*M
        LL = L2 + (J-1)*N
        call mat_wcopy(M,GM_REALS(LS),GM_IMAGS(LS),-1,GM_REALS(LL),GM_IMAGS(LL),-1)
      enddo
   23 continue
      DO J = 1, N
        G_BUF(J) = 0
      enddo
      call ML_WQRDC(GM_REALS(location),GM_IMAGS(location), &
                  & M,M,N, &
                  & GM_REALS(L4),GM_IMAGS(L4), &
                  & G_BUF, &
                  & GM_REALS(L3),GM_IMAGS(L3), &
                  & 1)
      K = 0
      EPS = GM_REALS(GM_BIGMEM-4)
      T(1) = DABS(GM_REALS(location))+DABS(GM_IMAGS(location))
      TOL = mat_flop(dble(MAX(M,N))*EPS*T(1))
      MN = MIN(M,N)
      DO J = 1, MN
        LS = location+J-1+(J-1)*M
        T(1) = DABS(GM_REALS(LS)) + DABS(GM_IMAGS(LS))
        IF (T(1) .GT. TOL) K = J
      enddo
      IF (K .LT. MN) then
         WRITE(message,'(" RANK DEFICIENT,  RANK =",I4,",  TOL =",1PD13.4)') K,TOL
         call journal(message)
      endif
      MN = MAX(M,N)
      DO J = 1, N2
        LS = L2+(J-1)*MN
        call ML_WQRSL(GM_REALS(location),GM_IMAGS(location), &
                        & M,M,K, &
                        & GM_REALS(L4),GM_IMAGS(L4), &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & T,T, &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & GM_REALS(LS),GM_IMAGS(LS), &
                        & T,T,T,T,100,INFO)
        LL = LS+K
        call mat_wset(N-K,0.0D0,0.0D0,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      DO J = 1, N
        G_BUF(J) = -G_BUF(J)
      enddo
      DO J = 1, N
        IF (G_BUF(J) .GT. 0) cycle
        K = -G_BUF(J)
        G_BUF(J) = K
   33   CONTINUE
          IF (K .EQ. J) cycle
          LS = L2+J-1
          LL = L2+K-1
          call mat_wswap(N2,GM_REALS(LS),GM_IMAGS(LS),MN,GM_REALS(LL),GM_IMAGS(LL),MN)
          G_BUF(K) = -G_BUF(K)
          K = G_BUF(K)
          goto 33
      enddo
      DO J = 1, N2
        LS = L2+(J-1)*MN
        LL = location+(J-1)*N
        call mat_wcopy(N,GM_REALS(LS),GM_IMAGS(LS),1,GM_REALS(LL),GM_IMAGS(LL),1)
      enddo
      G_VAR_ROWS(G_ARGUMENT_POINTER) = N
      G_VAR_COLS(G_ARGUMENT_POINTER) = N2
      IF (G_FIN .EQ. -1) call mat_stack1(QUOTE)
      IF (G_ERR .GT. 0) return
      goto 99
!===================================================================================================================================
!     QR
!
   40 continue
      mm = max(m,n)
      ls = location + mm*mm
      if (G_LHS.eq.1 .and. G_FIN.eq.1) ls = location
      le = ls + m*n
      l4 = le + mm

      if(too_much_memory( l4+mm - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      if (ls.ne.location) then
         call mat_wcopy(m*n,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(ls),GM_IMAGS(ls),1)
      endif
      job = 1
      if (G_LHS.lt.3) job = 0
      do j = 1, n
        G_BUF(j) = 0
      enddo
      call ml_wqrdc(GM_REALS(ls),GM_IMAGS(ls), &
       & m,m,n, &
       & GM_REALS(l4),GM_IMAGS(l4), &
       & G_BUF, &
       & GM_REALS(le),GM_IMAGS(le), &
       & job)
      if (G_LHS.eq.1 .and. G_FIN.eq.1) goto 99
      call mat_wset(m*m,0.0d0,0.0d0,GM_REALS(location),GM_IMAGS(location),1)
      call mat_wset(m,1.0d0,0.0d0,GM_REALS(location),GM_IMAGS(location),m+1)
      do j = 1, m
        ll = location+(j-1)*m
        call ml_wqrsl(GM_REALS(ls),GM_IMAGS(ls),m,m,n,GM_REALS(l4),GM_IMAGS(l4),   &
     &             GM_REALS(ll),GM_IMAGS(ll),GM_REALS(ll),GM_IMAGS(ll),t,t,        &
     &             t,t,t,t,t,t,10000,info)
      enddo
      if (G_FIN .eq. 2) goto 99
      G_VAR_COLS(G_ARGUMENT_POINTER) = M
      do j = 1, n
        ll = ls+j+(j-1)*m
        call mat_wset(m-j,0.0d0,0.0d0,GM_REALS(ll),GM_IMAGS(ll),1)
      enddo
      if (G_ARGUMENT_POINTER+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = ls
      G_VAR_ROWS(G_ARGUMENT_POINTER) = m
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      if (G_LHS .eq. 2) goto 99
      call mat_wset(N*N,0.0D0,0.0D0,GM_REALS(le),GM_IMAGS(le),1)
      do j = 1, n
        ll = le+G_BUF(j)-1+(j-1)*n
        GM_REALS(ll) = 1.0d0
      enddo
      if (G_ARGUMENT_POINTER+1 .ge. G_TOP_OF_SAVED) then
         call mat_err(18)
         return
      endif
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = le
      G_VAR_ROWS(G_ARGUMENT_POINTER) = n
      G_VAR_COLS(G_ARGUMENT_POINTER) = n
      goto 99
!===================================================================================================================================
!
   99 continue
END SUBROUTINE mat_matfn4
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_matfn5()

! ident_28="@(#) M_matrix mat_matfn5(3fp) file handling and other I/O"

character(len=GG_LINELEN) :: mline
character(len=256)        :: errmsg
integer,save              :: flag=0  ! should be saved or set at each call?
integer,save              :: lrat=5
integer,save              :: mrat=100
integer                   :: ch,top2
integer                   :: id(GG_MAX_NAME_LENGTH)
doubleprecision           :: eps,b,s,t,tdum(2)
logical                   :: text
integer                   :: i, j, k, location, m, n
integer                   :: img
integer                   :: space_left
integer                   :: l2
integer                   :: ll
integer                   :: ls
integer                   :: lun
integer                   :: lunit
integer                   :: lw
integer                   :: lx
integer                   :: ly
integer                   :: mn
!
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)

   !  functions/G_FIN
   !  exec save load print diary display base line char plot rat  debug  doc  delete
   !    1    2    3    4     5      6     7    8    9    10   11    12   13      14

   select case(G_FIN)
      case(:5,13,14) ! setup for filename parameter

         mn = m*n

         if (G_SYM .eq. semi)then
            flag = 0
         else
            flag = 3
         endif

         if (G_RHS .ge. 2) then            ! if more than one parameter on exec('filename',flag) get value of FLAG
            flag = nint(GM_REALS(location))
            top2 = G_ARGUMENT_POINTER
            G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
            location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
            mn = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
         endif

         ! if a single character and a digit set LUN to that so exec(0) works
         if (mn.eq.1 .and. GM_REALS(location).LT.10.0d0)then
            lun = nint(GM_REALS(location))
         else
            lun = -1
            do j = 1, GG_LINELEN
               ls = location+j-1
               if (j .le. mn) ch = int(GM_REALS(ls))
               if (j .gt. mn) ch = blank
               if (ch.lt.0 .or. ch.ge.g_charset_size) then
                  call mat_err(38)
                  return
               endif
               G_BUF(j) = ch
            enddo
         endif
      end select
!===================================================================================================================================
      FUN5 : select case(G_FIN)
!===================================================================================================================================
      case(1) ! COMMAND::EXEC
      EXEC_CMD : block
      character(len=:),allocatable :: filename
      if (lun .eq. 0) then                              ! exec(0)
         G_LUN_READING_FROM = G_INPUT_LUN
         G_ERR = 99
      else
         k = G_LINE_POINTER(6)
         G_LIN(k+1) = G_LINE_POINTER(1)
         G_LIN(k+2) = G_LINE_POINTER(3)
         G_LIN(k+3) = G_LINE_POINTER(6)
         G_LIN(k+4) = G_PTZ
         G_LIN(k+5) = G_LUN_READING_FROM
         G_LIN(k+6) = G_LINECOUNT(4)
         G_LINE_POINTER(1) = k + 7
         G_LINECOUNT(4) = flag
         G_PTZ = G_PT - 4

         if (G_LUN_READING_FROM .eq. G_INPUT_LUN)then
            G_LUN_READING_FROM = 12
         endif

         G_LUN_READING_FROM = G_LUN_READING_FROM + 1

         filename=find_exec_file(ade2str(G_BUF))
         call mat_str2buf(filename,G_BUF,GG_LINELEN)    ! convert input line to ADE buffer
         call mat_files(G_LUN_READING_FROM,G_BUF,status='old')
         if(G_FILE_OPEN_ERROR)then
            G_LUN_READING_FROM = G_INPUT_LUN
            G_ERR = 99
         endif

         if (flag .ge. 4)then
            call journal(' PAUSE MODE. Enter blank lines.')
         endif

         G_SYM = GG_EOL
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      endif
      endblock EXEC_CMD
!===================================================================================================================================
      case(2) ! COMMAND::SAVE
      lunit = 1
      call mat_files(lunit,G_BUF)
      k = GG_MAX_NUMBER_OF_NAMES-4
      if (k .lt. G_TOP_OF_SAVED) k = GG_MAX_NUMBER_OF_NAMES
      if (G_RHS .eq. 2) k = top2
      if (G_RHS .eq. 2) call mat_copyid(G_VAR_IDS(1,k),G_SYN)
      do
         location = G_VAR_DATALOC(k)
         m = G_VAR_ROWS(k)
         n = G_VAR_COLS(k)
         do i = 1, GG_MAX_NAME_LENGTH
            j = G_VAR_IDS(i,k)
            G_BUF(i) = j
         enddo
         img = 0
         if (mat_wasum(m*n,GM_IMAGS(location),GM_IMAGS(location),1) .ne. 0.0d0) img = 1
         if(.not.G_FILE_OPEN_ERROR)call mat_savlod(lunit,G_BUF,m,n,img,0,GM_REALS(location),GM_IMAGS(location))
         k = k-1
         if (k .lt. G_TOP_OF_SAVED) exit
      enddo
      call mat_files(-lunit,G_BUF) ! close unit
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0  ! do not set "ans" to filename
!===================================================================================================================================
      case(14) ! COMMAND::DELETE
         DELETE_IT: block
         integer :: templun
         integer :: ios
         call mat_buf2str(mline,G_BUF,GG_LINELEN)
         open(file=mline,newunit=templun,iostat=ios,iomsg=errmsg,status='old')
         if(ios.ne.0)then
            call journal('sc','ERROR:',errmsg)
            G_ERR=999
            exit FUN5
         endif
         close(unit=templun,iostat=ios,iomsg=errmsg,status='delete')
         if(ios.ne.0)then
            call journal('sc','ERROR:',errmsg)
            G_ERR=999
            exit FUN5
         endif
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 0  ! do not set "ans" to filename
         endblock DELETE_IT
!===================================================================================================================================
      case(3) ! command::load
      call mat_buf2str(mline,G_BUF,GG_LINELEN)

      lunit = 2
      call mat_files(LUNIT,G_BUF) ! open the unit
      call mat_buf2str(mline,G_BUF,GG_LINELEN)

      do
         space_left = G_VAR_DATALOC(G_TOP_OF_SAVED) - location
         IF(.not.G_FILE_OPEN_ERROR)then
            call mat_savlod(lunit, &
                & id, &
                & G_VAR_ROWS(G_ARGUMENT_POINTER), &
                & G_VAR_COLS(G_ARGUMENT_POINTER), &
                & img, &
                & space_left, &
                & GM_REALS(location), &
                & GM_IMAGS(location))
         endif

         mn = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)

         if (mn .ne. 0)then
            !if (img .eq. 0) call mat_rset(mn,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
            if (img .eq. 0) gm_imags(location:location+mn-1)=0.0d0 ! set imaginary component to zero

            !do i = 1, GG_MAX_NAME_LENGTH
            !   do j=1,G_CHARSET_SIZE
            !      if(id(i).eq.blank)then
            !         id(i) = blank
            !         exit
            !      elseif (id(i).ne.J)then
            !         cycle
            !      else
            !         id(i) = j-1  ! ????
            !         exit
            !      endif
            !   enddo
            !enddo

            G_SYM = semi
            G_RHS = 0
            call MAT_STACK_PUT(ID)
            G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
         else
            exit
         endif

      enddo

      call mat_files(-lunit,G_BUF) ! close unit

      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(4) ! command::print
      call mat_files(7,G_BUF)

      location = G_LINECOUNT(2)                       ! hold
      G_LINECOUNT(2) = 999999                         ! turn off paging of output
      if (G_RHS .gt. 1) call mat_print(G_SYN,top2)

      G_LINECOUNT(2) = location                       ! restore

      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(5) ! command::diary
      call mat_files(8,G_BUF)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(6,7) !     COMMAND::DISPLAY
                !     COMMAND::BASE
60    continue
      if (G_FIN.eq.7)goto 65
      if (G_RHS .ge. 2)then
         if (G_RHS .ne. 2) call mat_err(39)           ! Incorrect number of arguments
         if (GM_REALS(location) .lt. 1.0d0)then       ! test if base is 0
            call mat_err(36)                          ! Argument out of range
            exit FUN5
         endif
         b = GM_REALS(location)
         if(b.gt.1)then
            goto 65
         endif
      else
         b=10
      endif
      mn = m*n
      text = .true.
      do i = 1, mn
        ls = location+i-1
        ch = int(GM_REALS(LS))
        text = text .and. (ch.ge.0) .and. (ch.lt.G_CHARSET_SIZE)
        text = text .and. (dble(ch).eq.GM_REALS(ls) )
      enddo
      if(b.le.1)text=.false. ! for forcing non-text display when values are in range of text

      do i = 1, m
         do j = 1, n
           ls = location+i-1+(j-1)*m
           if (GM_REALS(ls) .eq. 0.0d0) ch = blank
           if (GM_REALS(ls) .gt. 0.0d0) ch = plus
           if (GM_REALS(ls) .lt. 0.0d0) ch = minus
           if (text) ch = int(GM_REALS(ls))
           G_BUF(j) = ch
         enddo
         call mat_buf2str(mline,G_BUF,n)
         call journal(mline)
      enddo
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      exit FUN5
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
!     command::base
   65 CONTINUE
      if (G_RHS .ne. 2) then
         call mat_err(39)                         ! Incorrect number of arguments
         exit FUN5
      endif
      if (GM_REALS(location) .le. 1.0d0) then     ! test if base is <= 0
         call mat_err(36)                         ! Argument out of range
         exit FUN5
      endif
      b = GM_REALS(location)
      l2 = location
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
      G_RHS = 1
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      m = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      eps = GM_REALS(GM_BIGMEM-4)
      do i = 1, m
         ls = l2+(i-1)*n
         ll = location+i-1
         call mat_base(GM_REALS(ll),b,eps,GM_REALS(ls),n)
      enddo
      !call mat_rset(m*n,0.0d0,GM_IMAGS(l2),1) ! set imaginary values to zero
      gm_imags(l2:l2+m*n-1)=0.0d0 ! set imaginary component to zero
      call mat_wcopy(m*n,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = n
      G_VAR_COLS(G_ARGUMENT_POINTER) = m
      call mat_stack1(quote)
      if (G_FIN .eq. 6) goto 60
!===================================================================================================================================
      case(8)
!     command::lines
      G_LINECOUNT(2) = int(GM_REALS(location))
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      !!! BROKEN BY GOING TO ASCII. ELIMINATE OR CORRECT
      case(9) !     COMMAND::CHAR                   ! does currently not do anything
      K = IABS(int(GM_REALS(location)))
      IF (M*N.NE.1 .OR. K.GT.G_CHARSET_SIZE-1) then
         call mat_err(36) ! Argument out of range
         exit FUN5
      endif
      CH = K
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(10) !     COMMAND::PLOT
      IF (G_RHS .GE. 2) goto 82
      N = M*N
      DO I = 1, N
         LL = location+I-1
         GM_IMAGS(LL) = dble(I)
      enddo
      call mat_plot(STDOUT,GM_IMAGS(location),GM_REALS(location),N,TDUM,0)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      exit FUN5
!. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

   82 continue
      IF (G_RHS .EQ. 2) K = 0
      IF (G_RHS .EQ. 3) K = M*N
      IF (G_RHS .GT. 3) K = G_RHS - 2
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - (G_RHS - 1)
      N = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER+1)*G_VAR_COLS(G_ARGUMENT_POINTER+1) .NE. N) then
         call mat_err(5)
         exit FUN5
      endif
      LX = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      LY = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      IF (G_RHS .GT. 3) location = G_VAR_DATALOC(G_ARGUMENT_POINTER+2)
      call mat_plot(STDOUT,GM_REALS(LX),GM_REALS(LY),N,GM_REALS(location),K)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(11) ! COMMAND::RAT
      if (G_RHS .ne. 2) then
         mn = m*n
         l2 = location
         if (G_lhs .eq. 2) l2 = location + mn
         lw = l2 + mn

         if(too_much_memory( lw + lrat - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

         if (G_lhs .eq. 2) G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
         G_VAR_DATALOC(G_ARGUMENT_POINTER) = l2
         G_VAR_ROWS(G_ARGUMENT_POINTER) = m
         G_VAR_COLS(G_ARGUMENT_POINTER) = n
         !call mat_rset(G_lhs*mn,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
         gm_imags(location:location+G_lhs*m*n-1)=0.0d0 ! set imaginary component to zero
         do i = 1, mn
            call mat_rat(GM_REALS(location),lrat,mrat,s,t,GM_REALS(lw))
            GM_REALS(location) = s
            GM_REALS(l2) = t
            if (G_lhs .eq. 1) GM_REALS(location) = mat_flop(s/t)
            location = location + 1
            l2 = l2 + 1
         enddo
      else
         mrat = int(GM_REALS(location))
         lrat = int(GM_REALS(location-1))
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
         G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      endif
!===================================================================================================================================
      case(12) !     COMMAND::DEBUG
      G_DEBUG_LEVEL = int(GM_REALS(location))
      call journal('sc',' DEBUG ',G_DEBUG_LEVEL)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      case(13) !     COMMAND::SHOW
      call printit()
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!===================================================================================================================================
      end select FUN5
!===================================================================================================================================
end subroutine mat_matfn5
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stack_get(id)

! ident_29="@(#) M_matrix mat_stack_get(3fp) get variables from storage"

integer,intent(in)  :: id(GG_MAX_NAME_LENGTH)
integer             :: i
integer             :: j
integer             :: k
integer             :: location
integer             :: l2
integer             :: l3
integer             :: li
integer             :: lj
integer             :: current_location
integer             :: ll
integer             :: ls
integer             :: m
integer             :: mk
integer             :: mn
integer             :: mnk
integer             :: n

   call mat_copyid(G_VAR_IDS(1,G_TOP_OF_SAVED-1), ID)    ! copy ID to next blank entry in G_VAR_IDS in case it is not there(?)

   do k=GG_MAX_NUMBER_OF_NAMES,1,-1                      ! start at bottom and search up through names till find the name
      if (mat_eqid(G_VAR_IDS(1:,k), id))exit             ! if found name exit loop
   enddo
   ! if (?)
   ! or if matched the name inserted above did not find it.
   if ( (k .ge. GG_MAX_NUMBER_OF_NAMES-1 .and. G_RHS .gt. 0) .or. (k .eq. G_TOP_OF_SAVED-1) ) then
      G_FIN = 0
      return
   endif

   current_location = G_VAR_DATALOC(K)                               ! found it, so this is the location where the data begins
   IF (G_RHS .EQ. 1) then                                             ! VECT(ARG)
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .EQ. 0) goto 99
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      MN = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      MNK = G_VAR_ROWS(K)*G_VAR_COLS(K)                            ! number of values in this variable
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .LT. 0) MN = MNK
      DO I = 1, MN
        LL = location+I-1
        LS = current_location+I-1
        IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .GT. 0) LS = current_location + int(GM_REALS(LL)) - 1
        IF (LS .LT. current_location .OR. LS .GE. current_location+MNK) then
           call mat_err(21)          ! Subscript out of range
           return
        endif
        GM_REALS(LL) = GM_REALS(LS)
        GM_IMAGS(LL) = GM_IMAGS(LS)
      enddo
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      IF (G_VAR_ROWS(K) .GT. 1) G_VAR_ROWS(G_ARGUMENT_POINTER) = MN
      IF (G_VAR_ROWS(K) .EQ. 1) G_VAR_COLS(G_ARGUMENT_POINTER) = MN
      goto 99
   elseif (G_RHS .EQ. 2) then                                              ! MATRIX(ARG,ARG)
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER+1) .EQ. 0) G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .EQ. 0) goto 99
      L2 = G_VAR_DATALOC(G_ARGUMENT_POINTER+1)
      M = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .LT. 0) M = G_VAR_ROWS(K)
      N = G_VAR_ROWS(G_ARGUMENT_POINTER+1)*G_VAR_COLS(G_ARGUMENT_POINTER+1)
      IF (G_VAR_ROWS(G_ARGUMENT_POINTER+1) .LT. 0) N = G_VAR_COLS(K)
      L3 = L2 + N
      MK = G_VAR_ROWS(K)
      MNK = G_VAR_ROWS(K)*G_VAR_COLS(K)
      DO J = 1, N
         DO I = 1, M
           LI = location+I-1
           IF (G_VAR_ROWS(G_ARGUMENT_POINTER) .GT. 0) LI = location + int(GM_REALS(LI)) - 1
           LJ = L2+J-1
           IF (G_VAR_ROWS(G_ARGUMENT_POINTER+1) .GT. 0) LJ = L2 + int(GM_REALS(LJ)) - 1
           LS = current_location + LI-location + (LJ-L2)*MK
           IF (LS.LT.current_location .OR. LS.GE.current_location+MNK) then
              call mat_err(21)
              return
           endif
           LL = L3 + I-1 + (J-1)*M
           GM_REALS(LL) = GM_REALS(LS)
           GM_IMAGS(LL) = GM_IMAGS(LS)
         enddo
      enddo
      MN = M*N
      call mat_wcopy(MN,GM_REALS(L3),GM_IMAGS(L3),1,GM_REALS(location),GM_IMAGS(location),1)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = M
      G_VAR_COLS(G_ARGUMENT_POINTER) = N
      goto 99
   elseif (G_RHS .GT. 2) then
      call mat_err(21)                                                     ! Subscript out of range
      return
   else                                                                    ! SCALAR
      location = 1
      IF (G_ARGUMENT_POINTER .GT. 0) &
        & location = G_VAR_DATALOC(G_ARGUMENT_POINTER) + &
        & G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      IF (G_ARGUMENT_POINTER+1 .GE. G_TOP_OF_SAVED) then
         call mat_err(18)  ! Too many names
         return
      endif

      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1

      !  LOAD VARIABLE TO TOP OF STACK
      G_VAR_DATALOC(G_ARGUMENT_POINTER) = location
      G_VAR_ROWS(G_ARGUMENT_POINTER) = G_VAR_ROWS(K)
      G_VAR_COLS(G_ARGUMENT_POINTER) = G_VAR_COLS(K)
      MN = G_VAR_ROWS(K)*G_VAR_COLS(K)

      if(too_much_memory( location+MN - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

      !  IF RAND, MATFN6 GENERATES RANDOM NUMBER
      IF (K .EQ. GG_MAX_NUMBER_OF_NAMES) then
         !write(*,*)'GOT HERE A:MAT_STACK_GET:'
         G_FIN = 7
         G_FUN = 6
         return
      endif
      call mat_wcopy(MN,GM_REALS(current_location),   &
                        & GM_IMAGS(current_location), &
                        & 1,                               &
                        & GM_REALS(location),         &
                        & GM_IMAGS(location),         &
                        & 1)
   endif

99 continue
   G_FIN = -1
   G_FUN = 0

END SUBROUTINE MAT_STACK_GET
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_stack2(op)

! ident_30="@(#) M_matrix ml_stackp(3fp) binary and ternary operations"

integer           :: op
doubleprecision   :: sr,si,e1,st,e2

integer           ::  i
integer           ::  j
integer           ::  k
integer           ::  k1
integer           ::  k2
integer           ::  kexp
integer           ::  location
integer           ::  l1
integer           ::  l2
integer           ::  l3
integer           ::  ll
integer           ::  ls
integer           ::  m
integer           ::  m2
integer           ::  mn
integer           ::  n
integer           ::  n2
integer           ::  nexp
integer           :: op_select
logical           :: scalar

   l2 = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m2 = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n2 = G_VAR_COLS(G_ARGUMENT_POINTER)
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)
   G_FUN = 0

   if(op.eq.DSTAR)then
      op_select=-op
   else
      op_select=op
   endif
   DO_OP: select case(op_select)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (PLUS) ! ADDITION
      if (m .lt. 0) then
         if (m2 .ne. n2) then
            call mat_err(8)
            exit DO_OP
         endif
         m = m2
         n = n2
         G_VAR_ROWS(G_ARGUMENT_POINTER) = m
         G_VAR_COLS(G_ARGUMENT_POINTER) = n
         sr = GM_REALS(location)
         si = GM_IMAGS(location)
         call mat_wcopy(m*n,GM_REALS(location+1),GM_IMAGS(location+1),1,GM_REALS(location),GM_IMAGS(location),1)
         call finish()
         exit DO_OP
      endif
      if (m2 .lt. 0)then
         if (m .ne. n) then
            call mat_err(8)
            exit DO_OP
         endif
         sr = GM_REALS(l2)
         si = GM_IMAGS(l2)
         call finish()
         exit DO_OP
      endif
      if (m .ne. m2) then
         call mat_err(8)
         exit DO_OP
      endif
      if (n .ne. n2) then
         call mat_err(8)
         exit DO_OP
      endif
      call matX_waxpy(m*n,1.0d0,0.0d0,GM_REALS(l2),GM_IMAGS(l2),1,GM_REALS(location),GM_IMAGS(location),1)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (MINUS) ! SUBTRACTION
      if (m .lt. 0) then
         if (m2 .ne. n2)then
            call mat_err(9)
            exit do_op
         endif
         m = m2
         n = n2
         G_VAR_ROWS(G_ARGUMENT_POINTER) = m
         G_VAR_COLS(G_ARGUMENT_POINTER) = n
         sr = GM_REALS(location)
         si = GM_IMAGS(location)
         call mat_wcopy(m*n,GM_REALS(location+1),GM_IMAGS(location+1),1,GM_REALS(location),GM_IMAGS(location),1)
         call mat_wrscal(m*n,-1.0d0,GM_REALS(location),GM_IMAGS(location),1)
         call finish()
         exit DO_OP
      endif
      if (m2 .lt. 0) then
         ! add or subtract scalar
         if (m .ne. n) then
            call mat_err(9)
            exit DO_OP
         endif
         sr = -GM_REALS(l2)
         si = -GM_IMAGS(l2)
         call finish()
         exit DO_OP
      endif
      if (m .ne. m2)then
         call mat_err(9)
         exit DO_OP
      endif
      if (n .ne. n2) then
         call mat_err(9)
         exit DO_OP
      endif
      call matX_waxpy(M*N,-1.0D0,0.0D0,GM_REALS(L2),GM_IMAGS(L2),1,GM_REALS(location),GM_IMAGS(location),1)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (STAR) ! MULTIPLICATION
      if (m2*m2*n2 .eq. 1) goto 10
      if (m*n .eq. 1) goto 11
      if (m2*n2 .eq. 1) goto 10
      if (n .ne. m2) then
         call mat_err(10) ! 'Incompatible for MULTIPLICATION'
         exit do_op
      endif
      mn = m*n2
      ll = location + mn

      if(too_much_memory( ll+m*n+m2*n2 - G_VAR_DATALOC(G_TOP_OF_SAVED)) ) exit do_op

      call mat_wcopy(m*n+m2*n2,GM_REALS(location),GM_IMAGS(location),-1,GM_REALS(ll),GM_IMAGS(ll),-1)
      do j = 1, n2
         do i = 1, m
            k1 = location + mn + (i-1)
            k2 = l2 + mn + (j-1)*m2
            k = location + (i-1) + (j-1)*m
            GM_REALS(k) = mat_wdotur(N,GM_REALS(k1),GM_IMAGS(k1),m,GM_REALS(k2),GM_IMAGS(k2),1)
            GM_IMAGS(k) = mat_wdotui(N,GM_REALS(k1),GM_IMAGS(k1),m,GM_REALS(k2),GM_IMAGS(k2),1)
         enddo
      enddo
      G_VAR_COLS(G_ARGUMENT_POINTER) = n2
      exit do_op
!-----------------------------------------------------------------------------------------------------------------------------------
   ! multiplication by scalar
   10 continue
      sr = GM_REALS(l2)
      si = GM_IMAGS(l2)
      l1 = location
      goto 13
   11 continue
      sr = GM_REALS(location)
      si = GM_IMAGS(location)
      l1 = location+1
      G_VAR_ROWS(G_ARGUMENT_POINTER) = m2
      G_VAR_COLS(G_ARGUMENT_POINTER) = n2
   13 continue
      mn = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
      call mat_wscal(mn,sr,si,GM_REALS(l1),GM_IMAGS(l1),1)
      if (l1.ne.location) call mat_wcopy(mn,GM_REALS(l1),GM_IMAGS(l1),1,GM_REALS(location),GM_IMAGS(location),1)
!-----------------------------------------------------------------------------------------------------------------------------------
   case (-DSTAR,CARET) ! POWER
      IF (M2*N2 .NE. 1) then
         call mat_err(30)
         exit do_op
      endif
      IF (M .NE. N) then
         call mat_err(20)
         exit do_op
      endif
      NEXP = int(GM_REALS(L2))

      IF ( (GM_REALS(L2) .NE. dble(NEXP)) .or. (GM_IMAGS(L2) .NE. 0.0D0) .or. (NEXP .LT. 2) )then
         ! NONINTEGER OR NONPOSITIVE POWER, USE EIGENVECTORS
         G_FUN = 2
         G_FIN = 0
         exit DO_OP
      endif

      MN = M*N

      if(too_much_memory( L2+MN+N - G_VAR_DATALOC(G_TOP_OF_SAVED)) ) exit do_op

      call mat_wcopy(MN,GM_REALS(location),GM_IMAGS(location),1,GM_REALS(L2),GM_IMAGS(L2),1)
      L3 = L2+MN
      DO KEXP = 2, NEXP
         DO J = 1, N
            LS = location+(J-1)*N
            call mat_wcopy(N,GM_REALS(LS),GM_IMAGS(LS),1,GM_REALS(L3),GM_IMAGS(L3),1)
            DO I = 1, N
               LS = L2+I-1
               LL = location+I-1+(J-1)*N
               GM_REALS(LL)=mat_wdotur(N,GM_REALS(LS),GM_IMAGS(LS),N,GM_REALS(L3),GM_IMAGS(L3),1)
               GM_IMAGS(LL)=mat_wdotui(N,GM_REALS(LS),GM_IMAGS(LS),N,GM_REALS(L3),GM_IMAGS(L3),1)
            enddo
         enddo
      enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   case (SLASH) ! right division
      if (m2*n2 .ne. 1) then
         if (m2 .eq. n2) G_FUN = 1
         if (m2 .ne. n2) G_FUN = 4
         G_FIN = -1
         G_RHS = 2
         exit DO_OP
      endif
      sr = GM_REALS(l2)
      si = GM_IMAGS(l2)
      mn = m*n
      do i = 1, mn
         ll = location+i-1
         call mat_wdiv(GM_REALS(ll),GM_IMAGS(ll),sr,si,GM_REALS(ll),GM_IMAGS(ll))
         if (G_ERR .gt. 0) exit
      enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   case (BSLASH) ! LEFT DIVISION
      if (m*n .ne. 1) then
         if (m .eq. n) G_FUN = 1
         if (m .ne. n) G_FUN = 4
         G_FIN = -2
         G_RHS = 2
         exit DO_OP
      endif
      SR = GM_REALS(location)
      SI = GM_IMAGS(location)
      G_VAR_ROWS(G_ARGUMENT_POINTER) = M2
      G_VAR_COLS(G_ARGUMENT_POINTER) = N2
      MN = M2*N2
      DO I = 1, MN
         LL = location+I-1
         call mat_wdiv(GM_REALS(LL+1),GM_IMAGS(LL+1),SR,SI,GM_REALS(LL),GM_IMAGS(LL))
         IF (G_ERR .GT. 0) exit
      enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   case (COLON) ! COLON
      E2 = GM_REALS(L2)
      ST = 1.0D0
      N = 0
      IF (G_RHS .GE. 3) then
         ST = GM_REALS(location)
         G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
         location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
         IF (ST .EQ. 0.0D0) goto 63
      endif

      E1 = GM_REALS(location)
      ! CHECK FOR CLAUSE
      IF (G_RSTK(G_PT) .EQ. 3) then
   !     FOR CLAUSE
         GM_REALS(location) = E1
         GM_REALS(location+1) = ST
         GM_REALS(location+2) = E2
         G_VAR_ROWS(G_ARGUMENT_POINTER) = -3
         G_VAR_COLS(G_ARGUMENT_POINTER) = -1
         exit DO_OP
      endif

      if(too_much_memory( location + MAX(3,int((E2-E1)/ST)) - G_VAR_DATALOC(G_TOP_OF_SAVED) ) ) exit do_op

      do
         IF (ST .GT. 0.0D0 .AND. GM_REALS(location) .GT. E2) exit
         IF (ST .LT. 0.0D0 .AND. GM_REALS(location) .LT. E2) exit
         N = N+1
         location = location+1
         GM_REALS(location) = E1 + dble(N)*ST
         GM_IMAGS(location) = 0.0D0
      enddo

   63 continue
      G_VAR_COLS(G_ARGUMENT_POINTER) = N
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      IF (N .EQ. 0) G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
!-----------------------------------------------------------------------------------------------------------------------------------
   case (1000:2000-1) ! element-wise operations
      op = op -1000
      scalar=.false.
      if (op.eq.CARET .and. m2*n2.eq.1)then
         scalar=.true.
      elseif (m.ne.m2 .or. n.ne.n2) then
         select case(op)
         case(STAR);   call mat_err(10) ! 'Incompatible for MULTIPLICATION'
         case(SLASH);  call mat_err(11) ! 'Incompatible for RIGHT DIVISION'
         case(BSLASH); call mat_err(12) ! 'Incompatible for LEFT DIVISION'
         case(CARET);  call mat_err(41) ! 'Incompatible for POWER'
         case default
         end select
         exit do_op
      endif
      mn = m*n
      do i = 1, mn
         j = location+i-1
         k = l2+i-1
         select case(op)
         case(STAR)
                    !  in1  in2 out
         call mat_wmul(GM_REALS(J),GM_IMAGS(J), GM_REALS(K),GM_IMAGS(K), GM_REALS(J),GM_IMAGS(J))
         case(SLASH)
         call mat_wdiv(GM_REALS(J),GM_IMAGS(J), GM_REALS(K),GM_IMAGS(K), GM_REALS(J),GM_IMAGS(J))
         case(BSLASH)
         call mat_wdiv(GM_REALS(K),GM_IMAGS(K), GM_REALS(J),GM_IMAGS(J), GM_REALS(J),GM_IMAGS(J))
         case(CARET)
         if(scalar)then
            !    mat_wpow(in_real,    in_imag,    out_real,   out_imag,   power_real, power_imag)
            call mat_wpow(GM_REALS(J),GM_IMAGS(J),GM_REALS(J),GM_IMAGS(J),GM_REALS(l2),GM_IMAGS(l2))
         else
            !    mat_wpow(in_real,    in_imag,    out_real,   out_imag,   power_real, power_imag)
            call mat_wpow(GM_REALS(J),GM_IMAGS(J),GM_REALS(J),GM_IMAGS(J),GM_REALS(K),GM_IMAGS(K))
         endif
         end select
         IF (G_ERR .GT. 0) exit
      enddo
!-----------------------------------------------------------------------------------------------------------------------------------
   case (2000:) ! kronecker
      G_FIN = op - 2000 - star + 11
      G_FUN = 6
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
      G_RHS = 2
!-----------------------------------------------------------------------------------------------------------------------------------
   case default
      write(*,*)'<ERROR> unknown operator ',op
      stop
   end select DO_OP
!-----------------------------------------------------------------------------------------------------------------------------------
contains
subroutine finish()
   do i = 1, n
      ll = location + (i-1)*(n+1)
      GM_REALS(ll) = mat_flop(GM_REALS(LL)+sr)
      GM_IMAGS(ll) = mat_flop(GM_IMAGS(LL)+si)
   enddo
end subroutine finish
end subroutine mat_stack2
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_getlin() ! get a new input line

character(len=GG_LINELEN) :: mline
character(len=GG_LINELEN) :: shift_mline

integer                   :: istat
integer,parameter         :: retu(GG_MAX_NAME_LENGTH) =  [iachar(['q','u','i','t',' ',' ',' ']),GG_PAD(8:)]
integer                   :: i, j, k
integer                   :: l
integer                   :: n
integer                   :: ios
!.......................................................................
   l = G_LINE_POINTER(1)
!.......................................................................
   11 continue

      G_BUF(:GG_LINELEN)= blank      ! blank out buffer before reading into it
      n = GG_LINELEN+1

      ! get line of input and place it in line buffer
      if(size(G_PSEUDO_FILE).eq.1.and.G_LUN_READING_FROM.eq.STDIN)then
         mline=get_pseudo_line()
         G_LUN_READING_FROM = G_INPUT_LUN
      elseif(size(G_PSEUDO_FILE).ne.0.and.G_LUN_READING_FROM.eq.STDIN)then
         mline=get_pseudo_line()
      else
         mline(:)=' '
         read(G_LUN_READING_FROM,'(a)',iostat=ios) mline   ! read input line from file
         if( (ios.ne.0) ) then
             if(is_iostat_end(ios))then                    ! hit end of file
                call mat_copyid(G_LIN(l),retu)             ! store QUIT onto G_LIN(L) to simulate RETURN command
                l = l + 4
                goto 45
             else
                goto 15
             endif
         endif
      endif
      if(G_ECHO)write(*,'(*(g0))')'',trim(mline)
      shift_mline=adjustl(mline)
      if(shift_mline(1:2).eq.'??')then                     ! edit command line history
         mline='. '//mline(3:)
      endif

      call redo(mline,'.')         ! pass line to REDO(3f). This is a no-op except for storing the line into the input history
                                   ! (unless the input line is the "r" command)
      if(G_LUN_READING_FROM.eq.stdin)then
         call journal('t',mline)   ! reading from standard input, so copy to trail file
      else
         call journal('c',mline)   ! reading from an exec() command, so write as a comment
      endif

      ! look for other lines to immediately process and then ignore
      shift_mline=adjustl(mline)
      if(shift_mline(1:1).eq.'#')then
         mline=''                                                      ! ignore lines with a # as first non-blank character
      elseif(shift_mline(1:1).eq.'!')then
         if(shift_mline.eq.'!')then
            call get_environment_variable('SHELL',shift_mline)         ! get command to execute
            call execute_command_line(shift_mline,cmdstat=istat)       ! call system shell
         else
            call execute_command_line(shift_mline(2:),cmdstat=istat)   ! call system shell
         endif
         mline=''
      endif

      call mat_str2buf(mline,G_BUF,GG_LINELEN)    ! convert input line to "Hollerith" buffer
!.......................................................................
   15 continue
      n = n-1
      if(n.lt.1)then
         n=1
      elseif (G_BUF(n) .eq. blank)then
         goto 15 ! trim off trailing spaces
      endif

      if (mod(G_LINECOUNT(4),2) .eq. 1) then
              call mat_buf2str(mline,G_BUF,n) ! convert ADE buffer to character
              call journal('s',mline) ! just to standard output
      endif
!.......................................................................
      do j = 1, n
         do k = 1, G_CHARSET_SIZE  ! make sure this letter is in set of LALA characters and get its LALA number
           if (G_BUF(j).eq.k ) goto 30
         enddo
         call journal('sc','Unknown character at column ',j) ! this is not a known character
         k = GG_EOL+1
         if (k .gt. GG_EOL) then
            l = G_LINE_POINTER(1)
            goto 11   ! Unknown character , K not changed. get new line
         endif
         if (k .eq. GG_EOL) exit
         if (k .eq. -1) l = l-1
         if (k .le. 0) cycle
!
   30    continue
         if (k.eq.slash .and. G_BUF(j+1).eq.G_BUF(j)) exit     ! if // rest is comment
         if (k.eq.dot .and. G_BUF(j+1).eq.G_BUF(j)) goto 11    ! if .. line continuation
         if (k.eq.bslash .and. n.eq.1) then                    ! if \ in column 1
            n = G_LINE_POINTER(6) - G_LINE_POINTER(1)
            do i = 1, n
               k = G_LIN(l+i-1)
               G_BUF(i) = k
            enddo
            goto 15
         endif
         G_LIN(l) = k
         if (l.lt.1024) l = l+1
         if (l.eq.1024) call journal('sc','input buffer limit exceeded=',l)
      enddo
!.......................................................................
   45 CONTINUE      ! line is ready, reset line pointers
      G_LIN(l) = GG_EOL;G_LIN(l+1:)=blank
      G_LINE_POINTER(6) = l
      G_LINE_POINTER(4) = G_LINE_POINTER(1)
      G_LINE_POINTER(3) = 0
      G_LINE_POINTER(2) = 0
      G_LINECOUNT(1) = 0
      call mat_getch() ! load first character onto G_CHRA

contains

function get_pseudo_line() result(line)
character(len=GG_LINELEN) :: line
! reallocating all the time is inefficient
   line=G_PSEUDO_FILE(1)
   if(size(G_PSEUDO_FILE).gt.1)then
      G_PSEUDO_FILE=G_PSEUDO_FILE(2:)
   else
      G_PSEUDO_FILE=[character(len=GG_LINELEN) :: ]
   endif
end function get_pseudo_line

end subroutine mat_getlin
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_clause()
doubleprecision    :: e1,e2
integer            :: op
integer            :: r
integer,parameter  :: for(GG_MAX_NAME_LENGTH)   =  [iachar(['f','o','r',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: while(GG_MAX_NAME_LENGTH) =  [iachar(['w','h','i','l','e',' ',' ']),GG_PAD(8:)]
integer,parameter  :: iff(GG_MAX_NAME_LENGTH)   =  [iachar(['i','f',' ',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: else(GG_MAX_NAME_LENGTH)  =  [iachar(['e','l','s','e',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: ennd(GG_MAX_NAME_LENGTH)  =  [iachar(['e','n','d',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: do(GG_MAX_NAME_LENGTH)    =  [iachar(['d','o',' ',' ',' ',' ',' ']),GG_PAD(8:)]
integer,parameter  :: thenn(GG_MAX_NAME_LENGTH) =  [iachar(['t','h','e','n',' ',' ',' ']),GG_PAD(8:)]

integer            :: j
integer            :: kount
integer            :: location
integer            :: l2
integer            :: lj
integer            :: m
integer            :: n

   r = -G_FIN-10
   G_FIN = 0
   if (r.lt.1 .or. r.gt.6) goto 01
   goto (02,30,30,80,99,90),R
01 continue
   r = G_RSTK(G_PT)
   goto (99,99,05,40,45,99,99,99,99,99,99,99,15,55,99,99,99),R
   call journal('*mat_clause* -- internal error')
   goto 99
!.......................................................................
!     FOR
02 continue
   call mat_getsym()
   if (G_SYM .ne. isname) then
      call mat_err(34) ! improper for clause
      return
   endif
   G_PT = G_PT+2
   call mat_copyid(G_IDS(1,G_PT),G_SYN)
   call mat_getsym()
   if (G_SYM .ne. equal) then
      call mat_err(34) ! improper for clause
      return
   endif
   call mat_getsym()
   G_RSTK(G_PT) = 3
   ! *call* expr
   return
05 continue
   G_PSTK(G_PT-1) = 0
   G_PSTK(G_PT) = G_LINE_POINTER(4) - 1
   if (mat_eqid(G_SYN,DO)) G_SYM = semi
   if (G_SYM .eq. comma) G_SYM = semi
   if (G_SYM .ne. semi) then
      call mat_err(34) ! improper for clause
      return
   endif
10 continue
   j = G_PSTK(G_PT-1)
   G_LINE_POINTER(4) = G_PSTK(G_PT)
   G_SYM = semi
   G_CHRA = blank
   j = j+1
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   m = G_VAR_ROWS(G_ARGUMENT_POINTER)
   n = G_VAR_COLS(G_ARGUMENT_POINTER)
   lj = location+(j-1)*m
   l2 = location + m*n
   if (m .ne. -3) goto 12
   lj = location+3
   l2 = lj
   GM_REALS(lj) = GM_REALS(location) + dble(j-1)*GM_REALS(location+1)
   GM_IMAGS(lj) = 0.0d0
   if (GM_REALS(location+1).gt.0.0d0 .and. GM_REALS(lj).gt.GM_REALS(location+2)) goto 20
   if (GM_REALS(location+1).lt.0.0d0 .and. GM_REALS(lj).lt.GM_REALS(location+2)) goto 20
   m = 1
   n = j
12 continue
   if (j .gt. n) goto 20
   if (G_ARGUMENT_POINTER+1 .ge. G_TOP_OF_SAVED) then
      call mat_err(18) ! too many names
      return
   endif
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
   G_VAR_DATALOC(G_ARGUMENT_POINTER) = l2
   G_VAR_ROWS(G_ARGUMENT_POINTER) = m
   G_VAR_COLS(G_ARGUMENT_POINTER) = 1

   if(too_much_memory( l2+m - G_VAR_DATALOC(G_TOP_OF_SAVED) ) )return

   call mat_wcopy(m,GM_REALS(lj),GM_IMAGS(lj),1,GM_REALS(l2),GM_IMAGS(l2),1)
   G_RHS = 0
   call mat_stack_put(G_IDS(1,G_PT))
   if (G_ERR .gt. 0) return
   G_PSTK(G_PT-1) = j
   G_PSTK(G_PT) = G_LINE_POINTER(4)
   G_RSTK(G_PT) = 13
!     *call* PARSE
   return
15 continue
   goto 10
20 continue
   G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
   G_VAR_COLS(G_ARGUMENT_POINTER) = 0
   G_RHS = 0
   call mat_stack_put(G_IDS(1,G_PT))
   if (G_ERR .gt. 0) return
   G_PT = G_PT-2
   goto 80
!.......................................................................
!
!     WHILE OR IF
!
30 continue
   G_PT = G_PT+1
   call mat_copyid(G_IDS(1,G_PT),G_SYN)
   G_PSTK(G_PT) = G_LINE_POINTER(4)-1
35 continue
   G_LINE_POINTER(4) = G_PSTK(G_PT)
   G_CHRA = blank
   call mat_getsym()
   G_RSTK(G_PT) = 4
!     *call* EXPR
   return
40 continue
   if (G_SYM.ne.equal .and. (G_SYM.NE.LESS.and.G_SYM.ne.lbracket) .and. (G_SYM.NE.GREAT.and.G_SYM.ne.rbracket))then
      call mat_err(35)    ! improper WHILE or IF clause
      return
   endif
   op = G_SYM
   call mat_getsym()
   if (G_SYM.EQ.equal .or. (G_SYM.EQ.great)) op = op + G_SYM
   if (op .gt. great) call mat_getsym()
   G_PSTK(G_PT) = 256*G_PSTK(G_PT) + op
   G_RSTK(G_PT) = 5
!     *call* EXPR
   return
45 continue
   op = mod(G_PSTK(G_PT),256)
   G_PSTK(G_PT) = G_PSTK(G_PT)/256
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER-1)
   e1 = GM_REALS(location)
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   e2 = GM_REALS(location)
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 2
   if (mat_eqid(G_SYN,do) .or. mat_eqid(G_SYN,thenn)) G_SYM = semi
   if (G_SYM .EQ. COMMA) G_SYM = SEMI
   if (G_SYM .NE. SEMI) then
      call mat_err(35) ! improper WHILE or IF clause
      return
   endif
   if (op.eq.equal .and. e1.eq.e2) goto 50
   if ((op.eq.less) .and. e1.lt.e2) goto 50
   if (op.eq.great         .and. e1.gt.e2) goto 50
   if (op.eq.(less+equal)  .and. e1.le.e2) goto 50
   if (op.eq.(great+equal) .and. e1.ge.e2) goto 50
   if (op.eq.(less+great)  .and. e1.ne.e2) goto 50
   G_PT = G_PT-1
   goto 80
50 continue
   G_RSTK(G_PT) = 14
!     *call* PARSE
   return
55 continue
   IF (mat_eqid(G_IDS(1:,G_PT),while)) goto 35
   G_PT = G_PT-1
   if (mat_eqid(G_SYN,else)) goto 80
   return
!.......................................................................
!     SEARCH FOR MATCHING END OR ELSE
80 continue
   kount = 0
   call mat_getsym()
82 continue
   if (G_SYM .eq. GG_EOL) return
   if (G_SYM .ne. isname) goto 83
   if (mat_eqid(G_SYN,ennd) .and. kount.eq.0) return
   if (mat_eqid(G_SYN,else) .and. kount.eq.0) return
   if (mat_eqid(G_SYN,ennd) .or. mat_eqid(G_SYN,else))kount = kount-1
   if (mat_eqid(G_SYN,for) .or. mat_eqid(G_SYN,while).or.mat_eqid(G_SYN,iff)) kount = kount+1
83 continue
   call mat_getsym()
   goto 82
!.......................................................................
!     EXIT FROM LOOP
90 continue

   if (G_RSTK(G_PT) .eq. 14) G_PT = G_PT-1
   if (G_PT .le. G_PTZ) return

   if (G_RSTK(G_PT) .eq. 14) G_PT = G_PT-1
   if (G_PT-1 .le. G_PTZ) return

   if (G_RSTK(G_PT) .eq. 13) G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
   if (G_RSTK(G_PT) .eq. 13) G_PT = G_PT-2
   goto 80
!.......................................................................
!
99 continue
   call mat_err(22)    ! recursion difficulties
end subroutine mat_clause
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_expr()
integer           :: r
integer           :: sign
integer,parameter :: eye(GG_MAX_NAME_LENGTH) =  [iachar(['e','y','e',' ',' ',' ',' ']),GG_PAD(8:)]
integer           :: kount
integer           :: ls
integer           :: op

   r = G_RSTK(G_pt)
!===================================================================================================================================
!        1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 16 18 19 20
   goto (01,01,01,01,01,05,25,99,99,01,01,99,99,99,99,99,99,01,01,01),R
!  what about drop-though???
!===================================================================================================================================
01 continue
   if (G_SYM .eq. colon) call mat_copyid(G_SYN,eye)
   if (G_SYM .eq. colon) G_SYM = isname
   kount = 1
02 continue
   sign = plus
   if (G_SYM .eq. minus) sign = minus
   if (G_SYM.eq.plus .or. G_SYM.eq.minus) call mat_getsym()
   G_pt = G_pt+1
   if (G_pt .gt. G_PSIZE-1) then
      call mat_err(26) ! too complicated (stack overflow)
      return
   endif
   G_PSTK(G_pt) = sign + 256*kount
   G_RSTK(G_pt) = 6
   ! *call* term
   return
!===================================================================================================================================
05 continue
   sign = mod(G_PSTK(G_pt),256)
   kount = G_PSTK(G_pt)/256
   G_pt = G_pt-1
   if (sign .eq. minus) call mat_stack1(minus)
   if (G_err .gt. 0) return
10 continue
   if (G_SYM.eq.plus .or. G_SYM.eq.minus) goto 20
   goto 50
!===================================================================================================================================
20 continue
   if (G_RSTK(G_pt) .eq. 10) then
      ! blank is delimiter inside angle brackets
      ls = G_LINE_POINTER(3) - 2
      if (G_LIN(ls) .eq. blank) goto 50
   endif
   op = G_SYM
   call mat_getsym()
   G_PT = G_PT+1
   G_PSTK(G_PT) = op + 256*kount
   G_RSTK(G_PT) = 7
!     *call* term
   return
!===================================================================================================================================
25 continue
   op = mod(G_PSTK(G_pt),256)
   kount = G_PSTK(G_pt)/256
   G_PT = G_PT-1
   call mat_stack2(op)
   if (G_ERR .gt. 0) return
   goto 10
!===================================================================================================================================
50 continue
   if (G_SYM .ne. colon) goto 60
   call mat_getsym()
   kount = kount+1
   goto 02
!===================================================================================================================================
60 continue
   if (kount .gt. 3) then
      call mat_err(33)  ! too many colons
      return
   endif
   G_RHS = kount
   if (kount .gt. 1) call mat_stack2(colon)
   if (G_err .gt. 0) return
   return
!===================================================================================================================================
99 continue
   call mat_err(22)     ! recursion difficulties
   return
!===================================================================================================================================
end subroutine mat_expr
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_factor()
integer :: r
integer :: id(gg_max_name_length)
integer :: excnt
integer :: i, j, k
integer :: location
integer :: ln
integer :: ls
integer :: n

   r = G_RSTK(G_PT)
   !      1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
   goto (99,99,99,99,99,99,99,01,01,25,45,65,99,99,99,55,75,32,37),r
01 continue
   if (.not.(G_SYM.eq.isnum .or. G_SYM.eq.quote .or. (G_SYM.EQ.less.or.G_SYM.eq.lbracket))) then

      if (G_SYM .eq. great.or.G_SYM.eq.rbracket)then
         !  MACROS STRING
            call mat_getsym()
            if ((G_SYM .eq. less.or.G_SYM.eq.lbracket) .and. G_CHRA.EQ.GG_EOL) then
            call mat_err(28) ! Empty macro
            return
         endif
            G_PT = G_PT+1
            G_RSTK(G_PT) = 18
            ! *call* EXPR
            return
      endif

      excnt = 0
      if (G_SYM .eq. isname)then
         ! FUNCTION OR MATRIX ELEMENT
         call mat_copyid(id,G_SYN)
         call mat_getsym()
         if (G_SYM .eq. lparen .or. G_SYM.eq. lbrace) goto 42
         G_RHS = 0
         !write(*,gen1)'GOT HERE A:MAT_FACTOR:G_FUN:',G_FUN,':G_FIN:',G_FIN
         call mat_funs(ID)
         !write(*,gen1)'GOT HERE B:MAT_FACTOR:G_FUN:',G_FUN,':G_FIN:',G_FIN
         if (G_FIN .ne. 0) then
            call mat_err(25) ! Can not use function name as variable
            return
         endif
         call mat_stack_get(id)
         !write(*,gen1)'GOT HERE C:MAT_FACTOR:MAT_STACK_GET:G_FUN:',G_FUN,':G_FIN:',G_FIN
         if (G_ERR .gt. 0) return
         if (G_FIN .eq. 7) goto 50
         if (G_FIN .eq. 0) call mat_copyid(G_IDS(1,G_PT+1),id)

         if (G_FIN .eq. 0) then
            call mat_err(4) ! undefined variable
            return
         endif
         goto 60
      endif
      id(1) = BLANK
      if (G_SYM .eq. lparen .or. G_SYM.eq. lbrace) goto 42
      ! needs to allow for empty parenthesis() but does not
      !write(*,gen1)'GOT HERE B',char(G_SYM),char(G_CHRA)
      if ( G_SYM .ne. rparen ) then
         call mat_err(2) ! improper factor
      endif
      return
   endif
!======================================================================
   ! put something on the stack
   location = 1
   if (G_ARGUMENT_POINTER .gt. 0) then
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER) &
       & + G_VAR_ROWS(G_ARGUMENT_POINTER) &
       & * G_VAR_COLS(G_ARGUMENT_POINTER)
   endif
   if (G_ARGUMENT_POINTER+1 .ge. G_TOP_OF_SAVED) then
      call mat_err(18)
      return
   endif

   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER+1
   G_VAR_DATALOC(G_ARGUMENT_POINTER) = location
   if (G_SYM .ne. quote) then
      if (G_SYM .eq. less.or.G_SYM.eq.lbracket) goto 20
      ! single number, getsym stored it in GM_IMAGS
      G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
      G_VAR_COLS(G_ARGUMENT_POINTER) = 1
      GM_REALS(location) = GM_IMAGS(GM_BIGMEM)
      GM_IMAGS(location) = 0.0D0
      call mat_getsym()
      goto 60
      ! string
   endif

   n = 0
   G_LINE_POINTER(4) = G_LINE_POINTER(3)
   call mat_getch()  ! get next character

!==================================
16 continue
   if (G_CHRA .eq. QUOTE) goto 18
17 continue
   ln = location+n
   if (G_CHRA .eq. GG_EOL) then
      call mat_err(31) ! Improper string
      return
   endif
   GM_REALS(LN) = dble(G_CHRA)
   GM_IMAGS(LN) = 0.0d0
   n = n+1
   call mat_getch()  ! get next character
   goto 16

18 continue
   call mat_getch()  ! get next character
   if (G_CHRA .eq. QUOTE) goto 17
!==================================

   if (n .le. 0) then
      call mat_err(31) ! Improper string
      return
   endif
   G_VAR_ROWS(G_ARGUMENT_POINTER) = 1
   G_VAR_COLS(G_ARGUMENT_POINTER) = n
   call mat_getsym()
   goto 60
!==================================================================================================================================!
!  explicit matrix
20 continue
   G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
   G_VAR_COLS(G_ARGUMENT_POINTER) = 0

21 continue
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
   G_VAR_DATALOC(G_ARGUMENT_POINTER) = &
      &   G_VAR_DATALOC(G_ARGUMENT_POINTER-1) &
      & + G_VAR_ROWS(G_ARGUMENT_POINTER-1)&
      & * G_VAR_COLS(G_ARGUMENT_POINTER-1)
   G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
   G_VAR_COLS(G_ARGUMENT_POINTER) = 0
   call mat_getsym()

22 continue
   if (G_SYM.eq.semi .or. (G_SYM.eq.great.or.G_SYM.eq.rbracket) .or. G_SYM.eq.GG_EOL) then
      if (G_SYM.eq.semi .and. G_CHRA.eq.GG_EOL) call mat_getsym()
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
      if (G_VAR_ROWS(G_ARGUMENT_POINTER) .eq. 0)  &
         & G_VAR_ROWS(G_ARGUMENT_POINTER) = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
      if (G_VAR_ROWS(G_ARGUMENT_POINTER) .ne. G_VAR_ROWS(G_ARGUMENT_POINTER+1) &
         & .and. G_VAR_ROWS(G_ARGUMENT_POINTER+1) .gt. 0) then
         call mat_err(6)
         return
      endif
      G_VAR_COLS(G_ARGUMENT_POINTER) = G_VAR_COLS(G_ARGUMENT_POINTER) &
         & + G_VAR_COLS(G_ARGUMENT_POINTER+1)
      if (G_SYM .eq. GG_EOL) call mat_getlin()
      if (G_SYM .ne. great.and. G_SYM.ne.rbracket) goto 21
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      call mat_getsym()
      goto 60
   endif
   if (G_SYM .eq. comma) call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 10
   ! *call* EXPR
   return
!==================================================================================================================================!
25 continue
   G_PT = G_PT-1
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER - 1
   if (G_VAR_ROWS(G_ARGUMENT_POINTER) .eq. 0) then
      G_VAR_ROWS(G_ARGUMENT_POINTER) = G_VAR_ROWS(G_ARGUMENT_POINTER+1)
   endif

   if (G_VAR_ROWS(G_ARGUMENT_POINTER) .ne. G_VAR_ROWS(G_ARGUMENT_POINTER+1))then
      call mat_err(5)
      return
   endif
   G_VAR_COLS(G_ARGUMENT_POINTER) =  &
      & G_VAR_COLS(G_ARGUMENT_POINTER) + G_VAR_COLS(G_ARGUMENT_POINTER+1)
   goto 22
!==================================================================================================================================!
32 continue
   G_PT = G_PT-1
   if ((G_SYM.ne.less.or.G_SYM.eq.lbracket) .and. G_SYM.NE.GG_EOL) then
      call mat_err(37) ! Improper MACROS
      return
   endif
   if (G_SYM .EQ. LESS.or.G_SYM.eq.lbracket) call mat_getsym()
   k = G_LINE_POINTER(6)
   G_LIN(k+1) = G_LINE_POINTER(1)
   G_LIN(k+2) = G_LINE_POINTER(2)
   G_LIN(k+3) = G_LINE_POINTER(6)
   G_LINE_POINTER(1) = k + 4
!     transfer stack to input line
   k = G_LINE_POINTER(1)
   location = G_VAR_DATALOC(G_ARGUMENT_POINTER)
   n = G_VAR_ROWS(G_ARGUMENT_POINTER)*G_VAR_COLS(G_ARGUMENT_POINTER)
   do j = 1, n
      ls = location + j-1
      G_LIN(k) = int(GM_REALS(ls))
      if (G_LIN(k).lt.0 .or. G_LIN(k).ge.G_CHARSET_SIZE) then
         call mat_err(37) ! Improper MACROS
         return
      endif
      if (k.lt.1024) k = k+1
      if (k.eq.1024)call journal('sc','Input buffer char limit exceeded=',K)
   enddo
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER-1
   G_LIN(k) = GG_EOL;G_LIN(k+1:)=blank
   G_LINE_POINTER(6) = k
   G_LINE_POINTER(4) = G_LINE_POINTER(1)
   G_LINE_POINTER(3) = 0
   G_LINE_POINTER(2) = 0
   G_LINECOUNT(1) = 0
   G_CHRA = blank
   call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 19
!     *call* EXPR
   return
!==================================================================================================================================!
37 continue
   G_PT = G_PT-1
   k = G_LINE_POINTER(1) - 4
   G_LINE_POINTER(1) = G_LIN(K+1)
   G_LINE_POINTER(4) = G_LIN(K+2)
   G_LINE_POINTER(6) = G_LIN(K+3)
   G_CHRA = BLANK
   call mat_getsym()
   goto 60
!==================================================================================================================================!
42 continue
   call mat_getsym()
   excnt = excnt+1
   G_PT = G_PT+1
   G_PSTK(G_PT) = excnt
   call mat_copyid(G_IDS(1,G_PT),id)
   G_RSTK(G_PT) = 11
   ! *call* expr
   return
!==================================================================================================================================!
45 continue
   call mat_copyid(id,G_IDS(1,G_PT))
   excnt = G_PSTK(G_PT)
   G_PT = G_PT-1
   if (G_SYM .eq. comma) goto 42
   if ((G_SYM .ne. rparen) .and. (G_SYM.ne.rbrace)) then
      call mat_err(3)
      return
   endif
   if ((G_SYM .eq. rparen) .or. (G_SYM .eq. rbrace)) call mat_getsym()
   if (id(1) .eq. blank) goto 60
   G_RHS = excnt
   call MAT_STACK_GET(id)
   if (G_ERR .gt. 0) return
   if (G_FIN .eq. 0) call mat_funs(ID)
   if (G_FIN .eq. 0) then
      call mat_err(4) ! undefined variable
      return
   endif
   ! evaluate matrix function
50 continue
   G_PT = G_PT+1
   G_RSTK(G_PT) = 16
   ! *call* matfn
   return
!==================================================================================================================================!
55 continue
   G_PT = G_PT-1
   goto 60
!==================================================================================================================================!
!  check for quote (transpose) and ** (power)
60 continue
   if (G_SYM .eq. quote) then
      i = G_LINE_POINTER(3) - 2
      if (G_LIN(i) .eq. blank) goto 90
      call mat_stack1(quote)
      if (G_ERR .gt. 0) return
      call mat_getsym()
   endif
   if (G_SYM.ne.star .or. G_CHRA.ne.star) goto 90
   call mat_getsym()
   call mat_getsym()
   G_PT = G_PT+1
   G_RSTK(G_PT) = 12
   ! *call* factor
   goto 01
!==================================================================================================================================!
65 continue
   G_PT = G_PT-1
   call mat_stack2(DSTAR)
   if (G_ERR .gt. 0) return
   if (G_FUN .ne. 2) goto 90
   !  matrix power, use eigenvectors
   G_PT = G_PT+1
   G_RSTK(G_PT) = 17
   ! *call* matfn
   return
!==================================================================================================================================!
75 continue
   G_PT = G_PT-1
90 continue
   return
!==================================================================================================================================!
99 continue
   call mat_err(22) ! recursion difficulties
   return
end subroutine mat_factor
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_term()
integer                   :: op

   select case( G_RSTK(G_PT) )
   case(6,7)
      G_PT = G_PT+1
      G_RSTK(G_PT) = 8
      ! *call* factor
      return
   case(8)
      G_PT = G_PT-1
   case(9)
      op = G_PSTK(G_PT)
      G_PT = G_PT-1
      call mat_stack2(op)
      if (G_ERR .gt. 0)then
         return
      endif
      ! some binary ops done in matfns
      if (G_FUN .ne. 0) then
         G_PT = G_PT+1
         G_RSTK(G_PT) = 15
         ! *call* matfn
         return
      endif
   case(15)
      G_PT = G_PT-1
   case default
      call mat_err(22)
      return
   end select

   op = 0
   if (G_SYM .eq. dot) then
      op = dot
      call mat_getsym()
   endif
   if (.not.(G_SYM.eq.star .or. G_SYM.eq.slash .or. G_SYM.eq.bslash .or. G_SYM.eq.caret )) then
      return
   endif

   if(op.eq.0)then ! make a special code out of two characters ie. "./" or just set to last symbol found if op=0
      op = G_SYM
   else
      op = G_SYM + 1000
   endif

   call mat_getsym()

   if (G_SYM .eq. dot)then
      op = op + 1000  ! now holds three characters
      call mat_getsym()
   endif

   G_PT = G_PT+1
   G_PSTK(G_PT) = op
   G_RSTK(G_PT) = 9
   ! *call* factor

end subroutine mat_term
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_savlod(lun,id,m,n,img,space_left,xreal,ximag)

! ident_31="@(#) M_matrix mat_savlod(3fp) read next variable from a save file or write next variable to it"

integer,intent(in)                :: lun                                       ! logical unit number
integer                           :: id(GG_MAX_NAME_LENGTH)                    ! name, format 32a1
integer                           :: m, n                                      ! dimensions
integer                           :: img                                       ! nonzero if ximag is nonzero. returned on a load
integer                           :: space_left                                ! 0 for save, = space available for load
doubleprecision                   :: xreal(*), ximag(*)                        ! real and optional imaginary parts
character(len=GG_MAX_NAME_LENGTH) :: cid
integer                           :: j,k,l
integer                           :: ios
character(len=256)                :: message
                                                                               ! system dependent formats
character(len=*),parameter        :: f101 ='(A,3I9)'                           ! ID, MxN dimensions of ID, imaginary or real flag
character(len=*),parameter        :: f102 ='(4Z18)'                            ! format for data
      if (space_left .le. 0) then                                              ! save
         call mat_buf2str(cid,id,GG_MAX_NAME_LENGTH)                           ! convert ID to a character string
         write(lun,f101) cid,m,n,img
         do j = 1, n
            k = (j-1)*m+1
            l = j*m
            write(lun,f102) xreal(k:l)                                         ! real
            if (img .ne. 0) write(lun,f102) ximag(k:l)                         ! imaginary
         enddo
      else                                                                     ! load
         read(lun,f101,iostat=ios,iomsg=message) cid,m,n,img
         if(ios.ne.0)then
            call journal(message)
            m=0
            n=0
         else
            call mat_str2buf(cid,id,GG_MAX_NAME_LENGTH)                        ! convert character string to an ID
            if (m*n .gt. space_left) then
               m=0
               n=0
            else
               do j = 1, n
                  k = (j-1)*m+1
                  l = j*m
                  read(lun,f102,iostat=ios,iomsg=message) xreal(k:l)           ! real
                  if(ios.ne.0)then
                     call journal(message)
                     m=0
                     n=0
                     exit
                  elseif (img .ne. 0) then
                     read(lun,f102,iostat=ios,iomsg=message) ximag(k:l)        ! imaginary
                     if(ios.ne.0)then
                        m=0
                        n=0
                        exit
                     endif
                  endif
               enddo
            endif
         endif
      endif
end subroutine mat_savlod
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
logical function mat_eqid(x,y)

!     check for equality of two integer arrays

integer,intent(in) :: x(GG_MAX_NAME_LENGTH)
integer,intent(in) :: y(GG_MAX_NAME_LENGTH)

integer            :: i

   mat_eqid = .true.

   do i = 1, GG_MAX_NAME_LENGTH
      mat_eqid = mat_eqid .and. (x(i).eq.y(i))
   enddo

end function mat_eqid
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!
! NAME
!    ifin_lala(3f) - [M_matrix] test if variable name exists in lala()
!    LICENSE(MIT)
! SYNOPSIS
!      logical function ifin_lala(varname)
!
!      character(len=*),intent(in) :: varname
! DESCRIPTION
!    Determine if a variable name currently exists in lala().
!
! RETURNS
!     ifin_lala  TRUE if varname exists in lala, else FALSE.
! EXAMPLES
!   sample program:
!
!      program demo_ifin_lala
!      use M_matrix, only : ifin_lala
!      implicit none
!         write(*,*)'eps ',ifin_lala('eps')
!         write(*,*)'unknown ',ifin_lala('unknown')
!      end program demo_ifin_lala
!
!   Results:
!
!     eps  T
!     unknown  F
function ifin_lala(varname)

! ident_32="@(#) M_matrix ifin_lala(3f) access LALA variable stack and see if a variable name exists"

character(len=*),intent(in) :: varname
integer                     :: id(GG_MAX_NAME_LENGTH)
logical                     :: ifin_lala
integer                     :: k

   ifin_lala=.true.
   if(GM_BIGMEM.LT.0) call lala_init(200000) ! if not initialized initialize
   if( .not.mat_is_name(varname))then
      call journal('sc',varname,'is not a valid variable name')
      ifin_lala=.false.
   endif

   ! convert character name to lala character set
   id=iachar(' ')
   call mat_str2buf(varname,id,len(varname))
   call mat_copyid(G_VAR_IDS(1,G_TOP_OF_SAVED-1), ID)   ! copy ID to next blank entry in G_VAR_IDS for messages(?)

   do k=GG_MAX_NUMBER_OF_NAMES,1,-1                     ! start at bottom and search up through names till find the name
      if (mat_eqid(G_VAR_IDS(1:,k), id))exit            ! if found name exit loop
   enddo

   ! if matched the name inserted above did not find it.
   if ( (k .ge. GG_MAX_NUMBER_OF_NAMES-1) .or. (k .eq. G_TOP_OF_SAVED-1)) then
      ifin_lala=.false.                                 ! unknown variable name
   endif

end function ifin_lala
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
!
! NAME
!     get_from_lala(3f) - [M_matrix] return data from lala(3f) to calling program
!     LICENSE(MIT)
! SYNOPSIS
!     subroutine get_from_lala(varname,A,IERR,fixed)
!
!      character(len=*),intent(in)               :: varname
!      [INTRINSIC_TYPE],allocatable,intent(out)  :: a(:,:)
!      integer,intent(out)                       :: ierr
!      logical,intent(in),optional               :: fixed
!
! DESCRIPTION
!    Given the name of a variable defined with lala(3f) commands return
!    the values to the calling program.
!
! OPTIONS
!    VARNAME Name of lala(3f) variable to retrieve
!
!    FIXED   If .true., A is assumed to be a fixed size. It should only
!            be specified if the value is .true.! It is up to the user
!            at this point to ensure the size is correct at this point.
! RETURNS
!      A    May be of TYPE INTEGER, REAL, CHARACTER, LOGICAL or COMPLEX.
!           May be a scalar, vector, or MxN matrix.
!    IERR   Zero if no error occurred
!
! EXAMPLES
!   sample program:
!
!    program demo_get_from_lala
!    use M_matrix, only : lala, get_from_lala, put_into_lala
!    implicit none
!    doubleprecision,allocatable :: darr(:,:)
!    real,allocatable            :: rarr(:,:)
!    integer,allocatable         :: ivec(:)
!    integer                     :: ierr
!    integer                     :: i
!    character(len=*),parameter  :: gen='(*(g0,1x))'
!
!       ! create an array in LALA so have something to get
!       call lala('A=randu(4,5)*10.5,long,A')
!
!       ! get the array as a REAL array
!       call get_from_lala('A',rarr,ierr)
!       write(*,gen)'in calling program RARR=',shape(rarr)
!       write(*,gen)(rarr(i,:),new_line('A'),i=1,size(rarr,dim=1))
!
!       ! get the array as a DOUBLEPRECISION  array
!       call get_from_lala('A',darr,ierr)
!       write(*,gen)'in calling program darr=',shape(darr)
!       write(*,gen)(darr(i,:),new_line('A'),i=1,size(darr,dim=1))
!
!       ! get the array as an INTEGER vector, much like the
!       ! PUSH(3f) intrinsic
!       call get_from_lala('A',ivec,ierr)
!       write(*,gen)'in calling program ivec=',shape(ivec)
!       write(*,gen)ivec
!
!    end program demo_get_from_lala
!
!   Results:
!
!    >A  =
!    >   2.2189  6.9865  9.2213  7.6267  2.4278
!    >   7.9385  6.5981  0.7179  2.0844  2.2729
!    >   0.0023  8.9223  5.8889  5.7147  9.2756
!    >   3.4684  7.2002  6.9547  2.4368  6.8514
!
!    >A  =
!    >    COLUMNS     1 THRU     4
!    >  2.218911087373272 6.986501594306901 9.221273053670302 7.626682105707005
!    >  7.938460468780249 6.598113777581602 0.717927386518568 2.084401034284383
!    >  0.002321913605556 8.922324976650998 5.888910365989432 5.714701820863411
!    >  3.468434463255107 7.200175708159804 6.954747841693461 2.436785291880369
!    >    COLUMNS     5 THRU     5
!    >  2.427849056432024
!    >  2.272864263039082
!    >  9.275582205271348
!    >  6.851391694508493
!    >in calling program RARR= 4 5
!    > 2.21891117 6.98650169 9.22127342 7.62668228 2.42784905
!    > 7.93846035 6.59811401 0.717927396 2.08440113 2.27286434
!    > 0.232191361E-2 8.92232513 5.88891029 5.71470165 9.27558231
!    > 3.46843457 7.20017576 6.95474768 2.43678522 6.85139179
!
!    >in calling program darr= 4 5
!    > 2.2189110873732716 6.9865015943069011 9.2212730536703020 ..
!    > 7.6266821057070047 2.4278490564320236
!    > 7.9384604687802494 6.5981137775816023 0.71792738651856780 ..
!    > 2.0844010342843831 2.2728642630390823
!    > 0.23219136055558920E-2 8.9223249766509980 5.8889103659894317 ..
!    > 5.7147018208634108 9.2755822052713484
!    > 3.4684344632551074 7.2001757081598043 6.9547478416934609 ..
!    > 2.4367852918803692 6.8513916945084929
!
!    >in calling program ivec= 20
!    > 2 8 0 3 7 7 9 7 9 1 6 7 8 2 6 2 2 2 9 7
subroutine get_double_from_lala(varname,A,type,IERR)

! ident_33="@(#) M_matrix get_double_from_lala(3f) access LALA variable stack and get a variable by name and its data from the stack"

character(len=*),intent(in)              :: varname    ! the name of A.
integer,intent(in)                       :: type       ! type =  0  get REAL A from LALA, type  = 1  get IMAGINARY A into LALA,
integer,INTENT(OUT)                      :: ierr       ! return with nonzero IERR after LALA error message.
doubleprecision,allocatable,intent(out)  :: a(:,:)     ! A is an M by N matrix
integer                                  :: id(GG_MAX_NAME_LENGTH)
integer                                  :: i,j,k,location,m,n

   if(GM_BIGMEM.LT.0) then
      call lala_init(200000) ! if not initialized initialize
   endif
   ierr=0

   ! convert character name to lala character set
   id=iachar(' ')
   call mat_str2buf(varname,id,len(varname))
   ! ??? make sure this letter is in set of LALA characters and get its LALA number
   call mat_copyid(G_VAR_IDS(1,G_TOP_OF_SAVED-1), ID)   ! copy ID to next blank entry in G_VAR_IDS for messages(?)

   do k=GG_MAX_NUMBER_OF_NAMES,1,-1                       ! start at bottom and search up through names till find the name
      if (mat_eqid(G_VAR_IDS(1:,k), id))exit            ! if found name exit loop
   enddo

   ! if matched the name inserted above did not find it.
   if ( (k .ge. GG_MAX_NUMBER_OF_NAMES-1 .and. G_RHS .gt. 0) .or. (k .eq. G_TOP_OF_SAVED-1) ) then
      call journal('sc','<ERROR>get_double_from_lala: unknown variable name',varname)
      IERR=4
      if(allocated(a))deallocate(a)
      allocate(a(0,0))
   else
      if(allocated(a))deallocate(a)
      M=G_VAR_ROWS(k)
      N=G_VAR_COLS(k)
      allocate(a(m,n))
      location=G_VAR_DATALOC(k)
      do j=1,n
         do i=1,m
            if(type.eq.0)then
               a(i,j)=GM_REALS(location)       ! type =  0  GET REAL A FROM LALA,
            else
               a(i,j)=GM_IMAGS(location)       ! type =  1  GET IMAGINARY A FROM LALA,
            endif
            location=location+1
         enddo
      enddo
   endif

end subroutine get_double_from_lala
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function rowpack(arr) result(vec)
doubleprecision,intent(in)  :: arr(:,:)
doubleprecision,allocatable :: vec(:)
integer                     :: i
if(allocated(vec))deallocate(vec)
vec=[(arr(:,i),i=1,size(arr,dim=2))]
end function rowpack
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
!
! NAME
!     put_from_lala(3f) - [M_matrix] return data from lala(3f) to calling program
!     LICENSE(MIT)
! SYNOPSIS
!   subroutine put_into_lala(varname,A,IERR)
!
!    character(len=*),intent(in)              :: varname
!    [INTRINSIC_TYPE],allocatable,intent(in)  :: a(:,:)
!    integer,intent(out)                      :: ierr
!
! DESCRIPTION
!    Define a variable in the lala(3f) utility with a variable declared
!    in the calling program.
!
! OPTIONS
!    VARNAME Name of lala(3f) variable to retrieve
!      A     May be of TYPE INTEGER, REAL, CHARACTER, LOGICAL or COMPLEX.
!            May be a scalar, vector, or MxN matrix.
!
! RETURNS
!    IERR   Zero if no error occurred
!
! EXAMPLES
!   sample program:
!
!    program demo_put_into_lala
!    use M_matrix, only : lala, get_from_lala, put_into_lala
!    implicit none
!    integer :: ierr
!
!       ! store some data from the program into lala(3f)
!       call put_into_lala('A',[1,2,3,4,5,6,7,8,9],ierr)
!       call put_into_lala('B',[1.1,2.2,3.3],ierr)
!       call put_into_lala('C',"This is my title",ierr)
!
!       ! call lala(3f) and display the values
!       call lala([character(len=80) :: &
!       & 'who,A,B', &
!       & 'display(C);', &
!       & '', &
!       & ''])
!
!    end program demo_put_into_lala
!
!   Results:
!
!      > Your current variables are...
!      > C  B  A  eps  flops  eye  rand
!      >using 33 out of 200000 elements
!      >
!      > A  =
!      >     1.    2.    3.    4.    5.    6.    7.    8.    9.
!      >
!      > B  =
!      >    1.1000    2.2000    3.3000
!      >This is my title
subroutine store_double_into_lala(varname,realxx,imagxx,ierr)

! ident_34="@(#) M_matrix _store_double_into_lala(3f) put a variable name and its data onto LALA stack"

character(len=*),intent(in)          :: varname                ! the name of realxx.
doubleprecision,intent(in)           :: realxx(:,:)            ! inputarray is an M by N matrix
doubleprecision,intent(in),optional  :: imagxx(:,:)            ! inputarray is an M by N matrix
integer,intent(out)                  :: ierr                   ! return with nonzero ierr after LALA error message.

integer                              :: img
integer                              :: space_left
integer                              :: id(GG_MAX_NAME_LENGTH) ! ID = name, in numeric format
integer                              :: location
integer                              :: m,n                    ! m, n = dimensions

   if(GM_BIGMEM.LT.0) then
      call lala_init(200000) ! if not initialized initialize
   else
   endif

   ierr=0
   if(present(imagxx))then
      img=1
      if(size(realxx,dim=1).ne.size(imagxx,dim=1).or.size(realxx,dim=2).ne.size(imagxx,dim=2))then
         call journal('sc','<ERROR>*lala_put* real and imaginary parts have different sizes')
         ierr=-1
         return
      endif
   else
      img=0
   endif

   if(G_ARGUMENT_POINTER.ne.0)then
      location = G_VAR_DATALOC(G_ARGUMENT_POINTER) ! location of bottom of used scratch space
   else
     !call journal('sc','<WARNING>G_ARGUMENT_POINTER=',G_ARGUMENT_POINTER)
     G_ARGUMENT_POINTER= 1
     G_VAR_DATALOC(G_ARGUMENT_POINTER)=1
     location=1
   endif
   space_left = G_VAR_DATALOC(G_TOP_OF_SAVED) - location
   !! assume input arrays can be one or two dimension but lala stores everything as a vector and store m and n
   m=size(realxx,dim=1)
   n=size(realxx,dim=2)
   if (m*n .gt. space_left) then
      call journal('sc','<ERROR>*lala_put* insufficient space to save data to LALA')
      ierr=-2
      return
   elseif(m*n.eq.0)then ! check for zero-size input array
      call journal('sc','<ERROR>*lala_put* cannot save empty arrays to LALA')
      ierr=-3
      return
   else
      if (img .eq. 0)then
         !call mat_rset(m*n,0.0d0,GM_IMAGS(location),1) ! set imaginary values to zero
         gm_imags(location:location+m*n-1)=0.0d0 ! set imaginary component to zero
      else
         GM_IMAGS(location:location+m*n-1)=rowpack(imagxx)
      endif
      GM_REALS(location:location+m*n-1)=rowpack(realxx)
   endif
   G_VAR_ROWS(G_ARGUMENT_POINTER)=m
   G_VAR_COLS(G_ARGUMENT_POINTER)=n
   G_SYM = semi   !! ??? why
   G_RHS = 0      !! ??? why
   call mat_str2buf(varname,id,GG_MAX_NAME_LENGTH)                        ! convert character string to an ID
   !! ???? if(G_ERR.ne.0)
   !! ???? check if varname is an acceptable name
   call mat_stack_put(id)
   !! ???? if(G_ERR.ne.0)
   G_ARGUMENT_POINTER = G_ARGUMENT_POINTER + 1
   G_VAR_ROWS(G_ARGUMENT_POINTER) = 0
   G_VAR_COLS(G_ARGUMENT_POINTER) = 0
end subroutine store_double_into_lala
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine store_array_into_lala(varname,anything,ierr)
character(len=*),intent(in)  :: varname
class(*)                     :: anything(:,:)
integer,intent(out)          :: ierr
   select type(anything)
!!    type is (character(len=*));
!!       call store_double_into_lala(varname,
!!       reshape(real(str2ade(anything),kind=dp),[1,len(anything)])
!!       ,ierr=ierr)
!!       call store_double_into_lala(varname,reshape(real(str2ade(anything),kind=dp),[1,len(anything)]),ierr=ierr)
   type is (complex);              call store_double_into_lala(varname,real(anything,kind=dp), &
                                                                     & real(aimag(anything),kind=dp),ierr=ierr)
   type is (complex(kind=dp));     call store_double_into_lala(varname,real(anything),aimag(anything),ierr=ierr)
   type is (integer(kind=int8));   call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (integer(kind=int16));  call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (integer(kind=int32));  call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (integer(kind=int64));  call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (real(kind=real32));    call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (real(kind=real64));    call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   type is (real(kind=real128));   call store_double_into_lala(varname,real(anything,kind=dp),ierr=ierr)
   ! arbitrarily, 0 is false and not 0 is true, although I prefer the opposite
   type is (logical);              call store_double_into_lala(varname,merge(0.1d0,0.0d0,anything),ierr=ierr)
   class default
      stop 'crud. store_array_into_lala(1) does not know about this type'
   end select
end subroutine store_array_into_lala
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine store_vector_into_lala(varname,anything,ierr)
character(len=*),intent(in)  :: varname
class(*)                     :: anything(:)
integer,intent(out)          :: ierr
integer                      :: i
   select type(anything)
    type is (character(len=*));
       associate ( &
                   & letters  => [( real(str2ade(anything(i)),kind=dp),i=1,size(anything,dim=1))] , &
                   & r=> size(anything), &
                   & c=> len(anything) &
                 )
          call store_double_into_lala(varname,reshape(letters,[r,c],order=[2,1]),ierr=ierr)
       end associate
    type is (complex)
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]), &
                                          & reshape(real(aimag(anything),kind=dp),[1,size(anything)]), ierr=ierr)
    type is (complex(kind=dp))
       call store_double_into_lala(varname,reshape(real(anything),[1,size(anything)]), &
                                          & reshape(aimag(anything),[1,size(anything)]), ierr=ierr)
    type is (integer(kind=int8))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (integer(kind=int16))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (integer(kind=int32))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (integer(kind=int64))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (real(kind=real32))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (real(kind=real64))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (real(kind=real128))
       call store_double_into_lala(varname,reshape(real(anything,kind=dp),[1,size(anything)]),ierr=ierr)
    type is (logical)
       call store_double_into_lala(varname,reshape(merge(0.1d0,0.0d0,anything),[1,size(anything)]),ierr=ierr)
    class default
      stop 'crud. store_vector_into_lala(1) does not know about this type'
      ierr=-20
   end select
end subroutine store_vector_into_lala
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine store_scalar_into_lala(varname,anything,ierr)
character(len=*),intent(in)  :: varname
class(*)                     :: anything
integer,intent(out)          :: ierr
logical,parameter            :: T=.true.
   select type(anything)
    type is (character(len=*))
       call store_double_into_lala(varname,reshape(real(str2ade(anything),kind=dp),[1,len(anything)]),ierr=ierr)
    type is (complex)
       call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]), &
                                          & reshape([real(aimag(anything),kind=dp)],[1,1]), ierr=ierr)
    type is (complex(kind=dp))
             call store_double_into_lala(varname,reshape([real(anything)],[1,1]), reshape([aimag(anything)],[1,1]), ierr=ierr)
    type is (integer(kind=int8));  call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (integer(kind=int16)); call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (integer(kind=int32)); call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (integer(kind=int64)); call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (real(kind=real32));   call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (real(kind=real64));   call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    type is (real(kind=real128));  call store_double_into_lala(varname,reshape([real(anything,kind=dp)],[1,1]),ierr=ierr)
    ! arbitrarily, 0 is false and not 0 is true, although I prefer the opposite
    type is (logical);             call store_double_into_lala(varname,reshape([merge(1.0d0,0.0d0,anything)],[1,1]),ierr=ierr)
    class default
      stop 'crud. store_scalar_into_lala(1) does not know about this type'
   end select
end subroutine store_scalar_into_lala
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_fixed_array_from_lala_int8(varname,out,ierr,fixed)
character(len=*),intent(in)                :: varname
integer(kind=int8),intent(out) :: out(:,:)
doubleprecision,allocatable                :: double(:,:)
integer,intent(out)                        :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int8)
end subroutine get_fixed_array_from_lala_int8
!===================================================================================================================================
subroutine get_fixed_array_from_lala_int16(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int16),intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int16)
end subroutine get_fixed_array_from_lala_int16
!===================================================================================================================================
subroutine get_fixed_array_from_lala_int32(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int32),intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int32)
end subroutine get_fixed_array_from_lala_int32
!===================================================================================================================================
subroutine get_fixed_array_from_lala_int64(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int64),intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=int64)
end subroutine get_fixed_array_from_lala_int64
!===================================================================================================================================
subroutine get_fixed_array_from_lala_real32(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
real(kind=real32),intent(out) :: out(:,:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real32)
end subroutine get_fixed_array_from_lala_real32
!===================================================================================================================================
subroutine get_fixed_array_from_lala_real64(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
real(kind=real64),intent(out) :: out(:,:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real64)
end subroutine get_fixed_array_from_lala_real64
!===================================================================================================================================
subroutine get_fixed_array_from_lala_real128(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
real(kind=real128),intent(out)  :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real128)
end subroutine get_fixed_array_from_lala_real128
!===================================================================================================================================
subroutine get_fixed_array_from_lala_logical(varname,out,ierr,fixed)
character(len=*),intent(in)      :: varname
logical,intent(out)  :: out(:,:)
doubleprecision,allocatable      :: double(:,:)
integer,intent(out)              :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=merge(.false.,.true.,nint(double).eq.0)
end subroutine get_fixed_array_from_lala_logical
!===================================================================================================================================
subroutine get_fixed_array_from_lala_cmplx(varname,out,ierr,fixed)
character(len=*),intent(in)      :: varname
complex,intent(out)  :: out(:,:)
doubleprecision,allocatable      :: double(:,:), doublei(:,:)
integer,intent(out)              :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(double,doublei,kind=sp)
end subroutine get_fixed_array_from_lala_cmplx
!===================================================================================================================================
subroutine get_fixed_array_from_lala_dpcmplx(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
complex(kind=dp),intent(out)  :: out(:,:)
doubleprecision,allocatable               :: double(:,:), doublei(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(double,doublei,kind=sp)
end subroutine get_fixed_array_from_lala_dpcmplx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_character(varname,out,ierr,fixed)
character(len=*),intent(in)              :: varname
character(len=*),intent(out) :: out(:)
doubleprecision,allocatable              :: double(:,:)
integer,intent(out)                      :: ierr
integer                                  :: i,j
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   do i=1,size(double,dim=1)
      do j=1,size(double,dim=2)
         out(i)(j:j)=achar(nint(double(i,j)))
      enddo
   enddo
end subroutine get_fixed_vector_from_lala_character
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_int8(varname,out,ierr,fixed)
character(len=*),intent(in)                :: varname
integer(kind=int8),intent(out) :: out(:)
doubleprecision,allocatable                :: double(:,:)
integer,intent(out)                        :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int8)
end subroutine get_fixed_vector_from_lala_int8
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_int16(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int16),intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int16)
end subroutine get_fixed_vector_from_lala_int16
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_int32(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int32),intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int32)
end subroutine get_fixed_vector_from_lala_int32
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_int64(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
integer(kind=int64),intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=int64)
end subroutine get_fixed_vector_from_lala_int64
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_real32(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
real(kind=real32),intent(out) :: out(:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real32)
end subroutine get_fixed_vector_from_lala_real32
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_real64(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
real(kind=real64),intent(out) :: out(:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real64)
end subroutine get_fixed_vector_from_lala_real64
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_real128(varname,out,ierr,fixed)
character(len=*),intent(in)                 :: varname
real(kind=real128),intent(out)  :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real128)
end subroutine get_fixed_vector_from_lala_real128
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_logical(varname,out,ierr,fixed)
character(len=*),intent(in)      :: varname
logical,intent(out)  :: out(:)
doubleprecision,allocatable      :: double(:,:)
integer,intent(out)              :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=merge(.false.,.true.,nint(rowpack(double)).eq.0)
end subroutine get_fixed_vector_from_lala_logical
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_cmplx(varname,out,ierr,fixed)
character(len=*),intent(in)      :: varname
complex,intent(out)  :: out(:)
doubleprecision,allocatable      :: double(:,:), doublei(:,:)
integer,intent(out)              :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(rowpack(double),rowpack(doublei),kind=sp)
end subroutine get_fixed_vector_from_lala_cmplx
!===================================================================================================================================
subroutine get_fixed_vector_from_lala_dpcmplx(varname,out,ierr,fixed)
character(len=*),intent(in)               :: varname
complex(kind=dp),intent(out)  :: out(:)
doubleprecision,allocatable               :: double(:,:), doublei(:,:)
integer,intent(out)                       :: ierr
logical,intent(in)                         :: fixed
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(rowpack(double),rowpack(doublei),kind=dp)
end subroutine get_fixed_vector_from_lala_dpcmplx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_fixed_scalar_from_lala_character(varname,out,ierr,fixed)
character(len=*),intent(in)              :: varname
character(len=*),intent(out) :: out
doubleprecision,allocatable              :: double(:,:)
integer,intent(out)                      :: ierr
logical,intent(in)                         :: fixed
integer                                  :: i,j,k
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   k=0
   do i=1,size(double,dim=1)
      do j=1,size(double,dim=2)
         k=k+1
         out(k:k)=achar(nint(double(i,j)))
      enddo
   enddo
end subroutine get_fixed_scalar_from_lala_character
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_array_from_lala_int8(varname,out,ierr)
character(len=*),intent(in)                :: varname
integer(kind=int8),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable                :: double(:,:)
integer,intent(out)                        :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int8)
end subroutine get_array_from_lala_int8
!===================================================================================================================================
subroutine get_array_from_lala_int16(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int16),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int16)
end subroutine get_array_from_lala_int16
!===================================================================================================================================
subroutine get_array_from_lala_int32(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int32),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(double,kind=int32)
end subroutine get_array_from_lala_int32
!===================================================================================================================================
subroutine get_array_from_lala_int64(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int64),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=int64)
end subroutine get_array_from_lala_int64
!===================================================================================================================================
subroutine get_array_from_lala_real32(varname,out,ierr)
character(len=*),intent(in)               :: varname
real(kind=real32),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real32)
end subroutine get_array_from_lala_real32
!===================================================================================================================================
subroutine get_array_from_lala_real64(varname,out,ierr)
character(len=*),intent(in)               :: varname
real(kind=real64),allocatable,intent(out) :: out(:,:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real64)
end subroutine get_array_from_lala_real64
!===================================================================================================================================
subroutine get_array_from_lala_real128(varname,out,ierr)
character(len=*),intent(in)                 :: varname
real(kind=real128),allocatable,intent(out)  :: out(:,:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(double,kind=real128)
end subroutine get_array_from_lala_real128
!===================================================================================================================================
subroutine get_array_from_lala_logical(varname,out,ierr)
character(len=*),intent(in)      :: varname
logical,allocatable,intent(out)  :: out(:,:)
doubleprecision,allocatable      :: double(:,:)
integer,intent(out)              :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=merge(.false.,.true.,nint(double).eq.0)
end subroutine get_array_from_lala_logical
!===================================================================================================================================
subroutine get_array_from_lala_cmplx(varname,out,ierr)
character(len=*),intent(in)      :: varname
complex,allocatable,intent(out)  :: out(:,:)
doubleprecision,allocatable      :: double(:,:), doublei(:,:)
integer,intent(out)              :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(double,doublei,kind=sp)
end subroutine get_array_from_lala_cmplx
!===================================================================================================================================
subroutine get_array_from_lala_dpcmplx(varname,out,ierr)
character(len=*),intent(in)               :: varname
complex(kind=dp),allocatable,intent(out)  :: out(:,:)
doubleprecision,allocatable               :: double(:,:), doublei(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(double,doublei,kind=sp)
end subroutine get_array_from_lala_dpcmplx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_vector_from_lala_character(varname,out,ierr)
character(len=*),intent(in)              :: varname
character(len=:),allocatable,intent(out) :: out(:)
doubleprecision,allocatable              :: double(:,:)
integer,intent(out)                      :: ierr
integer                                  :: i,j
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(allocated(out))deallocate(out)
   allocate(character(len=size(double,dim=2)) :: out(size(double,dim=1)))
   do i=1,size(double,dim=1)
      do j=1,size(double,dim=2)
         out(i)(j:j)=achar(nint(double(i,j)))
      enddo
   enddo
end subroutine get_vector_from_lala_character
!===================================================================================================================================
subroutine get_vector_from_lala_int8(varname,out,ierr)
character(len=*),intent(in)                :: varname
integer(kind=int8),allocatable,intent(out) :: out(:)
doubleprecision,allocatable                :: double(:,:)
integer,intent(out)                        :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int8)
end subroutine get_vector_from_lala_int8
!===================================================================================================================================
subroutine get_vector_from_lala_int16(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int16),allocatable,intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int16)
end subroutine get_vector_from_lala_int16
!===================================================================================================================================
subroutine get_vector_from_lala_int32(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int32),allocatable,intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=nint(rowpack(double),kind=int32)
end subroutine get_vector_from_lala_int32
!===================================================================================================================================
subroutine get_vector_from_lala_int64(varname,out,ierr)
character(len=*),intent(in)                 :: varname
integer(kind=int64),allocatable,intent(out) :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=int64)
end subroutine get_vector_from_lala_int64
!===================================================================================================================================
subroutine get_vector_from_lala_real32(varname,out,ierr)
character(len=*),intent(in)               :: varname
real(kind=real32),allocatable,intent(out) :: out(:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real32)
end subroutine get_vector_from_lala_real32
!===================================================================================================================================
subroutine get_vector_from_lala_real64(varname,out,ierr)
character(len=*),intent(in)               :: varname
real(kind=real64),allocatable,intent(out) :: out(:)
doubleprecision,allocatable               :: double(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real64)
end subroutine get_vector_from_lala_real64
!===================================================================================================================================
subroutine get_vector_from_lala_real128(varname,out,ierr)
character(len=*),intent(in)                 :: varname
real(kind=real128),allocatable,intent(out)  :: out(:)
doubleprecision,allocatable                 :: double(:,:)
integer,intent(out)                         :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=real(rowpack(double),kind=real128)
end subroutine get_vector_from_lala_real128
!===================================================================================================================================
subroutine get_vector_from_lala_logical(varname,out,ierr)
character(len=*),intent(in)      :: varname
logical,allocatable,intent(out)  :: out(:)
doubleprecision,allocatable      :: double(:,:)
integer,intent(out)              :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   out=merge(.false.,.true.,nint(rowpack(double)).eq.0)
end subroutine get_vector_from_lala_logical
!===================================================================================================================================
subroutine get_vector_from_lala_cmplx(varname,out,ierr)
character(len=*),intent(in)      :: varname
complex,allocatable,intent(out)  :: out(:)
doubleprecision,allocatable      :: double(:,:), doublei(:,:)
integer,intent(out)              :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(rowpack(double),rowpack(doublei),kind=sp)
end subroutine get_vector_from_lala_cmplx
!===================================================================================================================================
subroutine get_vector_from_lala_dpcmplx(varname,out,ierr)
character(len=*),intent(in)               :: varname
complex(kind=dp),allocatable,intent(out)  :: out(:)
doubleprecision,allocatable               :: double(:,:), doublei(:,:)
integer,intent(out)                       :: ierr
   if(allocated(out))deallocate(out)
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   out=cmplx(rowpack(double),rowpack(doublei),kind=dp)
end subroutine get_vector_from_lala_dpcmplx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine get_scalar_from_lala_character(varname,out,ierr)
character(len=*),intent(in)              :: varname
character(len=:),allocatable,intent(out) :: out
doubleprecision,allocatable              :: double(:,:)
integer,intent(out)                      :: ierr
integer                                  :: i,j,k
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(allocated(out))deallocate(out)
   allocate(character(len=size(double)) :: out)
   k=0
   do i=1,size(double,dim=1)
      do j=1,size(double,dim=2)
         k=k+1
         out(k:k)=achar(nint(double(i,j)))
      enddo
   enddo
end subroutine get_scalar_from_lala_character
!===================================================================================================================================
subroutine get_scalar_from_lala_int8(varname,out,ierr)
character(len=*),intent(in)    :: varname
integer(kind=int8),intent(out) :: out
doubleprecision,allocatable    :: double(:,:)
integer,intent(out)            :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=nint(double(1,1),kind=int8)
end subroutine get_scalar_from_lala_int8
!===================================================================================================================================
subroutine get_scalar_from_lala_int16(varname,out,ierr)
character(len=*),intent(in)     :: varname
integer(kind=int16),intent(out) :: out
doubleprecision,allocatable     :: double(:,:)
integer,intent(out)             :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=nint(double(1,1),kind=int16)
end subroutine get_scalar_from_lala_int16
!===================================================================================================================================
subroutine get_scalar_from_lala_int32(varname,out,ierr)
character(len=*),intent(in)     :: varname
integer(kind=int32),intent(out) :: out
doubleprecision,allocatable     :: double(:,:)
integer,intent(out)             :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=nint(double(1,1),kind=int32)
end subroutine get_scalar_from_lala_int32
!===================================================================================================================================
subroutine get_scalar_from_lala_int64(varname,out,ierr)
character(len=*),intent(in)     :: varname
integer(kind=int64),intent(out) :: out
doubleprecision,allocatable     :: double(:,:)
integer,intent(out)             :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=real(double(1,1),kind=int64)
end subroutine get_scalar_from_lala_int64
!===================================================================================================================================
subroutine get_scalar_from_lala_real32(varname,out,ierr)
character(len=*),intent(in)   :: varname
real(kind=real32),intent(out) :: out
doubleprecision,allocatable   :: double(:,:)
integer,intent(out)           :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=real(double(1,1),kind=real32)
end subroutine get_scalar_from_lala_real32
!===================================================================================================================================
subroutine get_scalar_from_lala_real64(varname,out,ierr)
character(len=*),intent(in)   :: varname
real(kind=real64),intent(out) :: out
doubleprecision,allocatable   :: double(:,:)
integer,intent(out)           :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=real(double(1,1),kind=real64)
end subroutine get_scalar_from_lala_real64
!===================================================================================================================================
subroutine get_scalar_from_lala_real128(varname,out,ierr)
character(len=*),intent(in)    :: varname
real(kind=real128),intent(out) :: out
doubleprecision,allocatable    :: double(:,:)
integer,intent(out)            :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=real(double(1,1),kind=real128)
end subroutine get_scalar_from_lala_real128
!===================================================================================================================================
subroutine get_scalar_from_lala_logical(varname,out,ierr)
character(len=*),intent(in)   :: varname
logical,intent(out)           :: out
doubleprecision,allocatable   :: double(:,:)
integer,intent(out)           :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=merge(.false.,.true.,nint(double(1,1)).eq.0)
end subroutine get_scalar_from_lala_logical
!===================================================================================================================================
subroutine get_scalar_from_lala_cmplx(varname,out,ierr)
character(len=*),intent(in)   :: varname
complex,intent(out)           :: out
doubleprecision,allocatable   :: double(:,:), doublei(:,:)
integer,intent(out)           :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=cmplx(double(1,1),doublei(1,1),kind=sp)
end subroutine get_scalar_from_lala_cmplx
!===================================================================================================================================
subroutine get_scalar_from_lala_dpcmplx(varname,out,ierr)
character(len=*),intent(in)   :: varname
complex(kind=dp),intent(out)  :: out
doubleprecision,allocatable   :: double(:,:), doublei(:,:)
integer,intent(out)           :: ierr
   call get_double_from_lala(varname,double,type=0,ierr=ierr)
   call get_double_from_lala(varname,doublei,type=1,ierr=ierr)
   if(ierr.ne.0)return
   if(size(double).ne.1)call journal('sc','warning: returned scalar does not have size 1 but size',size(double))
   out=cmplx(double(1,1),doublei(1,1),kind=dp)
end subroutine get_scalar_from_lala_dpcmplx
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function too_much_memory(expression)
integer,intent(in) :: expression
logical            :: too_much_memory

! ident_35="@(#) too much memory required"

   G_ERR=expression
   if(G_ERR.gt.0)then
      call mat_err(17)
      too_much_memory=.true.
   else
      too_much_memory=.false.
   endif

end function too_much_memory
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function system_getenv(name,default) result(value)

! ident_36="@(#) M_system system_getenv(3f) call get_environment_variable as a function with a default value(3f)"

character(len=*),intent(in)          :: name
character(len=*),intent(in),optional :: default
integer                              :: howbig
integer                              :: stat
character(len=:),allocatable         :: value

   if(NAME.ne.'')then
      call get_environment_variable(name, length=howbig, status=stat, trim_name=.true.)  ! get length required to hold value
      if(howbig.ne.0)then
         select case (stat)
         case (1)     ! print *, NAME, " is not defined in the environment. Strange..."
            value=''
         case (2)     ! print *, "This processor doesn't support environment variables. Boooh!"
            value=''
         case default ! make string to hold value of sufficient size and get value
            if(allocated(value))deallocate(value)
            allocate(character(len=max(howbig,1)) :: VALUE)
            call get_environment_variable(name,value,status=stat,trim_name=.true.)
            if(stat.ne.0)VALUE=''
         end select
      else
         value=''
      endif
   else
      value=''
   endif
   if(value.eq.''.and.present(default))value=default

end function system_getenv
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
function mat_is_name(line) result (lout)
! determine if a string is a valid Fortran name ignoring trailing spaces
! (but not leading spaces)
character(len=*),parameter   :: int='0123456789'
character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'
character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
character(len=*),parameter   :: allowed=upper//lower//int//'_'//'%'
character(len=*),intent(in)  :: line
character(len=:),allocatable :: name
logical                      :: lout
        name=trim(line)
        if(len(name).ne.0)then
            lout = .true.                                  &
             & .and. verify(name(1:1), lower//upper) == 0  &
             & .and. verify(name,allowed) == 0             &
             & .and. len(name) <= 33
        else
            lout = .false.
        endif
end function mat_is_name
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine update(key,valin1,valin2,valin3)
character(len=*),intent(in)      :: key
integer,optional                 :: valin1,valin2,valin3
integer                          :: place
   if(present(valin1))then
      ! find where string is or should be
      call locate(keywords,key,place)
      ! if string was not found insert it
      if(place.lt.1)then
         call insert(keywords,key,iabs(place))
         call insert(rows,valin1,iabs(place))
         call insert(cols,valin2,iabs(place))
         call insert(locs,valin3,iabs(place))
      else
         call replace(rows,valin1,place)
         call replace(cols,valin2,place)
         call replace(locs,valin3,place)
      endif
   else
      call locate(keywords,key,place)
      if(place.gt.0)then
         call remove(keywords,place)
         call remove(rows,place)
         call remove(cols,place)
         call remove(locs,place)
      endif
   endif
end subroutine update

subroutine get(key,valout1,valout2,valout3)
character(len=*),intent(in)   :: key
integer                       :: valout1, valout2, valout3
integer                       :: place
! find where string is or should be
   call locate(keywords,key,place)
   if(place.lt.1)then
      valout1=-99999
      valout2=-99999
      valout3=-99999
   else
      valout1=rows(place)
      valout2=cols(place)
      valout3=locs(place)
   endif
end subroutine get
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_help_text()
G_HELP_TEXT=[ CHARACTER(LEN=128) :: &
'================================================================================',&
'LALA USERS'' GUIDE                                                              ',&
'                                                                                ',&
'                        LALA (May, 1981 - Apr, 2021)                            ',&
'                                                                                ',&
'   The Linear Algebra Fortran Facility (LALA) is a collection of Fortran        ',&
'   procedures that serves as a convenient tool for Fortran programs to          ',&
'   interact with their data (interactively or in batch mode) with a             ',&
'   tool that acts as a basic "laboratory" for computations involving            ',&
'   matrices.                                                                    ',&
'                                                                                ',&
'   It provides easy access to matrix software developed by the LINPACK          ',&
'   and EISPACK projects.                                                        ',&
'                                                                                ',&
'   It is based on the Los Alamos procedure MATLAB, and owes much to             ',&
'   Cleve Moler, Department of Computer Science, University of New Mexico.       ',&
'                                                                                ',&
'                            CONTENTS                                            ',&
'                                                                                ',&
'          -  Elementary operations                                              ',&
'          -  LALA functions                                                     ',&
'          -  Rows, columns and submatrices                                      ',&
'          -  "for", "while" and "if"                                            ',&
'          -  Characters, text, files and macros                                 ',&
'          -  The numerical algorithms                                           ',&
'          -  "flop" and "chop"                                                  ',&
'          -  Census example                                                     ',&
'          -  Partial differential equation example                              ',&
'          -  Eigenvalue sensitivity example                                     ',&
'          -  Communicating with other programs                                  ',&
'          -  Appendix  (The HELP file)                                          ',&
'                                                                                ',&
'   The capabilities range from standard tasks such as solving simultaneous      ',&
'   linear equations and inverting matrices, through symmetric and               ',&
'   nonsymmetric eigenvalue problems, to fairly sophisticated matrix             ',&
'   tools such as the singular value decomposition.                              ',&
'                                                                                ',&
'   LALA should be useful in applied linear algebra, as well as more             ',&
'   general numerical analysis, matrix theory, statistics and applications       ',&
'   of matrices to other disciplines.                                            ',&
'                                                                                ',&
'   LALA can serve as a "desk calculator" for the quick solution of small        ',&
'   problems involving matrices.                                                 ',&
'                                                                                ',&
'   The program is written in Fortran and is designed to be readily              ',&
'   installed under any operating system which permits interactive               ',&
'   execution of Fortran programs. The resources required are fairly             ',&
'   modest.                                                                      ',&
'                                                                                ',&
'   The size of the matrices that can be handled in LALA depends upon the        ',&
'   amount of storage available on the supporting platform and the optional      ',&
'   word count that can be supplied on an initial call to LALA(3f).              ',&
'                                                                                ',&
'   In some ways, LALA resembles SPEAKEASY [4] and, to a lesser extent,          ',&
'   APL. All are interactive terminal languages that ordinarily accept           ',&
'   single-line commands or statements, process them immediately, and print      ',&
'   the results. All have arrays or matrices as principal data types. But        ',&
'   for LALA, the matrix is the only data type (although scalars, vectors        ',&
'   and text are special cases), the underlying system is portable and           ',&
'   requires fewer resources, and the supporting subroutines are more            ',&
'   powerful and in some cases, have better numerical properties.                ',&
'                                                                                ',&
'   Together, LINPACK and EISPACK provide for powerful matrix                    ',&
'   computation. EISPACK is a package of over 70 Fortran subroutines for         ',&
'   various matrix eigenvalue computations that are based for the most           ',&
'   part on Algol procedures published by Wilkinson, Reinsch and their           ',&
'   colleagues [5]. LINPACK is a package of 40 Fortran subroutines (in           ',&
'   each of four data types) for solving and analyzing simultaneous linear       ',&
'   equations and related matrix problems. Since LALA is not primarily           ',&
'   concerned with either execution time efficiency or storage savings,          ',&
'   it ignores most of the special matrix properties that LINPACK and            ',&
'   EISPACK subroutines use to advantage. Consequently, only 8 subroutines       ',&
'   from LINPACK and 5 from EISPACK are actually involved.                       ',&
'                                                                                ',&
'   In more advanced applications, LALA can be used in conjunction with          ',&
'   other programs in several ways. It is possible to define new LALA            ',&
'   functions and add them to the system. It is possible to use the local        ',&
'   file system to pass matrices between LALA and other programs. LALA           ',&
'   command and statement input can be obtained from a local file instead        ',&
'   of from the terminal. The most power and flexibility is obtained by          ',&
'   using LALA as a subroutine which is called by other programs.                ',&
'                                                                                ',&
'   This document first gives an overview of LALA from the user''s               ',&
'   point of view. Several extended examples involving data fitting,             ',&
'   partial differential equations, eigenvalue sensitivity and other             ',&
'   topics are included. The system was designed and programmed using            ',&
'   techniques described by Wirth [6], implemented in nonrecursive,              ',&
'   portable Fortran. There is a brief discussion of some of the matrix          ',&
'   algorithms and of their numerical properties. A final section describes      ',&
'   how LALA can be used with other programs. The appendix includes the          ',&
'   HELP documentation available on-line.                                        ',&
'                                                                                ',&
'================================================================================',&
'ELEMENTARY OPERATIONS                                                           ',&
'                                                                                ',&
'   LALA works with essentially only one kind of object, a rectangular           ',&
'   matrix with complex elements. If the imaginary parts of the elements         ',&
'   are all zero, they are not printed, but they still occupy storage. In        ',&
'   some situations, special meaning is attached to 1 by 1 matrices,             ',&
'   that is scalars, and to 1 by n and m by 1 matrices, that is row and          ',&
'   column vectors.                                                              ',&
'                                                                                ',&
'   Matrices can be introduced into LALA in four different                       ',&
'   ways:                                                                        ',&
'                                                                                ',&
'           --  Explicit list of elements,                                       ',&
'           --  Use of "for" and "while" statements,                             ',&
'           --  Read from an external file,                                      ',&
'           --  Execute an external Fortran program.                             ',&
'                                                                                ',&
'   The explicit list is surrounded by angle brackets, ''<'' and ''>'' or        ',&
'   braces ''['' and '']'', and uses the semicolon '';'' to indicate the ends    ',&
'   of the rows. For example, the input line                                     ',&
'                                                                                ',&
'      A = <1 2 3; 4 5 6; 7 8 9>                                                 ',&
'                                                                                ',&
'   will result in the output                                                    ',&
'                                                                                ',&
'      A     =                                                                   ',&
'                                                                                ',&
'          1.    2.   3.                                                         ',&
'          4.    5.   6.                                                         ',&
'          7.    8.   9.                                                         ',&
'                                                                                ',&
'   The matrix A will be saved for later use. The individual elements            ',&
'   are separated by commas or blanks and can be any LALA expressions,           ',&
'   for example                                                                  ',&
'                                                                                ',&
'      x = < -1.3, 4/5, 4*atan(1) >                                              ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'      x     =                                                                   ',&
'                                                                                ',&
'        -1.3000   0.8000   3.1416                                               ',&
'                                                                                ',&
'   The elementary functions available include sqrt, log, exp, sin, cos,         ',&
'   atan, abs, round, real, imag, pow, and conjg.                                ',&
'                                                                                ',&
'   Large matrices can be spread across several input lines, with the            ',&
'   carriage returns replacing the semicolons. The above matrix could            ',&
'   also have been produced by                                                   ',&
'                                                                                ',&
'      A = < 1 2 3                                                               ',&
'            4 5 6                                                               ',&
'            7 8 9 >                                                             ',&
'                                                                                ',&
'   If the desired result is actually one row use line continuation              ',&
'                                                                                ',&
'       vector = < 1 2 3 ...                                                     ',&
'                  4 5 6 ...                                                     ',&
'                  7 8 9 >                                                       ',&
'                                                                                ',&
'   Matrices can be input from the local file system. Say a file named           ',&
'   ''xyz'' contains five lines of text,                                         ',&
'                                                                                ',&
'      A = <                                                                     ',&
'      1 2 3                                                                     ',&
'      4 5 6                                                                     ',&
'      7 8 9                                                                     ',&
'      >;                                                                        ',&
'                                                                                ',&
'   then the LALA statement exec(''xyz'') reads the matrix and assigns it        ',&
'   to A .                                                                       ',&
'                                                                                ',&
'   The "for" statement allows the generation of matrices whose elements         ',&
'   are given by simple formulas. Our example matrix A could also have           ',&
'   been produced by                                                             ',&
'                                                                                ',&
'      for i = 1:3, for j = 1:3, A(i,j) = 3*(i-1)+j;                             ',&
'                                                                                ',&
'   The semicolon at the end of the line suppresses the printing, which          ',&
'   in this case would have been nine versions of A with changing elements.      ',&
'                                                                                ',&
'   Several statements may be given on a line, separated by semicolons           ',&
'   or commas.                                                                   ',&
'                                                                                ',&
'   Two consecutive periods anywhere on a line indicate continuation. The        ',&
'   periods and any following characters are deleted, then another line          ',&
'   is input and concatenated onto the previous line.                            ',&
'                                                                                ',&
'   Two consecutive slashes anywhere on a line cause the remainder of            ',&
'   the line to be ignored. This is useful for inserting comments.               ',&
'                                                                                ',&
'   Names of variables are formed by a letter, followed by any of                ',&
'   letters, digits and underscores, up to 63 characters in length.              ',&
'                                                                                ',&
'   The special character prime ('') is used to denote the transpose of          ',&
'   a matrix, so                                                                 ',&
'                                                                                ',&
'      X = X''                                                                   ',&
'                                                                                ',&
'   changes the row vector above into the column vector                          ',&
'                                                                                ',&
'      X     =                                                                   ',&
'                                                                                ',&
'        -1.3000                                                                 ',&
'         0.8000                                                                 ',&
'         3.1416                                                                 ',&
'                                                                                ',&
'   Individual matrix elements may be referenced by enclosing their              ',&
'   subscripts in parentheses. When any element is changed, the entire           ',&
'   matrix is reprinted. For example, using the above matrix,                    ',&
'                                                                                ',&
'      B(3,3) = B(1,3) + B(3,1)                                                  ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'      B     =                                                                   ',&
'                                                                                ',&
'          1.    2.    3.                                                        ',&
'          4.    5.    6.                                                        ',&
'          7.    8.   10.                                                        ',&
'                                                                                ',&
'   Addition, subtraction and multiplication of matrices are denoted by          ',&
'   +, -, and * . The operations are performed whenever the matrices             ',&
'   have the proper dimensions. For example, with the above A and x,             ',&
'   the expressions A + X and X*A are incorrect because A is 3 by 3 and          ',&
'   X is now 3 by 1. However,                                                    ',&
'                                                                                ',&
'      B = A*B                                                                   ',&
'                                                                                ',&
'   is correct and results in the output                                         ',&
'                                                                                ',&
'      B     =                                                                   ',&
'                                                                                ',&
'         9.7248                                                                 ',&
'        17.6496                                                                 ',&
'        28.7159                                                                 ',&
'                                                                                ',&
'   Note that both upper and lower case letters are allowed for input            ',&
'   (on those systems which have both).                                          ',&
'                                                                                ',&
'   There are two "matrix division" symbols in LALA, \ and / . If A and          ',&
'   B are matrices, then A\B and B/A correspond formally to left and right       ',&
'   multiplication of B by the inverse of A, that is inv(A)*B and B*inv(A),      ',&
'   but the result is obtained directly without the computation of the           ',&
'   inverse. In the scalar case, 3\1 and 1/3 have the same value, namely         ',&
'   one-third. In general, A\B denotes the solution X to the equation A*X =      ',&
'   B and B/A denotes the solution to X*A = B.                                   ',&
'                                                                                ',&
'   Left division, A\B, is defined whenever B has as many rows as A. If A        ',&
'   is square, it is factored using Gaussian elimination. The factors are        ',&
'   used to solve the equations A*X(:,j) = B(:,j) where B(:,j) denotes the       ',&
'   j-th column of B. The result is a matrix X with the same dimensions          ',&
'   as B. If A is nearly singular (according to the LINPACK condition            ',&
'   estimator, RCOND(3f)), a warning message is printed. If A is not             ',&
'   square, it is factored using Householder orthogonalization with column       ',&
'   pivoting. The factors are used to solve the under- or overdetermined         ',&
'   equations in a least squares sense. The result is an M by N matrix X         ',&
'   where M is the number of columns of A and N is the number of columns         ',&
'   of B . Each column of X has at most K nonzero components, where K is         ',&
'   the effective rank of A .                                                    ',&
'                                                                                ',&
'   Right division, B/A, can be defined in terms of left division by B/A =       ',&
'   (A''\B'')''.                                                                 ',&
'                                                                                ',&
'   For example, since our vector b was computed as A*X, the statement           ',&
'                                                                                ',&
'      Y = A\B                                                                   ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'      Y     =                                                                   ',&
'                                                                                ',&
'        -1.3000                                                                 ',&
'         0.8000                                                                 ',&
'         3.1416                                                                 ',&
'                                                                                ',&
'   Of course, Y is not exactly equal to X because of the roundoff errors        ',&
'   involved in both A*X and A\B , but we are not printing enough digits         ',&
'   to see the difference. The result of the statement                           ',&
'                                                                                ',&
'      E = X - Y                                                                 ',&
'                                                                                ',&
'   depends upon the particular computer being used. In one case it              ',&
'   produces                                                                     ',&
'                                                                                ',&
'      E     =                                                                   ',&
'                                                                                ',&
'         1.0e-15 *                                                              ',&
'                                                                                ',&
'           .3053                                                                ',&
'          -.2498                                                                ',&
'           .0000                                                                ',&
'                                                                                ',&
'   The quantity 1.0e-15 is a scale factor which multiplies all the              ',&
'   components which follow. Thus our vectors X and Y actually agree to          ',&
'   about 15 decimal places on this computer.                                    ',&
'                                                                                ',&
'   It is also possible to obtain element-by-element multiplicative              ',&
'   operations. If A and B have the same dimensions, then A .* B denotes         ',&
'   the matrix whose elements are simply the products of the individual          ',&
'   elements of A and B . The expressions A ./ B and A .\ B give the             ',&
'   quotients of the individual elements.                                        ',&
'                                                                                ',&
'   There are several possible output formats. The statement                     ',&
'                                                                                ',&
'      long, X                                                                   ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'      X     =                                                                   ',&
'                                                                                ',&
'         -1.300000000000000                                                     ',&
'           .800000000000000                                                     ',&
'          3.141592653589793                                                     ',&
'                                                                                ',&
'   The statement                                                                ',&
'                                                                                ',&
'      short                                                                     ',&
'                                                                                ',&
'   restores the original format.                                                ',&
'                                                                                ',&
'   The expression A**p means A to the p-th power. It is                         ',&
'   defined if A is a square matrix and p is a scalar. If p is an                ',&
'   integer greater than one, the power is computed by repeated                  ',&
'   multiplication. For other values of p the calculation involves               ',&
'   the eigenvalues and eigenvectors of A.                                       ',&
'                                                                                ',&
'   Previously defined matrices and matrix expressions can be                    ',&
'   used inside brackets to generate larger matrices. If conformable             ',&
'   arrays can be concatenated top-to-bottom or left-to-right.                   ',&
'                                                                                ',&
'       a=[0:3;4:7]                                                              ',&
'       a  =                                                                     ',&
'           0.    1.    2.    3.                                                 ',&
'           4.    5.    6.    7.                                                 ',&
'                                                                                ',&
'       b=[ 8  9 10 11                                                           ',&
'          12 13 14 15 ];                                                        ',&
'                                                                                ',&
'       c=<a;b> // top to bottom with semi-colon                                 ',&
'       c  =                                                                     ',&
'           0.    1.    2.    3.                                                 ',&
'           4.    5.    6.    7.                                                 ',&
'           8.    9.   10.   11.                                                 ',&
'          12.   13.   14.   15.                                                 ',&
'                                                                                ',&
'       d=<b;a>                                                                  ',&
'       d  =                                                                     ',&
'           8.    9.   10.   11.                                                 ',&
'          12.   13.   14.   15.                                                 ',&
'           0.    1.    2.    3.                                                 ',&
'           4.    5.    6.    7.                                                 ',&
'                                                                                ',&
'       e=<c,d> // left to right with comma                                      ',&
'       e  =                                                                     ',&
'           0.    1.    2.    3.    8.    9.   10.   11.                         ',&
'           4.    5.    6.    7.   12.   13.   14.   15.                         ',&
'           8.    9.   10.   11.    0.    1.    2.    3.                         ',&
'          12.   13.   14.   15.    4.    5.    6.    7.                         ',&
'                                                                                ',&
'   A more complex example is                                                    ',&
'                                                                                ',&
'      C = <A, B; <4 2 0>*X, X''>                                                ',&
'                                                                                ',&
'   which results in                                                             ',&
'                                                                                ',&
'      C     =                                                                   ',&
'                                                                                ',&
'         1.0000   2.0000   3.0000   9.7248                                      ',&
'         4.0000   5.0000   6.0000  17.6496                                      ',&
'         7.0000   8.0000  10.0000  28.7159                                      ',&
'        -3.6000  -1.3000   0.8000   3.1416                                      ',&
'                                                                                ',&
'   There are four predefined variables, "eps", "flop", "rand" and               ',&
'   "eye". The variable "eps" is used as a tolerance is determining such         ',&
'   things as near singularity and rank. Its initial value is the distance       ',&
'   from 1.0 to the next largest floating point number on the particular         ',&
'   computer being used. The user may reset this to any other value,             ',&
'   including zero. "eps" is changed by "chop", which is described later         ',&
'   in this manual.                                                              ',&
'                                                                                ',&
'   The value of "rand" is a random variable using a uniform distribution.       ',&
'                                                                                ',&
'   The name "eye" is used in place of "i" to denote identity matrices           ',&
'   because "i" is often used as a subscript or as sqrt(-1). The dimensions      ',&
'   of "eye" are determined by context. For example,                             ',&
'                                                                                ',&
'      B = A + 3*eye                                                             ',&
'                                                                                ',&
'   adds 3 to the diagonal elements of A and                                     ',&
'                                                                                ',&
'      X = eye/A                                                                 ',&
'                                                                                ',&
'   is one of several ways in LALA to invert a matrix.                           ',&
'                                                                                ',&
'   "flop" provides a measure of the number of floating point operations,        ',&
'   or "flops", required for each calculation by reporting the CPU time          ',&
'   consumed.                                                                    ',&
'                                                                                ',&
'   A statement may consist of an expression alone, in which case a              ',&
'   variable named "ans" is created and the result stored in "ans" for           ',&
'   possible future use. Thus                                                    ',&
'                                                                                ',&
'      A\A - eye                                                                 ',&
'                                                                                ',&
'   is the same as                                                               ',&
'                                                                                ',&
'      ans = A\A - eye                                                           ',&
'                                                                                ',&
'   (Roundoff error usually causes this result to be a matrix of "small"         ',&
'   numbers, rather than all zeros.)                                             ',&
'                                                                                ',&
'   All computations are done using double precision real arithmetic. There      ',&
'   is no mixed-precision arithmetic. The Fortran COMPLEX data type              ',&
'   is not used because many systems create unnecessary underflows and           ',&
'   overflows with complex operations.                                           ',&
'                                                                                ',&
'================================================================================',&
'FUNCTIONS                                                                       ',&
'                                                                                ',&
'   Much of LALA''s computational power comes from the various                   ',&
'   matrix functions available. The current list includes:                       ',&
'                                                                                ',&
'      inv(A)           - Inverse.                                               ',&
'      det(A)           - Determinant.                                           ',&
'      cond(A)          - Condition number.                                      ',&
'      rcond(A)         - A measure of nearness to singularity.                  ',&
'      eig(A)           - Eigenvalues and eigenvectors.                          ',&
'      schur(A)         - Schur triangular form.                                 ',&
'      hess(A)          - Hessenberg or tridiagonal form.                        ',&
'      poly(A)          - Characteristic polynomial.                             ',&
'      svd(A)           - Singular value decomposition.                          ',&
'      pinv(A,eps)      - Pseudo-inverse with optional tolerance.                ',&
'      rank(A,eps)      - Matrix rank with optional tolerance.                   ',&
'      lu(A)            - Factors from Gaussian elimination.                     ',&
'      chol(A)          - Factor from Cholesky factorization.                    ',&
'      qr(A)            - Factors from Householder orthogonalization.            ',&
'      rref(A)          - Reduced row echelon form.                              ',&
'      orth(A)          - Orthogonal vectors spanning range of A.                ',&
'      exp(A)           - e to the A.                                            ',&
'      log(A)           - Natural logarithm.                                     ',&
'      sqrt(A)          - Square root.                                           ',&
'      pow(A)           - raise the elements by a power                          ',&
'      sin(A)           - Trigonometric sine.                                    ',&
'      cos(A)           - Cosine.                                                ',&
'      atan(A)          - Arctangent.                                            ',&
'      round(A)         - Round the elements to nearest integers.                ',&
'      abs(A)           - Absolute value of the elements.                        ',&
'      real(A)          - Real parts of the elements.                            ',&
'      imag(A)          - Imaginary parts of the elements.                       ',&
'      conjg(A)         - Complex conjugate.                                     ',&
'      sum(A)           - Sum of the elements.                                   ',&
'      prod(A)          - Product of the elements.                               ',&
'      diag(A)          - Extract or create diagonal matrices.                   ',&
'      tril(A)          - Lower triangular part of A.                            ',&
'      triu(A)          - Upper triangular part of A.                            ',&
'      norm(A,p)        - Norm with p = 1, 2 or ''Infinity''.                    ',&
'      eye(m,n)         - Portion of identity matrix.                            ',&
'      randu(m,n)       - Matrix with uniformly distributed random elements.     ',&
'      randn(m,n)       - Matrix with normally distributed random elements.      ',&
'      ones(m,n)        - Matrix of all ones.                                    ',&
'      magic(n)         - Interesting test matrices.                             ',&
'      invh(n)          - Inverse Hilbert matrices.                              ',&
'      roots(C)         - Roots of polynomial with coefficients C.               ',&
'      display(A,p)     - Print base p representation of A.                      ',&
'      kron(A,B)        - Kronecker tensor product of A and B.                   ',&
'      plot(X,Y)        - Plot Y as a function of X .                            ',&
'      rat(A)           - Find "simple" rational approximation to A.             ',&
'      reshape(A,[m,n]) - Reshape an array                                       ',&
'      maxval(A)        - maximum real component of array A                      ',&
'      minval(A)        - minimum real component of array A                      ',&
'      user(A)          - Function defined by external program.                  ',&
'      pack(A,mask)     - Pack selected array elements into a vector             ',&
'                                                                                ',&
'      fmtc|fmti|fmtr(A,f)    - convert numbers to strings                       ',&
'      lt|le|eq|ge|gt|ne(A,B) - relational operators                             ',&
'                                                                                ',&
'   Some of these functions have different interpretations when the              ',&
'   argument is a matrix or a vector and some of them have additional            ',&
'   optional arguments. Details are given in the HELP document in the            ',&
'   appendix.                                                                    ',&
'                                                                                ',&
'   Several of these functions can be used in a generalized assignment           ',&
'   statement with two or three variables on the left hand side. For             ',&
'   example                                                                      ',&
'                                                                                ',&
'      <X,D> = eig(A)                                                            ',&
'                                                                                ',&
'   stores the eigenvectors of A in the matrix X and a diagonal matrix           ',&
'   containing the eigenvalues in the matrix D. The statement                    ',&
'                                                                                ',&
'      eig(A)                                                                    ',&
'                                                                                ',&
'   simply computes the eigenvalues and stores them in "ans".                    ',&
'                                                                                ',&
'   Future versions of LALA will probably include additional functions,          ',&
'   since they can easily be added to the system.                                ',&
'                                                                                ',&
'================================================================================',&
'ROWS COLUMNS AND SUBMATRICES                                                    ',&
'                                                                                ',&
'   Individual elements of a matrix can be accessed by giving their              ',&
'   subscripts in parentheses, eg. A(1,2), x(i), TAB(ind(k)+1).                  ',&
'   An expression used as a subscript is rounded to the nearest integer.         ',&
'                                                                                ',&
'   Individual rows and columns can be accessed using a colon '':'' (or a        ',&
'   ''|'') for the free subscript. For example, A(1,:) is the first row of       ',&
'   A and A(:,j) is the j-th column. Thus                                        ',&
'                                                                                ',&
'      A(i,:) = A(i,:) + c*A(k,:)                                                ',&
'                                                                                ',&
'   adds c times the k-th row of A to the i-th row.                              ',&
'                                                                                ',&
'   The colon is used in several other ways in LALA, but all of the uses         ',&
'   are based on the following definition.                                       ',&
'                                                                                ',&
'      j:k    is the same as  <j, j+1, ..., k>                                   ',&
'      j:k    is empty if  j > k .                                               ',&
'      j:i:k  is the same as  <j, j+i, j+2i, ..., k>                             ',&
'      j:i:k  is empty if  i > 0 and j > k or if i < 0 and j < k .               ',&
'                                                                                ',&
'   The colon is usually used with integers, but it is possible to               ',&
'   use arbitrary real scalars as well. Thus                                     ',&
'                                                                                ',&
'      1:4  is the same as  <1, 2, 3, 4>                                         ',&
'      0: 0.1: 0.5 is the same as <0.0, 0.1, 0.2, 0.3, 0.4, 0.5>                 ',&
'                                                                                ',&
'   In general, a subscript can be a vector. If X and V are vectors,             ',&
'   then X(V) is <X(V(1)), X(V(2)), ..., X(V(n))> . This can also be             ',&
'   used with matrices. If V has m components and W has n components,            ',&
'   then A(V,W) is the m by n matrix formed from the elements of A whose         ',&
'   subscripts are the elements of V and W. Combinations of the colon            ',&
'   notation and the indirect subscripting allow manipulation of various         ',&
'   submatrices. For example,                                                    ',&
'                                                                                ',&
'      A(<1,5>,:) = A(<5,1>,:)  interchanges rows 1 and 5 of A.                  ',&
'      A(2:k,1:n)  is the submatrix formed from rows 2 through k                 ',&
'         and columns 1 through n of A .                                         ',&
'      A(:,<3 1 2>)  is a permutation of the first three columns.                ',&
'                                                                                ',&
'   The notation A(:) has a special meaning. On the right hand side of an        ',&
'   assignment statement, it denotes all the elements of A, regarded as          ',&
'   a single column. When an expression is assigned to A(:), the current         ',&
'   dimensions of A, rather than of the expression, are used.                    ',&
'                                                                                ',&
'================================================================================',&
'FOR WHILE AND IF                                                                ',&
'                                                                                ',&
'   The "for" clause allows statements to be repeated a specific                 ',&
'   number of times. The general form is                                         ',&
'                                                                                ',&
'      for variable = expr, statement, ..., statement, end                       ',&
'                                                                                ',&
'   The "end" and the comma before it may be omitted. In general, the            ',&
'   expression may be a matrix, in which case the columns are stored one         ',&
'   at a time in the variable and the following statements, up to the            ',&
'   "end" or the end of the line, are executed. The expression is often          ',&
'   of the form j:k, and its "columns" are simply the scalars from j to          ',&
'   k. Some examples (assume n has already been assigned a value):               ',&
'                                                                                ',&
'      for i = 1:n, for j = 1:n, A(i,j) = 1/(i+j-1);                             ',&
'                                                                                ',&
'   generates the Hilbert matrix.                                                ',&
'                                                                                ',&
'      for j = 2:n-1, for i = j:n-1, ...                                         ',&
'         A(i,j) = 0; end; A(j,j) = j; end; A                                    ',&
'                                                                                ',&
'   changes all but the "outer edge" of the lower triangle and then              ',&
'   prints the final matrix.                                                     ',&
'                                                                                ',&
'      for h = 1.0: -0.1: -1.0, (<h, cos(pi*h)>)                                 ',&
'                                                                                ',&
'   prints a table of cosines.                                                   ',&
'                                                                                ',&
'      <X,D> = eig(A); for v = X, v, A*v                                         ',&
'                                                                                ',&
'   displays eigenvectors, one at a time.                                        ',&
'                                                                                ',&
'        The "while" clause allows statements to be repeated an                  ',&
'   indefinite number of times. The general form is                              ',&
'                                                                                ',&
'      while expr relop expr,   statement,..., statement, end                    ',&
'                                                                                ',&
'   where relop is =, <, >, <=, >=, or <> (not equal). The statements are        ',&
'   repeatedly executed as long as the indicated comparison between the          ',&
'   real parts of the first components of the two expressions is true. Here      ',&
'   are two examples. (Exercise for the reader: What do these segments do?)      ',&
'                                                                                ',&
'      eps = 1;                                                                  ',&
'      while 1 + eps > 1, eps = eps/2;                                           ',&
'      eps = 2*eps                                                               ',&
'                                                                                ',&
'      E = 0*A;  F = E + eye; n = 1;                                             ',&
'      while norm(E+F-E,1) > 0, E = E + F; F = A*F/n; n = n + 1;                 ',&
'      E                                                                         ',&
'                                                                                ',&
'   The IF clause allows conditional execution of statements. The general        ',&
'   form is                                                                      ',&
'                                                                                ',&
'      if expr relop expr,  statement, ..., statement,                           ',&
'         else statement, ..., statement                                         ',&
'                                                                                ',&
'   The first group of statements are executed if the relation is true and       ',&
'   the second group are executed if the relation is false. The "else"           ',&
'   and the statements following it may be omitted. For example,                 ',&
'                                                                                ',&
'      if abs(i-j) = 2, A(i,j) = 0;                                              ',&
'                                                                                ',&
'================================================================================',&
'CHARACTERS AND TEXTFILES AND MACROS                                             ',&
'                                                                                ',&
'   LALA has several commands which control the output format and the            ',&
'   overall execution of the system.                                             ',&
'                                                                                ',&
'   The "help" command allows on-line access to short portions of text           ',&
'   describing various operations, functions and special characters. The         ',&
'   entire "help" document is reproduced in an appendix.                         ',&
'                                                                                ',&
'   Results are usually printed in a scaled fixed point format that shows        ',&
'   4 or 5 significant figures. The commands "short", "long", "short e",         ',&
'   "long e" and "long z" alter the output format, but do not alter the          ',&
'   precision of the computations or the internal storage.                       ',&
'                                                                                ',&
'   The "who" command provides information about the functions and               ',&
'   variables that are currently defined.                                        ',&
'                                                                                ',&
'   The "clear" command erases all variables, except "eps", "flop",              ',&
'   "rand" and "eye". The statement A = <> indicates that a "0 by 0"             ',&
'   matrix is to be stored in A. This causes A to be erased so that its          ',&
'   storage can be used for other variables.                                     ',&
'                                                                                ',&
'   The "quit" and "exit" commands cause return to the underlying operating      ',&
'   system through the Fortran RETURN statement.                                 ',&
'                                                                                ',&
'   LALA has a limited facility for handling text. Any string of characters      ',&
'   delineated by quotes (with two quotes used to allow one quote within         ',&
'   the string) is saved as a vector of integer values that are the ADE          ',&
'   (Ascii Decimal Equivalent) value of the character, with special              ',&
'   equivalencing of the characters {}[]" into ()<>'' in expressions. It         ',&
'   is important to know you use those characters as part of an expression       ',&
'   or command without treating them as equivalent outside of strings.           ',&
'                                                                                ',&
'   (The complete list is in the appendix under "CHAR".) For example             ',&
'                                                                                ',&
'      ''2*A + 3''  is the same as  < 50 42 65 32 43 32 51 >.                    ',&
'                                                                                ',&
'   It is possible, though seldom very meaningful, to use such                   ',&
'   strings in matrix operations. More frequently, the text is used              ',&
'   as a special argument to various functions.                                  ',&
'                                                                                ',&
'      norm(A,''inf'')    computes the infinity norm of A .                      ',&
'      display(T)       prints the text stored in T .                            ',&
'      exec(''file'')     obtains LALA input from an external file.              ',&
'      save(''file'')     stores all the current variables in a file.            ',&
'      load(''file'')     retrieves all the variables from a file.               ',&
'      print(''file'',X)  prints X on a file.                                    ',&
'      diary(''file'')    makes a copy of the complete LALA session.             ',&
'                                                                                ',&
'   The text can also be used in a limited string substitution                   ',&
'   macro facility. If a variable, say T, contains the source text               ',&
'   for a LALA statement or expression, then the construction                    ',&
'                                                                                ',&
'      > T <                                                                     ',&
'                                                                                ',&
'   causes T to be executed or evaluated. For example                            ',&
'                                                                                ',&
'      T = ''2*A + 3'';                                                          ',&
'      S = ''B = >T< + 5''                                                       ',&
'      A = 4;                                                                    ',&
'      > S <                                                                     ',&
'                                                                                ',&
'   produces                                                                     ',&
'                                                                                ',&
'      B     =                                                                   ',&
'                                                                                ',&
'         16.                                                                    ',&
'                                                                                ',&
'   Some other examples are given under MACROS in the appendix. This             ',&
'   facility is useful for fairly short statements and expressions.              ',&
'   More complicated LALA "programs" should use the "exec" facility.             ',&
'                                                                                ',&
'================================================================================',&
'NUMERICAL ALGORITHMS                                                            ',&
'                                                                                ',&
'   The algorithms underlying the basic LALA functions are described in          ',&
'   the LINPACK and EISPACK guides [1-3]. The following list gives the           ',&
'   subroutines used by these functions.                                         ',&
'                                                                                ',&
'      inv(A)          - CGECO,CGEDI                                             ',&
'      det(A)          - CGECO,CGEDI                                             ',&
'      lu(A)           - CGEFA                                                   ',&
'      rcond(A)        - CGECO                                                   ',&
'      chol(A)         - CPOFA                                                   ',&
'      svd(A)          - CSVDC                                                   ',&
'      cond(A)         - CSVDC                                                   ',&
'      norm(A,2)       - CSVDC                                                   ',&
'      pinv(A,eps)     - CSVDC                                                   ',&
'      rank(A,eps)     - CSVDC                                                   ',&
'      qr(A)           - CQRDC,CQRSL                                             ',&
'      orth(A)         - CQRDC,CSQSL                                             ',&
'      A\B and B/A     - CGECO,CGESL if A is square.                             ',&
'                      - CQRDC,CQRSL if A is not square.                         ',&
'      eig(A)          - HTRIDI,IMTQL2,HTRIBK if A is Hermitian.                 ',&
'                      - CORTH,COMQR2         if A is not Hermitian.             ',&
'      schur(A)        - same as EIG.                                            ',&
'      hess(A)         - same as EIG.                                            ',&
'                                                                                ',&
'   Minor modifications were made to all these subroutines. The LINPACK          ',&
'   routines were changed to replace the Fortran complex arithmetic              ',&
'   with explicit references to real and imaginary parts. Since most             ',&
'   of the floating point arithmetic is concentrated in a few low-level          ',&
'   subroutines which perform vector operations (the Basic Linear Algebra        ',&
'   Subprograms), this was not an extensive change. It also facilitated          ',&
'   implementation of the "flop" and "chop" features which count and             ',&
'   optionally truncate each floating point operation.                           ',&
'                                                                                ',&
'   The EISPACK subroutine COMQR2 was modified to allow access to the            ',&
'   Schur triangular form, ordinarily just an intermediate result. IMTQL2        ',&
'   was modified to make computation of the eigenvectors optional. Both          ',&
'   subroutines were modified to eliminate the machine-dependent accuracy        ',&
'   parameter and all the EISPACK subroutines were changed to include            ',&
'   "flop" and "chop".                                                           ',&
'                                                                                ',&
'   The algorithms employed for the "poly" and "roots" functions                 ',&
'   illustrate an interesting aspect of the modern approach to eigenvalue        ',&
'   computation. "poly(A)" generates the characteristic polynomial of            ',&
'   A and "roots(poly(A))" finds the roots of that polynomial, which             ',&
'   are, of course, the eigenvalues of A . But both "poly" and "roots"           ',&
'   use EISPACK eigenvalues subroutines, which are based on similarity           ',&
'   transformations. So the classical approach which characterizes               ',&
'   eigenvalues as roots of the characteristic polynomial is actually            ',&
'   reversed.                                                                    ',&
'                                                                                ',&
'   If A is an n by n matrix, "poly(A)" produces the coefficients C(1)           ',&
'   through C(n+1), with C(1) = 1, in                                            ',&
'                                                                                ',&
'         det(z*eye-A) = C(1)*z**n + ... + C(n)*z + C(n+1) .                     ',&
'                                                                                ',&
'   The algorithm can be expressed compactly using LALA:                         ',&
'                                                                                ',&
'         Z = eig(A);                                                            ',&
'         C = 0*ones(n+1,1);  C(1) = 1;                                          ',&
'         for j = 1:n, C(2:j+1) = C(2:j+1) - Z(j)*C(1:j);                        ',&
'         C                                                                      ',&
'                                                                                ',&
'   This recursion is easily derived by expanding the product                    ',&
'                                                                                ',&
'         (z - z(1))*(z - z(2))* ... * (z-z(n)) .                                ',&
'                                                                                ',&
'   It is possible to prove that "poly(A)" produces the coefficients in          ',&
'   the characteristic polynomial of a matrix within roundoff error of           ',&
'   A. This is true even if the eigenvalues of A are badly conditioned. The      ',&
'   traditional algorithms for obtaining the characteristic polynomial           ',&
'   which do not use the eigenvalues do not have such satisfactory               ',&
'   numerical properties.                                                        ',&
'                                                                                ',&
'   If C is a vector with n+1 components, "roots(C)" finds the roots of          ',&
'   the polynomial of degree n ,                                                 ',&
'                                                                                ',&
'          p(z) = C(1)*z**n + ... + C(n)*z + C(n+1) .                            ',&
'                                                                                ',&
'   The algorithm simply involves computing the eigenvalues of the               ',&
'   companion matrix:                                                            ',&
'                                                                                ',&
'         A = 0*ones(n,n)                                                        ',&
'         for j = 1:n, A(1,j) = -C(j+1)/C(1);                                    ',&
'         for i = 2:n, A(i,i-1) = 1;                                             ',&
'         eig(A)                                                                 ',&
'                                                                                ',&
'   It is possible to prove that the results produced are the exact              ',&
'   eigenvalues of a matrix within roundoff error of the companion matrix        ',&
'   A, but this does not mean that they are the exact roots of a polynomial      ',&
'   with coefficients within roundoff error of those in C . There are            ',&
'   more accurate, more efficient methods for finding polynomial roots,          ',&
'   but this approach has the crucial advantage that it does not require         ',&
'   very much additional code.                                                   ',&
'                                                                                ',&
'   The elementary functions "exp", "log", "sqrt", "sin", "cos" and "atan"       ',&
'   are applied to square matrices by diagonalizing the matrix, applying         ',&
'   the functions to the individual eigenvalues and then transforming            ',&
'   back. For example, "exp(A)" is computed by                                   ',&
'                                                                                ',&
'         <X,D> = eig(A);                                                        ',&
'         for j = 1:n, D(j,j) = exp(D(j,j));                                     ',&
'         X*D/X                                                                  ',&
'                                                                                ',&
'   This is essentially method number 14 out of the 19 ''dubious''               ',&
'   possibilities described in [8]. It is dubious because it doesn''t always     ',&
'   work. The matrix of eigenvectors X can be arbitrarily badly conditioned      ',&
'   and all accuracy lost in the computation of X*D/X. A warning message         ',&
'   is printed if "rcond(X)" is very small, but this only catches the            ',&
'   extreme cases. An example of a case not detected is when A has a double      ',&
'   eigenvalue, but theoretically only one linearly independent eigenvector      ',&
'   associated with it. The computed eigenvalues will be separated by            ',&
'   something on the order of the square root of the roundoff level. This        ',&
'   separation will be reflected in "rcond(X)" which will probably not           ',&
'   be small enough to trigger the error message. The computed "exp(A)"          ',&
'   will be accurate to only half precision. Better methods are known for        ',&
'   computing "exp(A)", but they do not easily extend to the other five          ',&
'   functions and would require a considerable amount of additional code.        ',&
'                                                                                ',&
'   The expression A**p is evaluated by repeated multiplication if p is          ',&
'   an integer greater than 1. Otherwise it is evaluated by                      ',&
'                                                                                ',&
'         <X,D> = eig(A);                                                        ',&
'         for j = 1:n, D(j,j) = exp(p*log(D(j,j)))                               ',&
'         X*D/X                                                                  ',&
'                                                                                ',&
'   This suffers from the same potential loss of accuracy if X is                ',&
'   badly conditioned. It was partly for this reason that the case p =           ',&
'   1 is included in the general case. Comparison of A**1 with A gives           ',&
'   some idea of the loss of accuracy for other values of p and for the          ',&
'   elementary functions.                                                        ',&
'                                                                                ',&
'   "rref", the reduced row echelon form, is of some interest in                 ',&
'   theoretical linear algebra, although it has little computational             ',&
'   value. It is included in LALA for pedagogical reasons. The algorithm         ',&
'   is essentially Gauss-Jordan elimination with detection of negligible         ',&
'   columns applied to rectangular matrices.                                     ',&
'                                                                                ',&
'   There are three separate places in LALA where the rank of a matrix           ',&
'   is implicitly computed: in rref(A), in A\B for non-square A, and             ',&
'   in the pseudoinverse pinv(A). Three different algorithms with three          ',&
'   different criteria for negligibility are used and so it is possible          ',&
'   that three different values could be produced for the same matrix. With      ',&
'   rref(A), the rank of A is the number of nonzero rows. The elimination        ',&
'   algorithm used for "rref" is the fastest of the three rank-determining       ',&
'   algorithms, but it is the least sophisticated numerically and the            ',&
'   least reliable. With A\B, the algorithm is essentially that used             ',&
'   by example subroutine SQRST in chapter 9 of the LINPACK guide. With          ',&
'   pinv(A), the algorithm is based on the singular value decomposition          ',&
'   and is described in chapter 11 of the LINPACK guide. The SVD algorithm       ',&
'   is the most time-consuming, but the most reliable and is therefore           ',&
'   also used for rank(A).                                                       ',&
'                                                                                ',&
'   The uniformly distributed random numbers in "rand" and "randu"are            ',&
'   obtained from the machine-independent random number generator URAND          ',&
'   described in [9]. It is possible to use normally distributed random          ',&
'   numbers using "randn", which are obtained using a transformation also        ',&
'   described in [9].                                                            ',&
'                                                                                ',&
'   The computation of                                                           ',&
'                                                                                ',&
'         sqrt( a**2 + b**2 )                                                    ',&
'                                                                                ',&
'   is required in many matrix algorithms, particularly those involving          ',&
'   complex arithmetic. A new approach to carrying out this operation is         ',&
'   described by Moler and Morrison [10]. It is a cubically convergent           ',&
'   algorithm which starts with a and b , rather than with their squares,        ',&
'   and thereby avoids destructive arithmetic underflows and overflows. In       ',&
'   LALA, the algorithm is used for complex modulus, Euclidean vector            ',&
'   norm, plane rotations, and the shift calculation in the eigenvalue           ',&
'   and singular value iterations.                                               ',&
'                                                                                ',&
'================================================================================',&
'FLOP AND CHOP                                                                   ',&
'                                                                                ',&
'   Detailed information about the amount of work involved in matrix             ',&
'   calculations and the resulting accuracy is provided by "flop" and            ',&
'   "chop". The basic unit of work is the "flop", or floating point              ',&
'   operation. Roughly, one flop is one execution of a Fortran statement         ',&
'   like                                                                         ',&
'                                                                                ',&
'         S = S + X(I)*Y(I)                                                      ',&
'                                                                                ',&
'   or                                                                           ',&
'                                                                                ',&
'         Y(I) = Y(I) + T*X(I)                                                   ',&
'                                                                                ',&
'   In other words, it consists of one floating point multiplication,            ',&
'   together with one floating point addition and the associated                 ',&
'   indexing and storage reference operations.                                   ',&
'                                                                                ',&
'   LALA will print the CPU time required for a particular                       ',&
'   statement when the statement is terminated by an extra comma. For            ',&
'   example, the line                                                            ',&
'                                                                                ',&
'         n = 20;  randu(n)*randu(n);,                                           ',&
'                                                                                ',&
'   ends with an extra comma. Two 20 by 20 random matrices are generated         ',&
'   and multiplied together. The result is assigned to "ans", but the            ',&
'   semicolon suppresses its printing. The only output is                        ',&
'                                                                                ',&
'           8800 flops                                                           ',&
'                                                                                ',&
'   This is n**3 + 2*n**2 flops, n**2 for each random matrix and n**3            ',&
'   for the product.                                                             ',&
'                                                                                ',&
'   "flop" is a predefined vector with two components. "flop(1)" is              ',&
'   the number of flops used by the most recently executed statement,            ',&
'   except that statements with zero flops are ignored. For example,             ',&
'   after executing the previous statement,                                      ',&
'                                                                                ',&
'         flop(1)/n**3                                                           ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'         ans   =                                                                ',&
'                                                                                ',&
'             1.1000                                                             ',&
'                                                                                ',&
'   "flop(2)" is the cumulative total of all the flops used since                ',&
'   the beginning of the LALA session. The statement                             ',&
'                                                                                ',&
'         flop = <0 0>                                                           ',&
'                                                                                ',&
'   resets the total.                                                            ',&
'                                                                                ',&
'   There are several difficulties associated with keeping a                     ',&
'   precise count of floating point operations.                                  ',&
'                                                                                ',&
'   As the program generally uses complex values but only performs               ',&
'   operations on the real matrices in many cases where all the imaginary        ',&
'   values are zero it may not provide an accurate measure of the relative       ',&
'   costs of real and complex arithmetic.                                        ',&
'                                                                                ',&
'   The result of each floating point operation may also be "chopped"            ',&
'   to simulate a computer with a shorter word length. The details               ',&
'   of this chopping operation depend upon the format of the floating            ',&
'   point word. Usually, the fraction in the floating point word can be          ',&
'   regarded as consisting of several octal or hexadecimal digits. The           ',&
'   least significant of these digits can be set to zero by a logical            ',&
'   masking operation. Thus the statement                                        ',&
'                                                                                ',&
'         chop(p)                                                                ',&
'                                                                                ',&
'   causes the p least significant octal or hexadecimal digits in                ',&
'   the result of each floating point operation to be set to zero.               ',&
'   For example, if the computer being used has an IBM 360 long floating         ',&
'   point word with 14 hexadecimal digits in the fraction, then "chop(8)"        ',&
'   results in simulation of a computer with only 6 hexadecimal digits           ',&
'   in the fraction, i.e. a short floating point word. On a computer such        ',&
'   as the CDC 6600 with 16 octal digits, "chop(8)" results in about the         ',&
'   same accuracy because the remaining 8 octal digits represent the same        ',&
'   number of bits as 6 hexadecimal digits.                                      ',&
'                                                                                ',&
'   Some idea of the effect of "chop" on any particular system can               ',&
'   be obtained by executing the following statements.                           ',&
'                                                                                ',&
'         long,   t = 1/10                                                       ',&
'         long z, t = 1/10                                                       ',&
'         chop(8)                                                                ',&
'         long,   t = 1/10                                                       ',&
'         long z, t = 1/10                                                       ',&
'                                                                                ',&
'   The following Fortran subprograms illustrate more details of                 ',&
'   "flop" and "chop". The first subprogram is a simplified example of a         ',&
'   system-dependent function used within LALA itself. The common variable       ',&
'   G_FLOP_COUNTER is essentially the first component of the variable            ',&
'   FLOP. The common variable CHP is initially zero, but it is set to p          ',&
'   by the statement "chop(p)". To shorten the DATA statement, we assume         ',&
'   there are only 6 hexadecimal digits. We also assume an extension of          ',&
'   Fortran that allows .AND. to be used as a binary operation between           ',&
'   two real variables.                                                          ',&
'                                                                                ',&
'         REAL FUNCTION FLOP(X)                                                  ',&
'         REAL X                                                                 ',&
'         INTEGER G_FLOP_COUNTER,CHP                                             ',&
'         COMMON G_FLOP_COUNTER,CHP                                              ',&
'         REAL MASK(5)                                                           ',&
'         DATA MASK/ZFFFFFFF0,ZFFFFFF00,ZFFFFF000,ZFFFF0000,ZFFF00000/           ',&
'         G_FLOP_COUNTER = G_FLOP_COUNTER + 1                                    ',&
'         IF (CHP .EQ. 0) FLOP = X                                               ',&
'         IF (CHP .GE. 1 .AND. CHP .LE. 5) FLOP = X .AND. MASK(CHP)              ',&
'         IF (CHP .GE. 6) FLOP = 0.0                                             ',&
'         END REAL FUNCTION FLOP                                                 ',&
'                                                                                ',&
'   The following subroutine illustrates a typical use of the                    ',&
'   previous function within LALA. It is a simplified version of                 ',&
'   the Basic Linear Algebra Subprogram that adds a scalar multiple              ',&
'   of one vector to another. We assume here that the vectors are                ',&
'   stored with a memory increment of one.                                       ',&
'                                                                                ',&
'         SUBROUTINE SAXPY(N,TR,TI,XR,XI,YR,YI)                                  ',&
'         REAL TR,TI,XR(N),XI(N),YR(N),YI(N),FLOP                                ',&
'         IF (N .LE. 0) return                                                   ',&
'         IF (TR .EQ. 0.0 .AND. TI .EQ. 0.0) return                              ',&
'         DO I = 1, N                                                            ',&
'            YR(I) = FLOP(YR(I) + TR*XR(I) - TI*XI(I))                           ',&
'            YI(I) = YI(I) + TR*XI(I) + TI*XR(I)                                 ',&
'            IF (YI(I) .NE. 0.0D0) YI(I) = FLOP(YI(I))                           ',&
'         enddo                                                                  ',&
'         END SUBROUTINE SAXPY                                                   ',&
'                                                                                ',&
'   The saxpy operation is perhaps the most fundamental                          ',&
'   operation within LINPACK. It is used in the computation of the               ',&
'   LU, the QR and the SVD factorizations, and in several other                  ',&
'   places. We see that adding a multiple of one vector with n                   ',&
'   components to another uses n flops if the vectors are real and               ',&
'   between n and 2*n flops if the vectors have nonzero imaginary                ',&
'   components.                                                                  ',&
'                                                                                ',&
'   The permanent LALA variable "eps" is reset by the statement                  ',&
'   CHOP(p). Its new value is usually the smallest inverse power of              ',&
'   two that satisfies the Fortran logical test                                  ',&
'                                                                                ',&
'               FLOP(1.0+eps) .GT. 1.0                                           ',&
'                                                                                ',&
'   However, if "eps" had been directly reset to a larger value, the             ',&
'   old value is retained.                                                       ',&
'                                                                                ',&
'================================================================================',&
'CENSUS EXAMPLE                                                                  ',&
'                                                                                ',&
'   Our first extended example involves predicting the population of the         ',&
'   United States in 1980 using extrapolation of various fits to the             ',&
'   census data from 1900 through 1970. There are eight observations,            ',&
'   so we begin with the LALA statement                                          ',&
'                                                                                ',&
'      n = 8                                                                     ',&
'                                                                                ',&
'   The values of the dependent variable, the population in millions,            ',&
'   can be entered with                                                          ',&
'                                                                                ',&
'      y = < 75.995   91.972  105.711  123.203   ...                             ',&
'           131.669  150.697  179.323  203.212>''                                ',&
'                                                                                ',&
'   In order to produce a reasonably scaled matrix, the independent              ',&
'   variable, time, is transformed from the interval [1900,1970] to              ',&
'   [-1.00,0.75]. This can be accomplished directly with                         ',&
'                                                                                ',&
'      t = -1.0:0.25:0.75                                                        ',&
'                                                                                ',&
'   or in a fancier, but perhaps clearer, way with                               ',&
'                                                                                ',&
'      t = 1900:10:1970;   t = (t - 1940*ones(t))/40                             ',&
'                                                                                ',&
'   Either of these is equivalent to                                             ',&
'                                                                                ',&
'      t = <-1 -.75 -.50 -.25 0 .25 .50 .75>                                     ',&
'                                                                                ',&
'   The interpolating polynomial of degree n-1 involves an Vandermonde           ',&
'   matrix of order n with elements that might be generated by                   ',&
'                                                                                ',&
'      for i = 1:n, for j = 1:n, a(i,j) = t(i)**(j-1);                           ',&
'                                                                                ',&
'   However, this results in an error caused by 0**0 when i = 5 and              ',&
'   j = 1 . The preferable approach is                                           ',&
'                                                                                ',&
'      A = ones(n,n);                                                            ',&
'      for i = 1:n, for j = 2:n, a(i,j) = t(i)*a(i,j-1);                         ',&
'                                                                                ',&
'   Now the statement                                                            ',&
'                                                                                ',&
'      cond(A)                                                                   ',&
'                                                                                ',&
'   produces the output                                                          ',&
'                                                                                ',&
'      ans  =                                                                    ',&
'                                                                                ',&
'         1.1819E+03                                                             ',&
'                                                                                ',&
'   which indicates that transformation of the time variable has resulted        ',&
'   in a reasonably well conditioned matrix.                                     ',&
'                                                                                ',&
'        The statement                                                           ',&
'                                                                                ',&
'      c = A\y                                                                   ',&
'                                                                                ',&
'   results in                                                                   ',&
'                                                                                ',&
'      C     =                                                                   ',&
'                                                                                ',&
'        131.6690                                                                ',&
'         41.0406                                                                ',&
'        103.5396                                                                ',&
'        262.4535                                                                ',&
'       -326.0658                                                                ',&
'       -662.0814                                                                ',&
'        341.9022                                                                ',&
'        533.6373                                                                ',&
'                                                                                ',&
'   These are the coefficients in the interpolating polynomial                   ',&
'                                                                                ',&
'         n-1                                                                    ',&
'                                                                                ',&
'         c  + c t + ... + c t                                                   ',&
'          1    2           n                                                    ',&
'                                                                                ',&
'   Our transformation of the time variable has resulted in t = 1                ',&
'   corresponding to the year 1980. Consequently, the extrapolated               ',&
'   population is simply the sum of the coefficients. This can be                ',&
'   computed by                                                                  ',&
'                                                                                ',&
'      p = sum(c)                                                                ',&
'                                                                                ',&
'   The result is                                                                ',&
'                                                                                ',&
'      P     =                                                                   ',&
'                                                                                ',&
'        426.0950                                                                ',&
'                                                                                ',&
'   which indicates a 1980 population of over 426 million. Clearly, using        ',&
'   the seventh degree interpolating polynomial to extrapolate even a            ',&
'   fairly short distance beyond the end of the data interval is not a           ',&
'   good idea.                                                                   ',&
'                                                                                ',&
'   The coefficients in least squares fits by polynomials of lower degree        ',&
'   can be computed using fewer than n columns of the matrix.                    ',&
'                                                                                ',&
'      for k = 1:n, c = A(:,1:k)\y,  p = sum(c)                                  ',&
'                                                                                ',&
'   would produce the coefficients of these fits, as well as the                 ',&
'   resulting extrapolated population. If we do not want to print all the        ',&
'   coefficients, we can simply generate a small table of populations            ',&
'   predicted by polynomials of degrees zero through seven. We also              ',&
'   compute the maximum deviation between the fitted and observed values.        ',&
'                                                                                ',&
'      for k = 1:n, X = A(:,1:k);  c = X\y;  ...                                 ',&
'         d(k) = k-1;  p(k) = sum(c);  e(k) = norm(X*c-y,''inf'');               ',&
'      <d, p, e>                                                                 ',&
'                                                                                ',&
'   The resulting output is                                                      ',&
'                                                                                ',&
'         0   132.7227  70.4892                                                  ',&
'         1   211.5101   9.8079                                                  ',&
'         2   227.7744   5.0354                                                  ',&
'         3   241.9574   3.8941                                                  ',&
'         4   234.2814   4.0643                                                  ',&
'         5   189.7310   2.5066                                                  ',&
'         6   118.3025   1.6741                                                  ',&
'         7   426.0950   0.0000                                                  ',&
'                                                                                ',&
'   The zeroth degree fit, 132.7 million, is the result of fitting a             ',&
'   constant to the data and is simply the average. The results obtained         ',&
'   with polynomials of degree one through four all appear reasonable. The       ',&
'   maximum deviation of the degree four fit is slightly greater than the        ',&
'   degree three, even though the sum of the squares of the deviations           ',&
'   is less. The coefficients of the highest powers in the fits of degree        ',&
'   five and six turn out to be negative and the predicted populations of        ',&
'   less than 200 million are probably unrealistic. The hopefully absurd         ',&
'   prediction of the interpolating polynomial concludes the table.              ',&
'                                                                                ',&
'   We wish to emphasize that roundoff errors are not significant                ',&
'   here. Nearly identical results would be obtained on other computers,         ',&
'   or with other algorithms. The results simply indicate the difficulties       ',&
'   associated with extrapolation of polynomial fits of even modest degree.      ',&
'                                                                                ',&
'   A stabilized fit by a seventh degree polynomial can be obtained using        ',&
'   the pseudoinverse, but it requires a fairly delicate choice of a             ',&
'   tolerance. The statement                                                     ',&
'                                                                                ',&
'      s = svd(A)                                                                ',&
'                                                                                ',&
'   produces the singular values                                                 ',&
'                                                                                ',&
'      S     =                                                                   ',&
'                                                                                ',&
'         3.4594                                                                 ',&
'         2.2121                                                                 ',&
'         1.0915                                                                 ',&
'         0.4879                                                                 ',&
'         0.1759                                                                 ',&
'         0.0617                                                                 ',&
'         0.0134                                                                 ',&
'         0.0029                                                                 ',&
'                                                                                ',&
'   We see that the last three singular values are less than 0.1 ,               ',&
'   consequently, A can be approximately by a matrix of rank five with an        ',&
'   error less than 0.1 . The Moore-Penrose pseudoinverse of this rank           ',&
'   five matrix is obtained from the singular value decomposition with           ',&
'   the following statements                                                     ',&
'                                                                                ',&
'      c = pinv(A,0.1)*y, p = sum(c), e = norm(a*c-y,''inf'')                    ',&
'                                                                                ',&
'   The output is                                                                ',&
'                                                                                ',&
'      C     =                                                                   ',&
'                                                                                ',&
'       134.7972                                                                 ',&
'        67.5055                                                                 ',&
'        23.5523                                                                 ',&
'         9.2834                                                                 ',&
'         3.0174                                                                 ',&
'         2.6503                                                                 ',&
'        -2.8808                                                                 ',&
'         3.2467                                                                 ',&
'                                                                                ',&
'      P     =                                                                   ',&
'                                                                                ',&
'       241.1720                                                                 ',&
'                                                                                ',&
'      E     =                                                                   ',&
'                                                                                ',&
'         3.9469                                                                 ',&
'                                                                                ',&
'   The resulting seventh degree polynomial has coefficients which are much      ',&
'   smaller than those of the interpolating polynomial given earlier. The        ',&
'   predicted population and the maximum deviation are reasonable. Any           ',&
'   choice of the tolerance between the fifth and sixth singular values          ',&
'   would produce the same results, but choices outside this range result        ',&
'   in pseudoinverses of different rank and do not work as well.                 ',&
'                                                                                ',&
'   The one term exponential approximation                                       ',&
'                                                                                ',&
'        y(t) = k exp(pt)                                                        ',&
'                                                                                ',&
'   can be transformed into a linear approximation by taking logarithms.         ',&
'                                                                                ',&
'        log(y(t)) = log k + pt                                                  ',&
'                                                                                ',&
'                  = c  + c t                                                    ',&
'                     1    2                                                     ',&
'                                                                                ',&
'   The following segment makes use of the fact that a function of a             ',&
'   vector is the function applied to the individual components.                 ',&
'                                                                                ',&
'      X = A(:,1:2);                                                             ',&
'      c = X\log(y)                                                              ',&
'      p = exp(sum(c))                                                           ',&
'      e = norm(exp(X*c)-y,''inf'')                                              ',&
'                                                                                ',&
'   The resulting output is                                                      ',&
'                                                                                ',&
'      C     =                                                                   ',&
'                                                                                ',&
'         4.9083                                                                 ',&
'         0.5407                                                                 ',&
'                                                                                ',&
'      P     =                                                                   ',&
'                                                                                ',&
'       232.5134                                                                 ',&
'                                                                                ',&
'      E     =                                                                   ',&
'                                                                                ',&
'         4.9141                                                                 ',&
'                                                                                ',&
'   The predicted population and maximum deviation appear satisfactory and       ',&
'   indicate that the exponential model is a reasonable one to consider.         ',&
'                                                                                ',&
'   As a curiosity, we return to the degree six polynomial. Since the            ',&
'   coefficient of the high order term is negative and the value of the          ',&
'   polynomial at t = 1 is positive, it must have a root at some value           ',&
'   of t greater than one. The statements                                        ',&
'                                                                                ',&
'      X = A(:,1:7);                                                             ',&
'      c = X\y;                                                                  ',&
'      c = c(7:-1:1);  //reverse the order of the coefficients                   ',&
'      z = roots(c)                                                              ',&
'                                                                                ',&
'   produce                                                                      ',&
'                                                                                ',&
'      Z     =                                                                   ',&
'                                                                                ',&
'         1.1023-  0.0000*i                                                      ',&
'         0.3021+  0.7293*i                                                      ',&
'        -0.8790+  0.6536*i                                                      ',&
'        -1.2939-  0.0000*i                                                      ',&
'        -0.8790-  0.6536*i                                                      ',&
'         0.3021-  0.7293*i                                                      ',&
'                                                                                ',&
'   There is only one real, positive root. The corresponding time on the         ',&
'   original scale is                                                            ',&
'                                                                                ',&
'      1940 + 40*real(z(1))                                                      ',&
'                                                                                ',&
'        =  1984.091                                                             ',&
'                                                                                ',&
'   We conclude that the United States population should become zero             ',&
'   early in February of 1984.                                                   ',&
'                                                                                ',&
'================================================================================',&
'PARTIAL DIFFERENTIAL EQUATION EXAMPLE                                           ',&
'                                                                                ',&
'   Our second extended example is a boundary value problem for Laplace''s       ',&
'   equation. The underlying physical problem involves the conductivity          ',&
'   of a medium with cylindrical inclusions and is considered by Keller          ',&
'   and Sachs [7].                                                               ',&
'                                                                                ',&
'        Find a function  u(x,y)  satisfying Laplace''s equation                 ',&
'                                                                                ',&
'                  u   + u   = 0                                                 ',&
'                   xx    yy                                                     ',&
'                                                                                ',&
'   The domain is a unit square with a quarter circle of radius rho removed      ',&
'   from one corner. There are Neumann conditions on the top and bottom          ',&
'   edges and Dirichlet conditions on the remainder of the boundary.             ',&
'                                                                                ',&
'                            u  = 0                                              ',&
'                             n                                                  ',&
'                                                                                ',&
'                        -------------                                           ',&
'                       |             .                                          ',&
'                       |             .                                          ',&
'                       |              .                                         ',&
'                       |               .  u = 1                                 ',&
'                       |                 .                                      ',&
'                       |                    .                                   ',&
'                       |                       .                                ',&
'                u = 0  |                        |                               ',&
'                       |                        |                               ',&
'                       |                        |                               ',&
'                       |                        |  u = 1                        ',&
'                       |                        |                               ',&
'                       |                        |                               ',&
'                       |                        |                               ',&
'                        ------------------------                                ',&
'                                                                                ',&
'                                 u  = 0                                         ',&
'                                  n                                             ',&
'                                                                                ',&
'   The effective conductivity of an medium is then given by the integral        ',&
'   along the left edge,                                                         ',&
'                                                                                ',&
'                               1                                                ',&
'                    sigma = integral  u (0,y) dy                                ',&
'                              0        n                                        ',&
'                                                                                ',&
'   It is of interest to study the relation between the radius rho and           ',&
'   the conductivity sigma. In particular, as rho approaches one, sigma          ',&
'   becomes infinite.                                                            ',&
'                                                                                ',&
'   Keller and Sachs use a finite difference approximation. The following        ',&
'   technique makes use of the fact that the equation is actually Laplace''s     ',&
'   equation and leads to a much smaller matrix problem to solve.                ',&
'                                                                                ',&
'        Consider an approximate solution of the form                            ',&
'                                                                                ',&
'                    n      2j-1                                                 ',&
'              u =  sum  c r    cos(2j-1)t                                       ',&
'                   j=1   j                                                      ',&
'                                                                                ',&
'   where r,t are polar coordinates (t is theta). The coefficients are           ',&
'   to be determined. For any set of coefficients, this function already         ',&
'   satisfies the differential equation because the basis functions are          ',&
'   harmonic; it satisfies the normal derivative boundary condition on           ',&
'   the bottom edge of the domain because we used cos t in preference to         ',&
'   sin t ; and it satisfies the boundary condition on the left edge of          ',&
'   the domain because we use only odd multiples of t .                          ',&
'                                                                                ',&
'   The computational task is to find coefficients so that the boundary          ',&
'   conditions on the remaining edges are satisfied as well as possible. To      ',&
'   accomplish this, pick m points (r,t) on the remaining edges. It is           ',&
'   desirable to have m > n and in practice we usually choose m to be two        ',&
'   or three times as large as n . Typical values of n are 10 or 20 and          ',&
'   of m are 20 to 60. An m by n matrix A is generated. The i,j element          ',&
'   is the j-th basis function, or its normal derivative, evaluated at           ',&
'   the i-th boundary point. A right hand side with m components is also         ',&
'   generated. In this example, the elements of the right hand side are          ',&
'   either zero or one. The coefficients are then found by solving the           ',&
'   overdetermined set of equations                                              ',&
'                                                                                ',&
'               Ac = b                                                           ',&
'                                                                                ',&
'   in a least squares sense.                                                    ',&
'                                                                                ',&
'   Once the coefficients have been determined, the approximate solution         ',&
'   is defined everywhere on the domain. It is then possible to compute the      ',&
'   effective conductivity sigma . In fact, a very simple formula results,       ',&
'                                                                                ',&
'                        n       j-1                                             ',&
'              sigma =  sum  (-1)   c                                            ',&
'                       j=1          j                                           ',&
'                                                                                ',&
'   To use LALA for this problem, the following "program" is first stored        ',&
'   in the local computer file system, say under the name "PDE".                 ',&
'                                                                                ',&
'      //Conductivity example.                                                   ',&
'      //Parameters ---                                                          ',&
'         rho       //radius of cylindrical inclusion                            ',&
'         n         //number of terms in solution                                ',&
'         m         //number of boundary points                                  ',&
'      //initialize operation counter                                            ',&
'         flop = <0 0>;                                                          ',&
'      //initialize variables                                                    ',&
'         m1 = round(m/3);   //number of points on each straight edge            ',&
'         m2 = m - m1;       //number of points with Dirichlet conditions        ',&
'         pi = 4*atan(1);                                                        ',&
'      //generate points in Cartesian coordinates                                ',&
'         //right hand edge                                                      ',&
'         for i = 1:m1, x(i) = 1; y(i) = (1-rho)*(i-1)/(m1-1);                   ',&
'         //top edge                                                             ',&
'         for i = m2+1:m, x(i) = (1-rho)*(m-i)/(m-m2-1); y(i) = 1;               ',&
'         //circular edge                                                        ',&
'         for i = m1+1:m2, t = pi/2*(i-m1)/(m2-m1+1); ...                        ',&
'            x(i) = 1-rho*sin(t);  y(i) = 1-rho*cos(t);                          ',&
'      //convert to polar coordinates                                            ',&
'         for i = 1:m-1, th(i) = atan(y(i)/x(i));  ...                           ',&
'            r(i) = sqrt(x(i)**2+y(i)**2);                                       ',&
'         th(m) = pi/2;  r(m) = 1;                                               ',&
'      //generate matrix                                                         ',&
'         //Dirichlet conditions                                                 ',&
'         for i = 1:m2, for j = 1:n, k = 2*j-1; ...                              ',&
'            a(i,j) = r(i)**k*cos(k*th(i));                                      ',&
'         //Neumann conditions                                                   ',&
'         for i = m2+1:m, for j = 1:n, k = 2*j-1; ...                            ',&
'            a(i,j) = k*r(i)**(k-1)*sin((k-1)*th(i));                            ',&
'      //generate right hand side                                                ',&
'         for i = 1:m2, b(i) = 1;                                                ',&
'         for i = m2+1:m, b(i) = 0;                                              ',&
'      //solve for coefficients                                                  ',&
'         c = A\b                                                                ',&
'      //compute effective conductivity                                          ',&
'         c(2:2:n) = -c(2:2:n);                                                  ',&
'         sigma = sum(c)                                                         ',&
'      //output total operation count                                            ',&
'         ops = flop(2)                                                          ',&
'                                                                                ',&
'   The program can be used within LALA by setting the three parameters          ',&
'   and then accessing the file. For example,                                    ',&
'                                                                                ',&
'      rho = .9;                                                                 ',&
'      n = 15;                                                                   ',&
'      m = 30;                                                                   ',&
'      exec(''PDE'')                                                             ',&
'                                                                                ',&
'   The resulting output is                                                      ',&
'                                                                                ',&
'      rho   =                                                                   ',&
'                                                                                ',&
'         .9000                                                                  ',&
'                                                                                ',&
'      n     =                                                                   ',&
'                                                                                ',&
'       15.                                                                      ',&
'                                                                                ',&
'      m     =                                                                   ',&
'                                                                                ',&
'       30.                                                                      ',&
'                                                                                ',&
'      c     =                                                                   ',&
'                                                                                ',&
'         2.2275                                                                 ',&
'        -2.2724                                                                 ',&
'         1.1448                                                                 ',&
'         0.1455                                                                 ',&
'        -0.1678                                                                 ',&
'        -0.0005                                                                 ',&
'        -0.3785                                                                 ',&
'         0.2299                                                                 ',&
'         0.3228                                                                 ',&
'        -0.2242                                                                 ',&
'        -0.1311                                                                 ',&
'         0.0924                                                                 ',&
'         0.0310                                                                 ',&
'        -0.0154                                                                 ',&
'        -0.0038                                                                 ',&
'                                                                                ',&
'      sigm  =                                                                   ',&
'                                                                                ',&
'         5.0895                                                                 ',&
'                                                                                ',&
'      ops   =                                                                   ',&
'                                                                                ',&
'         16204.                                                                 ',&
'                                                                                ',&
'   A total of 16204 floating point operations were necessary to set up the      ',&
'   matrix, solve for the coefficients and compute the conductivity. The         ',&
'   operation count is roughly proportional to m*n**2. The results obtained      ',&
'   for sigma as a function of rho by this approach are essentially the          ',&
'   same as those obtained by the finite difference technique of Keller          ',&
'   and Sachs, but the computational effort involved is much less.               ',&
'                                                                                ',&
'================================================================================',&
'EIGENVALUE SENSITIVITY EXAMPLE                                                  ',&
'                                                                                ',&
'   In this example, we construct a matrix whose eigenvalues are moderately      ',&
'   sensitive to perturbations and then analyze that sensitivity. We             ',&
'   begin with the statement                                                     ',&
'                                                                                ',&
'      B = <3 0 7; 0 2 0; 0 0 1>                                                 ',&
'                                                                                ',&
'   which produces                                                               ',&
'                                                                                ',&
'      B     =                                                                   ',&
'                                                                                ',&
'          3.    0.    7.                                                        ',&
'          0.    2.    0.                                                        ',&
'          0.    0.    1.                                                        ',&
'                                                                                ',&
'   Obviously, the eigenvalues of B are 1, 2 and 3 . Moreover, since             ',&
'   B is not symmetric, these eigenvalues are slightly sensitive to              ',&
'   perturbation. (The value b(1,3) = 7 was chosen so that the elements          ',&
'   of the matrix A below are less than 1000.)                                   ',&
'                                                                                ',&
'   We now generate a similarity transformation to disguise the eigenvalues      ',&
'   and make them more sensitive.                                                ',&
'                                                                                ',&
'      L = <1 0 0; 2 1 0; -3 4 1>, M = L\L''                                     ',&
'                                                                                ',&
'      L     =                                                                   ',&
'                                                                                ',&
'          1.    0.    0.                                                        ',&
'          2.    1.    0.                                                        ',&
'         -3.    4.    1.                                                        ',&
'                                                                                ',&
'      M     =                                                                   ',&
'                                                                                ',&
'          1.0000    2.0000   -3.0000                                            ',&
'         -2.0000   -3.0000   10.0000                                            ',&
'         11.0000   18.0000  -48.0000                                            ',&
'                                                                                ',&
'   The matrix M has determinant equal to 1 and is moderately badly              ',&
'   conditioned. The similarity transformation is                                ',&
'                                                                                ',&
'      A = M*B/M                                                                 ',&
'                                                                                ',&
'      A     =                                                                   ',&
'                                                                                ',&
'        -64.0000   82.0000   21.0000                                            ',&
'        144.0000 -178.0000  -46.0000                                            ',&
'       -771.0000  962.0000  248.0000                                            ',&
'                                                                                ',&
'   Because det(M) = 1 , the elements of A would be exact integers               ',&
'   if there were no roundoff. So,                                               ',&
'                                                                                ',&
'      A = round(A)                                                              ',&
'                                                                                ',&
'      A     =                                                                   ',&
'                                                                                ',&
'        -64.   82.   21.                                                        ',&
'        144. -178.  -46.                                                        ',&
'       -771.  962.  248.                                                        ',&
'                                                                                ',&
'   This, then, is our test matrix. We can now forget how it                     ',&
'   was generated and analyze its eigenvalues.                                   ',&
'                                                                                ',&
'      <X,D> = eig(A)                                                            ',&
'                                                                                ',&
'      D     =                                                                   ',&
'                                                                                ',&
'          3.0000    0.0000    0.0000                                            ',&
'          0.0000    1.0000    0.0000                                            ',&
'          0.0000    0.0000    2.0000                                            ',&
'                                                                                ',&
'      X     =                                                                   ',&
'                                                                                ',&
'          -.0891    3.4903   41.8091                                            ',&
'           .1782   -9.1284  -62.7136                                            ',&
'          -.9800   46.4473  376.2818                                            ',&
'                                                                                ',&
'   Since A is similar to B, its eigenvalues are also 1, 2 and 3. They           ',&
'   happen to be computed in another order by the EISPACK subroutines. The       ',&
'   fact that the columns of X, which are the eigenvectors, are so far           ',&
'   from being orthonormal is our first indication that the eigenvalues          ',&
'   are sensitive. To see this sensitivity, we display more figures of           ',&
'   the computed eigenvalues.                                                    ',&
'                                                                                ',&
'      long, diag(D)                                                             ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         2.999999999973599                                                      ',&
'         1.000000000015625                                                      ',&
'         2.000000000011505                                                      ',&
'                                                                                ',&
'   We see that, on this computer, the last five significant figures are         ',&
'   contaminated by roundoff error. A somewhat superficial explanation           ',&
'   of this is provided by                                                       ',&
'                                                                                ',&
'      short,  cond(X)                                                           ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         3.2216e+05                                                             ',&
'                                                                                ',&
'   The condition number of X gives an upper bound for the relative              ',&
'   error in the computed eigenvalues. However, this condition                   ',&
'   number is affected by scaling.                                               ',&
'                                                                                ',&
'      X = X/diag(X(3,:)),  cond(X)                                              ',&
'                                                                                ',&
'      X     =                                                                   ',&
'                                                                                ',&
'           .0909     .0751     .1111                                            ',&
'          -.1818    -.1965    -.1667                                            ',&
'          1.0000    1.0000    1.0000                                            ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         1.7692e+03                                                             ',&
'                                                                                ',&
'   Rescaling the eigenvectors so that their last components are all             ',&
'   equal to one has two consequences. The condition of X is decreased           ',&
'   by over two orders of magnitude. (This is about the minimum condition        ',&
'   that can be obtained by such diagonal scaling.)  Moreover, it is now         ',&
'   apparent that the three eigenvectors are nearly parallel.                    ',&
'                                                                                ',&
'   More detailed information on the sensitivity of the individual               ',&
'   eigenvalues involves the left eigenvectors.                                  ',&
'                                                                                ',&
'      Y = inv(X''),  Y''*A*X                                                    ',&
'                                                                                ',&
'      Y     =                                                                   ',&
'                                                                                ',&
'       -511.5000  259.5000  252.0000                                            ',&
'        616.0000 -346.0000 -270.0000                                            ',&
'        159.5000  -86.5000  -72.0000                                            ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'          3.0000     .0000     .0000                                            ',&
'           .0000    1.0000     .0000                                            ',&
'           .0000     .0000    2.0000                                            ',&
'                                                                                ',&
'   We are now in a position to compute the sensitivities of the individual      ',&
'   eigenvalues.                                                                 ',&
'                                                                                ',&
'      for j = 1:3, c(j) = norm(Y(:,j))*norm(X(:,j)); end,  C                    ',&
'                                                                                ',&
'      C     =                                                                   ',&
'                                                                                ',&
'        833.1092                                                                ',&
'        450.7228                                                                ',&
'        383.7564                                                                ',&
'                                                                                ',&
'   These three numbers are the reciprocals of the cosines of the                ',&
'   angles between the left and right eigenvectors. It can be shown that         ',&
'   perturbation of the elements of A can result in a perturbation of            ',&
'   the j-th eigenvalue which is c(j) times as large. In this example,           ',&
'   the first eigenvalue has the largest sensitivity.                            ',&
'                                                                                ',&
'   We now proceed to show that A is close to a matrix with a double             ',&
'   eigenvalue. The direction of the required perturbation is given by           ',&
'                                                                                ',&
'      E = -1.e-6*Y(:,1)*X(:,1)''                                                ',&
'                                                                                ',&
'      E     =                                                                   ',&
'                                                                                ',&
'         1.0e-03 *                                                              ',&
'                                                                                ',&
'           .0465    -.0930     .5115                                            ',&
'          -.0560     .1120    -.6160                                            ',&
'          -.0145     .0290    -.1595                                            ',&
'                                                                                ',&
'   With some trial and error which we do not show, we bracket the               ',&
'   point where two eigenvalues of a perturbed A coalesce and then               ',&
'   become complex.                                                              ',&
'                                                                                ',&
'      eig(A + .4*E),  eig(A + .5*E)                                             ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'          1.1500                                                                ',&
'          2.5996                                                                ',&
'          2.2504                                                                ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         2.4067 +  .1753*i                                                      ',&
'         2.4067 -  .1753*i                                                      ',&
'         1.1866 + 0.0000*i                                                      ',&
'                                                                                ',&
'   Now, a bisecting search, driven by the imaginary part of one of              ',&
'   the eigenvalues, finds the point where two eigenvalues are nearly            ',&
'   equal.                                                                       ',&
'                                                                                ',&
'      r = .4;  s = .5;                                                          ',&
'                                                                                ',&
'      while s-r > 1.e-14, t = (r+s)/2; d = eig(A+t*E); ...                      ',&
'        if imag(d(1))=0, r = t; else, s = t;                                    ',&
'                                                                                ',&
'      long,  T                                                                  ',&
'                                                                                ',&
'      T     =                                                                   ',&
'                                                                                ',&
'           .450380734134507                                                     ',&
'                                                                                ',&
'   Finally, we display the perturbed matrix, which is obviously close           ',&
'   to the original, and its pair of nearly equal eigenvalues. (We have          ',&
'   dropped a few digits from the long output.)                                  ',&
'                                                                                ',&
'      A+t*E,  eig(A+t*E)                                                        ',&
'                                                                                ',&
'      A                                                                         ',&
'                                                                                ',&
'       -63.999979057   81.999958114   21.000230369                              ',&
'       143.999974778 -177.999949557  -46.000277434                              ',&
'      -771.000006530  962.000013061  247.999928164                              ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         2.415741150                                                            ',&
'         2.415740621                                                            ',&
'         1.168517777                                                            ',&
'                                                                                ',&
'   The first two eigenvectors of A + t*E are almost indistinguishable           ',&
'   indicating that the perturbed matrix is almost defective.                    ',&
'                                                                                ',&
'      <X,D> = eig(A+t*E);  X = X/diag(X(3,:))                                   ',&
'                                                                                ',&
'      X     =                                                                   ',&
'                                                                                ',&
'          .096019578     .096019586    .071608466                               ',&
'         -.178329614    -.178329608   -.199190520                               ',&
'         1.000000000    1.000000000   1.000000000                               ',&
'                                                                                ',&
'      short,  cond(X)                                                           ',&
'                                                                                ',&
'      ans   =                                                                   ',&
'                                                                                ',&
'         3.3997e+09                                                             ',&
'                                                                                ',&
'================================================================================',&
'COMMUNICATING WITH OTHER PROGRAMS                                               ',&
'                                                                                ',&
'   There are four different ways LALA can be used in                            ',&
'   conjunction with other programs:                                             ',&
'                                                                                ',&
'      -- user() - a user-supplied subroutine                                    ',&
'      -- exec() - reading commands from a file                                  ',&
'      -- save() and load() -- reading specially formatted data files.           ',&
'      -- lala() - call the interpreter with a CHARACTER array of                ',&
'                  commands or interactively.                                    ',&
'                                                                                ',&
'   Let us illustrate each of these by equivalents of the following              ',&
'   simple example.                                                              ',&
'                                                                                ',&
'   You can start the lala(1) program up and simply enter:                       ',&
'                                                                                ',&
'         n = 6                                                                  ',&
'         for i = 1:n, for j = 1:n, a(i,j) = abs(i-j);                           ',&
'         a                                                                      ',&
'         x = inv(a)                                                             ',&
'                                                                                ',&
'   An example user routine could be introduced into LALA that                   ',&
'   does the same thing as the "for" statement by compiling and                  ',&
'   linking the following subroutine into the calling program.                   ',&
'                                                                                ',&
'         program demo_user                                                      ',&
'         implicit none                                                          ',&
'         use M_matrix                                                           ',&
'         call set_usersub(lala_user)                                            ',&
'         call lala()                                                            ',&
'         subroutine lala_user(a,m,n,s,t)                                        ',&
'            implicit none                                                       ',&
'            doubleprecision a(:),s,t                                            ',&
'            integer m,n                                                         ',&
'            n = int(a(1))                                                       ',&
'            m = n                                                               ',&
'            do j = 1, n                                                         ',&
'               do i = 1, n                                                      ',&
'                  k = i + (j-1)*m                                               ',&
'                  a(k) = iabs(i-j)                                              ',&
'               enddo                                                            ',&
'            enddo                                                               ',&
'            end subroutine lala_user                                            ',&
'         end program demo_user                                                  ',&
'                                                                                ',&
'   A user-defined function can then be registered with the program              ',&
'   with                                                                         ',&
'                                                                                ',&
'           call set_usersub(SUBROUTINE_NAME)                                    ',&
'                                                                                ',&
'   Note the routine must be defined with an explicit interface                  ',&
'   available in the calling unit.                                               ',&
'                                                                                ',&
'   Then the LALA statements                                                     ',&
'                                                                                ',&
'         n = 6                                                                  ',&
'         a = user(n)                                                            ',&
'         x = inv(a)                                                             ',&
'                                                                                ',&
'   do the job.                                                                  ',&
'                                                                                ',&
'   The example procedure could be called by storing the following               ',&
'   text in a file named, say, EXAMPLE.                                          ',&
'                                                                                ',&
'         for i = 1:n, for j = 1:n, a(i,j) = abs(i-j);                           ',&
'                                                                                ',&
'   Then the LALA statements                                                     ',&
'                                                                                ',&
'         n = 6                                                                  ',&
'         exec(''EXAMPLE'',0)                                                    ',&
'         x = inv(a)                                                             ',&
'                                                                                ',&
'   have the desired effect. The 0 as the optional second parameter              ',&
'   of exec indicates that the text in the file should not be printed            ',&
'   on the terminal.                                                             ',&
'                                                                                ',&
'   The matrices A and X could also be stored in files. Two                      ',&
'   separate main programs would be involved. The first is:                      ',&
'                                                                                ',&
'            program maina                                                       ',&
'            doubleprecision a(10,10)                                            ',&
'            n = 6                                                               ',&
'            do j = 1, n                                                         ',&
'               do i = 1, n                                                      ',&
'                  a(i,j) = iabs(i-j)                                            ',&
'               enddo                                                            ',&
'            enddo                                                               ',&
'            OPEN(UNIT=1,FILE=''A'')                                             ',&
'            write(1,''(a32,2i4)'') ''a'', n,n                                   ',&
'            do j = 1, n                                                         ',&
'               write(1,102) (a(i,j),i=1,n)                                      ',&
'            enddo                                                               ',&
'        102 format(4z18)                                                        ',&
'            end program maina                                                   ',&
'                                                                                ',&
'   The OPEN statement may take different forms on different systems.            ',&
'   It attaches Fortran logical unit number 1 to the file named A.               ',&
'                                                                                ',&
'   The FORMAT number 102 may also be system dependent. This                     ',&
'   particular one is appropriate for hexadecimal computers with an 8            ',&
'   byte double precision floating point word. Check, or modify,                 ',&
'   LALA subroutine SAVLOD.                                                      ',&
'                                                                                ',&
'   After this program is executed, enter LALA and give the                      ',&
'   following statements:                                                        ',&
'                                                                                ',&
'         load(''A'')                                                            ',&
'         X = inv(a)                                                             ',&
'         save(''X'',X)                                                          ',&
'                                                                                ',&
'   If all goes according to plan, this will read the matrix "a" from            ',&
'   the file A, invert it, store the inverse in X and then write the             ',&
'   matrix X on the file X. The following program can then access X.             ',&
'                                                                                ',&
'            program mainx                                                       ',&
'            doubleprecision x(10,10)                                            ',&
'            open(unit=1,file=''x'')                                             ',&
'            rewind 1                                                            ',&
'            read (1, ''(a32,2i4)'') id,m,n                                      ',&
'            do j = 1, n                                                         ',&
'               read(1,''(4z18)'') (x(i,j),i=1,m)                                ',&
'            enddo                                                               ',&
'            ...                                                                 ',&
'            ...                                                                 ',&
'                                                                                ',&
'                                                                                ',&
'   The most elaborate mechanism involves using LALA as a subroutine             ',&
'   within another program. Communication with the LALA stack is                 ',&
'   accomplished using subroutine lala().                                        ',&
'    The preamble of MATZ is:                                                    ',&
'                                                                                ',&
'         SUBROUTINE MATZ(A,LDA,M,N,ID,JOB,IERR)                                 ',&
'         INTEGER LDA,M,N,JOB,IERR                                               ',&
'         character(len=*) :: id                                                 ',&
'         DOUBLEPRECISION A(LDA,N)                                               ',&
'                                                                                ',&
'         ! ACCESS LALA VARIABLE STACK                                           ',&
'         ! A IS AN M BY N MATRIX, STORED IN AN ARRAY WITH                       ',&
'         !     LEADING DIMENSION LDA.                                           ',&
'         ! ID IS THE NAME OF A. ID IS UP TO FOUR CHARACTERS.                    ',&
'         ! JOB =  0  GET REAL A FROM LALA,                                      ',&
'         !     =  1  PUT REAL A INTO LALA,                                      ',&
'         !     = 10  GET IMAG PART OF A FROM LALA,                              ',&
'         !     = 11  PUT IMAG PART OF A INTO LALA.                              ',&
'         ! RETURN WITH NONZERO IERR AFTER LALA ERROR MESSAGE.                   ',&
'         !                                                                      ',&
'         ! USES LALA ROUTINES STACKG, STACKP AND ERROR                          ',&
'                                                                                ',&
'        The preamble of subroutine LALA is:                                     ',&
'                                                                                ',&
'         SUBROUTINE LALA(INIT)                                                  ',&
'         ! INIT = 0 FOR FIRST ENTRY, NONZERO FOR SUBSEQUENT ENTRIES             ',&
'                                                                                ',&
'        To do our example, write the following program:                         ',&
'                                                                                ',&
'            DOUBLEPRECISION A(10,10),X(10,10)                                   ',&
'            DATA LDA/10/                                                        ',&
'            call M_88(0,'''')                                                   ',&
'            N = 6                                                               ',&
'            DO J = 1, N                                                         ',&
'               DO I = 1, N                                                      ',&
'                  A(I,J) = IABS(I-J)                                            ',&
'               enddo                                                            ',&
'            enddo                                                               ',&
'            call MATZ(A,LDA,N,N,''A'',1,IERR)                                   ',&
'            IF (IERR .NE. 0) GOTO ...                                           ',&
'            call LALA(1,'''')                                                   ',&
'            call MATZ(X,LDA,N,N,''X'',0,IERR)                                   ',&
'            IF (IERR .NE. 0) GOTO ...                                           ',&
'            ...                                                                 ',&
'            ...                                                                 ',&
'                                                                                ',&
'   When this program is executed, the call to LALA(0) produces the              ',&
'   LALA greeting, then waits for input. The command                             ',&
'                                                                                ',&
'            quit                                                                ',&
'                                                                                ',&
'   sends control back to our example program. The matrix A is                   ',&
'   generated by the program and sent to the stack by the first call             ',&
'   to MATZ. The call to LALA(1) produces the LALA(1) prompt. Then               ',&
'   the statements                                                               ',&
'                                                                                ',&
'            X = inv(A)                                                          ',&
'            quit                                                                ',&
'                                                                                ',&
'   will invert our matrix, put the result on the stack and go back              ',&
'   to our program. The second call to MATZ will retrieve X .                    ',&
'                                                                                ',&
'   By the way, this matrix X is interesting. Take a look at                     ',&
'   round(2*(n-1)*X).                                                            ',&
'                                                                                ',&
'================================================================================',&
'ACKNOWLEDGEMENT                                                                 ',&
'                                                                                ',&
'   LALA was inspired by the MATLAB subroutine. Most of the work on              ',&
'   MATLAB was carried out at the University of New Mexico, where it was         ',&
'   being supported by the National Science Foundation. Additional work          ',&
'   has been done during visits to Stanford Linear Accelerator Center,           ',&
'   Argonne National Laboratory and Los Alamos Scientific Laboratory,            ',&
'   where support has been provided by NSF and the Department of Energy.         ',&
'                                                                                ',&
'================================================================================',&
'REFERENCES FOR THE MATLAB ROUTINE                                               ',&
'                                                                                ',&
' [1]  J. J. Dongarra, J. R. Bunch, C. B. Moler and G. W. Stewart,               ',&
'      LINPACK Users'' Guide, Society for Industrial and Applied                 ',&
'      Mathematics, Philadelphia, 1979.                                          ',&
'                                                                                ',&
' [2]  B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, Y.                ',&
'      Ikebe, V. C. Klema, C. B. Moler, Matrix Eigensystem Routines              ',&
'      -- EISPACK Guide, Lecture Notes in Computer Science, volume               ',&
'      6, second edition, Springer-Verlag, 1976.                                 ',&
'                                                                                ',&
' [3]  B. S. Garbow, J. M. Boyle, J. J. Dongarra, C. B. Moler,                   ',&
'      Matrix Eigensystem Routines -- EISPACK Guide Extension,                   ',&
'      Lecture Notes in Computer Science, volume 51, Springer-                   ',&
'      Verlag, 1977.                                                             ',&
'                                                                                ',&
' [4]  S. Cohen and S. Piper, SPEAKEASY III Reference Manual,                    ',&
'      Speakeasy Computing Corp., Chicago, Ill., 1979.                           ',&
'                                                                                ',&
' [5]  J. H. Wilkinson and C. Reinsch, Handbook for Automatic                    ',&
'      Computation, volume II, Linear Algebra, Springer-Verlag,                  ',&
'     1971.                                                                      ',&
'                                                                                ',&
' [6]  Niklaus Wirth, Algorithms + Data Structures = Programs,                   ',&
'      Prentice-Hall, 1976.                                                      ',&
'                                                                                ',&
' [7]  H. B. Keller and D. Sachs, "Calculations of the Conductivity              ',&
'      of a Medium Containing Cylindrical Inclusions", J. Applied                ',&
'      Physics 35, 537-538, 1964.                                                ',&
'                                                                                ',&
' [8]  C. B. Moler and C. F. Van Loan, Nineteen Dubious Ways to                  ',&
'      Compute the Exponential of a Matrix, SIAM Review 20, 801-                 ',&
'      836, 1979.                                                                ',&
'                                                                                ',&
' [9]  G. E. Forsythe, M. A. Malcolm and C. B. Moler, Computer                   ',&
'      Methods for Mathematical Computations, Prentice-Hall, 1977.               ',&
'                                                                                ',&
' [10] C. B. Moler and D. R. Morrison, "Replacing square roots by                ',&
'      Pythagorean sums", University of New Mexico, Computer                     ',&
'      Science Department, technical report, submitted for                       ',&
'     publication, 1980.                                                         ',&
'                                                                                ',&
'================================================================================',&
'SUMMARY    A list of basic (case-sensitive) section and topic names             ',&
'   .______________._________________________________________________________.   ',&
'   |SYNTAX        | [] <> () = .  , !  ; \ / '''' + - * : ^ semi ? ./ .\ .*   | ',&
'   |______________._________________________________________________________|   ',&
'   |VARIABLES     | ans    clear who                                        |   ',&
'   |______________._________________________________________________________|   ',&
'   |BASIC         | atan  cos  exp  log  pow  sin  sqrt minval maxval       |   ',&
'   |______________._________________________________________________________|   ',&
'   |RELATIONAL    | lt le eq ge gt ne                                       |   ',&
'   |______________._________________________________________________________|   ',&
'   |HIGH          | abs   all   any   base chol chop    cond  conjg  det    |   ',&
'   |              | diag  eig   eye   hess invh imag    inv   kron   lu     |   ',&
'   |              | magic norm  ones  orth pinv poly    prod  qr     randn  |   ',&
'   |              | randu rank  rcond rat  real reshape rref  roots  round  |   ',&
'   |              | schur shape sum   svd  tril triu    user  zeros         |   ',&
'   |______________._________________________________________________________|   ',&
'   |FLOW control  | else   end   if     for    while    exit   quit         |   ',&
'   |______________._________________________________________________________|   ',&
'   |FILE access   | exec   load  print  save   delete                       |   ',&
'   |______________._________________________________________________________|   ',&
'   |OUTPUT options| lines  long  short  diary  display  plot fmtc fmti fmtr |   ',&
'   |______________._________________________________________________________|   ',&
'   |ENVIRONMENT   | getenv date_and_time                                    |   ',&
'   |______________._________________________________________________________|   ',&
'   |DOCUMENTATION | help   fhelp  NEWS                                      |   ',&
'   |______________._________________________________________________________|   ',&
'   |MISCELLANEOUS | eps    debug  flops sh     MACROS   EDIT   CHARS        |   ',&
'   |______________._________________________________________________________|   ',&
'================================================================================',&
'SAMPLE                                                                          ',&
'      Here are a few sample statements:                                         ',&
'                                                                                ',&
'       A = <1 2; 3 4>                                                           ',&
'       b = <5 6>''                                                              ',&
'       x = A\b                                                                  ',&
'       <V,D> = eig(A),  norm(A-V*D/V)                                           ',&
'       help \ , help eig                                                        ',&
'       exec(''demo'',7)                                                         ',&
'                                                                                ',&
'      For more information, generate the LALA Users'' Guide                     ',&
'      using                                                                     ',&
'                                                                                ',&
'        help manual                                                             ',&
'        w help.txt                                                              ',&
'        q                                                                       ',&
'================================================================================',&
'DOCUMENTATION                                                                   ',&
'fhelp topic|SECTION_NAME                                                        ',&
'                                                                                ',&
'      "fhelp" is identical in usage to "help" except that it searches a         ',&
'      collection of descriptions of Fortran intrinsics.                         ',&
'                                                                                ',&
'        fhelp verify                                                            ',&
'        fhelp pack                                                              ',&
'                                                                                ',&
'      See "help"                                                                ',&
'                                                                                ',&
'help  topic|SECTION_NAME                                                        ',&
'                                                                                ',&
'      "help" gives assistance. It is equivalent to "help SUMMARY"               ',&
'      by default.                                                               ',&
'                                                                                ',&
'      o  "help" with no options lists common topic and section names.           ',&
'      o  The special topic "topics" shows all topic lines.                      ',&
'      o  The special topic "manual" displays all the help text.                 ',&
'      o  The special topic "search" shows lines from the manual                 ',&
'         containing the subsequent string                                       ',&
'                                                                                ',&
'         Enter "h" at the "help:" prompt for additional options.                ',&
'                                                                                ',&
'      For example:                                                              ',&
'                                                                                ',&
'         help        // a list of common topics and section names               ',&
'         help topics // a list of topics including the first line of            ',&
'                     // the topic.                                              ',&
'         help abs    // are_any_trueuces help on the function "abs".            ',&
'         help FLOW   // the entire section on flow control is displayed.        ',&
'         help manual // show all the help text                                  ',&
'         help help   // obviously prints this message.                          ',&
'         help search factor // show all lines containing "factor".              ',&
'                                                                                ',&
'      Alternatively, To place all the documentation in a file, use              ',&
'      "help manual" and enter "w help.txt" at the "help:" prompt.               ',&
'NEWS                                                                            ',&
'      May, 1981.                                                                ',&
'                                                                                ',&
'      This is a port of the Argonne National Lab. FORTRAN 77 MATLAB             ',&
'      routine circa 1981.                                                       ',&
'                                                                                ',&
'      Mar, 1990.                                                                ',&
'                                                                                ',&
'      Input lines can now be recalled and edited. A "??" on a line by           ',&
'      itself calls the command history mode. Enter "?" after entering           ',&
'      the mode for details.                                                     ',&
'                                                                                ',&
'      Apr, 2021.                                                                ',&
'                                                                                ',&
'      Rewritten but largely true to the original documentation.                 ',&
'                                                                                ',&
'      Mar, 2025.                                                                ',&
'                                                                                ',&
'      Added a few functions                                                     ',&
'                                                                                ',&
'       * pow      raise elements of an array to a power and the                 ',&
'                  equivalent .^ operator                                        ',&
'       * ^        ^ was added as an alias of the ** operator                    ',&
'       * reshape  added function to reshape arrays                              ',&
'       * all      return 1 if all values are not zero,                          ',&
'                  return 0 if any value is zero.                                ',&
'       * any      return 1 if any values are not zero,                          ',&
'                  return 0 if all value is zero.                                ',&
'       * lt,le,eq,ge,gt,ne  added relational functions                          ',&
'       * date_and_time      added additional representations of current         ',&
'                            time.                                               ',&
'       * fmtc,fmti,fmtr     convert numeric values to string                    ',&
'       * pack               select array elements via a mask into a vector      ',&
'       * minval,maxval      extrema of real component of an array               ',&
'                                                                                ',&
'      Enhancements                                                              ',&
'                                                                                ',&
'       * sum   Added the option to sum along rows or columns                    ',&
'                                                                                ',&
'      Differences                                                               ',&
'                                                                                ',&
'       * added randu(), randn(), and randseed() and eliminated overloading      ',&
'         of the word "rank", which was error-prone and had improbable but       ',&
'         possibly incorrect behavior if keywords were one-to-one matches to     ',&
'         data.                                                                  ',&
'================================================================================',&
'SYNTAX                                                                          ',&
'[     See "<"                                                                   ',&
']     See "<"                                                                   ',&
'>     See "<" . Also see MACROS.                                                ',&
'<     < > or [ ] are brackets used in forming vectors and matrices.             ',&
'      "<6.9 9.64 sqrt(-1)>" is a vector with three elements separated by        ',&
'      blanks. "[1+I 2-I 3]" and "[1 +I 2 -I 3]" are not the same. The           ',&
'      first has three elements, the second has five. <11 12 13; 21 22           ',&
'      23> is a 2 by 3 matrix. The semicolon ends the first row.                 ',&
'                                                                                ',&
'      Vectors and matrices can be used inside < > brackets. <A B; C>            ',&
'      is allowed if the number of rows of A equals the number of rows           ',&
'      of B and the number of columns of A plus the number of columns of         ',&
'      B equals the number of columns of C. This rule generalizes in a           ',&
'      hopefully obvious way to allow fairly complicated constructions.          ',&
'                                                                                ',&
'      A = < > stores an empty matrix in A, thereby removing it from the         ',&
'      list of current variables.                                                ',&
'                                                                                ',&
'      For the use of < and > on the left of the = in multiple assignment        ',&
'      statements, See "lu", "eig", "svd" and so on.                             ',&
'                                                                                ',&
'      In "while" and "if" clauses, "<>" means less than or greater than,        ',&
'      i.e. not equal, "<" means less than, ">" means greater than,              ',&
'      "<=" means less than or equal, ">=" means greater than or equal.          ',&
'                                                                                ',&
'      For the use of ">" and "<" to delineate macros, see MACROS.               ',&
'                                                                                ',&
'{     see "(".                                                                  ',&
'}     see "(".                                                                  ',&
')     See "(" .                                                                 ',&
'(     ( ) or { } are used to indicate precedence in arithmetic expressions      ',&
'      and to enclose arguments of functions in the usual way. They are          ',&
'      also used to enclose subscripts of vectors and matrices in a manner       ',&
'      somewhat more general than the usual way. If X and V are vectors,         ',&
'      then X(V) is <X(V(1)), X(V(2)), ..., X(V(N))>. The components of V        ',&
'      are rounded to nearest integers and used as subscripts. An error          ',&
'      occurs if any such subscript is less than 1 or greater than the           ',&
'      dimension of X. Some examples:                                            ',&
'                                                                                ',&
'         X(3) is the third element of X .                                       ',&
'         X([1 2 3]) is the first three elements of X. So is                     ',&
'         X([sqrt(2), sqrt(3), 4*atan(1)]) .                                     ',&
'         If X has N components, X(N:-1:1) reverses them.                        ',&
'                                                                                ',&
'      The same indirect subscripting is used in matrices. If V has              ',&
'      M components and W has N components, then A(V,W) is the M by N            ',&
'      matrix formed from the elements of A whose subscripts are the             ',&
'      elements of V and W. For example... A(<1,5>,:) = A(<5,1>,:)               ',&
'      interchanges rows 1 and 5 of A.                                           ',&
'                                                                                ',&
'=     Used in assignment statements and to mean equality in "while"             ',&
'      and "if" clauses.                                                         ',&
'                                                                                ',&
'.     Decimal point. 314/100, 3.14 and .314E1 are all the                       ',&
'      same.                                                                     ',&
'                                                                                ',&
'      Element-by-element multiplicative operations are obtained                 ',&
'      using .* , ./ , or .\ . For example, C = A ./ B is the                    ',&
'      matrix with elements c(i,j) = a(i,j)/b(i,j) .                             ',&
'                                                                                ',&
'      C=A .^ B is an element-by-element operator equivalent                     ',&
'      to pow(A,B).                                                              ',&
'                                                                                ',&
'      Kronecker tensor products and quotients are obtained with                 ',&
'      .*. , ./. and .\. . See "kron".                                           ',&
'                                                                                ',&
'      Two or more points at the end of the line indicate                        ',&
'      continuation. The total line length limit is 1024                         ',&
'      characters.                                                               ',&
'                                                                                ',&
',     Used to separate matrix subscripts and function arguments.                ',&
'      Used at the end of "for", "while" and "if" clauses. Used to               ',&
'      separate statements in multi-statement lines. In this                     ',&
'      situation, it may be replaced by a semicolon to suppress                  ',&
'      printing.                                                                 ',&
'                                                                                ',&
'!     If an exclamation is the first character of a line the                    ',&
'      rest of the line is passed to the system to be executed.                  ',&
'                                                                                ',&
'      Examples:                                                                 ',&
'                                                                                ',&
'         // enter command history mode and change all occurrences of            ',&
'         // "abc" to "123" on the last command entered.                         ',&
'         !!c/abc/123                                                            ',&
'                                                                                ',&
'         // pass command to system                                              ',&
'         !ls -ltrasd                                                            ',&
'                                                                                ',&
'      see "EDIT"                                                                ',&
'                                                                                ',&
';     Used inside brackets to end rows.                                         ',&
'                                                                                ',&
'      Used after an expression or statement to suppress printing.               ',&
'      See "semi".                                                               ',&
'                                                                                ',&
'\     Backslash or matrix left division. A\B is roughly the                     ',&
'      same as "inv(A)*B", except it is computed in a different                  ',&
'      way. If A is an N by N matrix and B is a column vector                    ',&
'      with N components, or a matrix with several such columns,                 ',&
'      then X = A\B is the solution to the equation A*X = B                      ',&
'      computed by Gaussian elimination. A warning message is                    ',&
'      printed if A is badly scaled or nearly singular.                          ',&
'      A\eye produces the inverse of A .                                         ',&
'                                                                                ',&
'      If A is an M by N matrix with M < or > N and B is a                       ',&
'      column vector with M components, or a matrix with several                 ',&
'      such columns, then X = A\B is the solution in the least                   ',&
'      squares sense to the under- or overdetermined system of                   ',&
'      equations A*X = B. The effective rank, K, of A is                         ',&
'      determined from the QR decomposition with pivoting. A                     ',&
'      solution X is computed which has at most K nonzero                        ',&
'      components per column. If K < N this will usually not be                  ',&
'      the same solution as pinv(A)*B .                                          ',&
'      A\eye produces a generalized inverse of A.                                ',&
'                                                                                ',&
'      If A and B have the same dimensions, then A .\ B has                      ',&
'      elements a(i,j)\b(i,j) .                                                  ',&
'                                                                                ',&
'      Also, see "edit".                                                         ',&
'                                                                                ',&
'/     Slash or matrix right division. B/A is roughly the same                   ',&
'      as B*inv(A) . More precisely, B/A = (A''\B'')'' . See \ .                 ',&
'                                                                                ',&
'      IF A and B have the same dimensions, then A ./ B has                      ',&
'      elements a(i,j)/b(i,j) .                                                  ',&
'                                                                                ',&
'      Two or more slashes together on a line indicate a logical end of          ',&
'      line. Any following text is ignored.                                      ',&
'                                                                                ',&
'''     Transpose. X'' is the complex conjugate transpose of X .                 ',&
'                                                                                ',&
'      A quote is also use to delimit text. ''ANY TEXT'' is a vector whose       ',&
'      components are the LALA internal codes for the characters. A              ',&
'      quote within the text is indicated by two quotes. See "display"           ',&
'      and "FILE" .                                                              ',&
'                                                                                ',&
'+     Addition. X + Y . X and Y must have the same dimensions.                  ',&
'                                                                                ',&
'-     Subtraction. X - Y . X and Y must have the same                           ',&
'      dimensions.                                                               ',&
'                                                                                ',&
'*     Matrix multiplication, X*Y . Any scalar (1 by 1 matrix)                   ',&
'      may multiply anything. Otherwise, the number of columns of                ',&
'      X must equal the number of rows of Y .                                    ',&
'                                                                                ',&
'      Element-by-element multiplication is obtained with X .* Y .               ',&
'                                                                                ',&
'      The Kronecker tensor product is denoted by X .*. Y .                      ',&
'                                                                                ',&
'      Powers. X**p is X to the p power. p must be a                             ',&
'      scalar. If X is a matrix, see "HIGH" .                                    ',&
'                                                                                ',&
':     Colon. Used in subscripts, "for" iterations and possibly                  ',&
'      elsewhere.                                                                ',&
'                                                                                ',&
'        j:k   is the same as  <j, j+1, ..., k>                                  ',&
'              is empty if  j > k .                                              ',&
'        j:i:k is the same as [j, j+i,j+2*i, ..., k]                             ',&
'              (Fortran DO loop users beware of the unusual order!)              ',&
'                                                                                ',&
'         j:i:k  is the same as  <j, j+i, j+2i, ..., k>                          ',&
'         j:i:k  is empty if  i > 0 and j > k or if i < 0 and j < k .            ',&
'                                                                                ',&
'      The colon notation can be used to pick out selected rows,                 ',&
'      columns and elements of vectors and matrices.                             ',&
'                                                                                ',&
'         A(:)    is all the elements of A, regarded as a single column.         ',&
'                 However, used on the left side of an assignment, A(:)          ',&
'                 fills A, but preserves its shape.                              ',&
'        A(:,j)   is the j-th column of A                                        ',&
'        A(j:k)   is A(j), A(j+1), ... , A(k)                                    ',&
'        A(:,j:k) is A(:,j), A(:,j+1), ... ,A(:,k) and so on.                    ',&
'        A(:,:)   is the same as A.                                              ',&
'                                                                                ',&
'      For the use of the colon in the "for" statement, See "for" .              ',&
'                                                                                ',&
'^     A ^ B                                                                     ',&
'                                                                                ',&
'         The expression A^p means A to the p-th power. It is defined if A       ',&
'         is a square matrix and p is a scalar. If p is an integer greater       ',&
'         than one, the power is computed by repeated multiplication. For        ',&
'         other values of p the calculation involves the eigenvalues and         ',&
'         eigenvectors of A.                                                     ',&
'                                                                                ',&
'         The expression A^p is evaluated by repeated multiplication if          ',&
'         p is an integer greater than 1. Otherwise it is evaluated by           ',&
'                                                                                ',&
'               <X,D> = eig(A);                                                  ',&
'               for j = 1:n, D(j,j) = exp(p*log(D(j,j)))                         ',&
'               X*D/X                                                            ',&
'                                                                                ',&
'         This suffers from a potential loss of accuracy if X is badly           ',&
'         conditioned. It was partly for this reason that the case p =           ',&
'         1 is included in the general case. Comparison of A**1 with A           ',&
'         gives some idea of the loss of accuracy for other values of p          ',&
'         and for the elementary functions.                                      ',&
'                                                                                ',&
'      A .^ B                                                                    ',&
'                                                                                ',&
'         If A and B are the same shape A .^ B is an element-wise                ',&
'         operation where each element of A is raised to the power in            ',&
'         the corresponding element of B.                                        ',&
'                                                                                ',&
'         If B is a scalar, A .^ B raises each element of A to the power         ',&
'         of B.                                                                  ',&
'                                                                                ',&
'         These elemental operations are equivalent to pow(A,B).                 ',&
'                                                                                ',&
'semi  "semi" toggles the action of semicolons at the end of lines.              ',&
'      It will make semicolons cause rather than suppress printing.              ',&
'      A second "semi" restores the initial interpretation.                      ',&
'================================================================================',&
'VARIABLES                                                                       ',&
'                                                                                ',&
'ans   Variable created automatically when expressions are not                   ',&
'      assigned to anything else.                                                ',&
'                                                                                ',&
'clear  Erases all variables, except "eps", "flop", "eye" and "rand".            ',&
'       X = <> erases only variable X . So does "clear X".                       ',&
'                                                                                ',&
'who   Lists current variables.                                                  ',&
'================================================================================',&
'MACROS                                                                          ',&
'                                                                                ',&
'       The macro facility involves text and inward pointing angle               ',&
'       brackets. If "STRING" is the source text for any LALA                    ',&
'       expression or statement, then                                            ',&
'                                                                                ',&
'             t = ''STRING'';                                                    ',&
'       encodes the text as a vector of integers and stores that                 ',&
'       vector in t. "display(t)" will print the text and                        ',&
'                                                                                ',&
'             >t<                                                                ',&
'       causes the text to be interpreted, either as a statement or              ',&
'       as a factor in an expression. For example                                ',&
'                                                                                ',&
'             t = ''1/(i+j-1)'';                                                 ',&
'             display(t)                                                         ',&
'             for i = 1:n, for j = 1:n, a(i,j) = >t<;                            ',&
'                                                                                ',&
'       generates the Hilbert matrix of order n.                                 ',&
'       Another example showing indexed text,                                    ',&
'                                                                                ',&
'             S = <''x = 3            ''                                         ',&
'                  ''y = 4            ''                                         ',&
'                  ''z = sqrt(x*x+y*y)''>                                        ',&
'             for k = 1:3, >S(k,:)<                                              ',&
'                                                                                ',&
'       It is necessary that the strings making up the "rows" of                 ',&
'       the "matrix" S have the same lengths.                                    ',&
'================================================================================',&
'BASIC FUNCTIONS                                                                 ',&
'                                                                                ',&
'      For matrix arguments X , the functions "sin", "cos", "atan",              ',&
'      "sqrt", "log", "exp" and X**p are computed using eigenvalues D            ',&
'      and eigenvectors V . If <V,D> = eig(X) then f(X) = V*f(D)/V . This        ',&
'      method may give inaccurate results if V is badly conditioned. Some        ',&
'      idea of the accuracy can be obtained by comparing X**1 with X .           ',&
'      For vector arguments, the function is applied to each component.          ',&
'                                                                                ',&
'atan  atan(X) is the arctangent of X . See "BASIC" .                            ',&
'                                                                                ',&
'cos   cos(X) is the cosine of X . See "BASIC" .                                 ',&
'                                                                                ',&
'exp   exp(X) is the exponential of X , e to the X . See "BASIC".                ',&
'                                                                                ',&
'log   log(X) is the natural logarithm of X.                                     ',&
'                                                                                ',&
'      Complex results are produced if X is not positive, or has                 ',&
'      nonpositive eigenvalues.                                                  ',&
'                                                                                ',&
'      See "BASIC".                                                              ',&
'                                                                                ',&
'pow   For a scalar exponent pow(X,exponent) raises each element of X to         ',&
'      the specified power. pow(X,Y) raise each element in X by the              ',&
'      corresponding element in Y. X and Y must have the same shape.             ',&
'                                                                                ',&
'          A=magic(3);                                                           ',&
'          pow(A,3)                                                              ',&
'                                                                                ',&
'      Alternatively FOR loops can be used to perform most elemental operations: ',&
'                                                                                ',&
'          a=ones(A)      // create output array same size as input              ',&
'          <m,n>=shape(A);for i=1:n, for j=1:m, a(i,j)=A(i,j)**3;                ',&
'                                                                                ',&
'      or for low whole number exponents elemental multiplication is sufficient  ',&
'                                                                                ',&
'          b = A .* A .* A // elemental multiplication                           ',&
'                                                                                ',&
'sin   sin(X) is the sine of X. See "BASIC".                                     ',&
'                                                                                ',&
'sqrt  sqrt(X) is the square root of X. See "BASIC". Complex                     ',&
'      results are produced if X is not positive, or has                         ',&
'      nonpositive eigenvalues.                                                  ',&
'================================================================================',&
'RELATIONAL                                                                      ',&
'                                                                                ',&
'   An alternative to using the relational operators in flow control commands like',&
'   "for" are the relational functions. In general zero is regarded as false, and ',&
'   any other value is considered true. Note that only the REAL component of values',&
'   is compared except for the "eq" and "ne" operators, which consider the entire  ',&
'   value.                                                                         ',&
'                                                                                  ',&
'eq    "eq(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the elements are equal, and to 0 if they are not.                        ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'          // return 1 if all elements are zero, else 0                            ',&
'          allzero=all(eq(X,0))                                                    ',&
'                                                                                  ',&
'          a=magic(4)      // make some arrays                                     ',&
'          b=a             // b is the same as a                                   ',&
'          c=b; c(4,4)=-10 // c is not the same as a                               ',&
'          if all(eq(a,b))=1,display(''SAME''),else display(''DIFFERENT'')         ',&
'          if all(eq(a,c))=1,display(''SAME''),else display(''DIFFERENT'')         ',&
'                                                                                  ',&
'lt    "lt(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the corresponding element in X is less than the one in Y.                ',&
'      Otherwise, the element is set to 0. Only the REAL component of the          ',&
'      numbers is tested.                                                          ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'          count_of_true_results=sum(lt(X,Y))                                      ',&
'                                                                                  ',&
'le    "le(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the corresponding element in X is less than or equal to the one          ',&
'      in Y; if X is greater than Y the element of the answer is 0. Only           ',&
'      the REAL component of the numbers is tested.                                ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'ge    "ge(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the corresponding element in X is greater than or equal to the           ',&
'      one in Y; if X is less than Y the element of the answer is 0. Only          ',&
'      the REAL component of the numbers is tested.                                ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'gt    "gt(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the corresponding element in X is greater than to the one in Y;          ',&
'      if X is less than or equal to Y the returned element in the answer          ',&
'      is 0. Only the REAL component of the numbers is tested.                     ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'ne    "ne(X,Y)" is an elemental function that sets element values to 1            ',&
'      if the elements are not equal, and to 0 if they are not equal.              ',&
'                                                                                  ',&
'      X and Y must have the same number of elements but need not be the same      ',&
'      shape. The returned value has the shape of X unless X is scalar, in         ',&
'      which case the returned value has the shape of Y.                           ',&
'                                                                                  ',&
'================================================================================  ',&
'HIGH LEVEL FUNCTIONS                                                              ',&
'                                                                                  ',&
'abs   abs(X) is the absolute value, or complex modulus,                           ',&
'      of the elements of X .                                                      ',&
'                                                                                  ',&
'all   all(X) returns FALSE(ie. 0) if any element value is FALSE(0).               ',&
'      Otherwise, it returns TRUE(ie. 1).                                          ',&
'                                                                                  ',&
'      0 is regarded as false and "not 0" signifies true in general in             ',&
'      lala(1). so if F=0 and T=1                                                  ',&
'                                                                                  ',&
'          all(T,T,T,T,T]) // produces 1 (which is a TRUE value)                   ',&
'          all(T,F,T,F,T]) // produces 0 (which is a FALSE value)                  ',&
'                                                                                  ',&
'any   any(X) returns TRUE(ie. 1) if any element value is TRUE(non-zero).          ',&
'                                                                                  ',&
'      0 is regarded as false and "not 0" signifies true in general in             ',&
'      lala(1).                                                                    ',&
'                                                                                  ',&
'          all(T,T,T,T,T]) // produces 1 (which is a TRUE value)                   ',&
'          all(T,F,F,F,F]) // produces 1 (which is a TRUE value)                   ',&
'          all(F,F,F,F,F]) // produces 0 (which is a FALSE value)                  ',&
'                                                                                  ',&
'base  base(X,B) is a vector containing the base B representation                  ',&
'      of X. This is often used in conjunction with "display".                     ',&
'      "display(X,B)" is the same as "display(base(X,B))". For example,            ',&
'      "display(4*atan(1),16)" prints the hexadecimal representation of pi.        ',&
'                                                                                  ',&
'chol  Cholesky factorization. "chol(X)" uses only the diagonal                    ',&
'      and upper triangle of X. The lower triangular is assumed to be              ',&
'      the (complex conjugate) transpose of the upper. If X is positive            ',&
'      definite, then "R = chol(X)" produces an upper triangular R so              ',&
'      that R''*R = X . If X is not positive definite, an error message            ',&
'      is printed.                                                                 ',&
'                                                                                  ',&
'chop  Truncate arithmetic. "chop(P)" causes P places to be chopped                ',&
'      off after each arithmetic operation in subsequent computations. This        ',&
'      means P hexadecimal digits on some computers and P octal digits             ',&
'      on others. "chop(0)" restores full precision.                               ',&
'                                                                                  ',&
'cond  Condition number in 2-norm. "cond(X)" is the ratio of the                   ',&
'      largest singular value of X to the smallest.                                ',&
'                                                                                  ',&
'conjg  "conjg(X)" is the complex conjugate of X .                                 ',&
'                                                                                  ',&
'date_and_time  date_and_time(IDS)" where an array of IDs indicate                 ',&
'               which values to return:                                            ',&
'                                                                                  ',&
'               Id                                                                 ',&
'                1. The year, including the century.                               ',&
'                2. The month of the year                                          ',&
'                3. The day of the month                                           ',&
'                4. Difference in minutes between the reported and UTC time.       ',&
'                5. The hour of the day, in the range 0 to 23.                     ',&
'                6. The minutes of the hour, in the range 0 to 59                  ',&
'                7. The seconds of the minute, in the range 0 to 60                ',&
'                8. The milliseconds of the second, in the range 0 to 999.         ',&
'                9. Unix epoch time                                                ',&
'               10. Julian time                                                    ',&
'               11. Modified Julian time                                           ',&
'               12. Basename and Seconds (BAS) time                                ',&
'               13. Ordinal day of the year                                        ',&
'               14. Day of week                                                    ',&
'                                                                                  ',&
'               dat=date_and_time(1:8)                                             ',&
'               YEAR=1;MONTH=2;DAY=3;                                              ',&
'               display(date_and_time(YEAR,MONTH,DAY))                             ',&
'                                                                                  ',&
'det   "det(X)" is the determinant of the square matrix X .                        ',&
'                                                                                  ',&
'diag  If V is a row or column vector with N components,                           ',&
'      "diag(V,K)" is a square matrix of order "N+abs(K)" with the                 ',&
'      elements of V on the K-th diagonal. K = 0 is the main diagonal,             ',&
'      K > 0 is above the main diagonal and K < 0 is below the main                ',&
'      diagonal. "diag(V)" simply puts V on the main diagonal. eg.                 ',&
'                                                                                  ',&
'         diag(-M:M) + diag(ones(2*M,1),1) + diag(ones(2*M,1),-1)                  ',&
'                                                                                  ',&
'      produces a tridiagonal matrix of order 2*M+1 .                              ',&
'                                                                                  ',&
'      If X is a matrix, "diag(X,K)" is a column vector formed from the            ',&
'      elements of the K-th diagonal of X. "diag(X)" is the main diagonal          ',&
'      of X. "diag(diag(X))" is a diagonal matrix .                                ',&
'                                                                                  ',&
'eig   Eigenvalues and eigenvectors.                                               ',&
'      "eig(X)" is a vector containing the eigenvalues of a square                 ',&
'      matrix X.                                                                   ',&
'      "<V,D> = eig(X)" produces a diagonal matrix D of                            ',&
'      eigenvalues and a full matrix V whose columns are the                       ',&
'      corresponding eigenvectors so that X*V = V*D .                              ',&
'                                                                                  ',&
'                                                                                  ',&
'eye   Identity matrix. "eye(N)" is the N by N identity matrix.                    ',&
'      "eye(M,N)" is an M by N matrix with 1''s on the diagonal and                ',&
'      zeros elsewhere. "eye(A)" is the same size as A. "eye"                      ',&
'      with no arguments is an identity matrix of whatever order                   ',&
'      is appropriate in the context. For example "A + 3*eye"                      ',&
'      adds 3 to each diagonal element of A.                                       ',&
'                                                                                  ',&
'fmtc  "fmtc(A,''format'')" converts given numbers to strings representing         ',&
'       a complex number using the optional specified Fortran format. Note         ',&
'       the format is used repeatedly to output each string. It is not             ',&
'       used to print multiple values as once.                                     ',&
'                                                                                  ',&
'         A=10+sqrt(-1)*20                                                         ',&
'         display(fmtc(A))                                                         ',&
'                                                                                  ',&
'fmti  "fmti(A,''format'')" converts given numbers to strings representing         ',&
'       the nearest integer values using the optional specified Fortran            ',&
'       format. Note the format is used repeatedly to output each string.          ',&
'       It is not used to print multiple values as once.                           ',&
'                                                                                  ',&
'         A=magic(3)                                                               ',&
'         display(fmti(A,''i0,1x''))                                               ',&
'         8 3 4 1 5 9 6 7 2                                                        ',&
'                                                                                  ',&
'fmtr  "fmtr(A,''format'')" converts given numbers to strings representing         ',&
'       real values using the optional specified Fortran format. Note              ',&
'       the format is used repeatedly to output each string. It is not             ',&
'       used to print multiple values as once.                                     ',&
'                                                                                  ',&
'         display(fmtr(A,''g0,1x''))                                               ',&
'                                                                                  ',&
'                                                                                  ',&
'hess  Hessenberg form. The Hessenberg form of a matrix is zero                    ',&
'      below the first subdiagonal. If the matrix is symmetric or                  ',&
'      Hermitian, the form is tridiagonal. <P,H> = "hess(A)" produces a            ',&
'      unitary matrix P and a Hessenberg matrix H so that A = P*H*P''. By          ',&
'      itself, "hess(A)" returns H.                                                ',&
'                                                                                  ',&
'invh  Inverse Hilbert matrix. "invh(N)" is the inverse of a N_by_N                ',&
'      Hilbert matrix (which is a famous example of a badly conditioned            ',&
'      matrix). The result is exact for N less than about 15, depending            ',&
'      upon the computer.                                                          ',&
'                                                                                  ',&
'         for i = 1:N, for j = 1:N, A(i,j) = 1/(i+j-1);                            ',&
'                                                                                  ',&
'      generates the NxN Hilbert matrix.                                           ',&
'                                                                                  ',&
'      "invh" has an alias of "inverse_hilbert" and "invhilb".                     ',&
'                                                                                  ',&
'aimag  see "imag"                                                                 ',&
'imag  "imag(X)" is the imaginary part of X .                                      ',&
'                                                                                  ',&
'inv   "inv(X)" is the inverse of the square matrix X . A warning                  ',&
'      message is printed if X is badly scaled or nearly                           ',&
'      singular.                                                                   ',&
'                                                                                  ',&
'kron  "kron(X,Y)" is the Kronecker tensor product of X and Y. It                  ',&
'      is also denoted by X .*. Y . The result is a large matrix                   ',&
'      formed by taking all possible products between the elements                 ',&
'      of X and those of Y . For example, if X is 2 by 3, then                     ',&
'      X .*. Y is                                                                  ',&
'                                                                                  ',&
'            < x(1,1)*Y  x(1,2)*Y  x(1,3)*Y                                        ',&
'              x(2,1)*Y  x(2,2)*Y  x(2,3)*Y >                                      ',&
'                                                                                  ',&
'      The five-point discrete Laplacian for an n-by-n grid can be                 ',&
'      generated by                                                                ',&
'                                                                                  ',&
'            T = diag(ones(n-1,1),1);  T = T + T'';  I = eye(T);                   ',&
'            A = T.*.I + I.*.T - 4*eye;                                            ',&
'                                                                                  ',&
'      Just in case they might be useful, LALA includes                            ',&
'      constructions called Kronecker tensor quotients, denoted by                 ',&
'      X ./. Y and X .\. Y . They are obtained by replacing the                    ',&
'      element-wise multiplications in X .*. Y with divisions.                     ',&
'                                                                                  ',&
'lu    Factors from Gaussian elimination. <L,U> = LU(X) stores a                   ',&
'      upper triangular matrix in U and a ''psychologically lower                  ',&
'      triangular matrix'', i.e. a product of lower triangular and                 ',&
'      permutation matrices, in L , so that X = L*U . By itself,                   ',&
'      "lu(X)" returns the output from CGEFA .                                     ',&
'                                                                                  ',&
'magic  Magic square. "magic(N)" is an N by N matrix constructed                   ',&
'       from the integers 1 through N**2 with equal row, column and                ',&
'       diagonal sums. N must be a positive whole number not equal to two.         ',&
'                                                                                  ',&
'maxval  "maxval(A)" returns the maximum real component found in the               ',&
'        elements of A                                                             ',&
'                                                                                  ',&
'minval  "minval(A)" returns the minimum real component found in the               ',&
'        elements of A                                                             ',&
'                                                                                  ',&
'norm  computes the norm or P-norm of X                                            ',&
'                                                                                  ',&
'      norm(X,P) computes the P-norm of X. P=2 is the default, which defines       ',&
'      the standard norm.                                                          ',&
'                                                                                  ',&
'      For matrices..                                                              ',&
'          norm(X,1)      is the 1-norm of X; ie. the largest column sum           ',&
'                         of X.                                                    ',&
'                                                                                  ',&
'          norm(X,2)      the largest singular value of X.                         ',&
'          or norm(X)                                                              ',&
'                                                                                  ',&
'          norm(X,''inf'')  is the infinity norm of X; ie. the largest row         ',&
'                         sum of X.                                                ',&
'                                                                                  ',&
'          norm(X,''fro'')  is the F-norm, i.e. "sqrt(sum(diag(X''*X)))" .         ',&
'                                                                                  ',&
'      For vectors..                                                               ',&
'          norm(V,P)      the same as sum(V(I)**P)**(1/P) .                        ',&
'                         ??? what about negative values of (I) and odd P? abs() or not',&
'                                                                                      ',&
'          norm(V,2)      the square root of the sum of the squares of                 ',&
'          or norm(V)     the entries of V.                                            ',&
'                                                                                      ',&
'          norm(V,''inf'')  the value is max(abs(V)) .                                 ',&
'<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      ',&
'!!          If X is a vector, then                                                    ',&
'!!                                                                                    ',&
'!!            norm(x,p) = sum(abs(x) .^ p) ^ (1/p)                                    ',&
'!!            norm(x,1) is the sum of the absolute values of X.                       ',&
'!!            norm(x)/sqrt(n) is the root-mean-square value.                          ',&
'!!            norm(x,-inf)=min(abs(x))                                                ',&
'<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<      ',&
'                                                                                      ',&
'ones  All ones. "ones(N)" is an N by N matrix of ones. "ones(M,N)"                    ',&
'      is an M by N matrix of ones . "ones(A)" is the same size as A and               ',&
'      all ones .                                                                      ',&
'                                                                                      ',&
'         a=magic(4)                                                                   ',&
'         a=a+ones(a)*3 // Add 3 to each element of "a"                                ',&
'                                                                                      ',&
'orth  Orthogonalization. "Q = orth(X)" is a matrix with                               ',&
'      orthonormal columns, i.e. Q''*Q = eye, which span the same                      ',&
'      space as the columns of X .                                                     ',&
'                                                                                      ',&
'pack  "pack(A,mask)" select the elements of an array whose corresponding              ',&
'      mask element is not zero into a vector. The logical mask must be                ',&
'      the same size as the array.                                                     ',&
'                                                                                      ',&
'          a=magic(10)                                                                 ',&
'          b=pack(a,ge(a,80)) // select elements >= 80                                 ',&
'                                                                                      ',&
'pinv  Pseudoinverse.                                                                  ',&
'                                                                                      ',&
'      "X = pinv(A)" produces a matrix X of the same dimensions as A''                 ',&
'      so that A*X*A = A , X*A*X = X and AX and XA are Hermitian . The                 ',&
'      computation is based on "svd(A)" and any singular values less                   ',&
'      than a tolerance are treated as zero. The default tolerance is                  ',&
'      "norm(shape(A),''inf'')*norM(A)*eps". This tolerance may be overridden          ',&
'      with "X = pinv(A,tol)". See "rank".                                             ',&
'                                                                                      ',&
'poly  Characteristic polynomial.                                                      ',&
'                                                                                      ',&
'      If A is an N by N matrix, "poly(A)" is a column vector with                     ',&
'      N+1 elements which are the coefficients of the characteristic                   ',&
'      polynomial, "det(lambda*eye - A)" .                                             ',&
'                                                                                      ',&
'      If V is a vector, "poly(V)" is a vector whose elements are the                  ',&
'      coefficients of the polynomial whose roots are the elements of V                ',&
'      . For vectors, "roots" and "poly" are inverse functions of each                 ',&
'      other, up to ordering, scaling, and roundoff error.                             ',&
'                                                                                      ',&
'      "roots(poly(1:20))" generates Wilkinson''s famous example.                      ',&
'                                                                                      ',&
'prod  "prod(X)" is the product of all the elements of X.                              ',&
'                                                                                      ',&
'           A=prod(1:10) // the factorial of 10                                        ',&
'           B=2*3*4*5*6*7*8*9*10                                                       ',&
'                                                                                      ',&
'qr    Orthogonal-triangular decomposition. "<Q,R> = qr(X)" produces an                ',&
'      upper triangular matrix R of the same                                           ',&
'      dimension as X and a unitary matrix Q so that X = Q*R .                         ',&
'                                                                                      ',&
'      "<Q,R,E> = qr(X)" produces a permutation matrix E, an upper                     ',&
'      triangular R with decreasing diagonal elements and a unitary Q                  ',&
'      so that X*E = Q*R . By itself, "qr(X)" returns the output of                    ',&
'      "cqrdc". "triu(qr(X))" is R .                                                   ',&
'                                                                                      ',&
'rand  "rand" with no arguments is a scalar whose value changes each time              ',&
'      it is referenced. See "randn" and "randu" for generating random                 ',&
'      matrices.                                                                       ',&
'                                                                                      ',&
'randu  Uniformly distributed random numbers and matrices in the interval              ',&
'       "(0.0,1.0). "randu(N)" is an N by N matrix with random                         ',&
'       entries. "randu(M,N)" is an M by N matrix with random entries.                 ',&
'                                                                                      ',&
'randn                                                                                 ',&
'       randn(N) or randn(N,M) produces random numbers with a normal                   ',&
'       distribution with mean 0.0 and variance 1.0. "randn(N)" is an N                ',&
'       by N matrix with random entries. "randn(M,N)" is an M by N matrix              ',&
'       with random entries.                                                           ',&
'                                                                                      ',&
'randseed  "randseed()" returns the current value of the seed for the                  ',&
'          generator. "randseed(n)" sets the seed to n.                                ',&
'          "randseed(0)" resets the seed to 0, its value when LALA is                  ',&
'          first entered.                                                              ',&
'                                                                                      ',&
'rank  Rank. "K = rank(X)" is the number of singular values of X                       ',&
'      that are larger than "norm(shape(X),''inf'')*norm(X)*eps".                      ',&
'      "K = rank(X,tol)" is the number of singular values of X that                    ',&
'      are larger than tol.                                                            ',&
'                                                                                      ',&
'rcond  "rcond(X)" is an estimate for the reciprocal of the                            ',&
'       condition of X in the 1-norm obtained by the LINPACK                           ',&
'       condition estimator. If X is well conditioned, rcond(X)                        ',&
'       is near 1.0. If X is badly conditioned, rcond(X) is                            ',&
'       near 0.0.                                                                      ',&
'       <R, Z> = rcond(A) sets R to rcond(A) and also produces a                       ',&
'       vector Z so that                                                               ',&
'                                                                                      ',&
'                 norm(A*Z,1) = R*norm(A,1)*norm(Z,1)                                  ',&
'                                                                                      ',&
'       So, if rcond(A) is small, then Z is an approximate null                        ',&
'       vector.                                                                        ',&
'                                                                                      ',&
'rat   An experimental function which attempts to remove the                           ',&
'      roundoff error from results that should be "simple"                             ',&
'      rational numbers.                                                               ',&
'      "rat(X)" approximates each element of X by a continued                          ',&
'      fraction of the form                                                            ',&
'                                                                                      ',&
'                a/b = d1 + 1/(d2 + 1/(d3 + ... + 1/dk))                               ',&
'                                                                                      ',&
'      with k <= len, integer di and abs(di) <= max . The default                      ',&
'      values of the parameters are len = 5 and max = 100.                             ',&
'      "rat(len,max)" changes the default values. Increasing either                    ',&
'      len or max increases the number of possible fractions.                          ',&
'      "<A,B> = rat(X)" produces integer matrices A and B so that                      ',&
'                                                                                      ',&
'                A ./ B  =  rat(X)                                                     ',&
'                                                                                      ',&
'      Some examples:                                                                  ',&
'                                                                                      ',&
'            long                                                                      ',&
'            T = invh(6), X = inv(T)                                                   ',&
'            <A,B> = rat(X)                                                            ',&
'            H = A ./ B, S = inv(H)                                                    ',&
'                                                                                      ',&
'            short e                                                                   ',&
'            d = 1:8,  e = ones(d),  A = abs(d''*e - e''*d)                            ',&
'            X = inv(A)                                                                ',&
'            rat(X)                                                                    ',&
'            display(ans)                                                              ',&
'                                                                                      ',&
'real  "real(X)" is the real part of X.                                                ',&
'                                                                                      ',&
'reshape  "reshape(A,[M,N])" reshapes the elements in array A to a                     ',&
'         new configuration with M rows and N columns. The size of                     ',&
'         A must match the value M*N.                                                  ',&
'                                                                                      ',&
'             A=reshape(1:100,[10,10])                                                 ',&
'             B=reshape(A,[20,5])                                                      ',&
'                                                                                      ',&
'         Alternatively note that using (:) on the LHS prevents the array              ',&
'         from being reshaped, allowing arbitrary shapes to be created                 ',&
'         and filled as well, but incurrs the overhead of copying the data.            ',&
'                                                                                      ',&
'             C=zeros(25,4) // create array of desired shape                           ',&
'             C(:)=A       // copy values from A into C ignoring shape of A            ',&
'                                                                                      ',&
'rref  "rref(A)" is the reduced row echelon form of the rectangular                    ',&
'      matrix. rref(A,B) is the same as rref(<A,B>) .                                  ',&
'                                                                                      ',&
'roots  Find polynomial roots. "roots(C)" computes the roots of the                    ',&
'       polynomial whose coefficients are the elements of the vector C.                ',&
'       If C has N+1 components, the polynomial is                                     ',&
'                                                                                      ',&
'          C(1)*X**N + ... + C(N)*X + C(N+1)                                           ',&
'                                                                                      ',&
'       See "poly".                                                                    ',&
'                                                                                      ',&
'round  "round(X)" rounds the elements of X to the nearest integers.                   ',&
'                                                                                      ',&
'schur  Schur decomposition. "<U,T> = schur(X)" produces an upper                      ',&
'       triangular matrix T , with the eigenvalues of X on the                         ',&
'       diagonal, and a unitary matrix U so that X = U*T*U'' and                       ',&
'       U''*U = eye . By itself, "schur(X)" returns T .                                ',&
'                                                                                      ',&
'shape  If X is an M by N matrix, then shape(X) is <M, N> .                            ',&
'       Can also be used with a multiple assignment,                                   ',&
'            <M, N> = shape(X) .                                                       ',&
'                                                                                      ',&
'sum   "sum(X)" is the sum of all the elements of X.                                   ',&
'      "sum(diag(X))" is the trace of X.                                               ',&
'                                                                                      ',&
'      "sum(X,dim)" is the vector of sums of elements along the                        ',&
'      specified dimension, where 1 <= dim <= 2.                                       ',&
'                                                                                      ',&
'          matrix=[  1,   2,   3,   4                                                  ',&
'                    10,  20,  30,  40                                                 ',&
'                    100, 200, 300, 400  ];                                            ',&
'          s=sum(matrix)                                                               ',&
'          sum_of_columns=sum(matrix,1)                                                ',&
'          sum_of_rows=sum(matrix,2)                                                   ',&
'                                                                                      ',&
'svd   Singular value decomposition. "<U,S,V> = svd(X)" produces a                     ',&
'      diagonal matrix S , of the same dimension as X and with                         ',&
'      nonnegative diagonal elements in decreasing order, and                          ',&
'      unitary matrices U and V so that X = U*S*V'' .                                  ',&
'                                                                                      ',&
'      By itself, "svd(X)" returns a vector containing the singular                    ',&
'      values.                                                                         ',&
'                                                                                      ',&
'      "<U,S,V> = svd(X,0)" produces the "economy size"                                ',&
'      decomposition. If X is m by n with m > n, then only the                         ',&
'      first n columns of U are computed and S is n by n .                             ',&
'                                                                                      ',&
'tril  Lower triangle. "tril(X)" is the lower triangular part of X.                    ',&
'      "tril(X,K)" is the elements on and below the K-th diagonal of                   ',&
'      X. K = 0 is the main diagonal, K > 0 is above the main                          ',&
'      diagonal and K < 0 is below the main diagonal.                                  ',&
'                                                                                      ',&
'triu  Upper triangle. "triu(X)" is the upper triangular part of X.                    ',&
'      "triu(X,K)" is the elements on and above the K-th diagonal of X. K              ',&
'      = 0 is the main diagonal, K > 0 is above the main diagonal and K <              ',&
'      0 is below the main diagonal.                                                   ',&
'                                                                                      ',&
'user  Allows personal Fortran subroutines to be linked into                           ',&
'      LALA. The subroutine should have the heading                                    ',&
'                                                                                      ',&
'         SUBROUTINE USER(A,M,N,S,T)                                                   ',&
'         REAL or DOUBLEPRECISION A(M,N),S,T                                           ',&
'                                                                                      ',&
'      The LALA statement "Y = user(X,s,t)" results in a call to the                   ',&
'      subroutine with a copy of the matrix X stored in the argument A,                ',&
'      its column and row dimensions in M and N, and the scalar parameters             ',&
'      s and t stored in S and T. If s and t are omitted, they are set                 ',&
'      to 0.0. After the return, A is stored in Y. The dimensions M and                ',&
'      N may be reset within the subroutine. The statement Y = "user(K)"               ',&
'      results in a call with M = 1, N = 1 and A(1,1) = "float(K)". After              ',&
'      the subroutine has been written, it must be compiled and linked                 ',&
'      to the LALA object code within the local operating system.                      ',&
'                                                                                      ',&
'what  does nothing for now                                                            ',&
'                                                                                      ',&
'zeros                                                                                 ',&
'      Returns a matrix of all zeros.                                                  ',&
'                                                                                      ',&
'         zeros(N)    returns an N by N matrix of zeroes.                              ',&
'         zeros(M,N)  returns an M by N matrix of zeroes.                              ',&
'         zeros(X)    returns a matrix of zeroes of the same order as X.               ',&
'================================================================================      ',&
'FLOW CONTROL                                                                          ',&
'                                                                                      ',&
'else  Used with "if".                                                                 ',&
'                                                                                      ',&
'end   Terminates the scope of "for", "while" and "if" statements.                     ',&
'      Without "end"s, "for" and "while" repeat all statements up to                   ',&
'      the end of the line. Each "end" is paired with the closest                      ',&
'      previous unpaired "for" or "while" and serves to terminate its                  ',&
'      scope. The line                                                                 ',&
'                                                                                      ',&
'         for I=1:N, for J=1:N, A(I,J)=1/(I+J-1); A                                    ',&
'                                                                                      ',&
'      would cause A to be printed N**2 times, once for each new                       ',&
'      element. On the other hand, the line                                            ',&
'                                                                                      ',&
'         for I=1:N, for J=1:N, A(I,J)=1/(I+J-1); end, end, A                          ',&
'                                                                                      ',&
'      will lead to only the final printing of A.                                      ',&
'      Similar considerations apply to "while".                                        ',&
'                                                                                      ',&
'      See "exit" (terminates execution of loops or of LALA itself).                   ',&
'                                                                                      ',&
'if    Conditionally execute statements                                                ',&
'                                                                                      ',&
'      SIMPLE FORM                                                                     ',&
'       Enter                                                                          ',&
'                                                                                      ',&
'         if expression rop expression, statements                                     ',&
'                                                                                      ',&
'      where rop is =, <, >, <=, >=, or <> (not equal). The                            ',&
'      statements are executed once if the indicated comparison                        ',&
'      between the real parts of the first components of the two                       ',&
'      expressions is true, otherwise the statements are skipped.                      ',&
'                                                                                      ',&
'      EXAMPLE                                                                         ',&
'        Enter                                                                         ',&
'                                                                                      ',&
'         if abs(i-j) = 1, a(i,j) = -1;                                                ',&
'                                                                                      ',&
'      More complicated forms use "end" in the same way it is used with                ',&
'      "for" and "while" and use "else" as an abbreviation for "end",                  ',&
'                                                                                      ',&
'         if expression not rop expression                                             ',&
'                                                                                      ',&
'      EXAMPLE                                                                         ',&
'        Enter                                                                         ',&
'                                                                                      ',&
'         for i = 1:n, for j = 1:n, ...                                                ',&
'            if i = j, a(i,j) = 2; else if abs(i-j) = 1, a(i,j) = -1; ...              ',&
'            else a(i,j) = 0;                                                          ',&
'                                                                                      ',&
'      An easier way to accomplish the same thing is                                   ',&
'                                                                                      ',&
'         a = 2*eye(n);                                                                ',&
'         for i = 1:n-1, a(i,i+1) = -1; a(i+1,i) = -1;                                 ',&
'                                                                                      ',&
'for   Repeat statements a specific number of times.                                   ',&
'                                                                                      ',&
'         for variable = expr, statement, ..., statement, end                          ',&
'                                                                                      ',&
'      The "end" at the end of a line may be omitted. The comma before the             ',&
'      "end" may also be omitted. The columns of the expression are stored             ',&
'      one at a time in the variable and then the following statements,                ',&
'      up to the "end", are executed. The expression is often of the form              ',&
'      X:Y, in which case its columns are simply scalars. Some examples                ',&
'      (assume N has already been assigned a value).                                   ',&
'                                                                                      ',&
'       for I = 1:N, for J = 1:N, A(I,J) = 1/(I+J-1);                                  ',&
'       for J = 2:N-1, A(J,J) = J; end; A                                              ',&
'       for S = 1.0: -0.1: 0.0, ... steps S with increments of -0.1 .                  ',&
'       for E = eye(N), ... sets E to the unit N-vectors.                              ',&
'       for V = A, ... has the same effect as                                          ',&
'       for J = 1:N, V = A(:,J); ... except J is also set here.                        ',&
'                                                                                      ',&
'while  Repeat statements an indefinite number of times.                               ',&
'                                                                                      ',&
'          while expr rop expr, statement, ..., statement, end                         ',&
'                                                                                      ',&
'       where rop is =, <, >, <=, >=, or <> (not equal). The "end"                     ',&
'       at the end of a line may be omitted. The comma before the                      ',&
'       "end" may also be omitted. The commas may be replaced by                       ',&
'       semicolons to avoid printing. The statements are                               ',&
'       repeatedly executed as long as the indicated comparison                        ',&
'       between the real parts of the first components of the two                      ',&
'       expressions is true.                                                           ',&
'                                                                                      ',&
'       EXAMPLE                                                                        ',&
'       (assume a matrix A is already defined).                                        ',&
'                                                                                      ',&
'        E = 0*A; F = E + eye; N = 1;                                                  ',&
'        while norm(E+F-E,1) > 0, E = E + F; F = A*F/N; N = N + 1;                     ',&
'        E                                                                             ',&
'                                                                                      ',&
'exit  Causes termination of a "for" or "while" loop.                                  ',&
'      If not in a loop, terminates execution of LALA.                                 ',&
'      Also see "quit".                                                                ',&
'                                                                                      ',&
'quit  From the terminal, causes return to the operating system                        ',&
'      or other program which invoked LALA. From inside an                             ',&
'      "exec", causes return to the invoking "exec", or to the                         ',&
'      terminal.                                                                       ',&
'================================================================================      ',&
'FILE ACCESS                                                                           ',&
'                                                                                      ',&
'      The "exec", "save", "delete", "load", "diary", and "print"                      ',&
'      functions access files. The ''file'' parameter takes different                  ',&
'      forms for different operating systems. On most systems, ''file''                ',&
'      may be a string of up to 1024 characters in quotes. For example,                ',&
'      "save(''A'')" or "exec(''LALA/demo.exec'')" . The string will be used           ',&
'      as the name of a file in the local operating system.                            ',&
'                                                                                      ',&
'      Check your local installation for details. The filename must be                 ',&
'      composed of recognized characters. See "char".                                  ',&
'                                                                                      ',&
'      Also see "quit" and "exit".                                                     ',&
'                                                                                      ',&
'delete  "delete(''filename'')" deletes the given file.                                ',&
'                                                                                      ',&
'exec  "exec(''file'',k)" obtains subsequent LALA input from an                        ',&
'      external file. The printing of input is controlled by the                       ',&
'      optional parameter k .                                                          ',&
'                                                                                      ',&
'      Files are searched for by the given name. If not found, it is searched          ',&
'      for in the colon-separated directory names in the environment variable          ',&
'      LALA_PATH. It is looked for first literally by the given name, and then         ',&
'      by the name suffixed with ".la".                                                ',&
'                                                                                      ',&
'      "include" is an alias for "exec".                                               ',&
'                                                                                      ',&
'         If k = 0 , there is no echo, prompt or pause. This is the                    ',&
'                    default if the exec command is followed by a semicolon.           ',&
'         If k = 1 , the input is echoed.                                              ',&
'         If k = 2 , the LALA prompt <> is printed.                                    ',&
'         If k = 3 , there will be echos and prompts, but no pauses.                   ',&
'                    This is the the default if the exec command is not                ',&
'                    followed by a semicolon.                                          ',&
'         If k = 4 , LALA pauses before each prompt and waits for a                    ',&
'                    null line to continue.                                            ',&
'         If k = 7 , there will be echos, prompts and pauses. This is                  ',&
'                    useful for demonstrations on video terminals.                     ',&
'                                                                                      ',&
'      "exec"''s may be nested, i.e. the text in the file may contain                  ',&
'      "exec" of another file.                                                         ',&
'                                                                                      ',&
'      "exec" may not be recursive, as Fortran (currently) does not allow              ',&
'      for multiple opens of a file.                                                   ',&
'                                                                                      ',&
'      "exec"s may also be driven by "for" and "while" loops.                          ',&
'                                                                                      ',&
'include  "include" is an alias for "exec".                                            ',&
'                                                                                      ',&
'load  "load(''file'')" retrieves all the variables from the file .                    ',&
'      See FILE and "save" for more details. To prepare your own                       ',&
'      file for "load"ing, change the "read" to "write" in the code                    ',&
'      given under "save".                                                             ',&
'                                                                                      ',&
'print  "print(''file'',X)" prints X on the file using the current                     ',&
'       format determined by "short", "long z", etc. See FILE.                         ',&
'                                                                                      ',&
'doc   does nothing at the moment                                                      ',&
'                                                                                      ',&
'save  "save(''file'')" stores all the current variables in a file.                    ',&
'      "save(''file'',X)" saves only X . See FILE .                                    ',&
'                                                                                      ',&
'      The variables may be retrieved later by "load(''file'')" or by your             ',&
'      own program using the following code for each matrix. The lines                 ',&
'      involving "ximag" may be eliminated if everything is known to                   ',&
'      be real.                                                                        ',&
'                                                                                      ',&
'        > ! attach LUN to ''file'', then ...                                          ',&
'        > doubleprecision :: xreal(mmax,nmax)                                         ',&
'        > doubleprecision :: ximag(mmax,nmax)                                         ',&
'        > character(len=32) :: id                                                     ',&
'        > read(LUN,''(a32,3i9)'') id,m,n,img                                          ',&
'        > do j = 1, n                                                                 ',&
'        >    read(LUN,''(4z18)'') (xreal(i,j), i=1,m)                                 ',&
'        >    if (img .ne. 0) read(LUN,102) (ximag(i,j),i=1,m)                         ',&
'        > enddo                                                                       ',&
'        > ! The formats used are system dependent. These are typical.                 ',&
'        > ! See SUBROUTINE mat_savlod(3f) in your local implementation                ',&
'        > ! of LALA.                                                                  ',&
'                                                                                      ',&
'================================================================================      ',&
'OUTPUT OPTIONS                                                                        ',&
'      ( Also see "FILE" ("exec", "load", "print", "save" ))                           ',&
'                                                                                      ',&
'lines  An internal count is kept of the number of lines of output                     ',&
'       since the last input. Whenever this count approaches a                         ',&
'       limit, the user is asked whether or not to suppress                            ',&
'       printing until the next input. Initially the limit is 21.                      ',&
'       "lines(N)" resets the limit to N .                                             ',&
'                                                                                      ',&
'long   See "short" also.                                                              ',&
'                                                                                      ',&
'       Determine output format. All computations are done in                          ',&
'       complex arithmetic and double precision if it is available.                    ',&
'       "short" and "long" merely switch between different output                      ',&
'       formats.                                                                       ',&
'                                                                                      ',&
'        long     // Scaled fixed point format with about 15 digits.                   ',&
'        long e   // Floating point format with about 15 digits.                       ',&
'        long z   // System dependent format, often hexadecimal.                       ',&
'                                                                                      ',&
'short  See "long" also.                                                               ',&
'       Determine output format. All computations are done in                          ',&
'       complex arithmetic and double precision if it is available.                    ',&
'       "short" and "long" merely switch between different output                      ',&
'       formats.                                                                       ',&
'                                                                                      ',&
'        short    // Scaled fixed point format with about 5 digits.                    ',&
'        short e  // Floating point format with about 5 digits.                        ',&
'                                                                                      ',&
'diary  "diary(''file'')" causes a copy of all subsequent terminal input and           ',&
'       most of the resulting output to be written on the file. "diary(0)"             ',&
'       turns it off. See "FILE".                                                      ',&
'                                                                                      ',&
'display  "display(X)" prints X in a compact format.                                   ',&
'                                                                                      ',&
'      If base >= 2 is specified the values are printed as numeric                     ',&
'      values in the specified base.                                                   ',&
'                                                                                      ',&
'           display(0:10,10 ) // display values in base 10                             ',&
'           display(0:10,16 ) // display values as hexadecimal values                  ',&
'           display(0:10,2 )  // display values as binary numbers                      ',&
'                                                                                      ',&
'      If no base is specified and all the elements of X are integers                  ',&
'      between 0 and 255, then X is interpreted as LALA text and printed               ',&
'      accordingly.                                                                    ',&
'                                                                                      ',&
'         <>display(''the analysis is complete'')                                      ',&
'           the analysis is complete                                                   ',&
'         display(32:126) // print the printable default LALA characters               ',&
'                                                                                      ',&
'      Otherwise or if the base is one, + , - and blank are printed for                ',&
'      positive, negative and zero elements.                                           ',&
'                                                                                      ',&
'         display(randu(24,80)-randu(24,80))                                           ',&
'                                                                                      ',&
'      Imaginary parts are ignored.                                                    ',&
'                                                                                      ',&
'      Note that "display(X,B)" is the same as "display(base(X,B))" except             ',&
'      for base 1 except it forces "display" to display numeric values.                ',&
'                                                                                      ',&
'      "display" has an alias of "disp".                                               ',&
'                                                                                      ',&
'plot  "plot(X,Y)" produces a plot of the elements of Y against                        ',&
'      those of X. plot(Y) is the same as plot(1:n,Y) where n is the number            ',&
'      of elements in Y. plot(X,Y,P) or "plot(X,Y,p1,...,pk)" passes the               ',&
'      optional parameter vector P or scalars p1 through pk to the plot                ',&
'      routine. The default plot routine is a crude printer-plot. This                 ',&
'      version writes the data as a simple X Y table into a scratch file               ',&
'      called "scratch.dat" and then calls the command                                 ',&
'                                                                                      ',&
'        xy scratch.dat [options]                                                      ',&
'                                                                                      ',&
'      Hopefully, you have the command xy(1) in your search path.                      ',&
'      If not, you can make one by creating a script that calls                        ',&
'      a plotting utility.                                                             ',&
'                                                                                      ',&
'         t = 0:50;                                                                    ',&
'         plot( t.*cos(t), t.*sin(t) )                                                 ',&
'         opts='' -m -1 -title test plot -d pdf''                                      ',&
'         plot( t.*cos(t), t.*sin(t),opts)                                             ',&
'================================================================================      ',&
'ENVIRONMENT                                                                           ',&
'                                                                                      ',&
'getenv   get environment variable or return a space                                   ',&
'                                                                                      ',&
'            // read commands from a file if an environment variable is set.           ',&
'            MATRC=getenv(''MATRC'');                                                  ',&
'            if MATRC <> '' '', exec(''MATRC'');                                       ',&
'                                                                                      ',&
'sh    Starts the command shell interactively, using the command defined by            ',&
'      the environment variable SHELL. Note that in addition any line                  ',&
'      starting with an exclamation (!) is passed to the system for                    ',&
'      execution.                                                                      ',&
'                                                                                      ',&
'================================================================================      ',&
'PERFORMANCE INFORMATION                                                               ',&
'                                                                                      ',&
'flops  Count of floating point operations.                                            ',&
'                                                                                      ',&
'       "flops" is a permanently defined row vector with two elements.                 ',&
'       "flops(1)" is the cpu time consumed by the the previous                        ',&
'       statement. "flops(2)" is a cumulative total. "flops" can be used               ',&
'       in the same way as any other vector. "flops(2) = 0" resets the                 ',&
'       cumulative total. In addition, "flops(1)" will be printed whenever             ',&
'       a statement is terminated by an extra comma. For example,                      ',&
'                                                                                      ',&
'         X = inv(A);,                                                                 ',&
'                                                                                      ',&
'       or                                                                             ',&
'                                                                                      ',&
'         cond(A), (as the last statement on the line).                                ',&
'================================================================================      ',&
'MISCELLANEOUS                                                                         ',&
'                                                                                      ',&
'CHAR  special issues regarding strings                                                ',&
'                                                                                      ',&
'   LALA has a limited facility for handling text. Any string of                       ',&
'   characters delineated by quotes (with two quotes used to allow one                 ',&
'   quote within the string) is saved as a vector of integer values that               ',&
'   are the ADE (Ascii Decimal Equivalent) value of the character.                     ',&
'                                                                                      ',&
'   In commands { and } are equivalent to ( and )                                      ',&
'                                                                                      ',&
'   When defining an array [ and ] or < and > may be used as the delimiters.           ',&
'                                                                                      ',&
'   lala(3f)  is too flexible about that and lets them be interchanged freely          ',&
'   instead of being matched but that will probably change to be more strictly         ',&
'   enforced.                                                                          ',&
'                                                                                      ',&
'   Currently " is not a special character but will probably be allowed as a           ',&
'   string quoting character in the future.                                            ',&
'                                                                                      ',&
'   For example                                                                        ',&
'                                                                                      ',&
'      ''2*A + 3''        //  is the same as  < 50 42 65 32 43 32 51 >.                ',&
'      display(32:126)  //  display the basic visible ASCII characters                 ',&
'                                                                                      ',&
'                                                                                      ',&
'   So if you wanted to home the cursor and clear the screen on an                     ',&
'   ANSI-compatible terminal and entered                                               ',&
'                                                                                      ',&
'       display(<27,''[H'',27,''[2J''>)                                                ',&
'                                                                                      ',&
'   The terminal screen would clear. More usefully, if you define the                  ',&
'   string                                                                             ',&
'                                                                                      ',&
'       clr=''display([27,91,''''H'''',27,91,''''2J''''])''                            ',&
'                                                                                      ',&
'   Then entering                                                                      ',&
'                                                                                      ',&
'       >clr                                                                           ',&
'                                                                                      ',&
'   will clear the screen on ANSI terminals and emulators.                             ',&
'                                                                                      ',&
'DECIMAL ADE TABLE                                                                     ',&
'      The ASCII Decimal Equivalents                                                   ',&
'      *-------*-------*-------*-------*-------*-------*-------*-------*               ',&
'      | 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|               ',&
'      | 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |               ',&
'      | 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|               ',&
'      | 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |               ',&
'      | 32 sp | 33  ! | 34  " | 35  # | 36  $ | 37  % | 38  & | 39  '' |              ',&
'      | 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |               ',&
'      | 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |               ',&
'      | 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |               ',&
'      | 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |               ',&
'      | 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |               ',&
'      | 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |               ',&
'      | 88  X | 89  Y | 90  Z | 91  [ | 92  \ | 93  ] | 94  ^ | 95  _ |               ',&
'      | 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |               ',&
'      |104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |               ',&
'      |112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |               ',&
'      |120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|               ',&
'      *-------*-------*-------*-------*-------*-------*-------*-------*               ',&
'                                                                                      ',&
'??    Two exclamation marks beginning a line enters command history mode.             ',&
'      The rest of the line is treated as an optional initial history                  ',&
'      edit command. Enter "???" to enter history mode and then display                ',&
'      additional instructions.                                                        ',&
'      see "EDIT" for further details.                                                 ',&
'                                                                                      ',&
'EDIT                                                                                  ',&
'      A command line consisting of two question marks("??") will cause a              ',&
'      small line-based editor to be called (very similar to the CDC NOS               ',&
'      editor "xedit") with a copy of the previous input lines. When the               ',&
'      editor returns control to LALA, it will execute the edited command              ',&
'      (by default).                                                                   ',&
'                                                                                      ',&
'      In editor mode the command to be edited is shifted over one and the             ',&
'      first character of input determines the edit mode. The letter "c"               ',&
'      begins a string change (ie. "c/oldstring/newstring/"). The "l"                  ',&
'      command lists the lines. A number goes to that command line as                  ',&
'      listed by the "l" command. If the change command begins with a                  ',&
'      space a letter replaces the one above it with the exception of                  ',&
'      the special characters # (delete) & (blank out) and ^ (insert the               ',&
'      following string here).                                                         ',&
'                                                                                      ',&
'      An editing loop is entered until a carriage return on an empty                  ',&
'      line is entered to accept the new line or a period is entered to                ',&
'      cancel the editing.                                                             ',&
'                                                                                      ',&
'      For example, if you had entered a line such as:                                 ',&
'                                                                                      ',&
'         <M,N>=shape(A);for I = 1:M, for J = 1:N, A(I,J) = A(I,J)+3.6;                ',&
'                                                                                      ',&
'      Then to repeat the command changing "3.6" to "5.1" enter                        ',&
'                                                                                      ',&
'         ??                                                                           ',&
'      the previous command is then displayed. Now enter                               ',&
'                                                                                      ',&
'         c/3.6/5.1                                                                    ',&
'                                                                                      ',&
'      and then enter a carriage return and the edited line will be                    ',&
'      executed.                                                                       ',&
'                                                                                      ',&
'      The first command can appear on the same line if the line starts                ',&
'      with "?? " (two question marks followed by a space). For example                ',&
'                                                                                      ',&
'         ?? /rand                                                                     ',&
'                                                                                      ',&
'      would take you into edit mode on the last command containing the                ',&
'      string "rand"                                                                   ',&
'                                                                                      ',&
'      Enter "?" in edit mode to display further help on editor mode.                  ',&
'                                                                                      ',&
'eps   Floating point relative accuracy. A permanent variable                          ',&
'      whose value is initially the distance from 1.0 to the next largest              ',&
'      floating point number. The value is changed by "chop", and other                ',&
'      values may be assigned. "eps" is used as a default tolerance by "pinv"          ',&
'      and "rank".                                                                     ',&
'                                                                                      ',&
'lala  A placeholder for a new command.                                                ',&
'                                                                                      ',&
'      LALA is intended to be used primarily by families of FORTRAN                    ',&
'      programs that wish to add a consistent interactive "calculator"                 ',&
'      mode for interactively inspecting and modifying data.                           ',&
'                                                                                      ',&
'debug  "debu(1)" turns on verbose low-level debugging for the developer,              ',&
'       "debu(0)" turns it back off.                                                   ',&
'                                                                                      ',&
'================================================================================      ',&
'']
end subroutine mat_help_text
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
function find_exec_file(filename) result(returned)
! ident_37="@(#) M_matrix find_exec_file(3fp) look for "file" or "file.la" in currect directory and those in LALA_PATH=DIR1 DIR2 DIR3..."
character(len=*),intent(in)  :: filename
character(len=:),allocatable :: returned
   returned=''
   if(filename.eq.'')then
      if(exists(filename))then
         returned=filename
      elseif(exists(trim(filename)//'.la'))then
         returned=filename//'.la'
      elseif(filename(1:1).ne.'/')then
         returned=lookfor(filename,'LALA_PATH')
         if(returned.eq.'')then
            returned=lookfor(filename//'.la','LALA_PATH')
         endif
      endif
   endif
   if(returned.eq.'')returned=filename
end function find_exec_file
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
logical function exists(filename) result(r)
character(len=*), intent(in) :: filename
   inquire(file=filename, exist=r)
end function exists
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine printit()
integer :: i
integer :: m,n
integer :: l
if(allocated(G_PSEUDO_FILE)) write(*,*)'G_PSEUDO_FILE:SIZE:',size(G_PSEUDO_FILE)
write(*,gen1)'G_PROMPT:',G_PROMPT,':G_ECHO:',G_ECHO
write(*,gen1)'G_LIN:',trim(ade2str(G_LIN))
write(*,gen1)'G_LINE_POINTER:',G_LINE_POINTER
!                                              ! [1] first character to process in current line
!                                              ! [2] last character to process in current line
!                                              ! [3]
!                                              ! [4] pointer into current character in current line being processed
!                                              ! [5]
!                                              ! [6]
write(*,gen1)'G_LHS:',G_LHS,':G_RHS:',G_RHS
write(*,gen1)'G_FIN:',G_FIN,':G_FUN:',G_FUN,':G_FMT:',G_FMT
write(*,gen1)'G_LUN_READING_FROM:',G_LUN_READING_FROM,':G_INPUT_LUN:',G_INPUT_LUN
write(*,gen1)'G_PTZ:',G_PTZ,':G_SYM:',G_SYM,':G_SYN:',trim(ade2str(G_SYN))
write(*,gen1)'G_CURRENT_RANDOM_SEED:',G_CURRENT_RANDOM_SEED
write(*,gen1)'G_FLOP_COUNTER:',G_FLOP_COUNTER
write(*,gen1)'G_DEBUG_LEVEL:',G_DEBUG_LEVEL
write(*,gen1)'G_FILE_OPEN_ERROR:',G_FILE_OPEN_ERROR,':G_ERR:',G_ERR
write(*,gen1)'G_LINECOUNT:',G_LINECOUNT
!                                    ! [1] lines displayed since count started
!                                    ! [2] line limit before warning (ie. page length+1)
!                                    ! [3] 0 or 1 for "semi" mode to be on or off
!                                    ! [4] flag from "exec" command, and ...
write(*,gen1)'G_BUF:',trim(ade2str(G_BUF))
write(*,gen1)'GM_BIGMEM:',GM_BIGMEM
write(*,gen1)'G_TOP_OF_SAVED:',G_TOP_OF_SAVED,':G_ARGUMENT_POINTER:',G_ARGUMENT_POINTER
do i=1,GG_MAX_NUMBER_OF_NAMES
   m=G_VAR_ROWS(i)
   n=G_VAR_COLS(i)
   l=G_VAR_DATALOC(i)
   if(.not.(ade2str(G_VAR_IDS(:,i)).eq.''.and.l.eq.0.and.m.eq.0.and.n.eq.0))then
      write(*,*)i,ade2str(G_VAR_IDS(:,i)),l,m,n,'VALS=',real(GM_REALS(l:l+m*n-1))
   endif
enddo
!==================================================================================================================================!
! PARSING
!integer,parameter        :: G_PSIZE=32                        ! stack size for pseudo-recursion
!integer                  :: G_IDS(GG_MAX_NAME_LENGTH,G_PSIZE)
!integer                  :: G_PSTK(G_PSIZE)
!integer                  :: G_RSTK(G_PSIZE)
!integer                  :: G_PT
!
!integer                  :: G_CHRA ! current character in line
!==================================================================================================================================!
!doubleprecision,allocatable    :: GM_REALS(:), GM_IMAGS(:)               ! set to size of GM_BIGMEM
!==================================================================================================================================!
end subroutine printit
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
subroutine mat_wdiv(ar,ai,br,bi,cr,ci)

! ident_38="@(#) M_matrix mat_wdiv(3fp) c = a/b"

doubleprecision :: ar
doubleprecision :: ai
doubleprecision :: br
doubleprecision :: bi
doubleprecision :: cr
doubleprecision :: ci

doubleprecision :: s
doubleprecision :: d
doubleprecision :: ars
doubleprecision :: ais
doubleprecision :: brs
doubleprecision :: bis

   s = dabs(br) + dabs(bi)
   if (s .eq. 0.0d0) then
      call mat_err(27)
      return
   endif
   ars = ar/s
   ais = ai/s
   brs = br/s
   bis = bi/s
   d = brs**2 + bis**2
   cr = mat_flop((ars*brs + ais*bis)/d)
   ci = (ais*brs - ars*bis)/d
   if (ci .ne. 0.0d0) ci = mat_flop(ci)
end subroutine mat_wdiv
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_wlog(in_real,in_imag,out_real,out_imag)

! ident_39="@(#) M_matrix mat_wlog(3fp) y = log(x)"

doubleprecision :: in_real, in_imag
doubleprecision :: out_real, out_imag
doubleprecision :: t
doubleprecision :: r
   r = mat_pythag(in_real,in_imag)

   if (r .eq. 0.0d0) then
      call mat_err(32) !  Singularity of LOG or ATAN
   else
      t = datan2(in_imag,in_real)
      if (in_imag.eq.0.0d0 .and. in_real.lt.0.0d0) t = dabs(t)
      out_real = dlog(r)
      out_imag = t
   endif

end subroutine mat_wlog
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
subroutine mat_watan(xr,xi,yr,yi)

! ident_40="@(#) M_LA mat_watan(3fp) y = atan(x) = (i/2)*log((i+x)/(i-x))"

doubleprecision,intent(in)  :: xr, xi
doubleprecision,intent(out) :: yr, yi
doubleprecision             :: tr, ti

   if (xi .eq. 0.0d0) then
      yr = datan2(xr,1.0d0)
      yi = 0.0d0
   elseif (xr.ne.0.0d0 .or. dabs(xi).ne.1.0d0) then
      call mat_wdiv(xr,1.0d0+xi,-xr,1.0d0-xi,tr,ti)
      call mat_wlog(tr,ti,tr,ti)
      yr = -(ti/2.0d0)
      yi = tr/2.0d0
   else
      call mat_err(32) ! Singularity of LOG or ATAN
   endif

end subroutine mat_watan
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
pure recursive function qsort(values) result(sorted)
! concise quicksort from @arjen and @beliavsky shows recursion,
! array sections, and vectorized comparisons.
!
intrinsic pack, size
real(kind=dp), intent(in) :: values(:)
real(kind=dp)             :: sorted(size(values))
   if (size(values) > 1) then
      sorted = &
      & [qsort(pack(values(2:),values(2:)<values(1))), values(1), &
      & qsort(pack(values(2:),values(2:)>=values(1)))]
   else
      sorted = values
   endif
end function qsort
!===================================================================================================================================
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()=
!===================================================================================================================================
end module M_matrix
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!

!>>>>> app/lala.f90
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!
program bigmat
use M_matrix, only  : lala
use M_CLI2, only : set_args, lget, sget, iget, expressions=>unnamed          ! add command-line parser module
implicit none
character(len=:),allocatable :: help_text(:)
character(len=:),allocatable :: version_text(:)
integer                      :: i
logical                      :: echo
logical                      :: markdown
   call setup()
   ! define command arguments,default values and crack command line
   call set_args('lala --markdown F -noecho F',help_text,version_text )
   echo=.not.lget('noecho')
   if(size(expressions).eq.0)then
      call lala(echo=echo)                           ! CALL LALA interactively with default scratch space
   else
      call lala(200000,echo=echo)                    ! CALL LALA to initialize it and set scratch space size
      do i=1,size(expressions)
         call lala(expressions(i))                   ! CALL LALA
      enddo
   endif
   stop
contains
subroutine setup()
help_text=[ CHARACTER(LEN=128) :: &
'NAME',&
'   lala(1f) - interpret matrix expressions using a shell-like interface',&
'                                                                       ',&
'SYNOPSIS                                                               ',&
'    lala [expression(s)] | [ --help| --version]                        ',&
'                                                                       ',&
'DESCRIPTION                                                            ',&
'   lala(1) is an interactive computer program that serves as a convenient',&
'   "laboratory" for computations involving matrices. It provides easy    ',&
'   access to matrix software developed by the LINPACK and EISPACK        ',&
'   projects. The capabilities range from standard tasks such as solving  ',&
'   simultaneous linear equations and inverting matrices, through symmetric',&
'   and nonsymmetric eigenvalue problems, to fairly sophisticated matrix   ',&
'   tools such as the singular value decomposition.                        ',&
'                                                                          ',&
'OPTIONS                                                                   ',&
'    --help         display this help and exit                             ',&
'    --version      output version information and exit                    ',&
'    expression(s)  if expressions are supplied they are evaluated and the ',&
'                   program terminates.                                    ',&
'                                                                          ',&
'AUTHOR                                                                    ',&
'    This is heavily based on a program from the Department of Computer    ',&
'    Science, University of New Mexico, by Cleve Moler.                    ',&
'                                                                          ',&
'EXAMPLES                                                                  ',&
'  Sample commands                                                         ',&
'                                                                          ',&
'    # Example 1: introductory usage:                                      ',&
'    lala                                                                  ',&
'    A=<1 2 3;5 4 6;7 8 9>                                                 ',&
'    b=<5;6;7>                                                             ',&
'    A*b                                                                   ',&
'    b*A                                                                   ',&
'    det(A)                                                                ',&
'    quit                                                                  ',&
'                                                                          ',&
'   An explanation of Example 1:                                           ',&
'                                                                          ',&
'    // For this session the <> character is the LALA prompt.              ',&
'     <> A=<1 2 3;5 4 6;7 8 9>            <---  you enter this             ',&
'     A     =                             <---  LALA response              ',&
'         1.    2.    3.                                                   ',&
'         5.    4.    6.                                                   ',&
'         7.    8.    9.                                                   ',&
'     <> b=<5;6;7>                                                         ',&
'     b     =                                                              ',&
'         5.                                                               ',&
'         6.                                                               ',&
'         7.                                                               ',&
'                                                                          ',&
'     <> A*b             <--- you enter "multiply A and b"                 ',&
'                                                                          ',&
'     ANS   =            <--- LALA response                                ',&
'        38.                                                               ',&
'        91.                                                               ',&
'       146.                                                               ',&
'                                                                          ',&
'     <> b*A             <---you enter "multiply b and A"                  ',&
'        /--ERROR                         <--- LALA response               ',&
'     INCOMPATIBLE FOR MULTIPLICATION                                      ',&
'                                                                          ',&
'     <> det(A)         <--- Take the determinant of A                     ',&
'                                                                          ',&
'     ANS   =           <---LALA response                                  ',&
'                                                                          ',&
'        18.                                                               ',&
'                                                                          ',&
'     <> quit           <--- you quit LALA                                 ',&
'                                                                          ',&
'     total flops        34                                                ',&
'     ADIOS                                                                ',&
'    // --------------------------------------                             ',&
'                                                                          ',&
'   Example 2: Simple looping and conditionals are also available          ',&
'                                                                          ',&
'    lala                                                                  ',&
'    //Eigenvalue sensitivity example. See section 8 of the Users'' Guide. ',&
'    B = <3 0 7; 0 2 0; 0 0 1>                                             ',&
'    L = <1 0 0; 2 1 0; -3 4 1>,  M = L\L''                                ',&
'    A = M*B/M                                                             ',&
'    A = round(A)                                                          ',&
'    <X,D> = eig(A)                                                        ',&
'    long,  diag(D),  short                                                ',&
'    cond(X)                                                               ',&
'    X = X/diag(X(3,:)),  cond(X)                                          ',&
'    Y = inv(X''),  Y''*A*X                                                ',&
'    for j = 1:3, c(j) = norm(Y(:,j))*norm(X(:,j));                        ',&
'    C                                                                     ',&
'    E = -1.e-6*Y(:,1)*X(:,1)''                                            ',&
'    eig(A + .4*E),  eig(A + .5*E)                                         ',&
'    r = .4;  s = .5;                                                      ',&
'    while s-r > 1.e-14, t = (r+s)/2; d = eig(A+t*E); ...                  ',&
'      if imag(d(1))=0, r = t; else, s = t;                                ',&
'    long,  t = r                                                          ',&
'    A+t*e,  eig(A+t*E)                                                    ',&
'    <X,D> = eig(A+t*E);  X = X/diag(X(3,:))                               ',&
'    short,  cond(X)                                                       ',&
'    // --------------------------------------                             ',&
'                                                                          ',&
'   Use the HELP command for further information.                          ',&
'   For example, to enter HELP on the entire manual,                       ',&
'   display directions for using HELP and                                  ',&
'   place a User manual in the file "lala.userguide.txt",                  ',&
'   enter                                                                  ',&
'                                                                          ',&
'    lala                                                                  ',&
'    <>help manual                                                         ',&
'    continue ...                                                          ',&
'    h // show directions for using "help"                                 ',&
'    w lala.userguide.txt                                                  ',&
'    continue ...                                                          ',&
'    q                                                                     ',&
'    quit                                                                  ',&
'']
version_text=[ CHARACTER(LEN=128) :: &
'PRODUCT:        GPF (General Purpose Fortran) utilities and examples',&
'PROGRAM:        lala(1)                                             ',&
'DESCRIPTION:    interpret matrix operations using a shell-like interface',&
'VERSION:        1.1, 2025-04-14                                         ',&
'AUTHOR:         John S. Urban; heavily based on the original by Cleve Moler',&
'HOME PAGE:      http://www.urbanjost.altervista.org/index.html             ',&
'']
end subroutine setup
end program bigmat
!==================================================================================================================================!
!()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()!
!==================================================================================================================================!

